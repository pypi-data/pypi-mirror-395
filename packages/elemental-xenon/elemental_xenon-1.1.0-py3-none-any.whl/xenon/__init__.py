"""
Xenon: A robust XML repair library for LLM-generated XML.

This library provides utilities to clean up and repair malformed XML that is
commonly generated by Large Language Models (LLMs), including handling:
- Truncation/Cut-off issues
- Conversational fluff around XML
- Malformed attributes
- Unescaped entities
- Pseudo-XML content
"""

from typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union

if TYPE_CHECKING:
    from .audit import AuditLogger

from .audit import (
    AuditEntry,
    AuditLogger,
    SecurityMetrics,
    Threat,
    ThreatDetector,
    ThreatSeverity,
    ThreatType,
)
from .config import RepairFlags, SecurityFlags, XMLRepairConfig
from .encoding import detect_encoding, normalize_encoding
from .entities import convert_html_entities_to_numeric as convert_html_entities
from .entities import normalize_entities
from .exceptions import (
    MalformedXMLError,
    RepairError,
    SecurityError,
    ValidationError,
    XenonException,
    get_context_snippet,
    get_line_column,
)
from .formatting import FormatStyle, format_xml
from .parser import XMLRepairEngine
from .preprocessor import XMLPreprocessor
from .reporting import RepairAction, RepairReport, RepairType
from .security import XMLSecurityFilter
from .streaming import StreamingXMLRepair, StreamState
from .trust import TrustLevel, get_security_config
from .utils import (
    batch_repair,
    batch_repair_with_reports,
    decode_xml,
    extract_text_content,
    stream_repair,
    validate_xml_structure,
)
from .validation import validate_repaired_output, validate_xml_input

__version__ = "1.1.0"
__author__ = "Xenon Contributors"

# Initialize the engine once for module-level functions
_engine = XMLRepairEngine()


def repair_xml(xml_string: str, trust: TrustLevel) -> str:
    """
    Repair malformed XML with security appropriate to trust level.

    This function handles common LLM failure modes:
    - Truncation/cut-off (auto-closes open tags)
    - Conversational fluff (extracts XML from surrounding text)
    - Malformed attributes (adds missing quotes)
    - Unescaped entities (escapes & and < in text content)

    Security features are automatically configured based on trust level.

    Args:
        xml_string: The potentially malformed XML string
        trust: Trust level of the source (UNTRUSTED, INTERNAL, or TRUSTED)

    Returns:
        str: A well-formed XML string

    Examples:
        >>> from xenon import repair_xml
        >>> from xenon.trust import TrustLevel
        >>>
        >>> # LLM output - maximum security
        >>> repair_xml(llm_response, trust=TrustLevel.UNTRUSTED)
        '<root><user name="john"></user></root>'
        >>>
        >>> # Internal service - balanced security
        >>> repair_xml(service_xml, trust=TrustLevel.INTERNAL)
        >>>
        >>> # Test fixture - no overhead
        >>> repair_xml(TEST_XML, trust=TrustLevel.TRUSTED)
    """
    security_config = get_security_config(trust)
    engine = XMLRepairEngine(
        strip_dangerous_pis=security_config.strip_dangerous_pis,
        strip_external_entities=security_config.strip_external_entities,
        strip_dangerous_tags=security_config.strip_dangerous_tags,
        max_depth=security_config.max_depth,
    )
    return engine.repair_xml(xml_string)[0]


def repair_xml_with_report(xml_string: str, trust: TrustLevel) -> Tuple[str, RepairReport]:
    """
    Repair malformed XML and get a detailed report of what was fixed.

    This function provides full transparency into what repairs were performed,
    making it easier to debug issues and understand LLM failure modes.

    Args:
        xml_string: The potentially malformed XML string
        trust: Trust level of the source (UNTRUSTED, INTERNAL, or TRUSTED)

    Returns:
        tuple: (repaired_xml: str, report: RepairReport)

    Example:
        >>> from xenon import repair_xml_with_report, RepairType
        >>> from xenon.trust import TrustLevel
        >>>
        >>> xml = '<root><item attr=unquoted>text & more'
        >>> result, report = repair_xml_with_report(xml, trust=TrustLevel.UNTRUSTED)
        >>>
        >>> print(result)
        '<root><item attr="unquoted">text &amp; more</item></root>'
        >>>
        >>> # The report now contains specific, machine-readable actions
        >>> print(len(report.actions))
        3
        >>>
        >>> action_types = {action.repair_type for action in report.actions}
        >>> print(RepairType.MALFORMED_ATTRIBUTE in action_types)
        True
        >>> print(RepairType.UNESCAPED_ENTITY in action_types)
        True
        >>> print(RepairType.TRUNCATION in action_types)
        True
    """
    security_config = get_security_config(trust)
    engine = XMLRepairEngine(
        strip_dangerous_pis=security_config.strip_dangerous_pis,
        strip_external_entities=security_config.strip_external_entities,
        strip_dangerous_tags=security_config.strip_dangerous_tags,
        max_depth=security_config.max_depth,
    )
    return engine.repair_xml(xml_string)


def parse_xml(xml_string: str, trust: TrustLevel) -> Dict[str, Any]:
    """
    Repair malformed XML and convert it to a Python dictionary.

    This function first repairs the XML using repair_xml(), then converts
    the result to a nested dictionary structure.

    Args:
        xml_string: The potentially malformed XML string
        trust: Trust level of the source (UNTRUSTED, INTERNAL, or TRUSTED)

    Returns:
        dict: A nested dictionary representation of the XML

    Examples:
        >>> from xenon import parse_xml
        >>> from xenon.trust import TrustLevel
        >>>
        >>> # LLM output
        >>> parse_xml(llm_response, trust=TrustLevel.UNTRUSTED)
        {'root': {'user': {'@attributes': {'name': 'john'}, '#text': 'Hello'}}}
        >>>
        >>> # Test fixture
        >>> parse_xml(TEST_XML, trust=TrustLevel.TRUSTED)
    """
    # First repair with security appropriate to trust level
    repaired = repair_xml(xml_string, trust=trust)
    # Then parse to dictionary
    return _engine.xml_to_dict(repaired)


def repair_xml_safe(
    xml_input: Union[bytes, str],
    trust: TrustLevel,
    strict: Optional[bool] = None,
    allow_empty: bool = False,
    max_size: Optional[int] = None,
    # Security overrides (defaults from trust level)
    strip_dangerous_pis: Optional[bool] = None,
    strip_external_entities: Optional[bool] = None,
    strip_dangerous_tags: Optional[bool] = None,
    escape_unsafe_attributes: Optional[bool] = None,
    max_depth: Optional[int] = None,
    validate_output_schema: Optional[bool] = None,
    # Repair features
    wrap_multiple_roots: bool = False,
    sanitize_invalid_tags: bool = False,
    fix_namespace_syntax: bool = False,
    auto_wrap_cdata: bool = False,
    # v0.6.0 Features
    format_output: Optional[FormatStyle] = None,
    html_entities: Optional[str] = None,
    normalize_unicode: bool = False,
    # Schema validation
    schema_content: Optional[str] = None,
    audit_logger: Optional["AuditLogger"] = None,
) -> str:
    """
    Safely repair XML with security appropriate to trust level.

    Security features are automatically configured based on trust level,
    but can be overridden with explicit parameters.

    Args:
        xml_input: The potentially malformed XML (string or bytes)
        trust: Trust level of the source (UNTRUSTED, INTERNAL, or TRUSTED)
        strict: Validate repaired output. Defaults based on trust level.
        allow_empty: If True, accept empty/whitespace-only input (returns '')
        max_size: Maximum input size in bytes. None = no limit (default: 100MB)

        Security overrides (defaults from trust level):
            strip_dangerous_pis: Strip processing instructions (PHP, ASP, JSP)
            strip_external_entities: Strip external entities (XXE prevention)
            strip_dangerous_tags: Strip dangerous tags (script, iframe, etc.)
            escape_unsafe_attributes: Aggressively escape attribute values to prevent XSS.
            max_depth: Maximum nesting depth (DoS prevention)
            validate_output_schema: If True, validate repaired output against a schema.

        Repair features:
            wrap_multiple_roots: Wrap multiple roots in <document>
            sanitize_invalid_tags: Fix invalid tag names (<123> → <tag_123>)
            fix_namespace_syntax: Fix invalid namespace syntax (<bad::ns> → <bad_ns>)
            auto_wrap_cdata: Wrap code content in CDATA sections

        v0.6.0 Features:
            format_output: Output formatting - 'pretty', 'compact', 'minify', or None
            html_entities: HTML entity handling - 'numeric', 'unicode', or None
            html_entities: HTML entity handling - 'numeric', 'unicode', or None
            normalize_unicode: Apply Unicode NFC normalization

        Schema validation:
            schema_content: The content of the schema (XSD or DTD) as a string.
    Returns:

    Raises:
        ValidationError: If input is invalid
        MalformedXMLError: If strict=True and repair produces invalid output
        RepairError: If an internal error occurs during repair

    Examples:
        >>> from xenon import repair_xml_safe
        >>> from xenon.trust import TrustLevel
        >>>
        >>> # LLM output - maximum security by default
        >>> repair_xml_safe(llm_response, trust=TrustLevel.UNTRUSTED)
        '<root><item></item></root>'
        >>>
        >>> # Override specific setting
        >>> repair_xml_safe(
        ...     llm_response,
        ...     trust=TrustLevel.UNTRUSTED,
        ...     max_depth=5000  # Allow deeper nesting
        ... )
        >>>
        >>> # Test fixture - fast, no security overhead
        >>> repair_xml_safe(TEST_XML, trust=TrustLevel.TRUSTED)
    """
    # Step 0: v0.6.0 - Handle bytes input by decoding
    xml_string = decode_xml(xml_input) if isinstance(xml_input, bytes) else xml_input

    # Step 1: Validate input
    try:
        validate_xml_input(xml_string, allow_empty=allow_empty, max_size=max_size)
    except ValidationError:
        # Re-raise validation errors as-is with their helpful messages
        raise

    # Step 2: Handle empty case early (after validation passes)
    if not xml_string.strip():
        return ""

    # Step 2.5: v0.6.0 - Apply Unicode normalization if requested
    if normalize_unicode:
        xml_string = normalize_encoding(xml_string, normalize_unicode=True)

    # Step 2.6: v0.6.0 - PRE-process HTML entities BEFORE repair
    # This prevents the repair engine from escaping them as &amp;euro;
    if html_entities == "numeric":
        xml_string = convert_html_entities(xml_string, preserve_xml_entities=True)
    elif html_entities == "unicode":
        xml_string = normalize_entities(xml_string, mode="unicode")
    elif html_entities is not None:
        raise ValueError(
            f"Invalid html_entities value: {html_entities!r}. Use 'numeric', 'unicode', or None"
        )

    # Step 3: Get security configuration based on trust level
    security_config = get_security_config(
        trust,
        strip_dangerous_pis=strip_dangerous_pis,
        strip_external_entities=strip_external_entities,
        strip_dangerous_tags=strip_dangerous_tags,
        escape_unsafe_attributes=escape_unsafe_attributes,
        max_depth=max_depth,
        strict=strict,
        validate_output_schema=validate_output_schema,
        audit_logger=audit_logger,
    )

    # Step 4: Attempt repair with error handling
    try:
        # Create engine with trust-based security + repair features
        custom_engine = XMLRepairEngine(
            strip_dangerous_pis=security_config.strip_dangerous_pis,
            strip_external_entities=security_config.strip_external_entities,
            strip_dangerous_tags=security_config.strip_dangerous_tags,
            escape_unsafe_attributes=security_config.escape_unsafe_attributes,
            max_depth=security_config.max_depth,
            wrap_multiple_roots=wrap_multiple_roots,
            sanitize_invalid_tags=sanitize_invalid_tags,
            fix_namespace_syntax=fix_namespace_syntax,
            auto_wrap_cdata=auto_wrap_cdata,
            schema_content=schema_content,
            audit_logger=security_config.audit_logger,
            trust_level=security_config.trust_level.value,
        )
        result, _ = custom_engine.repair_xml(xml_string)

        # Step 5: v0.6.0 - Apply formatting if requested
        if format_output is not None:
            result = format_xml(result, style=format_output)

        # Step 6: Validate output if in strict mode
        if security_config.strict:
            validate_repaired_output(result, xml_string)

        # Step 7: Apply schema validation if requested
        if schema_content and security_config.validate_output_schema:
            from .validation import validate_with_schema

            validate_with_schema(result, schema_content)

        return result

    except AttributeError as e:
        # Catch internal attribute errors (likely from None/unexpected values)
        raise RepairError(
            f"Internal error during repair: {e}. "
            f"This may indicate a bug in Xenon. Please report it."
        ) from e

    except IndexError as e:
        # Catch index errors from unexpected structure
        raise RepairError(
            f"Index error during parsing: {e}. Input may contain unexpected structure."
        ) from e

    except (ValidationError, MalformedXMLError, RepairError):
        # Re-raise our own exceptions as-is
        raise

    except Exception as e:
        # Catch-all for unexpected errors
        raise RepairError(f"Unexpected error during repair: {type(e).__name__}: {e}") from e


def parse_xml_safe(
    xml_string: str,
    trust: TrustLevel,
    strict: Optional[bool] = None,
    allow_empty: bool = False,
    max_size: Optional[int] = None,
    # Security overrides
    strip_dangerous_pis: Optional[bool] = None,
    strip_external_entities: Optional[bool] = None,
    strip_dangerous_tags: Optional[bool] = None,
    escape_unsafe_attributes: Optional[bool] = None,
    max_depth: Optional[int] = None,
    validate_output_schema: Optional[bool] = None,
    # Repair features
    wrap_multiple_roots: bool = False,
    sanitize_invalid_tags: bool = False,
    fix_namespace_syntax: bool = False,
    auto_wrap_cdata: bool = False,
    # v0.6.0 Features
    format_output: Optional[FormatStyle] = None,
    html_entities: Optional[str] = None,
    normalize_unicode: bool = False,
    # Schema validation
    schema_content: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Safely parse malformed XML to dictionary with error handling.

    This function repairs the XML using repair_xml_safe(), then converts
    to a dictionary. Provides the same safety guarantees as repair_xml_safe().

    Args:
        xml_string: The potentially malformed XML string to parse
        trust: Trust level of the source (UNTRUSTED, INTERNAL, or TRUSTED)
        strict: If True, validate repaired XML structure. Defaults based on trust.
        allow_empty: If True, accept empty input (returns {})
        max_size: Maximum input size in bytes. None = no limit (default: 100MB)
        **kwargs: All other arguments supported by repair_xml_safe()

    Returns:
        Dictionary representation of the XML

    Raises:
        ValidationError: If input is invalid
        MalformedXMLError: If strict=True and repair produces invalid output
        RepairError: If an internal error occurs

    Examples:
        >>> from xenon import parse_xml_safe
        >>> from xenon.trust import TrustLevel
        >>>
        >>> parse_xml_safe(llm_output, trust=TrustLevel.UNTRUSTED)
        {'root': {'item': 'test'}}
        >>>
        >>> parse_xml_safe('', trust=TrustLevel.TRUSTED, allow_empty=True)
        {}
    """
    # Use repair_xml_safe for validation and repair
    repaired = repair_xml_safe(
        xml_string,
        trust=trust,
        strict=strict,
        allow_empty=allow_empty,
        max_size=max_size,
        strip_dangerous_pis=strip_dangerous_pis,
        strip_external_entities=strip_external_entities,
        strip_dangerous_tags=strip_dangerous_tags,
        escape_unsafe_attributes=escape_unsafe_attributes,
        max_depth=max_depth,
        validate_output_schema=validate_output_schema,
        wrap_multiple_roots=wrap_multiple_roots,
        sanitize_invalid_tags=sanitize_invalid_tags,
        fix_namespace_syntax=fix_namespace_syntax,
        auto_wrap_cdata=auto_wrap_cdata,
        format_output=format_output,
        html_entities=html_entities,
        normalize_unicode=normalize_unicode,
        schema_content=schema_content,
    )

    # Handle empty case
    if not repaired.strip():
        return {}

    # Convert to dictionary
    try:
        return _engine.xml_to_dict(repaired)
    except Exception as e:
        raise RepairError(f"Error converting XML to dictionary: {type(e).__name__}: {e}") from e


def repair_xml_lenient(xml_input: Any) -> str:
    """
    Repair XML in lenient mode - never raises exceptions.

    This function attempts to repair any input and always returns a string,
    even if the input is invalid (None, wrong type, etc.). Returns empty
    string on any error.

    This is useful when you want maximum fault tolerance and prefer an
    empty result over handling exceptions.

    Args:
        xml_input: Any input (can be None, int, list, etc.)

    Returns:
        Repaired XML string, or empty string on any error

    Examples:
        >>> repair_xml_lenient(None)
        ''

        >>> repair_xml_lenient(123)
        ''

        >>> repair_xml_lenient(['<root>'])
        ''

        >>> repair_xml_lenient('<root><item')
        '<root><item></item></root>'

        >>> repair_xml_lenient('Just plain text')
        'Just plain text'
    """
    try:
        # Convert to string if not already
        if not isinstance(xml_input, str):
            if xml_input is None:
                return ""
            # Try to convert to string
            xml_input = str(xml_input)

        # Attempt repair
        return _engine.repair_xml(xml_input)[0]

    except Exception:
        # Silently return empty string on any error
        return ""


def parse_xml_lenient(xml_input: Any) -> Dict[str, Any]:
    """
    Parse XML in lenient mode - never raises exceptions.

    This function attempts to parse any input and always returns a dict,
    even if the input is invalid. Returns empty dict on any error.

    Args:
        xml_input: Any input (can be None, int, list, etc.)

    Returns:
        Dictionary representation, or empty dict on any error

    Examples:
        >>> parse_xml_lenient(None)
        {}

        >>> parse_xml_lenient('<root><item>test</item>')
        {'root': {'item': 'test'}}

        >>> parse_xml_lenient('invalid')
        {}
    """
    try:
        repaired = repair_xml_lenient(xml_input)
        if not repaired.strip():
            return {}
        return _engine.xml_to_dict(repaired)
    except Exception:
        return {}


# Convenience alias for diff reporting
repair_xml_with_diff = repair_xml_with_report


# Public interface
__all__ = [  # noqa: RUF022
    # Core functions
    "repair_xml",
    "parse_xml",
    # Safe functions with error handling
    "repair_xml_safe",
    "parse_xml_safe",
    # Lenient functions (never raise)
    "repair_xml_lenient",
    "parse_xml_lenient",
    # Advanced features (v0.5.0+)
    "repair_xml_with_report",
    "repair_xml_with_diff",  # v0.6.0: Alias for repair_xml_with_report
    # Exceptions
    "XenonException",
    "ValidationError",
    "MalformedXMLError",
    "RepairError",
    "SecurityError",
    # Exception helpers
    "get_line_column",
    "get_context_snippet",
    # Advanced usage - Core engine
    "XMLRepairEngine",
    # Advanced usage - Configuration (v0.5.0+)
    "XMLRepairConfig",
    "SecurityFlags",
    "RepairFlags",
    # Advanced usage - Components (v0.5.0+)
    "XMLPreprocessor",
    "XMLSecurityFilter",
    # Advanced usage - Reporting (v0.5.0+)
    "RepairReport",
    "RepairAction",
    "RepairType",
    # v0.6.0 Features - Formatting
    "format_xml",
    "FormatStyle",
    # v0.6.0 Features - HTML Entities
    "convert_html_entities",
    "normalize_entities",
    # v0.6.0 Features - Encoding
    "detect_encoding",
    "normalize_encoding",
    # v0.6.0 Features - Utilities
    "decode_xml",
    "batch_repair",
    "batch_repair_with_reports",
    "stream_repair",
    "validate_xml_structure",
    "extract_text_content",
    # v0.7.0 Features - Streaming
    "StreamingXMLRepair",
    "StreamState",
    # v1.0.0 Features - Trust-based Security
    "TrustLevel",
    # v1.0.0 Features - Audit Mode
    "ThreatDetector",
    "ThreatType",
    "ThreatSeverity",
    "Threat",
    "AuditLogger",
    "AuditEntry",
    "SecurityMetrics",
]
