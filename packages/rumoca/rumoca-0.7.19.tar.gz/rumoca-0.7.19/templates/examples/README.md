# Rumoca Template Examples

âš ï¸ **These templates are NOT installed with Rumoca** - They exist in the source repository as educational examples only.

## Recommended Workflow (No Templates Needed!)

For production use, use native JSON export:

```bash
# Export to Base Modelica JSON (fast, type-safe, recommended)
rumoca model.mo --json > model.json

# Then use Cyecca for backend generation
python3 -c "
from cyecca.io.base_modelica import import_base_modelica
from cyecca.backends.casadi import generate_casadi

model = import_base_modelica('model.json')
casadi_code = generate_casadi(model)
print(casadi_code)
"
```

**Why native JSON export?**
- âš¡ **Fast** - No template rendering overhead
- ðŸ”’ **Type-safe** - Compile-time validation
- ðŸ§¹ **Maintainable** - Schema changes only need Rust updates
- âœ… **Standards-compliant** - MCP-0031 Base Modelica IR

## Template Examples (Educational Only)

These templates demonstrate the template system for custom code generation:

### Base Modelica

- **`base_modelica.jinja`** - Reference implementation showing template-based JSON export
  - **Note:** Native `--json` export is faster and recommended
  - Useful for understanding how templates work
  - Shows how to traverse DAE structures

### CasADi Templates

- **`casadi.jinja`** - Generate CasADi Python code directly
  - Demonstrates expression rendering for CasADi syntax
  - **Recommended:** Use Cyecca's CasADi backend instead

- **`casadi_daebuilder.jinja`** - Uses CasADi's DaeBuilder API
  - More structured CasADi code generation
  - **Recommended:** Use Cyecca's CasADi backend instead

### SymPy Template

- **`sympy.jinja`** - Generate SymPy symbolic math code
  - **Recommended:** Use Cyecca's SymPy backend instead

### Gazebo SDF

- **`gz_ackermann.jinja`** - Generates Gazebo SDF XML for robot simulation
  - Shows template system for non-IR formats
  - Specialized use case where templates make sense

## Usage

```bash
# Export using a template
rumoca model.mo --template-file templates/examples/casadi.jinja > model_casadi.py

# Export using native JSON (recommended)
rumoca model.mo --json > model.json

# Then use Cyecca for backend generation
python3 -c "
from cyecca.io.base_modelica import import_base_modelica
from cyecca.backends.casadi import generate_casadi

model = import_base_modelica('model.json')
casadi_code = generate_casadi(model)
print(casadi_code)
"
```

## Creating Custom Templates

Templates use the [Jinja2](https://jinja.palletsprojects.com/) template language via Rust's [minijinja](https://github.com/mitsuhiko/minijinja) library.

### Available Data

Templates receive a `dae` object with the following structure:

```rust
dae {
    rumoca_version: String,
    git_version: String,
    model_hash: String,

    // Variables
    p: IndexMap<String, Component>,    // parameters
    cp: IndexMap<String, Component>,   // constant parameters
    x: IndexMap<String, Component>,    // continuous states
    y: IndexMap<String, Component>,    // algebraic variables
    u: IndexMap<String, Component>,    // inputs
    z: IndexMap<String, Component>,    // discrete variables

    // Equations
    fx: Vec<Equation>,  // continuous equations (der() calls appear here)

    // ... other fields
}
```

### Example Template

```jinja
{# Simple template example #}
# Generated by Rumoca {{ dae.rumoca_version }}

# Parameters
{% for (name, comp) in dae.p | items %}
{{ name }} = {{ comp.start }}  # {{ comp.description }}
{% endfor %}

# States
{% for (name, comp) in dae.x | items %}
{{ name }} = Symbol('{{ name }}')
{% endfor %}
```

### Expression Rendering

Expressions are Rust enums that serialize to JSON structures:

```json
{
  "op": "der",
  "args": [{
    "op": "component_ref",
    "parts": [{"name": "x", "subscripts": []}]
  }]
}
```

See existing templates for examples of how to render expressions for different target languages.

## Why Not Use Templates for Everything?

Templates are powerful but have limitations:

1. **Maintenance burden** - Each backend needs a separate template
2. **Error-prone** - String-based code generation is fragile
3. **Limited tooling** - No type checking or validation
4. **Duplication** - Logic repeated across templates

The Base Modelica JSON â†’ Cyecca workflow solves these issues with:
- Type-safe transformations
- Shared IR infrastructure
- Tested backend implementations
- Easy to extend with new backends

## Contributing

If you create useful custom templates, consider contributing them as examples!

## See Also

- [Cyecca Documentation](https://github.com/cognipilot/cyecca)
- [Base Modelica IR Specification (MCP-0031)](https://modelica.org/mcp/)
- [minijinja Template Documentation](https://docs.rs/minijinja/)
