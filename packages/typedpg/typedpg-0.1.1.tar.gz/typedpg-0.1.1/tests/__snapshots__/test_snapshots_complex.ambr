# serializer version: 1
# name: TestAggregations.test_group_by_with_aggregates
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrderStatsByStatusResult:
      status: str | None
      order_count: int | None
      total_revenue: Decimal | None
      avg_order_value: Decimal | None
      first_order: datetime | None
      last_order: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrderStatsByStatusParams:
      sinceDate: datetime
  
  
  async def get_order_stats_by_status(conn: asyncpg.Connection[Any], params: GetOrderStatsByStatusParams) -> GetOrderStatsByStatusResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  status,
                  COUNT(*) as order_count,
                  SUM(total_amount) as total_revenue,
                  AVG(total_amount) as avg_order_value,
                  MIN(created_at) as first_order,
                  MAX(created_at) as last_order
              FROM test_orders
              WHERE created_at >= $1
              GROUP BY status
              ORDER BY total_revenue DESC
              """,
          params.sinceDate,
      )
      return GetOrderStatsByStatusResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestAggregations.test_having_clause
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetFrequentHighValueCustomersResult:
      user_id: int | None
      order_count: int | None
      total_spent: Decimal | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetFrequentHighValueCustomersParams:
      minOrders: int
      minSpent: Decimal
  
  
  async def get_frequent_high_value_customers(conn: asyncpg.Connection[Any], params: GetFrequentHighValueCustomersParams) -> list[GetFrequentHighValueCustomersResult]:
      rows = await conn.fetch(
          """
              SELECT
                  user_id,
                  COUNT(*) as order_count,
                  SUM(total_amount) as total_spent
              FROM test_orders
              GROUP BY user_id
              HAVING COUNT(*) >= $1 AND SUM(total_amount) >= $2
              """,
          params.minOrders, params.minSpent,
      )
      return [GetFrequentHighValueCustomersResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestAggregations.test_window_functions
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithRankingsResult:
      id: int | None
      email: str | None
      name: str | None
      created_at: datetime | None
      signup_order: int | None
      role_rank: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithRankingsParams:
      isActive: bool
  
  
  async def get_users_with_rankings(conn: asyncpg.Connection[Any], params: GetUsersWithRankingsParams) -> GetUsersWithRankingsResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  id,
                  email,
                  name,
                  created_at,
                  ROW_NUMBER() OVER (ORDER BY created_at) as signup_order,
                  RANK() OVER (PARTITION BY role ORDER BY created_at) as role_rank
              FROM test_users
              WHERE is_active = $1
              """,
          params.isActive,
      )
      return GetUsersWithRankingsResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestArrayOperations.test_array_contains
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByTagsResult:
      id: int | None
      email: str | None
      name: str | None
      tags: Any | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByTagsParams:
      requiredTags: Any
  
  
  async def get_users_by_tags(conn: asyncpg.Connection[Any], params: GetUsersByTagsParams) -> list[GetUsersByTagsResult]:
      rows = await conn.fetch(
          """
              SELECT id, email, name, tags
              FROM test_users
              WHERE tags @> $1
              """,
          params.requiredTags,
      )
      return [GetUsersByTagsResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestArrayOperations.test_array_overlap
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByAnyTagResult:
      id: int | None
      email: str | None
      name: str | None
      tags: Any | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByAnyTagParams:
      anyOfTags: Any
  
  
  async def get_users_by_any_tag(conn: asyncpg.Connection[Any], params: GetUsersByAnyTagParams) -> list[GetUsersByAnyTagResult]:
      rows = await conn.fetch(
          """
              SELECT id, email, name, tags
              FROM test_users
              WHERE tags && $1
              """,
          params.anyOfTags,
      )
      return [GetUsersByAnyTagResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestArrayOperations.test_array_unnest
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserTagsExpandedResult:
      id: int | None
      email: str | None
      tag: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserTagsExpandedParams:
      userId: int
  
  
  async def get_user_tags_expanded(conn: asyncpg.Connection[Any], params: GetUserTagsExpandedParams) -> GetUserTagsExpandedResult | None:
      row = await conn.fetchrow(
          """
              SELECT u.id, u.email, unnest(u.tags) as tag
              FROM test_users u
              WHERE u.id = $1
              """,
          params.userId,
      )
      return GetUserTagsExpandedResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBatchOperations.test_insert_multiple_rows
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateTagsBatchResult:
      id: int | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateTagsBatchParams:
      tagNames: Any
  
  
  async def create_tags_batch(conn: asyncpg.Connection[Any], params: CreateTagsBatchParams) -> list[CreateTagsBatchResult]:
      rows = await conn.fetch(
          """
              INSERT INTO test_tags (name)
              SELECT unnest($1::text[])
              ON CONFLICT (name) DO NOTHING
              RETURNING id, name
              """,
          params.tagNames,
      )
      return [CreateTagsBatchResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestBatchOperations.test_update_multiple_with_values
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateProductStockBatchResult:
      id: int | None
      name: str | None
      stock_count: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateProductStockBatchParams:
      productIds: Any
      newStockCounts: Any
  
  
  async def update_product_stock_batch(conn: asyncpg.Connection[Any], params: UpdateProductStockBatchParams) -> list[UpdateProductStockBatchResult]:
      rows = await conn.fetch(
          """
              UPDATE test_products p
              SET stock_count = v.new_stock, updated_at = NOW()
              FROM (
                  SELECT unnest($1::int[]) as id, unnest($2::int[]) as new_stock
              ) v
              WHERE p.id = v.id
              RETURNING p.id, p.name, p.stock_count
              """,
          params.productIds, params.newStockCounts,
      )
      return [UpdateProductStockBatchResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestCTEs.test_cte_with_insert
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithAuditResult:
      id: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithAuditParams:
      email: str
      name: str
      performedBy: int
  
  
  async def create_user_with_audit(conn: asyncpg.Connection[Any], params: CreateUserWithAuditParams) -> CreateUserWithAuditResult | None:
      row = await conn.fetchrow(
          """
              WITH new_user AS (
                  INSERT INTO test_users (email, name)
                  VALUES ($1, $2)
                  RETURNING id, email, name
              )
              INSERT INTO test_audit_log (table_name, record_id, action, new_data, performed_by)
              SELECT 'test_users', id, 'INSERT', to_jsonb(new_user), $3
              FROM new_user
              RETURNING id
              """,
          params.email, params.name, params.performedBy,
      )
      return CreateUserWithAuditResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestCTEs.test_multiple_ctes
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetHighValueUsersResult:
      id: int | None
      email: str | None
      name: str | None
      total_spent: Decimal | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetHighValueUsersParams:
      minSpent: Decimal
  
  
  async def get_high_value_users(conn: asyncpg.Connection[Any], params: GetHighValueUsersParams) -> GetHighValueUsersResult | None:
      row = await conn.fetchrow(
          """
              WITH
              user_orders AS (
                  SELECT user_id, COUNT(*) as order_count, SUM(total_amount) as total_spent
                  FROM test_orders
                  GROUP BY user_id
              ),
              high_value_users AS (
                  SELECT user_id, total_spent
                  FROM user_orders
                  WHERE total_spent > $1
              )
              SELECT u.id, u.email, u.name, hvu.total_spent
              FROM test_users u
              JOIN high_value_users hvu ON u.id = hvu.user_id
              ORDER BY hvu.total_spent DESC
              """,
          params.minSpent,
      )
      return GetHighValueUsersResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestCTEs.test_recursive_cte
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetCategoryTreeResult:
      id: int | None
      name: str | None
      parent_id: int | None
      depth: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetCategoryTreeParams:
      rootCategoryId: int
  
  
  async def get_category_tree(conn: asyncpg.Connection[Any], params: GetCategoryTreeParams) -> GetCategoryTreeResult | None:
      row = await conn.fetchrow(
          """
              WITH RECURSIVE category_tree AS (
                  SELECT id, name, parent_id, 1 as depth
                  FROM test_categories
                  WHERE id = $1
  
                  UNION ALL
  
                  SELECT c.id, c.name, c.parent_id, ct.depth + 1
                  FROM test_categories c
                  JOIN category_tree ct ON c.parent_id = ct.id
              )
              SELECT id, name, parent_id, depth
              FROM category_tree
              ORDER BY depth
              """,
          params.rootCategoryId,
      )
      return GetCategoryTreeResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestCTEs.test_simple_cte
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetActiveUsersByEmailPatternResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetActiveUsersByEmailPatternParams:
      emailPattern: str
  
  
  async def get_active_users_by_email_pattern(conn: asyncpg.Connection[Any], params: GetActiveUsersByEmailPatternParams) -> GetActiveUsersByEmailPatternResult | None:
      row = await conn.fetchrow(
          """
              WITH active_users AS (
                  SELECT id, email, name
                  FROM test_users
                  WHERE is_active = true
              )
              SELECT * FROM active_users WHERE email LIKE $1
              """,
          params.emailPattern,
      )
      return GetActiveUsersByEmailPatternResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestComplexDeletes.test_delete_using
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteItemsFromOrdersByStatusResult:
      id: int | None
      order_id: int | None
      product_id: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteItemsFromOrdersByStatusParams:
      status: str
  
  
  async def delete_items_from_orders_by_status(conn: asyncpg.Connection[Any], params: DeleteItemsFromOrdersByStatusParams) -> DeleteItemsFromOrdersByStatusResult | None:
      row = await conn.fetchrow(
          """
              DELETE FROM test_order_items oi
              USING test_orders o
              WHERE oi.order_id = o.id AND o.status = $1
              RETURNING oi.id, oi.order_id, oi.product_id
              """,
          params.status,
      )
      return DeleteItemsFromOrdersByStatusResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestComplexDeletes.test_delete_with_subquery
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteOldOrdersForInactiveUsersParams:
      beforeDate: datetime
  
  
  async def delete_old_orders_for_inactive_users(conn: asyncpg.Connection[Any], params: DeleteOldOrdersForInactiveUsersParams) -> int:
      result = await conn.execute(
          """
              DELETE FROM test_orders
              WHERE user_id IN (
                  SELECT id FROM test_users WHERE is_active = false
              )
              AND created_at < $1
              """,
          params.beforeDate,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestComplexUpdates.test_update_from_subquery
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CancelOrdersForInactiveUsersResult:
      id: int | None
      status: str | None
      user_id: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class CancelOrdersForInactiveUsersParams:
      newStatus: str
  
  
  async def cancel_orders_for_inactive_users(conn: asyncpg.Connection[Any], params: CancelOrdersForInactiveUsersParams) -> CancelOrdersForInactiveUsersResult | None:
      row = await conn.fetchrow(
          """
              UPDATE test_orders o
              SET status = $1, updated_at = NOW()
              FROM test_users u
              WHERE o.user_id = u.id AND u.is_active = false
              RETURNING o.id, o.status, o.user_id
              """,
          params.newStatus,
      )
      return CancelOrdersForInactiveUsersResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestComplexUpdates.test_update_with_case
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class ClassifyPendingOrdersResult:
      id: int | None
      status: str | None
      total_amount: Decimal | None
  
  
  @dataclass(frozen=True, slots=True)
  class ClassifyPendingOrdersParams:
      priorityThreshold: Decimal
      standardThreshold: Decimal
  
  
  async def classify_pending_orders(conn: asyncpg.Connection[Any], params: ClassifyPendingOrdersParams) -> list[ClassifyPendingOrdersResult]:
      rows = await conn.fetch(
          """
              UPDATE test_orders
              SET status = CASE
                  WHEN total_amount >= $1 THEN 'priority'
                  WHEN total_amount >= $2 THEN 'standard'
                  ELSE 'economy'
              END,
              updated_at = NOW()
              WHERE status = 'pending'
              RETURNING id, status, total_amount
              """,
          params.priorityThreshold, params.standardThreshold,
      )
      return [ClassifyPendingOrdersResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestInsertOnConflict.test_insert_on_conflict_do_nothing
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserIfNotExistsParams:
      email: str
      name: str
  
  
  async def create_user_if_not_exists(conn: asyncpg.Connection[Any], params: CreateUserIfNotExistsParams) -> int:
      result = await conn.execute(
          """
              INSERT INTO test_users (email, name)
              VALUES ($1, $2)
              ON CONFLICT (email) DO NOTHING
              """,
          params.email, params.name,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestInsertOnConflict.test_insert_on_conflict_do_nothing_returning
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserIfNotExistsReturningResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserIfNotExistsReturningParams:
      email: str
      name: str
  
  
  async def create_user_if_not_exists_returning(conn: asyncpg.Connection[Any], params: CreateUserIfNotExistsReturningParams) -> CreateUserIfNotExistsReturningResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_users (email, name)
              VALUES ($1, $2)
              ON CONFLICT (email) DO NOTHING
              RETURNING id, email, name
              """,
          params.email, params.name,
      )
      return CreateUserIfNotExistsReturningResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestInsertOnConflict.test_insert_on_conflict_do_update
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpsertUserResult:
      id: int | None
      email: str | None
      name: str | None
      role: str | None
      updated_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class UpsertUserParams:
      email: str
      name: str
      role: str
  
  
  async def upsert_user(conn: asyncpg.Connection[Any], params: UpsertUserParams) -> UpsertUserResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_users (email, name, role)
              VALUES ($1, $2, $3)
              ON CONFLICT (email) DO UPDATE
              SET name = EXCLUDED.name, role = EXCLUDED.role, updated_at = NOW()
              RETURNING id, email, name, role, updated_at
              """,
          params.email, params.name, params.role,
      )
      return UpsertUserResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestInsertOnConflict.test_insert_on_conflict_do_update_partial
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpsertProductIfPriceHigherResult:
      id: int | None
      name: str | None
      price: Decimal | None
      updated_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class UpsertProductIfPriceHigherParams:
      name: str
      price: Decimal
      categoryId: int
  
  
  async def upsert_product_if_price_higher(conn: asyncpg.Connection[Any], params: UpsertProductIfPriceHigherParams) -> UpsertProductIfPriceHigherResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_products (name, price, category_id)
              VALUES ($1, $2, $3)
              ON CONFLICT (name) DO UPDATE
              SET price = EXCLUDED.price, updated_at = NOW()
              WHERE test_products.price < EXCLUDED.price
              RETURNING id, name, price, updated_at
              """,
          params.name, params.price, params.categoryId,
      )
      return UpsertProductIfPriceHigherResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestJoins.test_inner_join
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrdersWithUserByStatusResult:
      id: int | None
      status: str | None
      total_amount: Decimal | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrdersWithUserByStatusParams:
      status: str
  
  
  async def get_orders_with_user_by_status(conn: asyncpg.Connection[Any], params: GetOrdersWithUserByStatusParams) -> GetOrdersWithUserByStatusResult | None:
      row = await conn.fetchrow(
          """
              SELECT o.id, o.status, o.total_amount, u.email, u.name
              FROM test_orders o
              INNER JOIN test_users u ON o.user_id = u.id
              WHERE o.status = $1
              """,
          params.status,
      )
      return GetOrdersWithUserByStatusResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestJoins.test_left_join
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithOrderCountResult:
      id: int | None
      email: str | None
      name: str | None
      order_count: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithOrderCountParams:
      isActive: bool
  
  
  async def get_users_with_order_count(conn: asyncpg.Connection[Any], params: GetUsersWithOrderCountParams) -> GetUsersWithOrderCountResult | None:
      row = await conn.fetchrow(
          """
              SELECT u.id, u.email, u.name, COUNT(o.id) as order_count
              FROM test_users u
              LEFT JOIN test_orders o ON u.id = o.user_id
              WHERE u.is_active = $1
              GROUP BY u.id, u.email, u.name
              """,
          params.isActive,
      )
      return GetUsersWithOrderCountResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestJoins.test_multiple_joins
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrderDetailsResult:
      order_id: int | None
      status: str | None
      user_email: str | None
      product_name: str | None
      quantity: int | None
      unit_price: Decimal | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrderDetailsParams:
      orderId: int
  
  
  async def get_order_details(conn: asyncpg.Connection[Any], params: GetOrderDetailsParams) -> GetOrderDetailsResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  o.id as order_id,
                  o.status,
                  u.email as user_email,
                  p.name as product_name,
                  oi.quantity,
                  oi.unit_price
              FROM test_orders o
              JOIN test_users u ON o.user_id = u.id
              JOIN test_order_items oi ON o.id = oi.order_id
              JOIN test_products p ON oi.product_id = p.id
              WHERE o.id = $1
              """,
          params.orderId,
      )
      return GetOrderDetailsResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestJoins.test_self_join
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetCategoryWithParentResult:
      id: int | None
      name: str | None
      parent_name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetCategoryWithParentParams:
      categoryId: int
  
  
  async def get_category_with_parent(conn: asyncpg.Connection[Any], params: GetCategoryWithParentParams) -> GetCategoryWithParentResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  c.id,
                  c.name,
                  p.name as parent_name
              FROM test_categories c
              LEFT JOIN test_categories p ON c.parent_id = p.id
              WHERE c.id = $1
              """,
          params.categoryId,
      )
      return GetCategoryWithParentResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestJsonOperations.test_jsonb_array_elements
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrderShippingAddressesResult:
      id: int | None
      status: str | None
      street: str | None
      city: str | None
      zip_code: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetOrderShippingAddressesParams:
      orderId: int
  
  
  async def get_order_shipping_addresses(conn: asyncpg.Connection[Any], params: GetOrderShippingAddressesParams) -> GetOrderShippingAddressesResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  o.id,
                  o.status,
                  addr->>'street' as street,
                  addr->>'city' as city,
                  addr->>'zip' as zip_code
              FROM test_orders o,
              jsonb_array_elements(o.shipping_address->'addresses') as addr
              WHERE o.id = $1
              """,
          params.orderId,
      )
      return GetOrderShippingAddressesResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestJsonOperations.test_jsonb_containment
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByMetadataMatchResult:
      id: int | None
      email: str | None
      name: str | None
      metadata: Any | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByMetadataMatchParams:
      metadataFilter: Any
  
  
  async def get_users_by_metadata_match(conn: asyncpg.Connection[Any], params: GetUsersByMetadataMatchParams) -> list[GetUsersByMetadataMatchResult]:
      rows = await conn.fetch(
          """
              SELECT id, email, name, metadata
              FROM test_users
              WHERE metadata @> $1
              """,
          params.metadataFilter,
      )
      return [GetUsersByMetadataMatchResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestJsonOperations.test_jsonb_field_access
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByThemeResult:
      id: int | None
      email: str | None
      theme: str | None
      language: str | None
      notifications_enabled: bool | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByThemeParams:
      theme: str
  
  
  async def get_users_by_theme(conn: asyncpg.Connection[Any], params: GetUsersByThemeParams) -> GetUsersByThemeResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  id,
                  email,
                  metadata->>'theme' as theme,
                  metadata->>'language' as language,
                  (metadata->>'notifications')::boolean as notifications_enabled
              FROM test_users
              WHERE metadata->>'theme' = $1
              """,
          params.theme,
      )
      return GetUsersByThemeResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestSubqueries.test_exists_subquery
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithOrderStatusResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithOrderStatusParams:
      status: str
  
  
  async def get_users_with_order_status(conn: asyncpg.Connection[Any], params: GetUsersWithOrderStatusParams) -> GetUsersWithOrderStatusResult | None:
      row = await conn.fetchrow(
          """
              SELECT id, email, name
              FROM test_users u
              WHERE EXISTS (
                  SELECT 1 FROM test_orders o
                  WHERE o.user_id = u.id AND o.status = $1
              )
              """,
          params.status,
      )
      return GetUsersWithOrderStatusResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestSubqueries.test_lateral_join
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithRecentOrdersResult:
      id: int | None
      email: str | None
      order_id: int | None
      total_amount: Decimal | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithRecentOrdersParams:
      orderLimit: int
  
  
  async def get_users_with_recent_orders(conn: asyncpg.Connection[Any], params: GetUsersWithRecentOrdersParams) -> GetUsersWithRecentOrdersResult | None:
      row = await conn.fetchrow(
          """
              SELECT u.id, u.email, recent_orders.order_id, recent_orders.total_amount
              FROM test_users u
              CROSS JOIN LATERAL (
                  SELECT o.id as order_id, o.total_amount
                  FROM test_orders o
                  WHERE o.user_id = u.id
                  ORDER BY o.created_at DESC
                  LIMIT $1
              ) recent_orders
              WHERE u.is_active = true
              """,
          params.orderLimit,
      )
      return GetUsersWithRecentOrdersResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestSubqueries.test_subquery_in_select
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserWithStatsResult:
      id: int | None
      email: str | None
      name: str | None
      cnt: int | None
      sum: Decimal | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserWithStatsParams:
      userId: int
  
  
  async def get_user_with_stats(conn: asyncpg.Connection[Any], params: GetUserWithStatsParams) -> GetUserWithStatsResult | None:
      row = await conn.fetchrow(
          """
              SELECT
                  u.id,
                  u.email,
                  u.name,
                  (SELECT COUNT(*) FROM test_orders WHERE user_id = u.id) as cnt,
                  (SELECT COALESCE(SUM(total_amount), 0) FROM test_orders WHERE user_id = u.id) as sum
              FROM test_users u
              WHERE u.id = $1
              """,
          params.userId,
      )
      return GetUserWithStatsResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestSubqueries.test_subquery_in_where
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from decimal import Decimal
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithHighValueOrdersResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersWithHighValueOrdersParams:
      minAmount: Decimal
  
  
  async def get_users_with_high_value_orders(conn: asyncpg.Connection[Any], params: GetUsersWithHighValueOrdersParams) -> list[GetUsersWithHighValueOrdersResult]:
      rows = await conn.fetch(
          """
              SELECT id, email, name
              FROM test_users
              WHERE id IN (
                  SELECT DISTINCT user_id
                  FROM test_orders
                  WHERE total_amount > $1
              )
              """,
          params.minAmount,
      )
      return [GetUsersWithHighValueOrdersResult(**dict(row)) for row in rows]
  
  '''
# ---
