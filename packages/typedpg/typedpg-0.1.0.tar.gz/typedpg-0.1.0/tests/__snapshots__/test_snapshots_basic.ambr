# serializer version: 1
# name: TestBasicDelete.test_delete_by_id
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteUserByIdParams:
      userId: int
  
  
  async def delete_user_by_id(conn: asyncpg.Connection[Any], params: DeleteUserByIdParams) -> int:
      result = await conn.execute(
          """DELETE FROM test_users WHERE id = $1""",
          params.userId,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestBasicDelete.test_delete_returning
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteUserReturningResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteUserReturningParams:
      userId: int
  
  
  async def delete_user_returning(conn: asyncpg.Connection[Any], params: DeleteUserReturningParams) -> DeleteUserReturningResult | None:
      row = await conn.fetchrow(
          """DELETE FROM test_users WHERE id = $1 RETURNING id, email, name""",
          params.userId,
      )
      return DeleteUserReturningResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicDelete.test_delete_with_condition
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class DeleteInactiveUsersBeforeParams:
      beforeDate: datetime
  
  
  async def delete_inactive_users_before(conn: asyncpg.Connection[Any], params: DeleteInactiveUsersBeforeParams) -> int:
      result = await conn.execute(
          """DELETE FROM test_users WHERE is_active = false AND deleted_at < $1""",
          params.beforeDate,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestBasicDelete.test_soft_delete
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class SoftDeleteUserResult:
      id: int | None
      email: str | None
      deleted_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class SoftDeleteUserParams:
      userId: int
  
  
  async def soft_delete_user(conn: asyncpg.Connection[Any], params: SoftDeleteUserParams) -> SoftDeleteUserResult | None:
      row = await conn.fetchrow(
          """
              UPDATE test_users
              SET deleted_at = NOW(), is_active = false
              WHERE id = $1
              RETURNING id, email, deleted_at
              """,
          params.userId,
      )
      return SoftDeleteUserResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicInsert.test_insert_returning_all
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserFullResult:
      id: int | None
      email: str | None
      name: str | None
      age: int | None
      is_active: bool | None
      role: str | None
      metadata: Any | None
      tags: Any | None
      created_at: datetime | None
      updated_at: datetime | None
      deleted_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserFullParams:
      email: str
      name: str
      role: str
  
  
  async def create_user_full(conn: asyncpg.Connection[Any], params: CreateUserFullParams) -> CreateUserFullResult | None:
      row = await conn.fetchrow(
          """INSERT INTO test_users (email, name, role) VALUES ($1, $2, $3) RETURNING *""",
          params.email, params.name, params.role,
      )
      return CreateUserFullResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicInsert.test_insert_returning_id
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserReturningIdResult:
      id: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserReturningIdParams:
      email: str
      name: str
  
  
  async def create_user_returning_id(conn: asyncpg.Connection[Any], params: CreateUserReturningIdParams) -> CreateUserReturningIdResult | None:
      row = await conn.fetchrow(
          """INSERT INTO test_users (email, name) VALUES ($1, $2) RETURNING id""",
          params.email, params.name,
      )
      return CreateUserReturningIdResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicInsert.test_insert_simple
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserSimpleParams:
      email: str
      name: str
  
  
  async def create_user_simple(conn: asyncpg.Connection[Any], params: CreateUserSimpleParams) -> int:
      result = await conn.execute(
          """INSERT INTO test_users (email, name) VALUES ($1, $2)""",
          params.email, params.name,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestBasicInsert.test_insert_with_array
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithTagsResult:
      id: int | None
      email: str | None
      tags: Any | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithTagsParams:
      email: str
      name: str
      tags: Any
  
  
  async def create_user_with_tags(conn: asyncpg.Connection[Any], params: CreateUserWithTagsParams) -> CreateUserWithTagsResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_users (email, name, tags)
              VALUES ($1, $2, $3)
              RETURNING id, email, tags
              """,
          params.email, params.name, params.tags,
      )
      return CreateUserWithTagsResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicInsert.test_insert_with_defaults
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithDefaultsResult:
      id: int | None
      email: str | None
      name: str | None
      is_active: bool | None
      role: str | None
      created_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithDefaultsParams:
      email: str
      name: str
  
  
  async def create_user_with_defaults(conn: asyncpg.Connection[Any], params: CreateUserWithDefaultsParams) -> CreateUserWithDefaultsResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_users (email, name)
              VALUES ($1, $2)
              RETURNING id, email, name, is_active, role, created_at
              """,
          params.email, params.name,
      )
      return CreateUserWithDefaultsResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicInsert.test_insert_with_jsonb
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithMetadataResult:
      id: int | None
      email: str | None
      metadata: Any | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserWithMetadataParams:
      email: str
      name: str
      metadata: Any
  
  
  async def create_user_with_metadata(conn: asyncpg.Connection[Any], params: CreateUserWithMetadataParams) -> CreateUserWithMetadataResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_users (email, name, metadata)
              VALUES ($1, $2, $3)
              RETURNING id, email, metadata
              """,
          params.email, params.name, params.metadata,
      )
      return CreateUserWithMetadataResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicSelect.test_select_all_columns
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetAllUsersResult:
      id: int | None
      email: str | None
      name: str | None
      age: int | None
      is_active: bool | None
      role: str | None
      metadata: Any | None
      tags: Any | None
      created_at: datetime | None
      updated_at: datetime | None
      deleted_at: datetime | None
  
  
  async def get_all_users(conn: asyncpg.Connection[Any]) -> list[GetAllUsersResult]:
      rows = await conn.fetch(
          """SELECT * FROM test_users""",
      )
      return [GetAllUsersResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestBasicSelect.test_select_count
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class CountActiveUsersResult:
      total: int | None
  
  
  @dataclass(frozen=True, slots=True)
  class CountActiveUsersParams:
      isActive: bool
  
  
  async def count_active_users(conn: asyncpg.Connection[Any], params: CountActiveUsersParams) -> CountActiveUsersResult | None:
      row = await conn.fetchrow(
          """SELECT COUNT(*) as total FROM test_users WHERE is_active = $1""",
          params.isActive,
      )
      return CountActiveUsersResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicSelect.test_select_specific_columns
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserBasicInfoResult:
      id: int | None
      email: str | None
      name: str | None
      created_at: datetime | None
  
  
  async def get_user_basic_info(conn: asyncpg.Connection[Any]) -> list[GetUserBasicInfoResult]:
      rows = await conn.fetch(
          """SELECT id, email, name, created_at FROM test_users""",
      )
      return [GetUserBasicInfoResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestBasicSelect.test_select_with_in_clause
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByIdsResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByIdsParams:
      userIds: Any
  
  
  async def get_users_by_ids(conn: asyncpg.Connection[Any], params: GetUsersByIdsParams) -> GetUsersByIdsResult | None:
      row = await conn.fetchrow(
          """SELECT id, email, name FROM test_users WHERE id = ANY($1)""",
          params.userIds,
      )
      return GetUsersByIdsResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicSelect.test_select_with_like
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class SearchUsersByEmailResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class SearchUsersByEmailParams:
      emailPattern: str
  
  
  async def search_users_by_email(conn: asyncpg.Connection[Any], params: SearchUsersByEmailParams) -> list[SearchUsersByEmailResult]:
      rows = await conn.fetch(
          """SELECT id, email, name FROM test_users WHERE email LIKE $1""",
          params.emailPattern,
      )
      return [SearchUsersByEmailResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestBasicSelect.test_select_with_limit
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetLatestUserResult:
      id: int | None
      email: str | None
  
  
  async def get_latest_user(conn: asyncpg.Connection[Any]) -> GetLatestUserResult | None:
      row = await conn.fetchrow(
          """SELECT id, email FROM test_users ORDER BY created_at DESC LIMIT 1""",
      )
      return GetLatestUserResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicSelect.test_select_with_multiple_params
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByStatusAndRoleResult:
      id: int | None
      email: str | None
      name: str | None
      role: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersByStatusAndRoleParams:
      isActive: bool
      role: str
  
  
  async def get_users_by_status_and_role(conn: asyncpg.Connection[Any], params: GetUsersByStatusAndRoleParams) -> list[GetUsersByStatusAndRoleResult]:
      rows = await conn.fetch(
          """
              SELECT id, email, name, role
              FROM test_users
              WHERE is_active = $1 AND role = $2
              """,
          params.isActive, params.role,
      )
      return [GetUsersByStatusAndRoleResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestBasicSelect.test_select_with_order_and_pagination
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersPaginatedResult:
      id: int | None
      email: str | None
      name: str | None
      created_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUsersPaginatedParams:
      limit: int
      offset: int
  
  
  async def get_users_paginated(conn: asyncpg.Connection[Any], params: GetUsersPaginatedParams) -> list[GetUsersPaginatedResult]:
      rows = await conn.fetch(
          """
              SELECT id, email, name, created_at
              FROM test_users
              ORDER BY created_at DESC
              LIMIT $1 OFFSET $2
              """,
          params.limit, params.offset,
      )
      return [GetUsersPaginatedResult(**dict(row)) for row in rows]
  
  '''
# ---
# name: TestBasicSelect.test_select_with_where_single_param
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserByIdResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetUserByIdParams:
      userId: int
  
  
  async def get_user_by_id(conn: asyncpg.Connection[Any], params: GetUserByIdParams) -> GetUserByIdResult | None:
      row = await conn.fetchrow(
          """SELECT id, email, name FROM test_users WHERE id = $1""",
          params.userId,
      )
      return GetUserByIdResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicUpdate.test_update_jsonb
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateUserMetadataResult:
      id: int | None
      metadata: Any | None
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateUserMetadataParams:
      newMetadata: Any
      userId: int
  
  
  async def update_user_metadata(conn: asyncpg.Connection[Any], params: UpdateUserMetadataParams) -> UpdateUserMetadataResult | None:
      row = await conn.fetchrow(
          """
              UPDATE test_users
              SET metadata = metadata || $1
              WHERE id = $2
              RETURNING id, metadata
              """,
          params.newMetadata, params.userId,
      )
      return UpdateUserMetadataResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicUpdate.test_update_multiple_columns
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateUserDetailsParams:
      name: str
      email: str
      role: str
      userId: int
  
  
  async def update_user_details(conn: asyncpg.Connection[Any], params: UpdateUserDetailsParams) -> int:
      result = await conn.execute(
          """
              UPDATE test_users
              SET name = $1, email = $2, role = $3, updated_at = NOW()
              WHERE id = $4
              """,
          params.name, params.email, params.role, params.userId,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestBasicUpdate.test_update_returning
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateUserNameReturningResult:
      id: int | None
      name: str | None
      email: str | None
      updated_at: datetime | None
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateUserNameReturningParams:
      name: str
      userId: int
  
  
  async def update_user_name_returning(conn: asyncpg.Connection[Any], params: UpdateUserNameReturningParams) -> UpdateUserNameReturningResult | None:
      row = await conn.fetchrow(
          """
              UPDATE test_users
              SET name = $1, updated_at = NOW()
              WHERE id = $2
              RETURNING id, name, email, updated_at
              """,
          params.name, params.userId,
      )
      return UpdateUserNameReturningResult(**dict(row)) if row else None
  
  '''
# ---
# name: TestBasicUpdate.test_update_single_column
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class UpdateUserNameParams:
      name: str
      userId: int
  
  
  async def update_user_name(conn: asyncpg.Connection[Any], params: UpdateUserNameParams) -> int:
      result = await conn.execute(
          """UPDATE test_users SET name = $1 WHERE id = $2""",
          params.name, params.userId,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestBasicUpdate.test_update_with_condition
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  from datetime import datetime
  import asyncpg
  
  
  
  @dataclass(frozen=True, slots=True)
  class DeactivateOldUsersByRoleParams:
      isActive: bool
      role: str
      beforeDate: datetime
  
  
  async def deactivate_old_users_by_role(conn: asyncpg.Connection[Any], params: DeactivateOldUsersByRoleParams) -> int:
      result = await conn.execute(
          """
              UPDATE test_users
              SET is_active = $1
              WHERE role = $2 AND created_at < $3
              """,
          params.isActive, params.role, params.beforeDate,
      )
      return int(result.split()[-1])
  
  '''
# ---
# name: TestPsycopgDriver.test_psycopg_insert_returning
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import psycopg
  from psycopg.rows import class_row
  
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserResult:
      id: int | None
      email: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class CreateUserParams:
      email: str
      name: str
  
  
  async def create_user(conn: psycopg.AsyncConnection[Any], params: CreateUserParams) -> CreateUserResult | None:
      async with conn.cursor(row_factory=class_row(CreateUserResult)) as cur:
          await cur.execute("""INSERT INTO test_users (email, name) VALUES ($1, $2) RETURNING id, email""", (params.email, params.name,))
          return await cur.fetchone()
  
  '''
# ---
# name: TestPsycopgDriver.test_psycopg_select
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from dataclasses import dataclass
  from typing import Any
  import psycopg
  from psycopg.rows import class_row
  
  
  
  @dataclass(frozen=True, slots=True)
  class GetActiveUsersResult:
      id: int | None
      email: str | None
      name: str | None
  
  
  @dataclass(frozen=True, slots=True)
  class GetActiveUsersParams:
      isActive: bool
  
  
  async def get_active_users(conn: psycopg.AsyncConnection[Any], params: GetActiveUsersParams) -> GetActiveUsersResult | None:
      async with conn.cursor(row_factory=class_row(GetActiveUsersResult)) as cur:
          await cur.execute("""SELECT id, email, name FROM test_users WHERE is_active = $1""", (params.isActive,))
          return await cur.fetchone()
  
  '''
# ---
# name: TestPydanticOutput.test_pydantic_insert_returning
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from typing import Any
  
  from pydantic import BaseModel, ConfigDict
  from datetime import datetime
  from typing import Any
  import asyncpg
  
  
  
  class CreateUserResult(BaseModel):
      model_config = ConfigDict(frozen=True)
  
      id: int | None
      email: str | None
      name: str | None
      age: int | None
      is_active: bool | None
      role: str | None
      metadata: Any | None
      tags: Any | None
      created_at: datetime | None
      updated_at: datetime | None
      deleted_at: datetime | None
  
  
  class CreateUserParams(BaseModel):
      model_config = ConfigDict(frozen=True)
  
      email: str
      name: str
      metadata: Any
  
  
  async def create_user(conn: asyncpg.Connection[Any], params: CreateUserParams) -> CreateUserResult | None:
      row = await conn.fetchrow(
          """
              INSERT INTO test_users (email, name, metadata)
              VALUES ($1, $2, $3)
              RETURNING *
              """,
          params.email, params.name, params.metadata,
      )
      return CreateUserResult.model_validate(dict(row)) if row else None
  
  '''
# ---
# name: TestPydanticOutput.test_pydantic_select
  '''
  """
  
  Auto-generated typed queries.
  
  DO NOT EDIT - Generated by typedpg
  
  """
  
  
  
  from __future__ import annotations
  
  from typing import Any
  
  from pydantic import BaseModel, ConfigDict
  from datetime import datetime
  from typing import Any
  import asyncpg
  
  
  
  class GetUserByIdResult(BaseModel):
      model_config = ConfigDict(frozen=True)
  
      id: int | None
      email: str | None
      name: str | None
      metadata: Any | None
      created_at: datetime | None
  
  
  class GetUserByIdParams(BaseModel):
      model_config = ConfigDict(frozen=True)
  
      userId: int
  
  
  async def get_user_by_id(conn: asyncpg.Connection[Any], params: GetUserByIdParams) -> GetUserByIdResult | None:
      row = await conn.fetchrow(
          """SELECT id, email, name, metadata, created_at FROM test_users WHERE id = $1""",
          params.userId,
      )
      return GetUserByIdResult.model_validate(dict(row)) if row else None
  
  '''
# ---
