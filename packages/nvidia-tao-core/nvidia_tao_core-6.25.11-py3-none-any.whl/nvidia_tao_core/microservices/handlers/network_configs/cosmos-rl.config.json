{
    "api_params": {
        "dataset_type": "vlm",
        "actions": ["train", "inference", "evaluate", "inference_microservice", "quantize"],
        "formats": ["llava"],
        "accepted_ds_intents": ["training", "evaluation", "testing"],
        "image": "COSMOS_RL",
        "spec_backend": "toml",
        "actions_pipe": {
            "train": "train",
            "inference":"inference",
            "evaluate": "evaluate",
            "quantize": "train"
        }
    },

    "actions_mapping": {
        "inference_microservice": {
            "action": "inference"
        }
    },

    "checkpoint": {
        "format": "safetensors",
        "folder": "true"
    },

    "cloud_upload": {
        "exclude_patterns": {
            "train": ["\\.pth$"],
            "evaluate": ["/merged/"],
            "inference": ["/merged/"]
        },
        "upload_strategy": {
            "evaluate": "tarball_after_completion"
        }
    },

    "data_sources": {
        "train": {
            "custom.train_dataset.annotation_path": {
                "source": "train_datasets",
                "multiple_sources": false,
                "path": "annotations.json"
            },
            "custom.train_dataset.media_path": {
                "source": "train_datasets",
                "multiple_sources": false,
                "path_from_format": {
                    "llava": ["images.tar.gz", "videos.tar.gz"],
                    "*": "images.tar.gz"
                }
            },
            "custom.val_dataset.annotation_path": {
                "source": "eval_dataset",
                "multiple_sources": false,
                "path": "annotations.json"
            },
            "custom.val_dataset.media_path": {
                "source": "eval_dataset",
                "multiple_sources": false,
                "path_from_format": {
                    "llava": ["images.tar.gz", "videos.tar.gz"],
                    "*": "images.tar.gz"
                }
            }
        },
        "evaluate": {
            "dataset.annotation_path": {
                "source": "eval_dataset",
                "multiple_sources": false,
                "path": "annotations.json"
            },
            "dataset.media_dir": {
                "source": "eval_dataset",
                "multiple_sources": false,
                "path_from_format": {
                    "llava": ["images.tar.gz", "videos.tar.gz"],
                    "*": "videos.tar.gz"
                }
            },
            "model.enable_lora": {
                "source": "parent_job_specs",
                "check_key_exists": "policy.lora"
            }
        },
        "quantize": {
            "calibration_dataset.annotation_path": {
                "source": "calibration_dataset",
                "multiple_sources": false,
                "path": "annotations.json"
            },
            "calibration_dataset.media_dir": {
                "source": "calibration_dataset",
                "multiple_sources": false,
                "path_from_format": {
                    "llava": ["images.tar.gz", "videos.tar.gz"],
                    "*": "images.tar.gz"
                }
            }
        }
    },
    "preserve_source_path_params": ["train.output_dir"],
    "spec_params":{
        "train": {
            "results_dir":"output_dir",
            "train.output_dir":"output_dir",
            "train.resume": "resume_model_bool"
        },
        "inference": {
            "results_dir":"output_dir",
            "model_path":"parent_model_folder"
        },
        "evaluate": {
            "results_dir":"output_dir",
            "model.model_name":"parent_model_folder"
        },
        "quantize": {
            "results_dir":"output_dir",
            "model.model_path":"parent_model_folder"
        }
    },

    "automl_spec_params":{
        "results_dir":"automl_output_dir",
        "train.resume": "automl_resume_model_bool",
        "train.output_dir":"automl_output_dir",
        "train.ckpt.save_freq_in_epoch": "assign_const_value,train.epoch",
        "validation.freq_in_epoch": "assign_const_value,train.epoch,train.ckpt.save_freq_in_epoch"
     },

    "metrics": {
        "available_metrics": [
            "steps_per_epoch",
            "operation",
            "component",
            "status",
            "event",
            "accuracy",
            "config",
            "detailed_results"
        ],
        "monitoring_metric": "val/loss",
        "dynamic_metric_patterns": [
            "^train/(iteration_time|loss_avg|loss_max|learning_rate|grad_norm|model_flops|mfu)$",
            "^val/(loss|step)$",
            "^(error|error_type|error_message)$",
            "^(interrupted|step_name|replica_type)$",
            "^(max_epochs|current_epoch)$",
            "^(training_phase|training_completed)$",
            "^(correct_samples|total_samples)$",
            "^(evaluation_phase|evaluation_status)$",
            "^(validation_phase|dataset_size|total_batches|batches_processed|progress_percent)$",
            "^(inference_time_seconds|total_inference_time_seconds|model_name|prepared_inputs)$",
            "^(results_dir|results_path)$",
            "^(shard_id|total_shards|total_tasks|tasks_processed)$",
            "^lora_(enabled|merge_status|merge_error)$",
            "^merged_model_path$",
            "^soft_(accuracy|correct|threshold)$",
            "^weighted_score$",
            "^bleu$",
            "^rouge[0-9]+$",
            "^rougel(sum)?$",
            "^bertscore_(precision|recall|f1)$",
            "^(count|distance|left_right|mcq|quantitative|qualitative)_(accuracy|total|correct)$",
            "^(going.straight|turning.left|turning.right)_(accuracy|total|correct)$",
            "^(quantization_status|quantization_scheme|num_calibration_samples|smoothing_strength)$",
            "^model_path$"
        ]
    }
}
