<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyCharting</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.24/dist/uPlot.min.css">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f3ef;
            color: #111111;
            display: flex;
            flex-direction: column;
        }

        header {
            padding: 10px 20px;
            border-bottom: 1px solid #222;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            padding: 8px 12px 12px;
            overflow: hidden;
        }
        
        #chartContainer {
            width: 100%;
            position: relative;
            min-height: 200px;
        }

        .resize-handle {
            width: 100%;
            height: 3px;
            background: transparent;
            cursor: ns-resize;
            position: relative;
            margin: 0;
            transition: background 0.2s;
        }

        .resize-handle:hover {
            background: #bbb;
        }

        .resize-handle:active {
            background: #888;
        }
        
        .resize-handle::before {
            content: '';
            position: absolute;
            width: 40px;
            height: 1px;
            background: #ddd;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        #subplotsContainer {
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .subplot-wrapper {
            width: 100%;
            position: relative;
            min-height: 80px;
        }

        /* keep required DOM nodes for JS, but hide them */
        #uiHidden {
            display: none;
        }
    </style>
</head>
<body>
    <header>PyCharting</header>
    <main id="mainContainer">
        <div id="chartContainer"></div>
        <div id="mainResizeHandle" class="resize-handle" style="display: none;"></div>
        <div id="subplotsContainer"></div>

        <!-- hidden UI elements kept for JS compatibility -->
        <div id="uiHidden">
            <div id="loadingIndicator"></div>
            <span id="loadingStatus"></span>
            <span id="totalPoints"></span>
            <span id="cachedRange"></span>
            <span id="visibleRange"></span>
        </div>
    </main>
    
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.24/dist/uPlot.iife.min.js"></script>
    <script src="/static/js/chart.js"></script>
    <script src="/static/js/viewport.js"></script>
    <script>
        let chart = null;
        let viewportManager = null;
        // Name -> uPlot instance for indicator-style subplots
        let subplotCharts = {};
        
        function getSessionId() {
            const params = new URLSearchParams(window.location.search);
            return params.get('session') || null;
        }
        
        // Initialize chart
        function setupChart() {
            const container = document.getElementById('chartContainer');
            const height = container.offsetHeight || 500;
            chart = new PyChart(container, {
                title: '',
                height: height
            });
        }
        
        // Initialize viewport manager and load data
        async function initializeData() {
            if (!chart) {
                setupChart();
            }
            
            const sessionId = getSessionId() || 'viewport-demo';
            
            // Create viewport manager with loading callbacks
            viewportManager = new ViewportManager(chart, {
                sessionId: sessionId,
                bufferMargin: 0.5,
                debounceDelay: 300,
                onLoading: [updateLoadingState],
                onSubplotsUpdate: [updateSubplots]
            });
            
            try {
                if (sessionId === 'viewport-demo') {
                    // Standalone demo: create a demo session on the backend
                    const result = await viewportManager.initializeSession();
                    document.getElementById('totalPoints').textContent = 
                        result.data_points.toLocaleString();
                } else {
                    // Python API path: session already exists with real user data
                    await viewportManager.loadInitialData();
                    const info = viewportManager.getCacheInfo();
                    if (info.totalLength) {
                        document.getElementById('totalPoints').textContent = 
                            info.totalLength.toLocaleString();
                    }
                }
                
                updateCacheInfo();
                
                // Setup viewport tracking
                setupViewportTracking();
                
            } catch (error) {
                alert('Failed to initialize session: ' + error.message);
            }
        }
        
        // Update loading state
        function updateLoadingState(isLoading) {
            const indicator = document.getElementById('loadingIndicator');
            const status = document.getElementById('loadingStatus');
            
            if (isLoading) {
                indicator.classList.add('active');
                status.textContent = 'Loading...';
                status.style.color = '#ff9800';
            } else {
                indicator.classList.remove('active');
                status.textContent = 'Ready';
                status.style.color = '#4caf50';
            }
        }
        
        // Setup viewport tracking
        function setupViewportTracking() {
            if (!chart.chart) return;
            
            // Track viewport changes
            setInterval(() => {
                if (chart.chart && chart.chart.scales && chart.chart.scales.x) {
                    const scale = chart.chart.scales.x;
                    if (scale.min != null && scale.max != null) {
                        document.getElementById('visibleRange').textContent = 
                            `${Math.floor(scale.min)} - ${Math.floor(scale.max)}`;
                    }
                }
            }, 1000);
        }

        // Store timestamps globally so they can be updated on each data fetch
        let subplotTimestamps = [];
        let subplotIndices = [];

        // Create or update subplot charts when backend sends subplots
        function updateSubplots(data) {
            if (!data || !data.subplots || !data.index) {
                return;
            }

            const container = document.getElementById('subplotsContainer');
            
            // Use generated indices for X-axis to align with main chart
            const index = data.xIndices || data.index.map((_, i) => (data.start_index || 0) + i);
            const timestamps = data.timestamps || data.index;
            
            // Update global references for date formatting
            subplotIndices = index;
            subplotTimestamps = timestamps;
            
            const names = Object.keys(data.subplots);

            if (names.length === 0) return;

            // Expose charts for X-scale syncing from ViewportManager
            window.viewportSubplotCharts = subplotCharts;

            names.forEach((name) => {
                const series = data.subplots[name];
                if (!Array.isArray(series) || series.length !== index.length) {
                    return;
                }

                // Lazily create subplot panel + chart
                if (!subplotCharts[name]) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'subplot-wrapper';
                    wrapper.dataset.name = name;
                    wrapper.style.height = '150px';

                    const title = document.createElement('div');
                    title.textContent = name;
                    title.style.fontSize = '12px';
                    title.style.fontWeight = '600';
                    title.style.marginBottom = '4px';
                    title.style.color = '#555';

                    const div = document.createElement('div');
                    div.style.height = '130px';
                    div.dataset.chartDiv = name;

                    wrapper.appendChild(title);
                    wrapper.appendChild(div);
                    container.appendChild(wrapper);
                    
                    // Create resize handle below this subplot
                    const resizeHandle = document.createElement('div');
                    resizeHandle.className = 'resize-handle';
                    resizeHandle.dataset.target = name;
                    container.appendChild(resizeHandle);
                    
                    // Setup resize handler
                    setupResizeHandle(resizeHandle, wrapper, div);

                    const colors = {
                        RSI_like: '#f44336',
                        Stoch_like: '#9C27B0',
                    };

                    const chart = new uPlot({
                        width: container.clientWidth || 800,
                        height: 130,
                        series: [
                            {
                                // Format X labels as dates using global timestamps
                                value: (u, v) => {
                                    // Find index in current data
                                    const idx = subplotIndices.indexOf(v);
                                    if (idx !== -1 && subplotTimestamps[idx]) {
                                        return new Date(subplotTimestamps[idx]).toLocaleString();
                                    }
                                    return v;
                                }
                            },
                            {
                                label: name,
                                stroke: colors[name] || '#FF9800',
                                width: 2,
                            },
                        ],
                        scales: {
                            x: { time: false },
                            y: { auto: true },
                        },
                        axes: [
                            {
                                // Minimal x-axis for subplots
                                show: true,
                                values: (u, vals) => vals.map(v => {
                                    const idx = subplotIndices.indexOf(Math.round(v));
                                    if (idx !== -1 && subplotTimestamps[idx]) {
                                        // Show shorter time format for subplots
                                        return new Date(subplotTimestamps[idx]).toLocaleTimeString();
                                    }
                                    return v.toFixed(0);
                                })
                            },
                            {
                                label: name,
                                labelSize: 18,
                            },
                        ],
                    }, [index, series], div);

                    subplotCharts[name] = chart;
                } else {
                    subplotCharts[name].setData([index, series]);
                }
            });
        }
        
        // Show cache information (no visible UI on minimal page, kept for compatibility)
        function showCacheInfo() {
            if (!viewportManager) {
                return;
            }
            const info = viewportManager.getCacheInfo();
            console.log('Cache info', info);
            updateCacheInfo();
        }

        // Update cache info display
        function updateCacheInfo() {
            if (!viewportManager) return;
            
            const info = viewportManager.getCacheInfo();
            if (info.cached) {
                document.getElementById('cachedRange').textContent = 
                    `${info.startIndex} - ${info.endIndex}`;
            } else {
                document.getElementById('cachedRange').textContent = 'No cache';
            }
        }
        
        // Clear cache (no alerts on minimal page)
        function clearCache() {
            if (!viewportManager) {
                return;
            }

            viewportManager.clearCache();
            const el = document.getElementById('cachedRange');
            if (el) {
                el.textContent = 'Cache cleared';
            }
        }
        
        // Setup resize handler for a subplot
        function setupResizeHandle(handle, wrapper, chartDiv) {
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startHeight = wrapper.offsetHeight;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const newHeight = Math.max(80, startHeight + deltaY);
                const newChartHeight = newHeight - 20; // Account for title
                
                wrapper.style.height = newHeight + 'px';
                chartDiv.style.height = newChartHeight + 'px';
                
                // Resize the uPlot chart
                const chartName = wrapper.dataset.name;
                if (subplotCharts[chartName]) {
                    subplotCharts[chartName].setSize({
                        width: chartDiv.offsetWidth,
                        height: newChartHeight
                    });
                }
            });
            
            document.addEventListener('mouseup', () => {
                isResizing = false;
            });
        }
        
        // Setup main chart resize handle
        function setupMainResize() {
            const handle = document.getElementById('mainResizeHandle');
            const chartContainer = document.getElementById('chartContainer');
            const mainContainer = document.getElementById('mainContainer');
            
            let isResizing = false;
            let startY = 0;
            let startHeight = 0;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startHeight = chartContainer.offsetHeight;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const deltaY = e.clientY - startY;
                const newHeight = Math.max(200, startHeight + deltaY);
                
                chartContainer.style.height = newHeight + 'px';
                chartContainer.style.flex = 'none';
                
                // Resize the uPlot chart
                if (chart && chart.chart) {
                    chart.setSize(chartContainer.offsetWidth, newHeight);
                }
            });
            
            document.addEventListener('mouseup', () => {
                isResizing = false;
            });
        }
        
        // Initialize chart heights based on whether subplots exist
        function initializeChartHeights() {
            const mainContainer = document.getElementById('mainContainer');
            const chartContainer = document.getElementById('chartContainer');
            const subplotsContainer = document.getElementById('subplotsContainer');
            const mainHandle = document.getElementById('mainResizeHandle');
            
            // Check if subplots will be rendered
            setTimeout(() => {
                const hasSubplots = subplotsContainer.children.length > 0;
                
                if (!hasSubplots) {
                    // No subplots: make main chart consume 80% of available height
                    const availableHeight = mainContainer.offsetHeight;
                    chartContainer.style.height = (availableHeight * 0.8) + 'px';
                    chartContainer.style.flex = 'none';
                    mainHandle.style.display = 'none';
                } else {
                    // Has subplots: show resize handle
                    chartContainer.style.flex = '1';
                    chartContainer.style.minHeight = '300px';
                    mainHandle.style.display = 'block';
                    setupMainResize();
                }
                
                // Resize chart to fit container
                if (chart && chart.chart) {
                    chart.setSize(chartContainer.offsetWidth, chartContainer.offsetHeight);
                }
            }, 100);
        }
        
        // Auto-initialize on page load
        window.addEventListener('load', () => {
            const sessionId = getSessionId();
            if (sessionId) {
                // When launched via Python API, auto-init using existing session
                initializeData();
                initializeChartHeights();
            } else {
                setupChart();
                initializeChartHeights();
            }
        });
    </script>
</body>
</html>
