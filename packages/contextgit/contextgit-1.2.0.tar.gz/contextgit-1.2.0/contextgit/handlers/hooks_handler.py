"""Handler for contextgit hooks command.

contextgit:
  id: C-115
  type: code
  title: "Hooks Handler - Git Hook Integration"
  status: active
  upstream: [SR-012]
  tags: [cli, git-hooks, automation, pre-commit]

This module implements the HooksHandler for installing, uninstalling, and
managing git hooks that integrate contextgit with the git workflow.

Supported hooks:
- pre-commit: Scans changed files and optionally fails if stale links detected
- post-merge: Scans repository after merges
- pre-push: Scans before pushing (optional)

Key Design Decisions:
--------------------
1. **Idempotent Installation**: Running install multiple times is safe and will
   update existing contextgit hooks without losing user customizations.

2. **User Hook Preservation**: If a hook file exists and contains non-contextgit
   content, we warn the user instead of overwriting.

3. **Cross-Platform Support**: Hooks work on Linux, macOS, and Windows (Git Bash).

4. **Fail-on-Stale Option**: Pre-commit can optionally block commits when stale
   links are detected, useful for CI/CD workflows.
"""

import os
import stat
import json
from pathlib import Path
from typing import Dict

from contextgit.handlers.base import BaseHandler
from contextgit.infra.filesystem import FileSystem
from contextgit.infra.yaml_io import YAMLSerializer
from contextgit.infra.output import OutputFormatter
from contextgit.exceptions import RepoNotFoundError


# Hook script templates
PRE_COMMIT_HOOK = """#!/bin/bash
# contextgit pre-commit hook
# Auto-generated by 'contextgit hooks install'

# Get changed markdown/code files
changed_files=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.(md|py|ts|js|jsx|tsx|mjs|cjs)$' || true)

if [ -n "$changed_files" ]; then
    echo "üìã contextgit: Scanning changed files..."

    # Scan each changed file
    echo "$changed_files" | while read -r file; do
        if [ -f "$file" ]; then
            contextgit scan "$file" 2>/dev/null || echo "Warning: Failed to scan $file"
        fi
    done

    # Check for stale links
    stale_count=$(contextgit status --stale --format json 2>/dev/null | python3 -c "import sys,json; data=json.load(sys.stdin); print(len(data.get('stale_links', [])))" 2>/dev/null || echo 0)

    if [ "$stale_count" -gt 0 ]; then
        echo "‚ö†Ô∏è  contextgit: $stale_count stale requirement links detected"
        if [ "$CONTEXTGIT_FAIL_ON_STALE" = "1" ]; then
            echo "‚ùå Commit blocked due to stale links. Run 'contextgit status --stale' to see details."
            exit 1
        fi
    else
        echo "‚úÖ contextgit: All requirement links synchronized"
    fi
fi

exit 0
"""

POST_MERGE_HOOK = """#!/bin/bash
# contextgit post-merge hook
# Auto-generated by 'contextgit hooks install'

echo "üìã contextgit: Scanning after merge..."
contextgit scan --recursive 2>/dev/null || echo "Warning: Scan failed"

# Show stale links if any
stale_count=$(contextgit status --stale --format json 2>/dev/null | python3 -c "import sys,json; data=json.load(sys.stdin); print(len(data.get('stale_links', [])))" 2>/dev/null || echo 0)

if [ "$stale_count" -gt 0 ]; then
    echo "‚ö†Ô∏è  contextgit: $stale_count stale requirement links detected after merge"
    echo "Run 'contextgit status --stale' to see details."
fi

exit 0
"""

PRE_PUSH_HOOK = """#!/bin/bash
# contextgit pre-push hook
# Auto-generated by 'contextgit hooks install'

echo "üìã contextgit: Checking for stale links before push..."

# Check for stale links
stale_count=$(contextgit status --stale --format json 2>/dev/null | python3 -c "import sys,json; data=json.load(sys.stdin); print(len(data.get('stale_links', [])))" 2>/dev/null || echo 0)

if [ "$stale_count" -gt 0 ]; then
    echo "‚ö†Ô∏è  contextgit: $stale_count stale requirement links detected"
    if [ "$CONTEXTGIT_FAIL_ON_STALE" = "1" ]; then
        echo "‚ùå Push blocked due to stale links. Run 'contextgit status --stale' to see details."
        exit 1
    fi
fi

exit 0
"""

HOOK_TEMPLATES = {
    'pre-commit': PRE_COMMIT_HOOK,
    'post-merge': POST_MERGE_HOOK,
    'pre-push': PRE_PUSH_HOOK,
}

CONTEXTGIT_HOOK_MARKER = "# Auto-generated by 'contextgit hooks install'"


class HooksHandler(BaseHandler):
    """Handler for git hooks management.

    Provides functionality to install, uninstall, and check status of git hooks
    that integrate contextgit with the git workflow.
    """

    def _find_git_dir(self, repo_root: str) -> Path:
        """Find .git directory.

        Args:
            repo_root: Repository root path

        Returns:
            Path to .git directory

        Raises:
            ValueError: If .git directory not found
        """
        git_dir = Path(repo_root) / '.git'
        if not git_dir.exists():
            raise ValueError("Not a git repository (no .git directory found)")

        # Handle worktrees (where .git is a file, not a directory)
        if git_dir.is_file():
            # Read the .git file to find the actual git directory
            git_file_content = git_dir.read_text().strip()
            if git_file_content.startswith('gitdir: '):
                actual_git_dir = Path(git_file_content[8:])  # Remove 'gitdir: ' prefix
                if not actual_git_dir.is_absolute():
                    actual_git_dir = (git_dir.parent / actual_git_dir).resolve()
                return actual_git_dir

        return git_dir

    def _get_hooks_dir(self, repo_root: str) -> Path:
        """Get git hooks directory.

        Args:
            repo_root: Repository root path

        Returns:
            Path to hooks directory
        """
        git_dir = self._find_git_dir(repo_root)
        hooks_dir = git_dir / 'hooks'
        hooks_dir.mkdir(exist_ok=True)
        return hooks_dir

    def _is_contextgit_hook(self, hook_path: Path) -> bool:
        """Check if a hook file was created by contextgit.

        Args:
            hook_path: Path to hook file

        Returns:
            True if hook contains contextgit marker
        """
        if not hook_path.exists():
            return False

        try:
            content = hook_path.read_text()
            return CONTEXTGIT_HOOK_MARKER in content
        except Exception:
            return False

    def _make_executable(self, file_path: Path):
        """Make a file executable.

        Args:
            file_path: Path to file
        """
        current_permissions = file_path.stat().st_mode
        # Add execute permission for owner, group, and others
        file_path.chmod(current_permissions | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    def install(
        self,
        pre_commit: bool = True,
        post_merge: bool = True,
        pre_push: bool = False,
        fail_on_stale: bool = False,
        format: str = "text"
    ) -> str:
        """Install git hooks.

        Args:
            pre_commit: Install pre-commit hook
            post_merge: Install post-merge hook
            pre_push: Install pre-push hook
            fail_on_stale: Fail hook if stale links detected
            format: Output format (text or json)

        Returns:
            Installation summary

        Raises:
            RepoNotFoundError: If not in a contextgit repository
            ValueError: If not in a git repository
        """
        # Find repo root
        repo_root = self.find_repo_root()

        # Get hooks directory
        try:
            hooks_dir = self._get_hooks_dir(repo_root)
        except ValueError as e:
            if format == "json":
                return json.dumps({"error": str(e)}, indent=2)
            return f"Error: {e}"

        installed = []
        skipped = []
        updated = []

        # Determine which hooks to install
        hooks_to_install = {}
        if pre_commit:
            hooks_to_install['pre-commit'] = HOOK_TEMPLATES['pre-commit']
        if post_merge:
            hooks_to_install['post-merge'] = HOOK_TEMPLATES['post-merge']
        if pre_push:
            hooks_to_install['pre-push'] = HOOK_TEMPLATES['pre-push']

        # Install each hook
        for hook_name, hook_content in hooks_to_install.items():
            hook_path = hooks_dir / hook_name

            # Check if hook exists
            if hook_path.exists():
                if self._is_contextgit_hook(hook_path):
                    # Update existing contextgit hook
                    hook_path.write_text(hook_content)
                    self._make_executable(hook_path)
                    updated.append(hook_name)
                else:
                    # User has custom hook, skip to avoid overwriting
                    skipped.append(hook_name)
            else:
                # Install new hook
                hook_path.write_text(hook_content)
                self._make_executable(hook_path)
                installed.append(hook_name)

        # Set environment variable hint if fail_on_stale is enabled
        fail_on_stale_note = ""
        if fail_on_stale:
            fail_on_stale_note = "\nTo enable fail-on-stale, set: export CONTEXTGIT_FAIL_ON_STALE=1"

        # Format output
        if format == "json":
            return json.dumps({
                "installed": installed,
                "updated": updated,
                "skipped": skipped,
                "fail_on_stale": fail_on_stale,
                "hooks_dir": str(hooks_dir)
            }, indent=2)
        else:
            lines = ["Git hooks installation:"]

            if installed:
                lines.append(f"\n‚úÖ Installed hooks: {', '.join(installed)}")

            if updated:
                lines.append(f"\nüîÑ Updated hooks: {', '.join(updated)}")

            if skipped:
                lines.append(f"\n‚ö†Ô∏è  Skipped hooks (existing custom hooks): {', '.join(skipped)}")
                lines.append("   To install contextgit hooks for these, manually backup and remove the existing hooks.")

            if not installed and not updated:
                lines.append("\n‚ÑπÔ∏è  No hooks were installed or updated.")

            lines.append(f"\nHooks directory: {hooks_dir}")

            if fail_on_stale_note:
                lines.append(fail_on_stale_note)

            return '\n'.join(lines)

    def uninstall(self, format: str = "text") -> str:
        """Remove contextgit git hooks.

        Only removes hooks that were created by contextgit (contain the marker).

        Args:
            format: Output format (text or json)

        Returns:
            Uninstallation summary

        Raises:
            RepoNotFoundError: If not in a contextgit repository
        """
        # Find repo root
        repo_root = self.find_repo_root()

        # Get hooks directory
        try:
            hooks_dir = self._get_hooks_dir(repo_root)
        except ValueError as e:
            if format == "json":
                return json.dumps({"error": str(e)}, indent=2)
            return f"Error: {e}"

        removed = []

        # Check and remove each hook type
        for hook_name in HOOK_TEMPLATES.keys():
            hook_path = hooks_dir / hook_name

            if hook_path.exists() and self._is_contextgit_hook(hook_path):
                hook_path.unlink()
                removed.append(hook_name)

        # Format output
        if format == "json":
            return json.dumps({
                "removed": removed,
                "hooks_dir": str(hooks_dir)
            }, indent=2)
        else:
            if removed:
                return f"‚úÖ Removed hooks: {', '.join(removed)}\nHooks directory: {hooks_dir}"
            else:
                return "‚ÑπÔ∏è  No contextgit hooks found to remove"

    def status(self, format: str = "text") -> str:
        """Show installed hooks status.

        Args:
            format: Output format (text or json)

        Returns:
            Hooks status

        Raises:
            RepoNotFoundError: If not in a contextgit repository
        """
        # Find repo root
        repo_root = self.find_repo_root()

        # Get hooks directory
        try:
            hooks_dir = self._get_hooks_dir(repo_root)
        except ValueError as e:
            if format == "json":
                return json.dumps({"error": str(e)}, indent=2)
            return f"Error: {e}"

        hooks_status: Dict[str, Dict[str, any]] = {}

        # Check each hook type
        for hook_name in HOOK_TEMPLATES.keys():
            hook_path = hooks_dir / hook_name

            if hook_path.exists():
                is_contextgit = self._is_contextgit_hook(hook_path)
                is_executable = os.access(str(hook_path), os.X_OK)

                hooks_status[hook_name] = {
                    "installed": True,
                    "is_contextgit": is_contextgit,
                    "is_executable": is_executable,
                    "path": str(hook_path)
                }
            else:
                hooks_status[hook_name] = {
                    "installed": False,
                    "is_contextgit": False,
                    "is_executable": False,
                    "path": str(hook_path)
                }

        # Format output
        if format == "json":
            return json.dumps({
                "hooks": hooks_status,
                "hooks_dir": str(hooks_dir)
            }, indent=2)
        else:
            lines = ["Git hooks status:"]
            lines.append(f"Hooks directory: {hooks_dir}\n")

            for hook_name, status in hooks_status.items():
                if status["installed"]:
                    hook_type = "contextgit" if status["is_contextgit"] else "custom"
                    executable_mark = "‚úÖ" if status["is_executable"] else "‚ö†Ô∏è  (not executable)"
                    lines.append(f"  {hook_name}: {executable_mark} ({hook_type})")
                else:
                    lines.append(f"  {hook_name}: ‚ùå not installed")

            return '\n'.join(lines)
