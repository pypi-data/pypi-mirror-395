
# python wrapper for package codeberg.org/slidge/slidgnal/slidgnal within overall package signal
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -output=generated -no-make=true .

# the following is required to enable dlopen to open the _go.so file
import os,sys,inspect,collections
try:
	import collections.abc as _collections_abc
except ImportError:
	_collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _signal
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from signal import signal
# and then refer to everything using signal. prefix
# packages imported by this package listed below:




# ---- Types ---

# Python type for slice []signal.Attachment
class Slice_signal_Attachment(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.Slice_signal_Attachment_CTor()
			_signal.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_signal_Attachment.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		s = 'signal.Slice_signal_Attachment len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'signal.Slice_signal_Attachment([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _signal.Slice_signal_Attachment_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _signal.Slice_signal_Attachment_len(self.handle)
				return Slice_signal_Attachment(handle=_signal.Slice_signal_Attachment_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Attachment(handle=_signal.Slice_signal_Attachment_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_signal.Slice_signal_Attachment_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_signal_Attachment.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Attachment(handle=_signal.Slice_signal_Attachment_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_signal.Slice_signal_Attachment_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []signal.Contact
class Slice_signal_Contact(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.Slice_signal_Contact_CTor()
			_signal.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_signal_Contact.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		s = 'signal.Slice_signal_Contact len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'signal.Slice_signal_Contact([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _signal.Slice_signal_Contact_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _signal.Slice_signal_Contact_len(self.handle)
				return Slice_signal_Contact(handle=_signal.Slice_signal_Contact_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Contact(handle=_signal.Slice_signal_Contact_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_signal.Slice_signal_Contact_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_signal_Contact.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Contact(handle=_signal.Slice_signal_Contact_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_signal.Slice_signal_Contact_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []signal.Group
class Slice_signal_Group(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.Slice_signal_Group_CTor()
			_signal.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_signal_Group.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		s = 'signal.Slice_signal_Group len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'signal.Slice_signal_Group([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _signal.Slice_signal_Group_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _signal.Slice_signal_Group_len(self.handle)
				return Slice_signal_Group(handle=_signal.Slice_signal_Group_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return Group(handle=_signal.Slice_signal_Group_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_signal.Slice_signal_Group_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_signal_Group.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = Group(handle=_signal.Slice_signal_Group_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_signal.Slice_signal_Group_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]

# Python type for slice []signal.GroupMember
class Slice_signal_GroupMember(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameter is a python list that we copy from
		"""
		self.index = 0
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.Slice_signal_GroupMember_CTor()
			_signal.IncRef(self.handle)
			if len(args) > 0:
				if not isinstance(args[0], _collections_abc.Iterable):
					raise TypeError('Slice_signal_GroupMember.__init__ takes a sequence as argument')
				for elt in args[0]:
					self.append(elt)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		s = 'signal.Slice_signal_GroupMember len: ' + str(len(self)) + ' handle: ' + str(self.handle) + ' ['
		if len(self) < 120:
			s += ', '.join(map(str, self)) + ']'
		return s
	def __repr__(self):
		return 'signal.Slice_signal_GroupMember([' + ', '.join(map(str, self)) + '])'
	def __len__(self):
		return _signal.Slice_signal_GroupMember_len(self.handle)
	def __getitem__(self, key):
		if isinstance(key, slice):
			if key.step == None or key.step == 1:
				st = key.start
				ed = key.stop
				if st == None:
					st = 0
				if ed == None:
					ed = _signal.Slice_signal_GroupMember_len(self.handle)
				return Slice_signal_GroupMember(handle=_signal.Slice_signal_GroupMember_subslice(self.handle, st, ed))
			return [self[ii] for ii in range(*key.indices(len(self)))]
		elif isinstance(key, int):
			if key < 0:
				key += len(self)
			if key < 0 or key >= len(self):
				raise IndexError('slice index out of range')
			return GroupMember(handle=_signal.Slice_signal_GroupMember_elem(self.handle, key))
		else:
			raise TypeError('slice index invalid type')
	def __setitem__(self, idx, value):
		if idx < 0:
			idx += len(self)
		if idx < len(self):
			_signal.Slice_signal_GroupMember_set(self.handle, idx, value.handle)
			return
		raise IndexError('slice index out of range')
	def __iadd__(self, value):
		if not isinstance(value, _collections_abc.Iterable):
			raise TypeError('Slice_signal_GroupMember.__iadd__ takes a sequence as argument')
		for elt in value:
			self.append(elt)
		return self
	def __iter__(self):
		self.index = 0
		return self
	def __next__(self):
		if self.index < len(self):
			rv = GroupMember(handle=_signal.Slice_signal_GroupMember_elem(self.handle, self.index))
			self.index = self.index + 1
			return rv
		raise StopIteration
	def append(self, value):
		_signal.Slice_signal_GroupMember_append(self.handle, value.handle)
	def copy(self, src):
		""" copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list """
		mx = min(len(self), len(src))
		for i in range(mx):
			self[i] = src[i]


#---- Enums from Go (collections of consts with same type) ---
from enum import Enum

class CallState(Enum):
	"""
	CallState represents the state of an ongoing or completed call.
	
	"""
	CallUnknown = 0
	"""
	The call states handled by the overarching session event handler.
	
	"""
	CallIncoming = 1
	"""
	The call states handled by the overarching session event handler.
	
	"""
	CallMissed = 2
	"""
	The call states handled by the overarching session event handler.
	
	"""

CallUnknown = 0
"""
The call states handled by the overarching session event handler.

"""
CallIncoming = 1
"""
The call states handled by the overarching session event handler.

"""
CallMissed = 2
"""
The call states handled by the overarching session event handler.

"""

class EventKind(Enum):
	"""
	EventKind represents all event types recognized by the Python session adapter, as emitted by the
	Go session adapter.
	
	"""
	EventUnknown = 0
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventLogin = 1
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventArchiveSync = 2
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventConnect = 3
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventLogout = 4
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventContact = 5
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventGroup = 6
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventMessage = 7
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventTyping = 8
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventReceipt = 9
	"""
	The event types handled by the overarching session adapter handler.
	
	"""
	EventCall = 10
	"""
	The event types handled by the overarching session adapter handler.
	
	"""

EventUnknown = 0
"""
The event types handled by the overarching session adapter handler.

"""
EventLogin = 1
"""
The event types handled by the overarching session adapter handler.

"""
EventArchiveSync = 2
"""
The event types handled by the overarching session adapter handler.

"""
EventConnect = 3
"""
The event types handled by the overarching session adapter handler.

"""
EventLogout = 4
"""
The event types handled by the overarching session adapter handler.

"""
EventContact = 5
"""
The event types handled by the overarching session adapter handler.

"""
EventGroup = 6
"""
The event types handled by the overarching session adapter handler.

"""
EventMessage = 7
"""
The event types handled by the overarching session adapter handler.

"""
EventTyping = 8
"""
The event types handled by the overarching session adapter handler.

"""
EventReceipt = 9
"""
The event types handled by the overarching session adapter handler.

"""
EventCall = 10
"""
The event types handled by the overarching session adapter handler.

"""

class GroupMemberState(Enum):
	"""
	GroupMemberState represents different state transitions available to members of a [Group].
	
	"""
	GroupMemberJoined = 0
	GroupMemberLeft = 1
	GroupMemberBanned = 2

GroupMemberJoined = 0
GroupMemberLeft = 1
GroupMemberBanned = 2

class GroupRole(Enum):
	"""
	A GroupRole represents any of the different levels of access available to a [GroupMember] in a
	[Group].
	
	"""
	GroupRoleMember = 0
	GroupRoleAdministrator = 1

GroupRoleMember = 0
GroupRoleAdministrator = 1

class MessageKind(Enum):
	"""
	MessageKind represents all concrete message types (plain-text messages, edit messages, reactions)
	recognized by the Python session adapter.
	
	"""
	MessagePlain = 0
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageAttachment = 1
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageReaction = 2
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageEdit = 3
	"""
	The message types handled by the overarching session event handler.
	
	"""
	MessageDelete = 4
	"""
	The message types handled by the overarching session event handler.
	
	"""

MessagePlain = 0
"""
The message types handled by the overarching session event handler.

"""
MessageAttachment = 1
"""
The message types handled by the overarching session event handler.

"""
MessageReaction = 2
"""
The message types handled by the overarching session event handler.

"""
MessageEdit = 3
"""
The message types handled by the overarching session event handler.

"""
MessageDelete = 4
"""
The message types handled by the overarching session event handler.

"""

class ReceiptKind(Enum):
	"""
	ReceiptKind represents the different types of delivery receipts possible in Signal.
	
	"""
	ReceiptUnknown = 0
	"""
	The delivery receipts handled by the overarching session event handler.
	
	"""
	ReceiptDelivered = 1
	"""
	The delivery receipts handled by the overarching session event handler.
	
	"""
	ReceiptRead = 2
	"""
	The delivery receipts handled by the overarching session event handler.
	
	"""

ReceiptUnknown = 0
"""
The delivery receipts handled by the overarching session event handler.

"""
ReceiptDelivered = 1
"""
The delivery receipts handled by the overarching session event handler.

"""
ReceiptRead = 2
"""
The delivery receipts handled by the overarching session event handler.

"""

class TypingState(Enum):
	"""
	A TypingState represents different states of typing notificates for incoming and outgoing messages.
	
	"""
	TypingStateStopped = 0
	"""
	The distinct typing states handled by the overarching session event handler.
	
	"""
	TypingStateStarted = 1
	"""
	The distinct typing states handled by the overarching session event handler.
	
	"""

TypingStateStopped = 0
"""
The distinct typing states handled by the overarching session event handler.

"""
TypingStateStarted = 1
"""
The distinct typing states handled by the overarching session event handler.

"""



#---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---

# Python type for struct signal.Login
class Login(go.GoClass):
	"""Login represents event data for login events, typically carrying QR code information used for\nout-of-band authentication.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Login_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.QRCode = args[0]
			if "QRCode" in kwargs:
				self.QRCode = kwargs["QRCode"]
			if  1 < len(args):
				self.DeviceID = args[1]
			if "DeviceID" in kwargs:
				self.DeviceID = kwargs["DeviceID"]
			if  2 < len(args):
				self.Error = args[2]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Login{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Login ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def QRCode(self):
		return _signal.signal_Login_QRCode_Get(self.handle)
	@QRCode.setter
	def QRCode(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Login_QRCode_Set(self.handle, value.handle)
		else:
			_signal.signal_Login_QRCode_Set(self.handle, value)
	@property
	def DeviceID(self):
		return _signal.signal_Login_DeviceID_Get(self.handle)
	@DeviceID.setter
	def DeviceID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Login_DeviceID_Set(self.handle, value.handle)
		else:
			_signal.signal_Login_DeviceID_Set(self.handle, value)
	@property
	def Error(self):
		return _signal.signal_Login_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Login_Error_Set(self.handle, value.handle)
		else:
			_signal.signal_Login_Error_Set(self.handle, value)

# Python type for struct signal.Message
class Message(go.GoClass):
	"""A Message represents one of many kinds of bidirectional communication payloads, for example, a\ntext message, a file (image, video) attachment, an emoji reaction, etc. Messages of different\nkinds are denoted as such, and re-use fields where the semantics overlap.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Message_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Kind = args[0]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
			if  1 < len(args):
				self.ID = args[1]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  2 < len(args):
				self.ChatID = args[2]
			if "ChatID" in kwargs:
				self.ChatID = kwargs["ChatID"]
			if  3 < len(args):
				self.SenderID = args[3]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  4 < len(args):
				self.TargetID = args[4]
			if "TargetID" in kwargs:
				self.TargetID = kwargs["TargetID"]
			if  5 < len(args):
				self.Body = args[5]
			if "Body" in kwargs:
				self.Body = kwargs["Body"]
			if  6 < len(args):
				self.Timestamp = args[6]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
			if  7 < len(args):
				self.IsCarbon = args[7]
			if "IsCarbon" in kwargs:
				self.IsCarbon = kwargs["IsCarbon"]
			if  8 < len(args):
				self.IsGroup = args[8]
			if "IsGroup" in kwargs:
				self.IsGroup = kwargs["IsGroup"]
			if  9 < len(args):
				self.Typing = args[9]
			if "Typing" in kwargs:
				self.Typing = kwargs["Typing"]
			if  10 < len(args):
				self.Reaction = args[10]
			if "Reaction" in kwargs:
				self.Reaction = kwargs["Reaction"]
			if  11 < len(args):
				self.ReplyTo = args[11]
			if "ReplyTo" in kwargs:
				self.ReplyTo = kwargs["ReplyTo"]
			if  12 < len(args):
				self.Attachments = args[12]
			if "Attachments" in kwargs:
				self.Attachments = kwargs["Attachments"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Message{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Message ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Kind(self):
		return _signal.signal_Message_Kind_Get(self.handle)
	@Kind.setter
	def Kind(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Kind_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_Kind_Set(self.handle, value)
	@property
	def ID(self):
		return _signal.signal_Message_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_ID_Set(self.handle, value)
	@property
	def ChatID(self):
		return _signal.signal_Message_ChatID_Get(self.handle)
	@ChatID.setter
	def ChatID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_ChatID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_ChatID_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Message_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_SenderID_Set(self.handle, value)
	@property
	def TargetID(self):
		return _signal.signal_Message_TargetID_Get(self.handle)
	@TargetID.setter
	def TargetID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_TargetID_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_TargetID_Set(self.handle, value)
	@property
	def Body(self):
		return _signal.signal_Message_Body_Get(self.handle)
	@Body.setter
	def Body(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Body_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_Body_Set(self.handle, value)
	@property
	def Timestamp(self):
		return _signal.signal_Message_Timestamp_Get(self.handle)
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Timestamp_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_Timestamp_Set(self.handle, value)
	@property
	def IsCarbon(self):
		return _signal.signal_Message_IsCarbon_Get(self.handle)
	@IsCarbon.setter
	def IsCarbon(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_IsCarbon_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_IsCarbon_Set(self.handle, value)
	@property
	def IsGroup(self):
		return _signal.signal_Message_IsGroup_Get(self.handle)
	@IsGroup.setter
	def IsGroup(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_IsGroup_Set(self.handle, value.handle)
		else:
			_signal.signal_Message_IsGroup_Set(self.handle, value)
	@property
	def Typing(self):
		return Typing(handle=_signal.signal_Message_Typing_Get(self.handle))
	@Typing.setter
	def Typing(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Typing_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Reaction(self):
		return Reaction(handle=_signal.signal_Message_Reaction_Get(self.handle))
	@Reaction.setter
	def Reaction(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Reaction_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ReplyTo(self):
		return Reply(handle=_signal.signal_Message_ReplyTo_Get(self.handle))
	@ReplyTo.setter
	def ReplyTo(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_ReplyTo_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Attachments(self):
		return Slice_signal_Attachment(handle=_signal.signal_Message_Attachments_Get(self.handle))
	@Attachments.setter
	def Attachments(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Message_Attachments_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Call
class Call(go.GoClass):
	"""A Call represents an incoming or outgoing voice/video call made over Signal. Full support for\ncalls is currently not implemented, and this structure contains the bare minimum data required\nfor notifying on missed calls.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Call_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.State = args[0]
			if "State" in kwargs:
				self.State = kwargs["State"]
			if  1 < len(args):
				self.SenderID = args[1]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  2 < len(args):
				self.ChatID = args[2]
			if "ChatID" in kwargs:
				self.ChatID = kwargs["ChatID"]
			if  3 < len(args):
				self.Timestamp = args[3]
			if "Timestamp" in kwargs:
				self.Timestamp = kwargs["Timestamp"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Call{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Call ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def State(self):
		return _signal.signal_Call_State_Get(self.handle)
	@State.setter
	def State(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Call_State_Set(self.handle, value.handle)
		else:
			_signal.signal_Call_State_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Call_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Call_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Call_SenderID_Set(self.handle, value)
	@property
	def ChatID(self):
		return _signal.signal_Call_ChatID_Get(self.handle)
	@ChatID.setter
	def ChatID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Call_ChatID_Set(self.handle, value.handle)
		else:
			_signal.signal_Call_ChatID_Set(self.handle, value)
	@property
	def Timestamp(self):
		return _signal.signal_Call_Timestamp_Get(self.handle)
	@Timestamp.setter
	def Timestamp(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Call_Timestamp_Set(self.handle, value.handle)
		else:
			_signal.signal_Call_Timestamp_Set(self.handle, value)

# Python type for struct signal.Group
class Group(go.GoClass):
	"""A Group represents a many-to-many chat containing one or more members, including ourselves.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Group_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Title = args[1]
			if "Title" in kwargs:
				self.Title = kwargs["Title"]
			if  2 < len(args):
				self.Description = args[2]
			if "Description" in kwargs:
				self.Description = kwargs["Description"]
			if  3 < len(args):
				self.Avatar = args[3]
			if "Avatar" in kwargs:
				self.Avatar = kwargs["Avatar"]
			if  4 < len(args):
				self.Members = args[4]
			if "Members" in kwargs:
				self.Members = kwargs["Members"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Group{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Group ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _signal.signal_Group_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Group_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Group_ID_Set(self.handle, value)
	@property
	def Title(self):
		return _signal.signal_Group_Title_Get(self.handle)
	@Title.setter
	def Title(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Group_Title_Set(self.handle, value.handle)
		else:
			_signal.signal_Group_Title_Set(self.handle, value)
	@property
	def Description(self):
		return _signal.signal_Group_Description_Get(self.handle)
	@Description.setter
	def Description(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Group_Description_Set(self.handle, value.handle)
		else:
			_signal.signal_Group_Description_Set(self.handle, value)
	@property
	def Avatar(self):
		return Avatar(handle=_signal.signal_Group_Avatar_Get(self.handle))
	@Avatar.setter
	def Avatar(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Group_Avatar_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Members(self):
		return Slice_signal_GroupMember(handle=_signal.signal_Group_Members_Get(self.handle))
	@Members.setter
	def Members(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Group_Members_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.GroupMember
class GroupMember(go.GoClass):
	"""A GroupMember represents any source or destination for messages in a [Group].\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_GroupMember_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.Role = args[1]
			if "Role" in kwargs:
				self.Role = kwargs["Role"]
			if  2 < len(args):
				self.State = args[2]
			if "State" in kwargs:
				self.State = kwargs["State"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.GroupMember{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.GroupMember ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _signal.signal_GroupMember_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_GroupMember_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_GroupMember_ID_Set(self.handle, value)
	@property
	def Role(self):
		return _signal.signal_GroupMember_Role_Get(self.handle)
	@Role.setter
	def Role(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_GroupMember_Role_Set(self.handle, value.handle)
		else:
			_signal.signal_GroupMember_Role_Set(self.handle, value)
	@property
	def State(self):
		return _signal.signal_GroupMember_State_Get(self.handle)
	@State.setter
	def State(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_GroupMember_State_Set(self.handle, value.handle)
		else:
			_signal.signal_GroupMember_State_Set(self.handle, value)

# Python type for struct signal.Logout
class Logout(go.GoClass):
	"""Logout represents event data for logout events, either expected (due to unlinking of a device) or\nunexpected (due to upstream errors).\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Logout_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Reason = args[0]
			if "Reason" in kwargs:
				self.Reason = kwargs["Reason"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Logout{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Logout ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Reason(self):
		return _signal.signal_Logout_Reason_Get(self.handle)
	@Reason.setter
	def Reason(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Logout_Reason_Set(self.handle, value.handle)
		else:
			_signal.signal_Logout_Reason_Set(self.handle, value)

# Python type for struct signal.Reaction
class Reaction(go.GoClass):
	"""A Reaction is a quick, emoji response to an existing message. Signal generally allows only a\nsingle reaction to messages, and has special rules around removal of reactions.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Reaction_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Emoji = args[0]
			if "Emoji" in kwargs:
				self.Emoji = kwargs["Emoji"]
			if  1 < len(args):
				self.Remove = args[1]
			if "Remove" in kwargs:
				self.Remove = kwargs["Remove"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reaction{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reaction ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Emoji(self):
		return _signal.signal_Reaction_Emoji_Get(self.handle)
	@Emoji.setter
	def Emoji(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reaction_Emoji_Set(self.handle, value.handle)
		else:
			_signal.signal_Reaction_Emoji_Set(self.handle, value)
	@property
	def Remove(self):
		return _signal.signal_Reaction_Remove_Get(self.handle)
	@Remove.setter
	def Remove(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reaction_Remove_Set(self.handle, value.handle)
		else:
			_signal.signal_Reaction_Remove_Set(self.handle, value)

# Python type for struct signal.Avatar
class Avatar(go.GoClass):
	"""A Avatar represents a small image set for a [Contact] or [Group].\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Avatar_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Delete = args[0]
			if "Delete" in kwargs:
				self.Delete = kwargs["Delete"]
			if  1 < len(args):
				self.Data = args[1]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Avatar{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Avatar ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Delete(self):
		return _signal.signal_Avatar_Delete_Get(self.handle)
	@Delete.setter
	def Delete(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Avatar_Delete_Set(self.handle, value.handle)
		else:
			_signal.signal_Avatar_Delete_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_signal.signal_Avatar_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Avatar_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Connect
class Connect(go.GoClass):
	"""Connect represents event data for connection events, typically carrying connection errors and\nother metadata.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Connect_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.AccountID = args[0]
			if "AccountID" in kwargs:
				self.AccountID = kwargs["AccountID"]
			if  1 < len(args):
				self.PhoneNumber = args[1]
			if "PhoneNumber" in kwargs:
				self.PhoneNumber = kwargs["PhoneNumber"]
			if  2 < len(args):
				self.Error = args[2]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Connect{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Connect ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def AccountID(self):
		return _signal.signal_Connect_AccountID_Get(self.handle)
	@AccountID.setter
	def AccountID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Connect_AccountID_Set(self.handle, value.handle)
		else:
			_signal.signal_Connect_AccountID_Set(self.handle, value)
	@property
	def PhoneNumber(self):
		return _signal.signal_Connect_PhoneNumber_Get(self.handle)
	@PhoneNumber.setter
	def PhoneNumber(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Connect_PhoneNumber_Set(self.handle, value.handle)
		else:
			_signal.signal_Connect_PhoneNumber_Set(self.handle, value)
	@property
	def Error(self):
		return _signal.signal_Connect_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Connect_Error_Set(self.handle, value.handle)
		else:
			_signal.signal_Connect_Error_Set(self.handle, value)

# Python type for struct signal.LinkedDevice
class LinkedDevice(go.GoClass):
	"""A LinkedDevice represents a unique pairing session between the gateway and Signal. It is not\nunique to the underlying \"main\" device (or user/phone number), as multiple linked devices may be\npaired with any main device.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_LinkedDevice_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.ArchiveSynced = args[1]
			if "ArchiveSynced" in kwargs:
				self.ArchiveSynced = kwargs["ArchiveSynced"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.LinkedDevice{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.LinkedDevice ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		"""ID is an opaque string identifying this [LinkedDevice] to a [Session]. Noted that this string
		is currently equivalent to a password, and needs to be protected accordingly.
		"""
		return _signal.signal_LinkedDevice_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_LinkedDevice_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_LinkedDevice_ID_Set(self.handle, value)
	@property
	def ArchiveSynced(self):
		"""Whether or not we've previously tried to sync this device from the main device's archive.
		"""
		return _signal.signal_LinkedDevice_ArchiveSynced_Get(self.handle)
	@ArchiveSynced.setter
	def ArchiveSynced(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_LinkedDevice_ArchiveSynced_Set(self.handle, value.handle)
		else:
			_signal.signal_LinkedDevice_ArchiveSynced_Set(self.handle, value)

# Python type for struct signal.Receipt
class Receipt(go.GoClass):
	"""A Receipt represents a notice of delivery or presentation for [Message] instances sent or\nreceived. Receipts can be delivered for many messages at once, but are generally all delivered\nunder one specific state at a time.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Receipt_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Kind = args[0]
			if "Kind" in kwargs:
				self.Kind = kwargs["Kind"]
			if  1 < len(args):
				self.SenderID = args[1]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  2 < len(args):
				self.Timestamps = args[2]
			if "Timestamps" in kwargs:
				self.Timestamps = kwargs["Timestamps"]
			if  3 < len(args):
				self.IsCarbon = args[3]
			if "IsCarbon" in kwargs:
				self.IsCarbon = kwargs["IsCarbon"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Receipt{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Receipt ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Kind(self):
		return _signal.signal_Receipt_Kind_Get(self.handle)
	@Kind.setter
	def Kind(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_Kind_Set(self.handle, value.handle)
		else:
			_signal.signal_Receipt_Kind_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Receipt_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Receipt_SenderID_Set(self.handle, value)
	@property
	def Timestamps(self):
		return go.Slice_uint64(handle=_signal.signal_Receipt_Timestamps_Get(self.handle))
	@Timestamps.setter
	def Timestamps(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_Timestamps_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def IsCarbon(self):
		return _signal.signal_Receipt_IsCarbon_Get(self.handle)
	@IsCarbon.setter
	def IsCarbon(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Receipt_IsCarbon_Set(self.handle, value.handle)
		else:
			_signal.signal_Receipt_IsCarbon_Set(self.handle, value)

# Python type for struct signal.Reply
class Reply(go.GoClass):
	"""A Reply represents a reference to a previous message being replied to, with partial data set.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Reply_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.AuthorID = args[1]
			if "AuthorID" in kwargs:
				self.AuthorID = kwargs["AuthorID"]
			if  2 < len(args):
				self.Body = args[2]
			if "Body" in kwargs:
				self.Body = kwargs["Body"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reply{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Reply ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _signal.signal_Reply_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reply_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Reply_ID_Set(self.handle, value)
	@property
	def AuthorID(self):
		return _signal.signal_Reply_AuthorID_Get(self.handle)
	@AuthorID.setter
	def AuthorID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reply_AuthorID_Set(self.handle, value.handle)
		else:
			_signal.signal_Reply_AuthorID_Set(self.handle, value)
	@property
	def Body(self):
		return _signal.signal_Reply_Body_Get(self.handle)
	@Body.setter
	def Body(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Reply_Body_Set(self.handle, value.handle)
		else:
			_signal.signal_Reply_Body_Set(self.handle, value)

# Python type for struct signal.Session
class Session(go.GoClass):
	"""A Session represents a connection to Signal under a given [Gateway]. In general, sessions are\ninactive until [Session.Login] is called and out-of-band registration is completed, in which case\nour internal event handlers will attempt to propagate any incoming events. Calls to session\nfunctions, such as [Session.ListContacts], will return an error immediately if the session is not\nactive and authenticated.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Session_CTor()
			_signal.IncRef(self.handle)
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Session{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Session ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	def Login(self):
		"""Login() str
		
		Login attempts to connect to Signal for the [LinkedDevice] in the underlying [Session],
		provisioning a new registration if none was already found.
		"""
		return _signal.signal_Session_Login(self.handle)
	def Logout(self):
		"""Logout() str
		
		Logout disconnects and unlinks the current active [Session]. If there is no active session, this
		function returns a nil error.
		"""
		return _signal.signal_Session_Logout(self.handle)
	def Disconnect(self):
		"""Disconnect() str
		
		Disconnect stops any active connection to Signal without removing authentication credentials.
		"""
		return _signal.signal_Session_Disconnect(self.handle)
	def SendMessage(self, message):
		"""SendMessage(object message) str, str
		
		SendMessage processes the given [Message], and sends it to to Signal. Messages can contain a
		multitude of different fields denoting different semantics, see the [Message] type for more
		information.
		"""
		return _signal.signal_Session_SendMessage(self.handle, message.handle)
	def SendTyping(self, typing):
		"""SendTyping(object typing) str
		
		SendTyping sends a typing notification from us to a given contact on Signal.
		"""
		return _signal.signal_Session_SendTyping(self.handle, typing.handle)
	def SendReceipt(self, receipt):
		"""SendReceipt(object receipt) str
		
		SendReceipt sends a read receipt for for a given set of messages to Signal.
		"""
		return _signal.signal_Session_SendReceipt(self.handle, receipt.handle)
	def ListContacts(self):
		"""ListContacts() []object, str
		
		ListContacts returns contacts stored in the local store, usually populated either during initial
		linking from the archive, or during incoming events for new contacts. Contact information
		returned may be partial.
		"""
		return Slice_signal_Contact(handle=_signal.signal_Session_ListContacts(self.handle))
	def GetContact(self, id):
		"""GetContact(str id) object, str
		
		GetContact returns a concrete [Contact] representation for the account ID given. If no contact
		information could be found, an empty contact will be returned with no error.
		"""
		return Contact(handle=_signal.signal_Session_GetContact(self.handle, id))
	def ListGroups(self):
		"""ListGroups() []object, str
		
		ListGroups returns group-chats stored in the local store, usually populated either during
		initial linking from the archive, or during incoming events. Group information returned may be
		partial, with only the group ID guaranteed to be set.
		"""
		return Slice_signal_Group(handle=_signal.signal_Session_ListGroups(self.handle))
	def GetGroup(self, id):
		"""GetGroup(str id) object, str
		
		GetGroup returns full group information from Signal for the given group ID.
		"""
		return Group(handle=_signal.signal_Session_GetGroup(self.handle, id))
	def SetEventHandler(self, h, goRun=False):
		"""SetEventHandler(callable h) 
		
		SetEventHandler assigns the given handler function for propagating internal events into the Python
		gateway. Note that the event handler function is not entirely safe to use directly, and all calls
		should instead be sent to the [Gateway] via its internal call channel.
		"""
		_signal.signal_Session_SetEventHandler(self.handle, h, goRun)

# Python type for struct signal.Typing
class Typing(go.GoClass):
	"""Typing contains event data related to typing notifications.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Typing_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.State = args[0]
			if "State" in kwargs:
				self.State = kwargs["State"]
			if  1 < len(args):
				self.SenderID = args[1]
			if "SenderID" in kwargs:
				self.SenderID = kwargs["SenderID"]
			if  2 < len(args):
				self.ChatID = args[2]
			if "ChatID" in kwargs:
				self.ChatID = kwargs["ChatID"]
			if  3 < len(args):
				self.IsGroup = args[3]
			if "IsGroup" in kwargs:
				self.IsGroup = kwargs["IsGroup"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Typing{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Typing ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def State(self):
		return _signal.signal_Typing_State_Get(self.handle)
	@State.setter
	def State(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Typing_State_Set(self.handle, value.handle)
		else:
			_signal.signal_Typing_State_Set(self.handle, value)
	@property
	def SenderID(self):
		return _signal.signal_Typing_SenderID_Get(self.handle)
	@SenderID.setter
	def SenderID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Typing_SenderID_Set(self.handle, value.handle)
		else:
			_signal.signal_Typing_SenderID_Set(self.handle, value)
	@property
	def ChatID(self):
		return _signal.signal_Typing_ChatID_Get(self.handle)
	@ChatID.setter
	def ChatID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Typing_ChatID_Set(self.handle, value.handle)
		else:
			_signal.signal_Typing_ChatID_Set(self.handle, value)
	@property
	def IsGroup(self):
		return _signal.signal_Typing_IsGroup_Get(self.handle)
	@IsGroup.setter
	def IsGroup(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Typing_IsGroup_Set(self.handle, value.handle)
		else:
			_signal.signal_Typing_IsGroup_Set(self.handle, value)

# Python type for struct signal.ArchiveSync
class ArchiveSync(go.GoClass):
	"""ArchiveSync represents event data for initial synchronization of chat state during login.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_ArchiveSync_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Error = args[0]
			if "Error" in kwargs:
				self.Error = kwargs["Error"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.ArchiveSync{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.ArchiveSync ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Error(self):
		return _signal.signal_ArchiveSync_Error_Get(self.handle)
	@Error.setter
	def Error(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_ArchiveSync_Error_Set(self.handle, value.handle)
		else:
			_signal.signal_ArchiveSync_Error_Set(self.handle, value)

# Python type for struct signal.Attachment
class Attachment(go.GoClass):
	"""A Attachment represents any binary data provided alongside a [Message], for instance, an image\nor voice message.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Attachment_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ContentType = args[0]
			if "ContentType" in kwargs:
				self.ContentType = kwargs["ContentType"]
			if  1 < len(args):
				self.Filename = args[1]
			if "Filename" in kwargs:
				self.Filename = kwargs["Filename"]
			if  2 < len(args):
				self.Data = args[2]
			if "Data" in kwargs:
				self.Data = kwargs["Data"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Attachment{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Attachment ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ContentType(self):
		return _signal.signal_Attachment_ContentType_Get(self.handle)
	@ContentType.setter
	def ContentType(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Attachment_ContentType_Set(self.handle, value.handle)
		else:
			_signal.signal_Attachment_ContentType_Set(self.handle, value)
	@property
	def Filename(self):
		return _signal.signal_Attachment_Filename_Get(self.handle)
	@Filename.setter
	def Filename(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Attachment_Filename_Set(self.handle, value.handle)
		else:
			_signal.signal_Attachment_Filename_Set(self.handle, value)
	@property
	def Data(self):
		return go.Slice_byte(handle=_signal.signal_Attachment_Data_Get(self.handle))
	@Data.setter
	def Data(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Attachment_Data_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Contact
class Contact(go.GoClass):
	"""A Contact represents any entity that be communicated with directly in Signal. This typically\nrepresents people, but not a group-chat.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Contact_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.ID = args[0]
			if "ID" in kwargs:
				self.ID = kwargs["ID"]
			if  1 < len(args):
				self.PhoneNumber = args[1]
			if "PhoneNumber" in kwargs:
				self.PhoneNumber = kwargs["PhoneNumber"]
			if  2 < len(args):
				self.Name = args[2]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  3 < len(args):
				self.Avatar = args[3]
			if "Avatar" in kwargs:
				self.Avatar = kwargs["Avatar"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Contact{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Contact ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def ID(self):
		return _signal.signal_Contact_ID_Get(self.handle)
	@ID.setter
	def ID(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_ID_Set(self.handle, value.handle)
		else:
			_signal.signal_Contact_ID_Set(self.handle, value)
	@property
	def PhoneNumber(self):
		return _signal.signal_Contact_PhoneNumber_Get(self.handle)
	@PhoneNumber.setter
	def PhoneNumber(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_PhoneNumber_Set(self.handle, value.handle)
		else:
			_signal.signal_Contact_PhoneNumber_Set(self.handle, value)
	@property
	def Name(self):
		return _signal.signal_Contact_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_Name_Set(self.handle, value.handle)
		else:
			_signal.signal_Contact_Name_Set(self.handle, value)
	@property
	def Avatar(self):
		return Avatar(handle=_signal.signal_Contact_Avatar_Get(self.handle))
	@Avatar.setter
	def Avatar(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Contact_Avatar_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.EventPayload
class EventPayload(go.GoClass):
	"""EventPayload represents the collected payloads for all event types handled by the overarching\nsession adapter handler. Only specific fields will be populated in events emitted by internal\nhandlers, see documentation for specific types for more information.\n"""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_EventPayload_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.Login = args[0]
			if "Login" in kwargs:
				self.Login = kwargs["Login"]
			if  1 < len(args):
				self.Logout = args[1]
			if "Logout" in kwargs:
				self.Logout = kwargs["Logout"]
			if  2 < len(args):
				self.ArchiveSync = args[2]
			if "ArchiveSync" in kwargs:
				self.ArchiveSync = kwargs["ArchiveSync"]
			if  3 < len(args):
				self.Connect = args[3]
			if "Connect" in kwargs:
				self.Connect = kwargs["Connect"]
			if  4 < len(args):
				self.Contact = args[4]
			if "Contact" in kwargs:
				self.Contact = kwargs["Contact"]
			if  5 < len(args):
				self.Group = args[5]
			if "Group" in kwargs:
				self.Group = kwargs["Group"]
			if  6 < len(args):
				self.Message = args[6]
			if "Message" in kwargs:
				self.Message = kwargs["Message"]
			if  7 < len(args):
				self.Typing = args[7]
			if "Typing" in kwargs:
				self.Typing = kwargs["Typing"]
			if  8 < len(args):
				self.Receipt = args[8]
			if "Receipt" in kwargs:
				self.Receipt = kwargs["Receipt"]
			if  9 < len(args):
				self.Call = args[9]
			if "Call" in kwargs:
				self.Call = kwargs["Call"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.EventPayload{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.EventPayload ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def Login(self):
		return Login(handle=_signal.signal_EventPayload_Login_Get(self.handle))
	@Login.setter
	def Login(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Login_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Logout(self):
		return Logout(handle=_signal.signal_EventPayload_Logout_Get(self.handle))
	@Logout.setter
	def Logout(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Logout_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def ArchiveSync(self):
		return ArchiveSync(handle=_signal.signal_EventPayload_ArchiveSync_Get(self.handle))
	@ArchiveSync.setter
	def ArchiveSync(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_ArchiveSync_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Connect(self):
		return Connect(handle=_signal.signal_EventPayload_Connect_Get(self.handle))
	@Connect.setter
	def Connect(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Connect_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Contact(self):
		return Contact(handle=_signal.signal_EventPayload_Contact_Get(self.handle))
	@Contact.setter
	def Contact(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Contact_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Group(self):
		return Group(handle=_signal.signal_EventPayload_Group_Get(self.handle))
	@Group.setter
	def Group(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Group_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Message(self):
		return Message(handle=_signal.signal_EventPayload_Message_Get(self.handle))
	@Message.setter
	def Message(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Message_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Typing(self):
		return Typing(handle=_signal.signal_EventPayload_Typing_Get(self.handle))
	@Typing.setter
	def Typing(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Typing_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Receipt(self):
		return Receipt(handle=_signal.signal_EventPayload_Receipt_Get(self.handle))
	@Receipt.setter
	def Receipt(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Receipt_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))
	@property
	def Call(self):
		return Call(handle=_signal.signal_EventPayload_Call_Get(self.handle))
	@Call.setter
	def Call(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_EventPayload_Call_Set(self.handle, value.handle)
		else:
			raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

# Python type for struct signal.Gateway
class Gateway(go.GoClass):
	""""""
	def __init__(self, *args, **kwargs):
		"""
		handle=A Go-side object is always initialized with an explicit handle=arg
		otherwise parameters can be unnamed in order of field names or named fields
		in which case a new Go object is constructed first
		"""
		if len(kwargs) == 1 and 'handle' in kwargs:
			self.handle = kwargs['handle']
			_signal.IncRef(self.handle)
		elif len(args) == 1 and isinstance(args[0], go.GoClass):
			self.handle = args[0].handle
			_signal.IncRef(self.handle)
		else:
			self.handle = _signal.signal_Gateway_CTor()
			_signal.IncRef(self.handle)
			if  0 < len(args):
				self.DBPath = args[0]
			if "DBPath" in kwargs:
				self.DBPath = kwargs["DBPath"]
			if  1 < len(args):
				self.Name = args[1]
			if "Name" in kwargs:
				self.Name = kwargs["Name"]
			if  2 < len(args):
				self.LogLevel = args[2]
			if "LogLevel" in kwargs:
				self.LogLevel = kwargs["LogLevel"]
	def __del__(self):
		_signal.DecRef(self.handle)
	def __str__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Gateway{'
		first = True
		for v in pr:
			if callable(v[1]):
				continue
			if first:
				first = False
			else:
				sv += ', '
			sv += v[0] + '=' + str(v[1])
		return sv + '}'
	def __repr__(self):
		pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith('__')]
		sv = 'signal.Gateway ( '
		for v in pr:
			if not callable(v[1]):
				sv += v[0] + '=' + str(v[1]) + ', '
		return sv + ')'
	@property
	def DBPath(self):
		"""Common configuration.
		"""
		return _signal.signal_Gateway_DBPath_Get(self.handle)
	@DBPath.setter
	def DBPath(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Gateway_DBPath_Set(self.handle, value.handle)
		else:
			_signal.signal_Gateway_DBPath_Set(self.handle, value)
	@property
	def Name(self):
		return _signal.signal_Gateway_Name_Get(self.handle)
	@Name.setter
	def Name(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Gateway_Name_Set(self.handle, value.handle)
		else:
			_signal.signal_Gateway_Name_Set(self.handle, value)
	@property
	def LogLevel(self):
		return _signal.signal_Gateway_LogLevel_Get(self.handle)
	@LogLevel.setter
	def LogLevel(self, value):
		if isinstance(value, go.GoClass):
			_signal.signal_Gateway_LogLevel_Set(self.handle, value.handle)
		else:
			_signal.signal_Gateway_LogLevel_Set(self.handle, value)
	def Init(self):
		"""Init() str"""
		return _signal.signal_Gateway_Init(self.handle)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewSession(g, d):
	"""NewSession(object g, object d) object
	
	NewSession returns a new, inactive connection to Signal. Sessions are expected to be activated
	via subsequent calls to [Session.Login], which will generally continue out-of-band; see the
	relevant documentation for more details.
	"""
	return Session(handle=_signal.signal_NewSession(g.handle, d.handle))
def NewGateway():
	"""NewGateway() object"""
	return Gateway(handle=_signal.signal_NewGateway())


# ---- Functions ---
def TimestampFromMessageID(id):
	"""TimestampFromMessageID(str id) long
	
	TimestampFromMessageID returns the timestamp part for the (semi-opaque) message ID given.
	"""
	return _signal.signal_TimestampFromMessageID(id)


