# Agent Capabilities for GraphScout Discovery
# ============================================
#
# This example demonstrates how to use the `capabilities` field to help
# GraphScout understand what each agent can do. Capabilities are tags that
# describe an agent's abilities, making it easier for GraphScout to discover
# and route to the right agent for a given task.
#
# GraphScout uses capabilities to:
# 1. Filter agents that match the required abilities
# 2. Build execution paths that fulfill the user's request
# 3. Choose between multiple agents based on their specializations

orchestrator:
  id: capabilities-demo
  strategy: sequential
  agents:
    - graph_scout_router
    - path_executor

agents:
  # GraphScout: Intelligent path discovery
  - id: graph_scout_router
    type: graph-scout
    params:
      k_beam: 3
      max_depth: 3
      require_terminal: true
      evaluation_model: "local_llm"
      evaluation_model_name: "llama3.2"
    prompt: |
      Analyze the request and select the optimal execution path: {{ input }}
      
      Available agents have the following capabilities:
      - search_specialist: [data_retrieval, web_search, external_data]
      - reasoning_specialist: [reasoning, analysis, deep_thinking]
      - memory_specialist: [data_storage, persistence, context_retrieval]
      - response_specialist: [answer_emit, response_generation, synthesis]

  # PathExecutor: Execute the discovered path
  - id: path_executor
    type: path_executor
    path_source: graph_scout_router
    on_agent_failure: continue

  # Specialized agents with capability tags
  - id: search_specialist
    type: duckduckgo
    capabilities: [data_retrieval, web_search, external_data]
    max_results: 5
    prompt: "Search for: {{ input }}"

  - id: reasoning_specialist
    type: local_llm
    capabilities: [reasoning, analysis, deep_thinking]
    model: llama3.2
    model_url: http://localhost:11434/api/generate
    provider: ollama
    temperature: 0.3
    prompt: |
      Analyze the following information: {{ input }}
      
      {% if previous_outputs.search_specialist %}
      Search Results: {{ safe_get_response('search_specialist', 'No search results', previous_outputs) }}
      {% endif %}
      
      Provide comprehensive analysis with reasoning.

  - id: memory_specialist
    type: memory
    capabilities: [data_storage, persistence, context_retrieval]
    namespace: capabilities_demo
    memory_preset: episodic
    config:
      operation: write
      vector: true
    prompt: |
      Store: {{ input }}
      {% if previous_outputs.search_specialist %}
      Search: {{ safe_get_response('search_specialist', 'No search', previous_outputs) }}
      {% endif %}
      {% if previous_outputs.reasoning_specialist %}
      Analysis: {{ safe_get_response('reasoning_specialist', 'No analysis', previous_outputs) }}
      {% endif %}

  - id: response_specialist
    type: local_llm
    capabilities: [answer_emit, response_generation, synthesis]
    model: llama3.2
    model_url: http://localhost:11434/api/generate
    provider: ollama
    temperature: 0.3
    prompt: |
      Create a comprehensive response for: {{ input }}
      
      {% if previous_outputs.search_specialist %}
      Search Results: {{ safe_get_response('search_specialist', 'No search results', previous_outputs) }}
      {% endif %}
      
      {% if previous_outputs.reasoning_specialist %}
      Analysis: {{ safe_get_response('reasoning_specialist', 'No analysis', previous_outputs) }}
      {% endif %}
      
      Synthesize all information into a clear, well-structured response.

# ============================================================================
# Capability Tags - Best Practices
# ============================================================================
#
# 1. Be Descriptive: Use clear, meaningful tags
#    Good: [data_retrieval, web_search, external_data]
#    Bad: [search, data, web]
#
# 2. Be Consistent: Use the same terminology across agents
#    Good: All memory agents use [data_storage, persistence]
#    Bad: Some use [storage], others [save_data]
#
# 3. Be Specific: Distinguish between similar capabilities
#    Good: [reasoning, analysis] vs [answer_emit, synthesis]
#    Bad: [thinking, output] for both
#
# 4. Common Capability Categories:
#    - Data Operations: data_retrieval, data_storage, persistence
#    - Search: web_search, semantic_search, vector_search
#    - Processing: reasoning, analysis, classification, validation
#    - Output: answer_emit, response_generation, synthesis
#    - Context: context_retrieval, memory_access, history_lookup
#    - Control: routing, decision_making, path_selection
#
# 5. Agent-Specific Capabilities:
#    - LLM agents: reasoning, analysis, answer_emit
#    - Search agents: data_retrieval, web_search
#    - Memory agents: data_storage, context_retrieval
#    - Router agents: routing, decision_making
#
# ============================================================================
# Usage Examples
# ============================================================================
#
# 1. Simple query (GraphScout chooses search → response):
#    orka run capabilities_example.yml "What are the latest AI trends?"
#
# 2. Complex query (GraphScout chooses search → reasoning → memory → response):
#    orka run capabilities_example.yml "Research quantum computing and explain its impact"
#
# 3. Memory-focused query (GraphScout includes memory operations):
#    orka run capabilities_example.yml "Store information about OrKa framework"
#
# GraphScout will analyze the request and select agents based on their
# capabilities to build the most appropriate execution path.
