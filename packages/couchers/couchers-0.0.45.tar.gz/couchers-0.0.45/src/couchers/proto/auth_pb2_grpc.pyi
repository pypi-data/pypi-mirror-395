from sqlalchemy import orm
from couchers.context import CouchersContext
"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import abc
import auth_pb2
import collections.abc
import google.protobuf.empty_pb2
import grpc
import grpc.aio
import sys
import typing

if sys.version_info >= (3, 13):
    import typing as typing_extensions
else:
    import typing_extensions

_T = typing.TypeVar("_T")

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta): ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

GRPC_GENERATED_VERSION: str
GRPC_VERSION: str
class AuthServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def SignupFlow(
        self,
        request: auth_pb2.SignupFlowReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.SignupFlowRes, collections.abc.Awaitable[auth_pb2.SignupFlowRes]]:
        """
        Authentication API

        This API facilitates authentication actions: signup and signin. Users need to use this before logging in, so you don't
        need to be authorized to use it.

        The signup flow is as follows:
        A user enters their email and submits a form, which fires off a Signup call
        Signup validates the email isn't in the database yet, creates a signup_token, and emails it to the email address
        User clicks on the signup link, which brings them onto the signup completion form
        When this form loads, the app queries SignupTokenInfo for the email address associated to that login token to
        display in the UI
        User chooses a username (possibly querying UsernameValid to check possibly usernames) and fills in other basic
        information
        User submits the signup completion form, which validates this input, creates the user and logs them in, returns a
        session token (signup token is invalidated)

        The login flow is as follows:
        User types in username and password and the frontend calls Authenticate

        Signup tokens expire after some time, and once used cannot be reused.

        There can be multiple signup requests simultaneously with the same email address. Email address uniqueness is checked
        once when creating the signup request, and again when creating the user.

        The signup flow (from point of view of backend) is as follows:
        * There are three parts to the signup: Basic, Account, and Feedback
        * Each part needs to be filled in, and the user's email needs to be confirmed before the user can continue to the
        app
        * The Basic part must be filled in in the first request, after which the backend returns a flow_token
        * The frontend may do the signup incrementally by sending the other parts with the same flow_token
        * You can only fill in each part once
        * You can get info on the flow_token by sending an empty request with just the flow_token
        * Once the flow completes, the user is logged in and the signup flow is destroyed
        """

    @abc.abstractmethod
    def UsernameValid(
        self,
        request: auth_pb2.UsernameValidReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.UsernameValidRes, collections.abc.Awaitable[auth_pb2.UsernameValidRes]]:
        """Check whether the username is valid and available"""

    @abc.abstractmethod
    def Authenticate(
        self,
        request: auth_pb2.AuthReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.AuthRes, collections.abc.Awaitable[auth_pb2.AuthRes]]:
        """Log in with username + password"""

    @abc.abstractmethod
    def GetAuthState(
        self,
        request: google.protobuf.empty_pb2.Empty,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.GetAuthStateRes, collections.abc.Awaitable[auth_pb2.GetAuthStateRes]]:
        """Get info on current authentication state
        we need this because the web client does not have access to the non-JS cookie that contains this info, so it
        needs to be validated against the backend
        """

    @abc.abstractmethod
    def Deauthenticate(
        self,
        request: google.protobuf.empty_pb2.Empty,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Invalidate a session, deauthing a user"""

    @abc.abstractmethod
    def ResetPassword(
        self,
        request: auth_pb2.ResetPasswordReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Sends a forgot password email to the given user if the user exists, returns no output (so you can't go around
        guessing email addresses)
        """

    @abc.abstractmethod
    def CompletePasswordResetV2(
        self,
        request: auth_pb2.CompletePasswordResetV2Req,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.AuthRes, collections.abc.Awaitable[auth_pb2.AuthRes]]:
        """Triggered when the user goes to the link sent in the forgot password email, and logs the user in

        Actually changes the user's password
        """

    @abc.abstractmethod
    def ConfirmChangeEmailV2(
        self,
        request: auth_pb2.ConfirmChangeEmailV2Req,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Triggered when the user goes to the link sent in the either email_changed_confirmation_*_email"""

    @abc.abstractmethod
    def ConfirmDeleteAccount(
        self,
        request: auth_pb2.ConfirmDeleteAccountReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Confirms deletion of a user using a token"""

    @abc.abstractmethod
    def RecoverAccount(
        self,
        request: auth_pb2.RecoverAccountReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[google.protobuf.empty_pb2.Empty, collections.abc.Awaitable[google.protobuf.empty_pb2.Empty]]:
        """Recovers a recently deleted account"""

    @abc.abstractmethod
    def Unsubscribe(
        self,
        request: auth_pb2.UnsubscribeReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.UnsubscribeRes, collections.abc.Awaitable[auth_pb2.UnsubscribeRes]]:
        """Handle an unsubscribe action from an email"""

    @abc.abstractmethod
    def AntiBot(
        self,
        request: auth_pb2.AntiBotReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.AntiBotRes, collections.abc.Awaitable[auth_pb2.AntiBotRes]]:
        """Send google recaptcha info asynchronously"""

    @abc.abstractmethod
    def AntiBotPolicy(
        self,
        request: auth_pb2.AntiBotPolicyReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.AntiBotPolicyRes, collections.abc.Awaitable[auth_pb2.AntiBotPolicyRes]]: ...

    @abc.abstractmethod
    def GetInviteCodeInfo(
        self,
        request: auth_pb2.GetInviteCodeInfoReq,
        context: CouchersContext,
        session: orm.Session,
    ) -> typing.Union[auth_pb2.GetInviteCodeInfoRes, collections.abc.Awaitable[auth_pb2.GetInviteCodeInfoRes]]:
        """Returns basic profile of the invite code creator: name, username, avatar_url"""

def add_AuthServicer_to_server(servicer: AuthServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
