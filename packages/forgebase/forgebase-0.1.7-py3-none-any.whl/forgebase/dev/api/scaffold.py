"""
Scaffolding API for AI Agents.

Provides programmatic code generation for ForgeBase components.
Returns generated code as strings for AI modification before writing.

Usage:
    from forgebase.dev.api import ScaffoldGenerator

    generator = ScaffoldGenerator()

    # Generate UseCase
    code = generator.create_usecase(
        name="CreateOrder",
        input_type="CreateOrderInput",
        output_type="CreateOrderOutput"
    )

    # AI can modify code before writing
    modified = customize_for_context(code)
    write_file("create_order_usecase.py", modified)

Author: ForgeBase Development Team
Created: 2025-11-04
"""

import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any


@dataclass
class ScaffoldResult:
    """
    Result from scaffolding operation.

    Attributes:
        component_type: Type of component generated (usecase, port, adapter)
        name: Name of the generated component
        code: Generated code as string
        file_path: Suggested file path for the component
        success: Whether generation succeeded
        error: Error message if failed
        metadata: Additional metadata (imports needed, dependencies, etc.)
    """

    component_type: str
    name: str
    code: str = ""
    file_path: str = ""
    success: bool = True
    error: str = ""
    metadata: dict[str, Any] = None  # type: ignore[assignment]

    def __post_init__(self) -> None:
        if self.metadata is None:
            self.metadata = {}

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            "component_type": self.component_type,
            "name": self.name,
            "code": self.code,
            "file_path": self.file_path,
            "success": self.success,
            "error": self.error,
            "metadata": self.metadata,
        }


class ScaffoldGenerator:
    """
    Code generation API for AI agents.

    Generates boilerplate code for ForgeBase components with:
    - Type-safe templates
    - Docstring generation
    - Lifecycle hooks
    - Clean Architecture compliance

    All methods return ScaffoldResult with generated code as strings,
    allowing AI agents to modify before writing to disk.

    Example:
        generator = ScaffoldGenerator()

        # Generate UseCase
        result = generator.create_usecase(
            name="CreateOrder",
            input_type="CreateOrderInput",
            output_type="CreateOrderOutput",
            repository="OrderRepositoryPort"
        )

        if result.success:
            # AI modifies code
            code = result.code.replace("pass", "# Implementation")
            write_file(result.file_path, code)
    """

    def __init__(self, project_root: Path | None = None):
        """
        Initialize scaffold generator.

        Args:
            project_root: Project root directory. Defaults to current directory.
        """
        self.project_root = project_root or Path.cwd()

    def create_usecase(
        self,
        name: str,
        input_type: str | None = None,
        output_type: str | None = None,
        repository: str | None = None,
    ) -> ScaffoldResult:
        """
        Generate UseCase boilerplate.

        Args:
            name: UseCase name (e.g., "CreateOrder")
            input_type: Input DTO type name (e.g., "CreateOrderInput")
            output_type: Output DTO type name (e.g., "CreateOrderOutput")
            repository: Repository dependency name (optional)

        Returns:
            ScaffoldResult with generated code

        Example:
            result = generator.create_usecase(
                name="CreateOrder",
                input_type="CreateOrderInput",
                output_type="CreateOrderOutput",
                repository="OrderRepositoryPort"
            )
            print(result.code)  # Generated UseCase code
        """
        # Default types
        input_type = input_type or f"{name}Input"
        output_type = output_type or f"{name}Output"

        # Generate code
        code = f'''"""
{name} UseCase.

Generated by ForgeBase ScaffoldGenerator.
"""

from forgebase.application.usecase_base import UseCaseBase
from forgebase.application.dto_base import DTOBase


class {input_type}(DTOBase):
    """Input DTO for {name} UseCase."""

    def __init__(self) -> None:
        """Initialize input."""
        pass

    def validate(self) -> None:
        """Validate input."""
        pass

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {{}}

    @classmethod
    def from_dict(cls, data: dict) -> "{input_type}":
        """Create from dictionary."""
        return cls()


class {output_type}(DTOBase):
    """Output DTO for {name} UseCase."""

    def __init__(self) -> None:
        """Initialize output."""
        pass

    def validate(self) -> None:
        """Validate output."""
        pass

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {{}}

    @classmethod
    def from_dict(cls, data: dict) -> "{output_type}":
        """Create from dictionary."""
        return cls()


class {name}UseCase(UseCaseBase[{input_type}, {output_type}]):
    """
    {name} UseCase.

    Implements business logic for {name.lower()}.
    """

    def __init__(self{', ' + repository.lower() + ': ' + repository if repository else ''}) -> None:
        """
        Initialize {name} UseCase.
'''

        if repository:
            code += f'''
        Args:
            {repository.lower()}: {repository} dependency
'''

        code += '''        """
'''

        if repository:
            code += f'''        self.{repository.lower()} = {repository.lower()}
'''

        code += f'''
    def execute(self, input_dto: {input_type}) -> {output_type}:
        """
        Execute {name} logic.

        Args:
            input_dto: Input data

        Returns:
            Output data
        """
        # Validate input
        input_dto.validate()

        # TODO: Implement business logic here

        # Return output
        return {output_type}()

    def _before_execute(self) -> None:
        """Hook before execution."""
        pass

    def _after_execute(self) -> None:
        """Hook after execution."""
        pass

    def _on_error(self, error: Exception) -> None:
        """Hook on error."""
        pass
'''

        # Determine file path
        snake_case_name = self._to_snake_case(name)
        file_path = f"src/forgebase/application/{snake_case_name}_usecase.py"

        # Metadata
        metadata = {
            "imports": [
                "from forgebase.application.usecase_base import UseCaseBase",
                "from forgebase.application.dto_base import DTOBase",
            ],
            "dependencies": [repository] if repository else [],
            "input_type": input_type,
            "output_type": output_type,
        }

        return ScaffoldResult(
            component_type="usecase",
            name=name,
            code=code,
            file_path=file_path,
            success=True,
            metadata=metadata,
        )

    def create_entity(self, name: str, attributes: list[str] | None = None) -> ScaffoldResult:
        """
        Generate Entity boilerplate.

        Args:
            name: Entity name (e.g., "Order")
            attributes: List of attribute names

        Returns:
            ScaffoldResult with generated code

        Example:
            result = generator.create_entity(
                name="Order",
                attributes=["customer_id", "total", "items"]
            )
        """
        attributes = attributes or []

        code = f'''"""
{name} Entity.

Generated by ForgeBase ScaffoldGenerator.
"""

from forgebase.domain.entity_base import EntityBase


class {name}(EntityBase):
    """
    {name} domain entity.

    Represents {name.lower()} in the domain model.
    """

    def __init__(
        self,
        id: str | None = None,
'''

        # Add attributes to __init__
        for attr in attributes:
            code += f"        {attr}: str | None = None,\n"

        code += f'''    ) -> None:
        """
        Initialize {name} entity.

        Args:
            id: Entity identifier
'''

        for attr in attributes:
            code += f"            {attr}: {attr.replace('_', ' ').title()}\n"

        code += '''        """
        super().__init__(id)
'''

        for attr in attributes:
            code += f"        self.{attr} = {attr}\n"

        code += '''
    def validate(self) -> None:
        """Validate entity invariants."""
        # TODO: Implement validation logic
        pass

    def to_dict(self) -> dict:
        """Convert to dictionary."""
        return {
            "id": self.id,
'''

        for attr in attributes:
            code += f'            "{attr}": self.{attr},\n'

        code += '''        }}

    @classmethod
    def from_dict(cls, data: dict) -> "{name}":
        """Create from dictionary."""
        return cls(
            id=data.get("id"),
'''

        for attr in attributes:
            code += f'            {attr}=data.get("{attr}"),\n'

        code += '''        )
'''

        snake_case_name = self._to_snake_case(name)
        file_path = f"src/forgebase/domain/{snake_case_name}.py"

        metadata = {
            "imports": ["from forgebase.domain.entity_base import EntityBase"],
            "attributes": attributes,
        }

        return ScaffoldResult(
            component_type="entity",
            name=name,
            code=code,
            file_path=file_path,
            success=True,
            metadata=metadata,
        )

    def run_legacy_scaffold(self, args: list[str] | None = None) -> ScaffoldResult:
        """
        Run legacy scaffold.py script.

        For backwards compatibility with existing scaffolding system.

        Args:
            args: Command line arguments

        Returns:
            ScaffoldResult with execution result
        """
        try:
            result = subprocess.run(
                [sys.executable, "scripts/scaffold.py"] + (args or []),
                capture_output=True,
                text=True,
                cwd=self.project_root,
            )

            return ScaffoldResult(
                component_type="legacy",
                name="scaffold.py",
                code="",
                success=result.returncode == 0,
                error=result.stderr if result.returncode != 0 else "",
                metadata={"stdout": result.stdout, "stderr": result.stderr},
            )

        except FileNotFoundError:
            return ScaffoldResult(
                component_type="legacy",
                name="scaffold.py",
                success=False,
                error="scaffold.py not found in scripts/",
            )

    def _to_snake_case(self, name: str) -> str:
        """Convert CamelCase to snake_case."""
        import re

        s1 = re.sub("(.)([A-Z][a-z]+)", r"\1_\2", name)
        return re.sub("([a-z0-9])([A-Z])", r"\1_\2", s1).lower()
