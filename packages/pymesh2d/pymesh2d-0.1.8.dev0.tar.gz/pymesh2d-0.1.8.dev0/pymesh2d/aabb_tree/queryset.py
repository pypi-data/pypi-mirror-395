import numpy as np


def queryset(tr, tm, fn, *args):
    """
    Perform spatial queries on AABB-indexed collections.

    This function executes spatial intersection queries between a collection 
    of objects indexed by an Axis-Aligned Bounding Box (AABB) tree and a set 
    of query elements. It uses a user-defined intersection kernel function to 
    determine which objects intersect within each relevant tree node.

    Parameters
    ----------
    TR : dict
        AABB tree structure generated by `maketree`, containing:
        - `TR["XX"]` : ndarray of shape (NT, NDIM*2)
          Bounding boxes of tree nodes as `[PMIN, PMAX]`.
        - `TR["II"]` : ndarray of shape (NT, 2)
          Parentâ€“child indices for each node.
        - `TR["LL"]` : list of lists
          Lists of object indices associated with each node.

    TM : dict
        Query-to-tree mapping structure, typically created by `mapvert` or `maprect`.
        - `TM["II"]` : ndarray of shape (M,)
          Indices of tree nodes intersecting the query elements.
        - `TM["LL"]` : list of lists
          Lists of query indices intersecting each corresponding node.

    FN : callable
        Intersection kernel function called to test for actual intersections between
        objects and query items within each non-empty tree node.

        The kernel must have the signature:
            (PK, CK) = FN(PJ, CJ, *args)

        where:
        - `PJ` : ndarray
            Indices of query items within the current node.
        - `CJ` : ndarray
            Indices of candidate objects within the same node.
        - `PK`, `CK` : ndarrays
            Lists of matching query and object indices, respectively.
        - `*args` : optional
            Additional arguments passed directly to `FN`.

    *args : optional
        Extra user-defined arguments passed internally to the intersection kernel `FN`.

    Returns
    -------
    QI : ndarray
        Indices of query items that have at least one intersection.
    QP : ndarray of shape (N, 2)
        Pointer array defining index ranges for each query item in `QJ`.
        The intersections for item `QI[i]` are found in `QJ[QP[i,0]:QP[i,1]]`.
    QJ : ndarray
        Flattened list of intersecting object indices.

    Notes
    -----
    - This function performs hierarchical spatial queries using the provided AABB tree.
    - The kernel function `FN` handles the exact intersection logic between query and object sets.
    - Designed for efficient, localized `O(N*M)` comparisons within each relevant tree node.

    References
    ----------
    Translation of the MESH2D function `QUERYSET`.  
    Original MATLAB source: https://github.com/dengwirda/mesh2d  

    See also
    --------
    mapvert : Compute vertex-to-tree mappings.  
    maprect : Compute rectangle-to-tree mappings.  
    maketree : Build an AABB tree from bounding boxes.
    """

    # ---------------------------------------------- basic checks
    if tr is None or len(tr) == 0:
        return np.array([]), np.array([]), np.array([])
    if not isinstance(tr, dict) or not isinstance(tm, dict):
        raise TypeError("queryset: incorrect input class.")
    if not all(k in tm for k in ("ii", "ll")):
        raise ValueError("queryset: invalid aabb-maps obj.")
    if not all(k in tr for k in ("xx", "ii", "ll")):
        raise ValueError("queryset: invalid aabb-tree obj.")
    #------------------------------ spatial query over tree-node
    ic = []
    jc = []

    for ip in range(len(tm["ii"])):
        #-------------------------- extract items/query per tile
        ni = tm["ii"][ip] #  node (in tree)

        # -------------------------- do O(n*m) search within tile
        qi, qj = fn(
            tm["ll"][ip],  # query in tile
            tr["ll"][ni],  # items in tile
            *args,
        )
        #-------------------------- push loc. item-query matches
        ic.append(np.atleast_1d(qi))
        jc.append(np.atleast_1d(qj))

    if len(ic) == 0 or len(jc) == 0:
        return np.array([]), np.array([]), np.array([])
    #-------------------------------- concat matches into arrays
    qi = np.concatenate(ic)
    qj = np.concatenate(jc)

    if qj.size == 0:
        return np.array([]), np.array([]), np.array([])

    # ------------------------------- form sparse-style indexing
    sort_idx = np.argsort(qi)
    qi = qi[sort_idx]
    qj = qj[sort_idx]

    diff_idx = np.nonzero(np.diff(qi) != 0)[0]
    ni = len(qi)

    qi_unique = np.concatenate((qi[diff_idx], [qi[-1]]))
    nj = len(qj)
    ni = len(qi_unique)

    # ----------------------------- each list is IP(I,1):IP(I,2)
    qp = np.zeros((ni, 2), dtype=int)
    qp[:, 0] = np.concatenate(([0], diff_idx + 1))
    qp[:, 1] = np.concatenate((diff_idx, [nj - 1]))

    return qi_unique, qp, qj
