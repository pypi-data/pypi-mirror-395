import numpy as np

from .scantree import scantree


def maprect(tr, pr):
    """
    Compute mappings between tree nodes and rectangles in an AABB tree.

    This function determines the intersections between a set of rectangles
    and the nodes of an Axis-Aligned Bounding Box (AABB) tree, returning
    both the tree-to-rectangle and rectangle-to-tree mappings.

    It is typically used to associate geometric primitives (e.g., rectangles,
    polygons) with spatial partitions defined by an AABB tree.

    Parameters
    ----------
    TR : dict
        AABB tree structure generated by `maketree`, containing:
        - `TR["XX"]` : ndarray of shape (NT, NDIM*2)
          Bounding boxes of tree nodes as `[PMIN, PMAX]`.
        - `TR["II"]` : ndarray of shape (NT, 2)
          Parentâ€“child indices for each node.
        - `TR["LL"]` : list of lists
          Lists of items associated with each node.
    PR : ndarray of shape (NR, NDIM*2)
        Array of rectangles or bounding boxes, where each row
        defines `[PMIN, PMAX]` coordinates for one rectangle.

    Returns
    -------
    TM : dict
        Tree-to-rectangle mapping:
        - `TM["II"]` : ndarray of shape (M,)
          Indices of tree nodes.
        - `TM["LL"]` : list of lists
          Lists of rectangle indices intersecting each node `TM["II"][j]`.
    IM : dict
        Rectangle-to-tree mapping:
        - `IM["II"]` : ndarray of shape (N,)
          Indices of rectangles.
        - `IM["LL"]` : list of lists
          Lists of tree node indices intersecting each rectangle `IM["II"][j]`.

    Notes
    -----
    - This function identifies all mutual intersections between the
      rectangles and the AABB tree nodes.
    - It returns two mappings for efficient bidirectional lookup between
      geometric primitives and spatial partitions.
    - It is often used as part of mesh or geometry preprocessing pipelines.

    References
    ----------
    Translation of the MESH2D function `MAPRECT`.
    Original MATLAB source: https://github.com/dengwirda/mesh2d

    See also
    --------
    queryset : Perform spatial queries within an AABB tree.
    mapvert : Compute vertex-to-tree mappings.
    maketree : Build an AABB tree from bounding boxes.
    """

    if tr is None or pr is None:
        raise ValueError("Invalid input arguments.")

    if len(pr.shape) != 2:
        raise ValueError("Input 'pr' must be a 2D array.")

    if "ii" not in tr or "xx" not in tr or "ll" not in tr:
        raise ValueError("Invalid AABB-tree structure.")

    # ---------------------- call SCANTREE to do the actual work
    tm, im = scantree(tr, pr, partrect)
    return tm, im


def partrect(pr, b1, b2):
    """
    PARTRECT: Partition rectangles between boxes B1 and B2 for SCANTREE.

    Parameters:
        pr (numpy.ndarray): Rectangles to partition.
        b1 (numpy.ndarray): Bounds of the first box.
        b2 (numpy.ndarray): Bounds of the second box.

    Returns:
        j1 (numpy.ndarray): Boolean mask for rectangles in B1.
        j2 (numpy.ndarray): Boolean mask for rectangles in B2.

    Notes
    -----
    Traduced from MATLAB aabb-tree repository

    References
    ----------
    Translation of the MESH2D function `PARTRECT`.
    Original MATLAB source: https://github.com/dengwirda/mesh2d
    """
    j1 = np.ones(pr.shape[0], dtype=bool)
    j2 = np.ones(pr.shape[0], dtype=bool)

    # Handle both 1D and 2D arrays for b1 and b2
    # In MATLAB, b1 and b2 are row vectors (1D), but indexing works the same
    if b1.ndim == 1:
        nd = b1.shape[0] // 2
        for ax in range(nd):
            # -------------- remains TRUE if inside bounds along axis AX
            # MATLAB: b1(ax+nd*0) and b1(ax+nd*1)
            j1 = j1 & (pr[:, ax + nd] >= b1[ax]) & (pr[:, ax] <= b1[ax + nd])
            j2 = j2 & (pr[:, ax + nd] >= b2[ax]) & (pr[:, ax] <= b2[ax + nd])
    else:
        nd = b1.shape[1] // 2
        for ax in range(nd):
            # -------------- remains TRUE if inside bounds along axis AX
            j1 = j1 & (pr[:, ax + nd] >= b1[0, ax]) & (pr[:, ax] <= b1[0, ax + nd])
            j2 = j2 & (pr[:, ax + nd] >= b2[0, ax]) & (pr[:, ax] <= b2[0, ax + nd])

    return j1, j2
