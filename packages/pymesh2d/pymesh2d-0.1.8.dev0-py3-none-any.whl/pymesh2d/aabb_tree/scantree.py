import numpy as np


def scantree(tr, pi, fn):
    """
    Compute tree-to-item and item-to-tree mappings for an AABB tree.

    This is a low-level routine that determines how a set of query items
    intersect with the nodes of an Axis-Aligned Bounding Box (AABB) tree.
    It returns both mappings: from tree nodes to intersecting items, and
    from items to intersected tree nodes.

    Parameters
    ----------
    TR : dict
        AABB tree structure generated by `maketree`, containing:
        - `TR["XX"]` : ndarray of shape (NT, NDIM*2)
          Bounding boxes of tree nodes as `[PMIN, PMAX]`.
        - `TR["II"]` : ndarray of shape (NT, 2)
          Parentâ€“child indices for each node.
        - `TR["LL"]` : list of lists
          Lists of items associated with each node.
    PI : ndarray
        Collection of query items (e.g., vertices, bounding boxes, etc.)
        to be mapped against the AABB tree.
    FN : callable
        Partition function that determines how items are assigned to
        child nodes during the tree traversal.

        The function must have the signature:
            KI, KJ = FN(PJ, NI, NJ)

        where:
        - `PJ` : ndarray
            Subset of items to test within the current node.
        - `NI`, `NJ` : objects
            Child node bounding boxes.
        - `KI[i] = True` if the i-th item intersects node NI.
        - `KJ[i] = True` if the i-th item intersects node NJ.

    Returns
    -------
    TM : dict
        Tree-to-item mapping:
        - `TM["II"]` : ndarray of shape (M,)
          Indices of tree nodes.
        - `TM["LL"]` : list of lists
          Lists of item indices intersecting each node `TM["II"][j]`.
    IM : dict
        Item-to-tree mapping:
        - `IM["II"]` : ndarray of shape (N,)
          Indices of items.
        - `IM["LL"]` : list of lists
          Lists of tree node indices intersecting each item `IM["II"][j]`.

    Notes
    -----
    - This function is typically used internally by higher-level
      spatial query routines such as `queryset`, `mapvert`, or `maprect`.
    - The function `FN` defines the intersection logic and is called
      recursively to propagate mappings through the tree hierarchy.
    - It provides a flexible, general-purpose mechanism for performing
      custom intersection tests in hierarchical search structures.

    References
    ----------
    Translation of the MESH2D function `SCANTREE`.
    Original MATLAB source: https://github.com/dengwirda/mesh2d

    See also
    --------
    queryset : Perform spatial queries within an AABB tree.
    mapvert : Compute vertex-to-tree mappings.
    maprect : Compute rectangle-to-tree mappings.
    maketree : Build an AABB tree from bounding boxes.
    """

    tm = {"ii": [], "ll": []}
    im = {"ii": [], "ll": []}

    # ----------------------------- quick return on empty inputs
    if pi is None or len(pi) == 0:
        return tm, im
    if tr is None or len(tr) == 0:
        return tm, im
    # --------------------------------------------- basic checks
    if not isinstance(tr, dict) or not isinstance(pi, np.ndarray) or not callable(fn):
        raise TypeError("scantree: incorrect input class.")

    if not all(k in tr for k in ("xx", "ii", "ll")):
        raise ValueError("scantree: incorrect AABB struct.")

    n_nodes = tr["ii"].shape[0]
    # ----------------------------------- alloc. output/workspace
    tm["ii"] = np.zeros(n_nodes, dtype=int)
    tm["ll"] = [None] * n_nodes

    ss = np.zeros(n_nodes, dtype=int)
    sl = [None] * n_nodes
    sl[0] = np.arange(pi.shape[0])

    tf = np.array([len(x) > 0 for x in tr["ll"]])
    # ---------- descend tree from root, push items amongst nodes
    ss[0] = 0
    ns = 1
    no = 0

    while ns > 0:
        # ---------------------------------- _pop node from stack
        ns -= 1
        ni = ss[ns]  # pop

        if tf[ni]:
            # push onto tree-item mapping -- non-empty node NI contains items LL
            tm["ii"][no] = ni
            tm["ll"][no] = sl[ns]
            no += 1

        if tr["ii"][ni, 1] != 0:
            # --------------------- partition amongst child nodes
            c1 = tr["ii"][ni, 1]
            c2 = tr["ii"][ni, 1] + 1
            # --------------------- user-defined partitions of LL
            j1, j2 = fn(pi[sl[ns], :], tr["xx"][c1, :], tr["xx"][c2, :])
            # --------------------- lists of items per child node
            l1 = sl[ns][j1]
            l2 = sl[ns][j2]

            if l1.size > 0:
                # --------------------- push nonempty node onto stack
                ss[ns] = c1
                sl[ns] = l1
                ns += 1
            if l2.size > 0:
                # --------------------- push nonempty node onto stack
                ss[ns] = c2
                sl[ns] = l2
                ns += 1

    # ----------------------------------------------- trim alloc.
    tm["ii"] = tm["ii"][:no]
    tm["ll"] = tm["ll"][:no]

    # ----------------------- compute inverse map only if desired
    if tm and im is None:
        return tm

    # ----------------------- accumulate pair'd tree-item matches
    ic = []
    jc = tm["ll"]

    for ip in range(no):
        ni = tm["ii"][ip]
        ic.append(np.full(len(jc[ip]), ni, dtype=int))

    if len(ic) == 0:
        return tm, im

    ii = np.concatenate(ic)
    jj = np.concatenate(jc)

    im["ll"] = [None] * pi.shape[0]

    # ---------------------------------- invert ordering via sort
    jx = np.argsort(jj)
    jj = jj[jx]
    ii = ii[jx]

    diff_idx = np.nonzero(np.diff(jj) != 0)[0]
    im["ii"] = np.concatenate((jj[diff_idx], [jj[-1]]))
    bounds = np.concatenate(([0], diff_idx + 1, [len(ii)]))
    # ----------------------- distribute single item-tree matches
    for ip in range(len(im["ii"])):
        im["ll"][ip] = ii[bounds[ip] : bounds[ip + 1]]

    return tm, im
