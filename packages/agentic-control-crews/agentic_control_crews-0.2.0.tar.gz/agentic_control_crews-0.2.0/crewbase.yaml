version: "2.0"
name: "development_crew"

# Reference external configuration files
agents_config: 'config/agents.yaml'
tasks_config: 'config/tasks.yaml'

# Crew-level configuration
process: hierarchical
manager_llm: "claude-3-7-sonnet-20250219"
verbose: true
memory: true
planning: true

# MCP tool server configuration
mcp_servers:
  conport:
    command: "uvx"
    args: ["--from", "context-portal-mcp", "conport-mcp"]

  git:
    command: "uvx"
    args: ["mcp-server-git", "--repository", "."]

  filesystem:
    command: "npx"
    args: ["-y", "@modelcontextprotocol/server-filesystem", "./"]

  playwright:
    command: "npx"
    args: ["-y", "@playwright/mcp"]

  context7:
    command: "npx"
    args: ["-y", "@upstash/context7-mcp"]

# ==============================================================================
# REUSABLE WORKFLOW PATTERNS
# ==============================================================================
# Workflow definitions are now in .ruler/ directory:
# - .ruler/tdd_prototype_workflow.yaml
# - .ruler/meshy_asset_workflow.yaml
# - .ruler/prototype_to_production_workflow.yaml

# ==============================================================================
# REUSABLE WORKFLOW PATTERNS (YAML Anchors)
# ==============================================================================

# TDD Prototype Workflow - Standard 4-phase pattern for any prototype
#
# NOTE: Separate anchors are needed for each workflow phase because YAML does not support
# referencing subfields of an alias (e.g., *anchor.subfield). This means we cannot define
# a single anchor for the whole workflow and then reference only a phase within it.
# Instead, each phase is anchored individually for reuse.
# See: https://yaml.org/spec/1.2.2/#id2760395
#
x-tdd-design-phase: &tdd_design_phase
  agent: rendering_engineer
  context_required: true
  human_input: true
  outputs:
    - technical_design_document
    - component_dependency_graph
    - acceptance_criteria_checklist

x-tdd-implementation-phase: &tdd_implementation_phase
  agent: rendering_engineer
  context_from_design: true
  outputs:
    - component_files
    - shader_files
    - integration_points

x-tdd-validation-phase: &tdd_validation_phase
  agent: qa_validator
  context_from_implementation: true
  human_input: true  # HITL approval checkpoint
  outputs:
    - validation_report
    - performance_metrics
    - approval_recommendation

x-tdd-documentation-phase: &tdd_documentation_phase
  agent: technical_writer
  context_from_all: true
  outputs:
    - updated_conport
    - integration_guide
    - handoff_notes

# Combined workflow reference (for documentation)
x-tdd-prototype-workflow: &tdd_prototype_workflow
  design_phase: *tdd_design_phase
  implementation_phase: *tdd_implementation_phase
  validation_phase: *tdd_validation_phase
  documentation_phase: *tdd_documentation_phase

# Meshy Asset Generation Workflow - Reusable for any species
x-meshy-asset-workflow: &meshy_asset_workflow
  api_sequence:
    - text3d_static
    - rigging
    - animation_default
    - animation_custom
    - retexture_variant

  webhook_config:
    base_url: "http://0.0.0.0:8000/webhooks/meshy"
    endpoints:
      - /static
      - /rigged
      - /animated_default
      - /animated_custom
      - /retextured

  output_structure:
    base_path: "client/public/models"
    files:
      - static.glb
      - walk.glb
      - attack.glb
      - variant.glb
    manifest: manifest.json

# ==============================================================================
# TASK DEFINITIONS - Proper decomposition with cascading dependencies
# ==============================================================================
tasks:
  # -------------------------------------------------------------------------
  # PHASE 0: ALPHA - Context Loading & Validation
  # -------------------------------------------------------------------------
  alpha_context_load:
    description: |
      ALPHA TASK: Load complete project context before any work begins.

      Actions:
      1. Read projectbrief.md for project goals and constraints
      2. Query ConPort schema to understand current state
      3. Read .ruler/ files for architectural patterns
      4. Identify any missing prerequisites or blockers

      Validation Criteria:
      - All context files are accessible
      - No critical blockers identified
      - Prerequisites are documented

      Output Format: Markdown checklist with:
      - [ ] Context item loaded
      - [ ] Prerequisite validated
      - [ ] Blocker identified (if any)
    expected_output: |
      Markdown report with:
      ## Context Loaded
      - List of files read
      - Current project state summary

      ## Prerequisites
      - [ ] Checklist of validated prerequisites

      ## Blockers (if any)
      - Description of any blockers

      ## Ready to Proceed
      - Yes/No with reasoning
    agent: project_manager
    human_input: false

  # -------------------------------------------------------------------------
  # PHASE 1: FOUNDATION - Parallel schema validation
  # -------------------------------------------------------------------------
  validate_ecs_component_schemas:
    description: |
      Validate existing ECS component schemas in src/ecs/.

      Focus Areas:
      1. TypeScript compilation with zero errors
      2. Adherence to Miniplex patterns
      3. Type exports are complete and correct
      4. Component schemas are minimal and focused

      DO NOT create new components. ONLY validate existing ones.

      Validation Steps:
      1. Run `npm run typecheck` in client/
      2. Check each component file against patterns
      3. Verify type exports exist
      4. Document any issues found

      If issues found: Create a remediation plan, do NOT fix yet.
    expected_output: |
      ## Validation Report

      ### TypeScript Compilation
      - Status: PASS/FAIL
      - Errors: (list if any)

      ### Pattern Compliance
      - AIComponent.ts: PASS/FAIL (reasoning)
      - AnimationComponent.ts: PASS/FAIL (reasoning)
      - [continue for all components]

      ### Type Exports
      - Complete: YES/NO
      - Missing: (list if any)

      ### Remediation Plan (if needed)
      - Issue 1: [description] → [fix]
      - Issue 2: [description] → [fix]

      ### Ready for Next Phase
      - YES/NO with reasoning
    agent: ecs_architect
    context: [alpha_context_load]
    async_execution: false

  validate_dfu_data_contracts:
    description: |
      Validate Daggerfall Unity data mappings in shared/backend/dfu_analysis/.

      Focus Areas:
      1. biomes.json structure matches BiomeContract.ts
      2. species.json structure matches SpeciesContract.ts
      3. Data completeness (no missing required fields)
      4. Type safety between backend and frontend contracts

      DO NOT modify contracts yet. ONLY validate.

      Validation Steps:
      1. Load shared/contracts/*.ts
      2. Load shared/backend/dfu_analysis/mappings/*.json
      3. Verify structural alignment
      4. Check for missing data
      5. Document any mismatches
    expected_output: |
      ## Contract Validation Report

      ### BiomeContract Alignment
      - Structure matches: YES/NO
      - Missing fields: (list if any)
      - Type mismatches: (list if any)

      ### SpeciesContract Alignment
      - Structure matches: YES/NO
      - Missing fields: (list if any)
      - Type mismatches: (list if any)

      ### Data Completeness
      - Biomes: X/Y complete
      - Species: X/Y complete

      ### Remediation Plan (if needed)
      - Issue 1: [description] → [fix]

      ### Ready for Next Phase
      - YES/NO with reasoning
    agent: ecs_architect
    context: [alpha_context_load]
    async_execution: false

  # -------------------------------------------------------------------------
  # CONDITIONAL: Fix foundation if validation failed
  # -------------------------------------------------------------------------
  fix_foundation_issues:
    description: |
      CONDITIONAL TASK: Only runs if validation tasks identified issues.

      Condition: Check previous task outputs for FAIL status or remediation plans.

      Actions:
      1. Review all remediation plans from validation tasks
      2. Prioritize fixes by impact (blocking vs. non-blocking)
      3. Apply fixes for blocking issues only
      4. Re-run validation to confirm fixes

      DO NOT scope creep. Fix ONLY documented issues.
    expected_output: |
      ## Fixes Applied

      ### Blocking Issues Fixed
      - Issue 1: [description] → [action taken] → [validated]

      ### Non-Blocking Issues Deferred
      - Issue 1: [description] → [deferred to phase X]

      ### Re-validation Results
      - ECS Schemas: PASS/FAIL
      - DFU Contracts: PASS/FAIL

      ### Ready to Proceed
      - YES/NO with reasoning
    agent: ecs_architect
    context: [validate_ecs_component_schemas, validate_dfu_data_contracts]
    condition: |
      lambda outputs: any(
        'FAIL' in str(output.raw) or 'Remediation Plan' in str(output.raw)
        for output in outputs if output
      )

  # -------------------------------------------------------------------------
  # PHASE 2: PROTOTYPE 1 - Biome/Weather/Day Cycle (Sequential)
  # -------------------------------------------------------------------------
  design_biome_rendering_slice:
    description: |
      Design the minimal vertical slice for Biome/Weather/DayNight rendering.

      Scope Definition:
      1. Identify MINIMUM components needed for biome diorama
      2. Define shader requirements (sky, ground, lighting)
      3. Specify ECS integration points
      4. Create acceptance criteria

      Deliverables:
      1. Technical design document (markdown)
      2. Component dependency graph
      3. Shader specification
      4. Acceptance criteria checklist

      Constraints:
      - Must work with EXISTING ECS schemas (no new components)
      - Must use existing post-processing pipeline
      - Must maintain 60fps on mobile

      This is DESIGN only. No implementation yet.
    expected_output: |
      ## Biome Rendering Vertical Slice Design

      ### Scope
      - Components used: [list]
      - Shaders required: [list]
      - Integration points: [list]

      ### Component Dependencies
      ```
      [ASCII dependency graph]
      ```

      ### Shader Specifications
      #### Sky Shader
      - Inputs: [list]
      - Outputs: [list]
      - Algorithm: [description]

      #### Ground Shader
      [same format]

      ### ECS Integration
      - BiomeComponent → [how it drives rendering]
      - TimeOfDayComponent → [how it affects shaders]
      - WeatherComponent → [how it affects scene]

      ### Acceptance Criteria
      - [ ] Biome selector UI works
      - [ ] Day/night cycle animates smoothly
      - [ ] Weather transitions are visible
      - [ ] 60fps maintained on iPhone 13
      - [ ] No console errors

      ### Estimated Complexity
      - Low/Medium/High with reasoning
    agent: rendering_engineer
    context: [validate_ecs_component_schemas, validate_dfu_data_contracts]
    depends_on:
      - validate_ecs_component_schemas: "process_completed_successfully"
      - validate_dfu_data_contracts: "process_completed_successfully"

  implement_biome_shaders:
    description: |
      Implement ONLY the shader code for biome rendering.

      Scope:
      - Create/modify shader files based on design spec
      - Implement sky gradient shader
      - Implement ground SDF shader
      - Add time-of-day lighting calculations

      Constraints:
      - Use existing shader patterns from client/.ruler/shaders.md
      - Maintain GLSL ES 3.0 compatibility (mobile)
      - Keep shader complexity LOW (mobile performance)

      DO NOT implement React components yet. Shaders only.
    expected_output: |
      ## Shader Implementation

      ### Files Modified/Created
      - path/to/SkyShader.glsl: [description]
      - path/to/GroundShader.glsl: [description]

      ### Shader Features
      #### Sky Shader
      - Time-of-day gradient: IMPLEMENTED
      - Weather effects: IMPLEMENTED
      - Performance: [ms per frame]

      #### Ground Shader
      - SDF terrain: IMPLEMENTED
      - Biome coloring: IMPLEMENTED
      - Performance: [ms per frame]

      ### Validation
      - Compiles without errors: YES/NO
      - Mobile compatible: YES/NO
      - Performance target met: YES/NO

      ### Ready for Integration
      - YES/NO with reasoning
    agent: rendering_engineer
    context: [design_biome_rendering_slice]

  implement_biome_r3f_components:
    description: |
      Implement React Three Fiber components that USE the shaders.

      Scope:
      - Create/modify R3F components for biome scene
      - Connect ECS state to shader uniforms
      - Implement control UI (biome selector, time slider, weather toggle)

      Integration Points:
      - BiomeComponent → shader material props
      - TimeOfDayComponent → sky shader uniforms
      - WeatherComponent → weather effects toggle

      Reference: client/.ruler/react_three_fiber.md for patterns
    expected_output: |
      ## R3F Component Implementation

      ### Components Created/Modified
      - BiomeDiorama.tsx: [description]
      - BiomeControls.tsx: [description]
      - SDFGround.tsx: [description]
      - SDFSky.tsx: [description]

      ### ECS Integration
      - useBiomeECS hook: [connects ECS to R3F]
      - State flow: BiomeComponent → uniforms → shaders

      ### UI Controls
      - Biome selector: IMPLEMENTED
      - Time of day slider: IMPLEMENTED
      - Weather toggle: IMPLEMENTED

      ### Validation
      - TypeScript compiles: YES/NO
      - Controls functional: YES/NO
      - Performance: [fps on test device]

      ### Ready for QA
      - YES/NO with reasoning
    agent: rendering_engineer
    context: [implement_biome_shaders]

  validate_biome_prototype:
    description: |
      Run automated validation of the biome prototype.

      Validation Steps:
      1. Run TypeScript compilation: `npm run typecheck`
      2. Start dev server and load prototype
      3. Test all acceptance criteria from design phase
      4. Measure performance metrics
      5. Check for console errors/warnings

      DO NOT fix issues. ONLY document them for review.
    expected_output: |
      ## Biome Prototype Validation Report

      ### TypeScript Compilation
      - Status: PASS/FAIL
      - Errors: [list if any]

      ### Acceptance Criteria Results
      - [ ] Biome selector UI works: PASS/FAIL
      - [ ] Day/night cycle animates: PASS/FAIL
      - [ ] Weather transitions visible: PASS/FAIL
      - [ ] 60fps maintained: PASS/FAIL (actual: X fps)
      - [ ] No console errors: PASS/FAIL

      ### Performance Metrics
      - Average FPS: X
      - Frame time: X ms
      - Memory usage: X MB

      ### Issues Found
      - Critical: [list]
      - Non-critical: [list]

      ### Recommendation
      - APPROVE for HITL review
      - FIX ISSUES before HITL review

      ### Screenshots/Evidence
      - [paths to screenshots if taken]
    agent: qa_validator
    context: [implement_biome_r3f_components]
    human_input: true  # HITL approval checkpoint

  # -------------------------------------------------------------------------
  # PHASE 3: PROTOTYPE 2 - Animated GLB Creature (Sequential after P1)
  # -------------------------------------------------------------------------
  design_creature_animation_slice:
    description: |
      Design minimal vertical slice for GLB creature with reactive animations.

      Scope Definition:
      1. Define creature component requirements (extends existing ECS)
      2. Specify animation triggers (buttons, movement, state changes)
      3. Design GLB loading and caching strategy
      4. Create acceptance criteria

      Context:
      - Builds on biome prototype (creature in foreground)
      - Uses existing AnimationComponent from ECS
      - References Meshy pipeline for asset source

      Constraints:
      - Must use EXISTING AnimationComponent
      - Animations must be from Meshy catalog
      - Must maintain 60fps with creature + biome
    expected_output: |
      ## Creature Animation Vertical Slice Design

      ### Scope
      - New components needed: [list or NONE]
      - ECS components used: AnimationComponent, [others]
      - Animation triggers: [button A → idle, direction → walk, etc.]

      ### Architecture
      ```
      [Component interaction diagram]
      ```

      ### GLB Loading Strategy
      - Asset source: Meshy API / local cache
      - Loading: [lazy/eager]
      - Caching: [strategy]

      ### Animation State Machine
      ```
      idle → walk (on movement)
      walk → attack (on button press)
      attack → idle (on completion)
      ```

      ### Acceptance Criteria
      - [ ] GLB model loads correctly
      - [ ] Animations transition smoothly
      - [ ] Button controls work
      - [ ] Direction changes affect animation
      - [ ] 60fps maintained with creature + biome
      - [ ] Mobile performance acceptable

      ### Integration with Prototype 1
      - Biome remains functional: [how]
      - Camera adjustments: [if needed]
      - UI additions: [creature controls]

      ### Estimated Complexity
      - Low/Medium/High with reasoning
    agent: rendering_engineer
    context: [validate_biome_prototype]
    depends_on:
      validate_biome_prototype: "process_completed_successfully"

  implement_glb_loader:
    description: |
      Implement GLB loading and caching system.

      Scope:
      - Create GLB loader utility
      - Implement asset caching
      - Add loading states
      - Handle errors gracefully

      Integration:
      - Connect to Meshy toolkit if using generated assets
      - Use React Three Fiber's useGLTF hook
      - Cache in browser storage
    expected_output: |
      ## GLB Loader Implementation

      ### Files Created/Modified
      - lib/glbLoader.ts: [description]
      - hooks/useCreatureModel.ts: [description]

      ### Features
      - Asset loading: IMPLEMENTED
      - Caching: IMPLEMENTED
      - Loading states: IMPLEMENTED
      - Error handling: IMPLEMENTED

      ### Performance
      - Load time (cached): X ms
      - Load time (uncached): X ms
      - Memory footprint: X MB

      ### Validation
      - TypeScript compiles: YES/NO
      - Unit tests pass: YES/NO

      ### Ready for Integration
      - YES/NO with reasoning
    agent: integration_specialist
    context: [design_creature_animation_slice]

  implement_creature_animations:
    description: |
      Implement creature component with reactive animations.

      Scope:
      - Create creature R3F component
      - Connect AnimationComponent to animation mixer
      - Implement state machine for animation transitions
      - Add control UI (attack button, direction controls)

      Reference existing OtterNPC.tsx for patterns.
    expected_output: |
      ## Creature Animation Implementation

      ### Components Created/Modified
      - components/CreatureNPC.tsx: [description]
      - components/CreatureControls.tsx: [description]
      - hooks/useCreatureAnimations.ts: [description]

      ### Animation State Machine
      - States: idle, walk, attack
      - Transitions: [as designed]
      - Triggers: [button events, movement]

      ### ECS Integration
      - AnimationComponent → animation mixer
      - State updates → ECS world

      ### UI Controls
      - Attack button: IMPLEMENTED
      - Direction pad: IMPLEMENTED
      - Animation state display: IMPLEMENTED

      ### Validation
      - TypeScript compiles: YES/NO
      - Animations play correctly: YES/NO
      - Performance: [fps with creature+biome]

      ### Ready for QA
      - YES/NO with reasoning
    agent: rendering_engineer
    context: [implement_glb_loader]

  validate_creature_prototype:
    description: |
      Validate creature animation prototype against acceptance criteria.

      Validation Steps:
      1. TypeScript compilation
      2. Load prototype with biome + creature
      3. Test all animation triggers
      4. Measure performance with both systems
      5. Check for regressions in biome functionality
    expected_output: |
      ## Creature Prototype Validation Report

      ### TypeScript Compilation
      - Status: PASS/FAIL

      ### Acceptance Criteria Results
      - [ ] GLB model loads: PASS/FAIL
      - [ ] Animations transition smoothly: PASS/FAIL
      - [ ] Button controls work: PASS/FAIL
      - [ ] Direction affects animation: PASS/FAIL
      - [ ] 60fps maintained: PASS/FAIL (actual: X fps)
      - [ ] Mobile performance OK: PASS/FAIL

      ### Performance Metrics
      - Average FPS (biome+creature): X
      - Frame time: X ms
      - Memory usage: X MB

      ### Regression Testing
      - Biome functionality: NOT BROKEN / BROKEN
      - Previous controls: WORKING / NOT WORKING

      ### Issues Found
      - Critical: [list]
      - Non-critical: [list]

      ### Recommendation
      - APPROVE for HITL review
      - FIX ISSUES before HITL review
    agent: qa_validator
    context: [implement_creature_animations]
    human_input: true  # HITL approval checkpoint

  # -------------------------------------------------------------------------
  # PHASE 4: ASSESSMENT - Plan Next Prototype
  # -------------------------------------------------------------------------
  assess_progress_and_plan_next:
    description: |
      STRATEGIC TASK: Assess completed prototypes and plan next vertical slice.

      Assessment Areas:
      1. Review what's been delivered (biome + creature prototypes)
      2. Identify gaps vs. final game vision
      3. Evaluate technical debt and refactoring needs
      4. Propose next logical vertical slice

      Planning Criteria:
      - Next slice should ADD capability, not redo existing work
      - Should be reasonably scoped (1-2 phases of work)
      - Should move toward playable game demo
      - Should address highest-risk unknowns
      
      Options for Next Slice (choose ONE):
      A. Multi-creature AI system (Yuka integration)
      B. Quest/dialogue system
      C. Terrain generation (procedural dungeons)
      D. Combat system (player vs. creatures)
      E. Other (specify)
      
      DO NOT implement. ONLY plan and get approval.
    expected_output: |
      ## Progress Assessment

      ### Delivered Capabilities
      - Prototype 1: Biome/Weather/DayNight rendering ✓
      - Prototype 2: Animated GLB creature ✓

      ### Gap Analysis
      - Missing for MVP: [list]
      - High-risk unknowns: [list]
      - Technical debt: [list]

      ### Proposed Next Vertical Slice
      **Selected Option**: [A/B/C/D/E]

      **Rationale**:
      - Addresses gap: [which gap]
      - Reduces risk: [which risk]
      - Builds on: [what we have]
      - Scope estimate: [time/complexity]

      ### Vertical Slice Breakdown
      1. Design Phase
         - Task 1: [description]
         - Task 2: [description]

      2. Implementation Phase
         - Task 1: [description]
         - Task 2: [description]

      3. Validation Phase
         - Task 1: [description]

      ### Approval Needed
      - Owner review required: YES
      - Estimated phases: X
      - Estimated agent-hours: Y

      ### Recommendation
      - PROCEED with this slice
      - DEFER (reason: [])
      - PIVOT to different slice (reason: [])
    agent: technical_director
    context: [validate_creature_prototype]
    human_input: true  # STRATEGIC checkpoint - owner decides next direction

  # -------------------------------------------------------------------------
  # NOTE: Meshy 3D Asset Generation
  # -------------------------------------------------------------------------
  # Meshy-related tasks are handled via custom tools from mesh-toolkit package.
  # Agents can use these tools directly:
  #   - text3d_generate: Generate 3D models from text
  #   - rig_model: Add skeleton to static model
  #   - apply_animation: Apply animation to rigged model
  #   - retexture_model: Apply new textures
  #   - list_animations: Browse animation catalog
  #   - check_task_status: Monitor generation progress
  #
  # See: packages/mesh-toolkit/.crewai/manifest.yaml
  # Usage: from crew_agents.tools import get_meshy_tools
  # -------------------------------------------------------------------------

  # -------------------------------------------------------------------------
  # OMEGA: Documentation & Context Recording
  # -------------------------------------------------------------------------
  omega_record_progress:
    description: |
      OMEGA TASK: Record all decisions, progress, and learnings into ConPort.

      Actions:
      1. Summarize all completed work
      2. Document architectural decisions made
      3. Record patterns discovered
      4. Update ConPort with current state
      5. Create handoff notes for next phase

      This runs AFTER every major phase completion.
    expected_output: |
      ## ConPort Update

      ### Work Completed
      - Phase 1: [summary]
      - Phase 2: [summary]
      - Phase 3: [summary]

      ### Architectural Decisions
      - Decision 1: [what, why, alternatives considered]
      - Decision 2: [what, why, alternatives considered]

      ### Patterns Discovered
      - Pattern 1: [description, when to use]
      - Pattern 2: [description, when to use]

      ### Current State
      - ECS schemas: [status]
      - Prototypes: [list with status]
      - Technical debt: [list]

      ### Handoff Notes for Next Phase
      - Prerequisites: [checklist]
      - Context to review: [files]
      - Open questions: [list]

      ### ConPort Updated
      - YES/NO with timestamp
    agent: technical_writer
    context: [assess_progress_and_plan_next]