import numpy as np
from markdown_it import MarkdownIt
import json

# Placeholder: Assume the CAIF_MODEL_CORE is available from model_core.py
# In a real setup, we would import the CAIF_MODEL_CORE object here.
# For now, we will assume it is an object with a .trained_model attribute.

# --- Internal Utility Functions for AILP (AI Language Processor) ---

def _convert_prediction_to_markdown(model, raw_input, target_type):
    """
    Acts as the AILP (AI Language Processor). It takes the model's raw 
    prediction (a number or category) and formats it into Markdown text.
    """
    
    # 1. Run the prediction
    # We use a placeholder prediction since we don't have the actual model object here.
    if hasattr(model, 'predict'):
        # The input needs to be prepared (e.g., scaled, turned into an array) before predicting
        # For simplicity, we create a dummy input array here.
        dummy_input = np.array([0]) # Placeholder!
        raw_prediction = model.predict(dummy_input)[0] 
    else:
        # If no model is trained, use a default result
        raw_prediction = "N/A - No trained model found"
        
    print(f"  [AILP] Raw Prediction: {raw_prediction}")

    # 2. Format the prediction into Markdown
    markdown_output = f"## CAIF Prediction Report\n\n"
    markdown_output += f"**Input:** _{raw_input}_\n\n"
    
    if target_type == 'regression':
        # If the model predicts a number (e.g., house price)
        markdown_output += f"The trained model, tagged **{CAIF_MODEL_CORE.model_type_tag}**, estimates the value to be: **${float(raw_prediction):,.2f}**\n\n"
        markdown_output += f"This is a high-confidence prediction based on complex data analysis."
    elif target_type == 'classification':
        # If the model predicts a category (e.g., dog, cat, spam)
        markdown_output += f"The trained model identifies the category as: **{raw_prediction}**\n\n"
        markdown_output += f"The AI used its internal NLP to determine the label for this result."
    else:
        # If the output is a general text (like a chatbot)
        markdown_output += f"**AI Response:** {raw_prediction}\n\n"

    return markdown_output

# --- Internal Utility Functions for MDP (Markdown Processor) ---

def _convert_markdown_to_html(markdown_text):
    """
    Uses the markdown-it library to convert rich Markdown text into clean HTML code.
    This fulfills the MDP requirement to generate HTML.
    """
    md = MarkdownIt()
    html_code = md.render(markdown_text)
    
    # Wrap the HTML in a basic page structure for easy viewing
    final_html = f"""<!DOCTYPE html>
<html>
<head>
    <title>CAIF Generated Report</title>
    <style>body {{font-family: Arial, sans-serif; max-width: 800px; margin: auto; padding: 20px;}}</style>
</head>
<body>
{html_code}
</body>
</html>"""
    
    return final_html

def _convert_markdown_to_python(markdown_text):
    """
    Fulfills the MDP requirement to generate executable Python code for rich text (e.g., using a library like Streamlit or Tkinter).
    We will generate code for a simple rich text printout.
    """
    # Escapes the markdown text to be placed inside a Python string
    escaped_markdown = json.dumps(markdown_text)
    
    python_code = f"""
# CAIF Generated Python Rich Text Output
# This file was generated by the CAIF (Code AI Fast) Framework.

# To display rich text accurately, you would typically need a library 
# like 'rich' or 'Streamlit'. We use simple print for portability.

# The generated Markdown is stored below:
CAIF_REPORT_MARKDOWN = {escaped_markdown}

def display_caif_report():
    print("--- CAIF RICH TEXT OUTPUT ---")
    print(CAIF_REPORT_MARKDOWN)
    print("-----------------------------")

if __name__ == "__main__":
    display_caif_report()
"""
    return python_code

# --- The Main Internal OutputProcessor Class ---

class _OutputProcessor:
    """
    Internal class managing prediction, AILP, and MDP for the CAIF framework.
    """
    def __init__(self):
        self.last_markdown_result = "" # Stores the last result for the OUTPUT command to use

    def generate_prediction(self, model_core_instance, raw_input):
        """
        Runs CAIF.PREDICT(). Calls the AILP to format the result.
        """
        print(f"  [OP] Preparing prediction for input: {raw_input}...")
        
        # Check if a model is trained
        if not model_core_instance.trained_model:
            print("  [OP] Warning: No trained model found. Returning placeholder text.")
            self.last_markdown_result = "# CAIF Error: Model Not Trained"
        else:
            # Call the AILP to get the formatted Markdown
            markdown_result = _convert_prediction_to_markdown(
                model_core_instance.trained_model,
                raw_input,
                model_core_instance.model_target_type
            )
            self.last_markdown_result = markdown_result

        return self.last_markdown_result

    def process_output(self, target: str, save_as: str):
        """
        Runs CAIF.OUTPUT(). Calls the MDP to convert the markdown result.
        """
        if not self.last_markdown_result:
            print("[OP] Error: No prediction results to process. Run CAIF.PREDICT() first.")
            return False

        target = target.upper()
        
        if target == 'HTML':
            final_content = _convert_markdown_to_html(self.last_markdown_result)
        elif target == 'PYTHON':
            final_content = _convert_markdown_to_python(self.last_markdown_result)
        else:
            print(f"[OP] Error: Unsupported output target '{target}'. Must be HTML or PYTHON.")
            return False
            
        try:
            with open(save_as, 'w') as f:
                f.write(final_content)
            print(f"  [OP] Successfully saved converted content to {save_as}")
            return True
        except Exception as e:
            print(f"[OP] Error saving file: {e}")
            return False

# We create a single instance of the Output Processor to manage the state
CAIF_OUTPUT_PROCESSOR = _OutputProcessor()
