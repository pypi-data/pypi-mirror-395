import{a as W}from"./chunk-U54GQJ26.js";import{a as F}from"./chunk-QBWQK3DT.js";import"./chunk-3MJ5AJB7.js";import{d as I}from"./chunk-STN7OMLL.js";import{b as R}from"./chunk-JFO4ENDF.js";import"./chunk-3W3OTHNE.js";import"./chunk-HB357Z3Y.js";import"./chunk-OI5V6APH.js";import"./chunk-S3FA7C5I.js";import"./chunk-FENW22PV.js";import"./chunk-K2P6CES6.js";import{b as z}from"./chunk-LNTKXTVM.js";import"./chunk-MFPRCIVI.js";import"./chunk-SVHROGNI.js";import{I as $,ka as E,ta as S}from"./chunk-DLJYFRIS.js";import{Oa as N,Qa as T,Sa as D,V as b,gb as d,hb as _,lb as L,mb as y,nb as B,u as Y,x as j,y as P}from"./chunk-MAT3H5WR.js";import{k as x}from"./chunk-KYPE3LET.js";var Z=j(16),w=class O extends E{#t;#i;#s;#e;constructor(r,t,a){super(r,t,a),this.#t=null,this.#i=[]}cleanup(){this.getPadPainter()?.cleanPrimitives(r=>r===this.#t||this.#i.indexOf(r)>=0),this.#t=null,this.#i=[],this.#s=void 0,super.cleanup()}buildStack(r,t){if(this.#s=null,!r.fHists)return!1;let a=r.fHists.arr.length;if(a<=0)return!1;let s=t?.findInPrimitives(void 0,b);if(s?.arr.length===a&&s?.name===r.fName)return this.#s=s,!0;s=L(b);let n=P(r.fHists.arr[0]);s.arr.push(n);for(let e=1;e<a;++e){let i=P(r.fHists.arr[e]),f=i.fXaxis,o=n.fXaxis,h=f.fNbins===o.fNbins&&f.fXmin===o.fXmin&&f.fXmax===o.fXmax;if(!h&&f.fNbins>0&&f.fNbins<o.fNbins&&f.fXmin===o.fXmin&&Math.abs((f.fXmax-f.fXmin)/f.fNbins-(o.fXmax-o.fXmin)/o.fNbins)<1e-4){let c=new Array(n.fNcells).fill(0);for(let m=1;m<=f.fNbins;++m)c[m]=i.fArray[m];i.fNcells=n.fNcells,Object.assign(f,o),i.fArray=c,h=!0}if(!h)return console.warn(`When drawing THStack, cannot sum-up histograms ${i.fName} and ${n.fName}`),!1;for(let c=0;c<i.fArray.length;++c)i.fArray[c]+=n.fArray[c];s.arr.push(i),n=i}return this.#s=s,!0}getMinMax(r){let t=this.getObject(),a=this.getOptions(),s=this.getPadPainter()?.getRootPad(!0),n=s?.fLogv??(a.ndim===1?s?.fLogy:s?.fLogz),e=0,i=0,f=(h,c)=>{let m={min:0,max:0},l=!0,M=!0;if(h.fMinimum!==d&&(m.min=h.fMinimum,l=!1),h.fMaximum!==d&&(m.max=h.fMaximum,M=!1),!l&&!M)return m;let A=1,v=h.fXaxis.fNbins,C=1,k=1,X=!0;h.fXaxis.TestBit(S.kAxisRange)&&(A=h.fXaxis.fFirst,v=h.fXaxis.fLast),h._typename.indexOf(T)===0&&(k=h.fYaxis.fNbins,h.fYaxis.TestBit(S.kAxisRange)&&(C=h.fYaxis.fFirst,k=h.fYaxis.fLast));let u=0;for(let g=C;g<=k;++g)for(let H=A;H<=v;++H){let p=h.getBinContent(H,g);c&&(u=h.getBinError(h.getBin(H,g))),!(n&&p-u<=0)&&(l&&(X||p-u<m.min)&&(m.min=p-u),M&&(X||p+u>m.max)&&(m.max=p+u),X=!1)}return m};if(a.nostack)for(let h=0;h<t.fHists.arr.length;++h){let c=f(t.fHists.arr[h],r);h===0?(e=c.min,i=c.max):(e=Math.min(e,c.min),i=Math.max(i,c.max))}else e=f(this.#s.arr.at(0),r).min,i=f(this.#s.arr.at(-1),r).max;n?e=e>0?e*.9:i*.001:e>0&&(e=0),t.fMaximum!==d&&(i=t.fMaximum),t.fMinimum!==d&&(e=t.fMinimum),(!a.nostack||t.fMaximum===d)&&(n?e>0&&(i*=1+.2*Math.log10(i/e)):t.fMaximum===d&&(i*=1+Y.fHistTopMargin)),(!a.nostack||t.fMinimum===d)&&n&&(e=e>0?e/(1+.5*Math.log10(i/e)):.001*i);let o={min:e,max:i,hopt:`;hmin:${e};hmax:${i}`};return t.fHistogram?.TestBit(Z)&&(o.hopt+=";zoom_min_max"),o}getHistDrawOption(r,t){let a=this.getOptions(),s=t||r.fOption||a.hopt;if(s.toUpperCase().indexOf(a.hopt)<0&&(s+=" "+a.hopt),a.draw_errors&&!s&&(s="E"),a.zscale){let n=s.toUpperCase().indexOf("COLZ");n>=0&&(s=s.slice(0,n+3)+s.slice(n+4))}return a.pads||(s+=" same nostat"+a.auto),s}drawNextHisto(r,t){return x(this,null,function*(){let a=this.getObject(),s=this.getOptions(),n=s.nostack?a.fHists:this.#s,e=n?.arr?.length||0;if(r>=e)return this;let i=s.horder?r:e-r-1,f=s.nostack?`hists_${i}`:`stack_${i}`,o=n.arr[i],h=this.getHistDrawOption(o,a.fHists.opt[i]);if(t){let m=t.getSubPadPainter(r+1);return m?(m.cleanPrimitives(!0),this.drawHist(m,o,h).then(l=>(l&&(l.setSecondaryId(this,f),this.#i.push(l)),this.drawNextHisto(r+1,t)))):this}i>0&&!s.nostack&&(o.$baseh=n.arr[i-1]),s.auto&&(o.$num_histos=e);let c=this.#t?.getPadPainter()||this.getDrawDom();return this.drawHist(c,o,h).then(m=>(m.setSecondaryId(this,f),this.#i.push(m),this.drawNextHisto(r+1,t)))})}decodeOptions(r){let t=this.setOptions({ndim:1,nostack:!1,same:!1,horder:!0,has_errors:!1,draw_errors:!1,hopt:"",auto:""}),a=this.getObject();(a.fHistogram||a.fHists?.arr[0]||this.#s?.arr[0])?._typename.indexOf(T)===0&&(t.ndim=2),t.ndim===2&&!r&&(r="lego1"),t.nostack||a.fHists?.arr.forEach(i=>{let f=i.fSumw2?.length??0;for(let o=0;o<f;++o)if(i.fSumw2[o]>0){t.has_errors=!0;break}}),t.nhist=a.fHists?.arr?.length??1;let n=new $(r);t.nostack=n.check("NOSTACK"),n.check("STACK")&&(t.nostack=!1),t.same=n.check("SAME"),n.check("NOCLEAR"),["PFC","PLC","PMC"].forEach(i=>{n.check(i)&&(t.auto+=" "+i)}),t.pads=n.check("PADS"),t.pads&&(t.nostack=!0),t.hopt=n.remain().trim();let e=n.check("LEGO");t.errors=n.check("E"),t.zscale=n.check("COLZ"),!t.nostack&&t.has_errors&&!e&&!n.check("HIST")&&t.hopt.indexOf("E")<0&&(t.draw_errors=!0),t.horder=t.nostack||e}createHistogram(r){let t=this.getOptions(),a=r.fHists,s=a?.arr.length??0;if(!s){let i=y(N,100);return B(i,r.fTitle),i.fBits|=_,i}let n=a.arr[0],e=y(t.ndim===1?N:D,n.fXaxis.fNbins,n.fYaxis.fNbins);e.fName="axis_hist",e.fBits|=_,Object.assign(e.fXaxis,n.fXaxis),t.ndim===2&&Object.assign(e.fYaxis,n.fYaxis);for(let i=1;i<s;++i){let f=a.arr[i];e.fXaxis.fLabels||(e.fXaxis.fXmin=Math.min(e.fXaxis.fXmin,f.fXaxis.fXmin),e.fXaxis.fXmax=Math.max(e.fXaxis.fXmax,f.fXaxis.fXmax)),t.ndim===2&&!e.fYaxis.fLabels&&(e.fYaxis.fXmin=Math.min(e.fYaxis.fXmin,f.fYaxis.fXmin),e.fYaxis.fXmax=Math.max(e.fYaxis.fXmax,f.fYaxis.fXmax))}return e.fTitle=r.fTitle,e}updateObject(r){if(!this.matchObjectType(r))return!1;let t=this.getObject(),a=this.getPadPainter(),s=this.getOptions();if(t.fHists=r.fHists,t.fTitle=r.fTitle,t.fMinimum=r.fMinimum,t.fMaximum=r.fMaximum,s.nostack||(s.nostack=!this.buildStack(t,a)),this.#t){let i=r.fHistogram;i||(i=t.fHistogram=this.createHistogram(t));let f=this.getMinMax(s.errors||s.draw_errors);this.#t.options.hmin=f.min,this.#t.options.hmax=f.max,this.#t._checked_zooming=!1,s.ndim===1?(this.#t.ymin=f.min,this.#t.ymax=f.max):(this.#t.zmin=f.min,this.#t.zmax=f.max),this.#t.updateObject(i),this.#t.options.zoom_min_max=i.TestBit(Z)}let n=s.nostack?t.fHists:this.#s,e=n?.arr?.length??0;if(e!==this.#i.length)this.#e=1,a?.cleanPrimitives(i=>this.#i.indexOf(i)>=0),this.#i=[];else{this.#e=2;for(let i=0;i<e;++i){let f=s.horder?i:e-i-1,o=n.arr[f];this.#i[i].updateObject(o,this.getHistDrawOption(o,t.fHists.opt[f]))}}return!0}redraw(r){if(!this.#e)return;let t=this.#e===1;this.#e=void 0;let a=Promise.resolve(this),s=this.getOptions();if(this.#t){let n=this.getMinMax(s.errors||s.draw_errors);this.#t.decodeOptions(s.hopt+n.hopt),a=this.#t.redraw(r)}return a.then(()=>{if(t)return this.drawNextHisto(0,s.pads?this.getPadPainter():null);let n=e=>e>=this.#i.length?this:this.#i[e].redraw(r).then(()=>n(e+1));return n(0)})}fillContextMenuItems(r){let t=this.getOptions();r.addRedrawMenu(this),t.pads||r.addchk(t.draw_errors,"Draw errors",a=>{t.draw_errors=a;let s=this.getObject(),n=t.nostack?s.fHists:this.#s,e=n?.arr?.length??0;for(let i=0;i<e;++i){let f=t.horder?i:e-i-1,o=n.arr[f];this.#i[i].decodeOptions(this.getHistDrawOption(o,s.fHists.opt[f]))}this.redrawPad()},"Change draw erros in the stack")}drawHist(r,t,a){return(this.getOptions().ndim===1?R.draw:I.draw)(r,t,a)}accessMM(r,t){let a=r?"fMinimum":"fMaximum",s=this.getObject();if(t===void 0)return s[a];this.#e=2,s[a]=t,this.interactiveRedraw("pad",r?`exec:SetMinimum(${t})`:`exec:SetMaximum(${t})`)}redrawWith(r,t){return x(this,null,function*(){let a=this.getPadPainter(),s=this.getOptions();!t&&a&&(this.#t=null,this.#i=[],s.pads&&a.divide(0,0),a.removePrimitive(this,!0)),this.decodeOptions(r);let n=this.getObject(),e=Promise.resolve(this),i=null;if(s.pads)e=z(this,!1).then(()=>(i=this.getPadPainter(),i.divide(s.nhist,0,!0)));else if(s.nostack||(s.nostack=!this.buildStack(n,a)),!s.same&&n.fHists?.arr.length){n.fHistogram||(n.fHistogram=this.createHistogram(n));let f=this.getMinMax(s.errors||s.draw_errors);e=this.drawHist(this.getDrawDom(),n.fHistogram,s.hopt+f.hopt).then(o=>{this.#t=o,o.$stack_hist=!0,o.setSecondaryId(this,"hist")})}return e.then(()=>this.drawNextHisto(0,i)).then(()=>(s.pads||this.addToPadPrimitives(),this))})}static draw(r,t,a){return x(this,null,function*(){return!t.fHists||!t.fHists.arr?null:new O(r,t,a).redrawWith(a,!0)})}};var K=class O extends w{drawHist(r,t,a){return(this.getOptions().ndim===1?F.draw:W.draw)(r,t,a)}static draw(r,t,a){return x(this,null,function*(){return!t.fHists||!t.fHists.arr?null:new O(r,t,a).redrawWith(a,!0)})}};export{K as THStackPainter};
