---
title: Type Safety Guidelines
description: MyPy configuration, type annotations, and type checking best practices
alwaysApply: true
---

# Type Safety Guidelines

## MyPy Configuration

Enable strict type checking with:

```toml
[tool.mypy]
python_version = "3.12"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_any_unimported = true
disallow_any_explicit = false  # Allow explicit Any with justification
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true
```

## Type Annotations

### Function Signatures

All functions must have complete type annotations:

```python
def process_changes(changes: List[Change]) -> List[Conflict]:
    """Process changes and return conflicts."""
    pass

def apply_resolution(resolution: Resolution) -> bool:
    """Apply a resolution and return success status."""
    pass
```

### Class Attributes

Use type annotations for class attributes:

```python
class ConflictResolver:
    config: Dict[str, Any]
    handlers: Dict[FileType, BaseHandler]
    strategy: ResolutionStrategy

    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        self.config = config or {}
```

### Generic Types

Use proper generic types for collections:

```python
from typing import List, Dict, Optional, Union, Tuple, Set

# Good
def get_conflicts(changes: List[Change]) -> List[Conflict]:
    pass

def process_files(files: Dict[str, str]) -> Dict[str, bool]:
    pass

# Avoid
def get_conflicts(changes):  # No type hints
    pass
```

## Type Aliases

Create type aliases for complex types:

```python
from typing import TypeAlias

# Type aliases for better readability
ChangeList: TypeAlias = List[Change]
ConflictMap: TypeAlias = Dict[str, List[Conflict]]
ResolutionResult: TypeAlias = Tuple[int, int, float]
```

## Optional Types

Use `Optional` or union syntax for nullable values:

```python
from typing import Optional

def find_handler(file_path: str) -> Optional[BaseHandler]:
    """Find handler for file type, return None if not found."""
    pass

# Or using union syntax (Python 3.10+)
def find_handler(file_path: str) -> BaseHandler | None:
    """Find handler for file type, return None if not found."""
    pass
```

## Protocol Types

Use protocols for structural typing:

```python
from typing import Protocol

class FileHandler(Protocol):
    def can_handle(self, file_path: str) -> bool: ...
    def apply_change(self, path: str, content: str, start_line: int, end_line: int) -> bool: ...

def process_with_handler(handler: FileHandler, file_path: str) -> bool:
    """Process file with any handler implementing FileHandler protocol."""
    pass
```

## Dataclass Types

Use proper typing in dataclasses:

```python
from dataclasses import dataclass
from typing import List, Dict, Any, Tuple

@dataclass
class Change:
    path: str
    start_line: int
    end_line: int
    content: str
    metadata: Dict[str, Any]
    fingerprint: str
    file_type: FileType

@dataclass
class Conflict:
    file_path: str
    line_range: Tuple[int, int]
    changes: List[Change]
    conflict_type: str
    severity: str
    overlap_percentage: float
```

## Enum Types

Use enums for type-safe constants:

```python
from enum import Enum

class FileType(Enum):
    PYTHON = "python"
    TYPESCRIPT = "typescript"
    JSON = "json"
    YAML = "yaml"
    TOML = "toml"
    PLAINTEXT = "plaintext"

class ConflictSeverity(Enum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"
```

## Type Guards

Use type guards for runtime type checking:

```python
from typing import TypeGuard

def is_json_file(file_path: str) -> TypeGuard[str]:
    """Type guard to check if file is JSON."""
    return file_path.endswith('.json')

def process_file(file_path: str) -> None:
    if is_json_file(file_path):
        # MyPy knows file_path is JSON here
        json_handler.process(file_path)
```

## Any Type Usage

Avoid `Any` type unless absolutely necessary:

```python
# Bad - too permissive
def process_data(data: Any) -> Any:
    pass

# Good - specific types
def process_data(data: Dict[str, Union[str, int]]) -> List[str]:
    pass

# When Any is necessary, document why
def handle_unknown_format(data: Any) -> bool:  # Any needed for dynamic content
    """Handle data of unknown format from external API."""
    pass
```

## Type Checking in Tests

Use type checking in test files:

```python
from typing import List
import pytest

def test_conflict_detection(changes: List[Change]) -> None:
    """Test conflict detection with typed parameters."""
    conflicts = detector.detect_conflicts(changes)
    assert isinstance(conflicts, List)
    for conflict in conflicts:
        assert isinstance(conflict, Conflict)
```

## Type Stubs

Add type stubs for external dependencies:

```python
# requirements-dev.txt
types-requests
types-click
types-PyYAML
```

## Runtime Type Checking

Use runtime type checking for external data:

```python
from typing import get_type_hints, get_origin, get_args

def validate_data(data: Dict[str, Any], expected_types: Dict[str, type]) -> bool:
    """Validate data structure matches expected types."""
    for key, expected_type in expected_types.items():
        if key not in data:
            return False
        if not isinstance(data[key], expected_type):
            return False
    return True
```

## Type-Safe Configuration

Use typed configuration classes:

```python
from dataclasses import dataclass
from typing import Dict, Optional

@dataclass
class ResolverConfig:
    mode: str
    skip_all_conflicts: bool
    manual_review_required: bool
    semantic_merging: bool
    priority_system: bool
    priority_rules: Optional[Dict[str, int]] = None
```

## Error Handling Types

Use specific exception types:

```python
class ConflictResolutionError(Exception):
    """Base exception for conflict resolution errors."""
    pass

class FileHandlerError(ConflictResolutionError):
    """Error in file handler operations."""
    pass

class ValidationError(ConflictResolutionError):
    """Error in data validation."""
    pass
```

## Type Checking Commands

Run type checking during development:

```bash
# Check all source files
mypy src/

# Check with strict mode
mypy --strict src/

# Check specific module
mypy src/review_bot_automator/core/resolver.py
```

## Integration with CI

Ensure type checking passes in CI:

```yaml
- name: Type Check
  run: mypy src/ --strict
```

## Type Safety Enforcement (MANDATORY)

### Never Bypass Type Checking

❌ **FORBIDDEN** - Never bypass type checking:

```bash
git commit --no-verify  # NEVER DO THIS
mypy --ignore-errors    # NEVER DO THIS
mypy --no-error-summary # Avoid unless debugging
```

✅ **CORRECT** - Fix type errors properly:

```bash
# Check types
source .venv/bin/activate && mypy src/ --strict

# Fix any type errors found
# Re-check until clean
source .venv/bin/activate && mypy src/ --strict

# Then commit
git commit -m "fix: resolve type errors"
```

### Strict Type Checking (REQUIRED)

This project uses **strict MyPy configuration**:

- No `Any` types allowed (unless explicitly justified)
- All functions must have complete type annotations
- No untyped definitions allowed
- No implicit optional types
- No unreachable code allowed

### Pre-commit Integration

Type checking is enforced via pre-commit hooks:

- **MyPy** runs on every commit with `--strict` mode
- **Additional dependencies** include type stubs for external libraries
- **Language version** is pinned to Python 3.12

### Mandatory Type Standards

These type safety rules are **NON-NEGOTIABLE**:

1. All function signatures must have complete type hints
2. All class attributes must be typed
3. No `Any` types without explicit justification
4. No untyped function definitions
5. All imports must be properly typed
6. No implicit optional types

### Fix Type Errors Before Commit

Type errors **MUST** be fixed before committing:

```bash
# Check types
source .venv/bin/activate && mypy src/ --strict

# Fix any type errors
# Re-check until clean
source .venv/bin/activate && mypy src/ --strict

# Only then commit
git commit -m "fix: resolve type errors"
```

## LLM-Specific Type Patterns

### LLM Provider Protocol Typing

Use Protocol for LLM provider typing:

```python
from typing import Protocol

class LLMProvider(Protocol):
    """Protocol for LLM providers."""
    def generate(self, prompt: str, max_tokens: int = 2000) -> str:
        """Generate text completion."""
        ...

    def count_tokens(self, text: str) -> int:
        """Count tokens in text."""
        ...

    def get_total_cost(self) -> float:
        """Get total cost in USD."""
        ...

def use_provider(provider: LLMProvider) -> str:
    """Function accepting any LLMProvider implementation."""
    return provider.generate("test")
```

### Configuration Dataclass Patterns

Use typed dataclasses for LLM configuration:

```python
@dataclass(frozen=True, slots=True)
class LLMConfig:
    """Type-safe LLM configuration."""
    enabled: bool
    provider: str
    model: str
    api_key: str | None
    fallback_to_regex: bool
    cache_enabled: bool
    max_tokens: int
    cost_budget: float | None
```

### Response Type Validation

Validate LLM response types:

```python
from typing import TypeGuard

def is_valid_parsed_change(obj: Any) -> TypeGuard[ParsedChange]:
    """Type guard for ParsedChange validation."""
    return (
        isinstance(obj, dict)
        and "file_path" in obj
        and "start_line" in obj
        and "end_line" in obj
        and isinstance(obj["file_path"], str)
        and isinstance(obj["start_line"], int)
        and isinstance(obj["end_line"], int)
    )

def parse_response(response: str) -> list[ParsedChange]:
    """Parse LLM response with type validation."""
    data = json.loads(response)
    changes = data.get("changes", [])

    validated_changes = [
        ParsedChange(**change) for change in changes
        if is_valid_parsed_change(change)
    ]

    return validated_changes
```

### Generic Types for Providers

Use generics for provider-specific types:

```python
from typing import TypeVar, Generic

T = TypeVar("T", bound=LLMProvider)

class LLMParser(Generic[T]):
    """Parser using a specific provider type."""
    def __init__(self, provider: T):
        self.provider = provider

    def parse(self, comment: str) -> list[ParsedChange]:
        """Parse using typed provider."""
        response = self.provider.generate(comment)
        return self._parse_response(response)
```

## Related Rules

- See `.cursor/rules/llm-integration.mdc` for LLM provider implementation
- See `.cursor/rules/python-style.mdc` for general type hints
