"""Property-based fuzzing tests for InputValidator.

This module uses Hypothesis to perform property-based testing on the InputValidator
class, focusing on finding edge cases and potential security vulnerabilities through
automated fuzzing.

Test Coverage:
- Path validation (traversal, symlinks, Unicode normalization)
- File extension validation (bypasses, null bytes, double extensions)
- Content sanitization (null bytes, control characters)
- URL validation (spoofing, encoding bypasses)
- Token validation (format bypasses, special characters)
"""

import pytest
from hypothesis import HealthCheck, assume, given, settings
from hypothesis import strategies as st

from review_bot_automator.security.input_validator import InputValidator

# =============================================================================
# Hypothesis Strategies
# =============================================================================


@st.composite
def path_strings(draw: st.DrawFn) -> str:
    """Generate path-like strings for fuzzing path validation.

    Generates various path patterns including:
    - Simple paths
    - Paths with traversal attempts
    - Paths with Unicode characters
    - Paths with null bytes
    - Absolute vs relative paths

    Args:
        draw: Hypothesis draw function

    Returns:
        A path-like string
    """
    # Choose path type
    path_type = draw(st.sampled_from(["simple", "traversal", "unicode", "mixed"]))

    if path_type == "simple":
        # Simple relative path
        parts = draw(
            st.lists(
                st.text(alphabet=st.characters(exclude_categories=["Cs"]), min_size=1, max_size=20),
                min_size=1,
                max_size=5,
            )
        )
        return "/".join(parts)
    elif path_type == "traversal":
        # Path with traversal attempts
        parts = draw(
            st.lists(st.sampled_from([".", "..", "...", "a", "b"]), min_size=1, max_size=10)
        )
        return "/".join(parts)
    elif path_type == "unicode":
        # Path with Unicode characters
        return draw(st.text(min_size=1, max_size=50))
    else:
        # Mixed: combine regular parts with special characters
        parts = draw(st.lists(st.text(max_size=20), min_size=1, max_size=5))
        return draw(st.sampled_from(["/", ""])) + "/".join(parts)


@st.composite
def extension_strings(draw: st.DrawFn) -> str:
    """Generate file extension strings for fuzzing.

    Generates:
    - Normal extensions (.txt, .py, etc.)
    - Double extensions (.tar.gz)
    - Extensions with null bytes
    - Extensions with special characters

    Args:
        draw: Hypothesis draw function

    Returns:
        An extension-like string
    """
    ext_type = draw(st.sampled_from(["normal", "double", "special"]))

    if ext_type == "normal":
        return draw(st.sampled_from([".txt", ".py", ".json", ".yaml", ".toml", ".md"]))
    elif ext_type == "double":
        ext1 = draw(st.sampled_from(["tar", "backup", "old"]))
        ext2 = draw(st.sampled_from(["gz", "zip", "txt", "py"]))
        return f".{ext1}.{ext2}"
    else:
        # Special characters
        return "." + draw(
            st.text(
                alphabet=st.characters(exclude_categories=("Cc", "Cs")), min_size=1, max_size=10
            )
        )


# =============================================================================
# Path Validation Fuzzing
# =============================================================================


@pytest.mark.fuzz
@given(path=st.text())
def test_fuzz_validate_file_path_never_crashes(path: str) -> None:
    """Fuzz validate_file_path() with arbitrary text - should never crash.

    Property: The validator should always return a boolean value without raising
    exceptions, regardless of input.

    Args:
        path: Arbitrary string to test as a file path
    """
    result = InputValidator.validate_file_path(path)
    assert isinstance(result, bool), "validate_file_path must return bool"


@pytest.mark.fuzz
@given(path=path_strings())
def test_fuzz_validate_file_path_with_path_like_strings(path: str) -> None:
    """Fuzz validate_file_path() with path-like strings.

    Property: Path validation should be consistent and never crash when given
    strings that look like paths.

    Args:
        path: Path-like string generated by path_strings() strategy
    """
    validator = InputValidator()
    result = validator.validate_file_path(path)
    assert isinstance(result, bool)


@pytest.mark.fuzz
@given(parts=st.lists(st.sampled_from([".", "..", "a", "b", "c"]), min_size=1, max_size=10))
@settings(suppress_health_check=[HealthCheck.filter_too_much])
def test_fuzz_path_traversal_detection(parts: list[str]) -> None:
    """Fuzz path traversal detection.

    Property: Paths containing ".." should be detected as traversal attempts.

    Args:
        parts: List of path parts to construct a path
    """
    path = "/".join(parts)
    validator = InputValidator()
    # Should detect and reject traversal attempts
    result = validator.validate_file_path(path)
    # We expect traversal attempts to be rejected, but the key property is no crash
    assert isinstance(result, bool)

    # If path contains "..", it should be rejected
    if ".." in parts:
        assert result is False, "Paths with '..' must be rejected"


# =============================================================================
# Extension Validation Fuzzing
# =============================================================================


@pytest.mark.fuzz
@given(extension=st.text())
def test_fuzz_validate_file_extension_never_crashes(extension: str) -> None:
    """Fuzz validate_file_extension() with arbitrary text.

    Property: Extension validation should handle any string without crashing.

    Args:
        extension: Arbitrary string to test as file extension
    """
    result = InputValidator.validate_file_extension(extension)
    assert isinstance(result, bool)


@pytest.mark.fuzz
@given(extension=extension_strings())
def test_fuzz_validate_file_extension_with_extension_like_strings(extension: str) -> None:
    """Fuzz extension validation with extension-like patterns.

    Property: Extension validation should handle various extension formats
    consistently without crashing.

    Args:
        extension: Extension-like string from extension_strings() strategy
    """
    validator = InputValidator()
    result = validator.validate_file_extension(extension)
    assert isinstance(result, bool)


# =============================================================================
# Content Sanitization Fuzzing
# =============================================================================


@pytest.mark.fuzz
@given(content=st.text(), file_type=st.sampled_from(["json", "yaml", "toml", "python", "text"]))
def test_fuzz_sanitize_content_never_crashes(content: str, file_type: str) -> None:
    """Fuzz sanitize_content() with arbitrary text.

    Property: Content sanitization should handle any string without crashing
    and always return a tuple of (string, list).

    Args:
        content: Arbitrary content to sanitize
        file_type: Type of file being sanitized
    """
    result = InputValidator.sanitize_content(content, file_type)
    assert isinstance(result, tuple)
    assert len(result) == 2
    sanitized, warnings = result
    assert isinstance(sanitized, str)
    assert isinstance(warnings, list)


@pytest.mark.fuzz
@given(
    content=st.text(alphabet=st.characters(categories=["Cc"])),
    file_type=st.sampled_from(["json", "yaml", "toml"]),
)
def test_fuzz_sanitize_content_with_control_characters(content: str, file_type: str) -> None:
    """Fuzz content sanitization with control characters.

    Property: Sanitization should remove or handle control characters safely.

    Args:
        content: String containing control characters
        file_type: Type of file being sanitized
    """
    result = InputValidator.sanitize_content(content, file_type)
    assert isinstance(result, tuple)
    sanitized, _warnings = result
    assert isinstance(sanitized, str)
    # After sanitization, null bytes should be removed
    assert "\x00" not in sanitized, "Null bytes should be removed"


# =============================================================================
# URL Validation Fuzzing
# =============================================================================


@pytest.mark.fuzz
@given(url=st.text())
def test_fuzz_validate_github_url_never_crashes(url: str) -> None:
    """Fuzz validate_github_url() with arbitrary text.

    Property: URL validation should handle any string without crashing.

    Args:
        url: Arbitrary string to test as URL
    """
    result = InputValidator.validate_github_url(url)
    assert isinstance(result, bool)


@pytest.mark.fuzz
@given(
    scheme=st.sampled_from(["http://", "https://", "ftp://", ""]),
    subdomain=st.text(alphabet=st.characters(categories=("Lu", "Ll", "Nd")), max_size=20),
    domain=st.sampled_from(["github.com", "githob.com", "githua.com", "example.com"]),
    path=st.text(max_size=50),
)
def test_fuzz_validate_github_url_with_url_like_strings(
    scheme: str, subdomain: str, domain: str, path: str
) -> None:
    """Fuzz GitHub URL validation with URL-like patterns.

    Property: Should only accept URLs from github.com domain.

    Args:
        scheme: URL scheme
        subdomain: Subdomain part
        domain: Domain part
        path: URL path
    """
    # Filter out empty subdomains to avoid invalid URLs
    assume(subdomain or not scheme)

    url = f"{scheme}{subdomain}.{domain}/{path}" if subdomain else f"{scheme}{domain}/{path}"

    validator = InputValidator()
    result = validator.validate_github_url(url)
    assert isinstance(result, bool)

    # If domain is github.com and has proper scheme, might be valid
    # Otherwise should be rejected (but key property is no crash)


# =============================================================================
# Token Validation Fuzzing
# =============================================================================


@pytest.mark.fuzz
@given(token=st.text())
def test_fuzz_validate_github_token_never_crashes(token: str) -> None:
    """Fuzz validate_github_token() with arbitrary text.

    Property: Token validation should handle any string without crashing.

    Args:
        token: Arbitrary string to test as token
    """
    result = InputValidator.validate_github_token(token)
    assert isinstance(result, bool)


@pytest.mark.fuzz
@given(
    prefix=st.sampled_from(["ghp_", "gho_", "ghu_", "ghs_", "ghr_", "github_pat_", "xxx_"]),
    suffix=st.text(
        alphabet=st.characters(categories=("Lu", "Ll", "Nd")), min_size=10, max_size=100
    ),
)
def test_fuzz_validate_github_token_with_token_like_strings(prefix: str, suffix: str) -> None:
    """Fuzz GitHub token validation with token-like patterns.

    Property: Should validate token format consistently.

    Args:
        prefix: Token prefix (valid or invalid GitHub prefixes)
        suffix: Token suffix
    """
    token = prefix + suffix
    validator = InputValidator()
    result = validator.validate_github_token(token)
    assert isinstance(result, bool)


# Note: validate_file_size() requires actual file paths, so we skip fuzzing it
# directly. It's tested through integration tests with actual files.
