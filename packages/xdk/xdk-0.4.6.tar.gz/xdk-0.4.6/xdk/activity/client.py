# AUTO-GENERATED FILE - DO NOT EDIT
# This file was automatically generated by the XDK build tool.
# Any manual changes will be overwritten on the next generation.

"""
Auto-generated activity client for the X API.

This module provides a client for interacting with the activity endpoints of the X API.
Real-time streaming operations return generators that yield data as it arrives.
Streaming connections are automatically managed with exponential backoff retry logic for robust handling.
All methods, parameters, and response models are generated from the OpenAPI specification.

Generated automatically - do not edit manually.
"""

from __future__ import annotations
from typing import (
    Dict,
    List,
    Optional,
    Any,
    Union,
    cast,
    TYPE_CHECKING,
    Iterator,
    Generator,
)
import requests
import time

from ..streaming import StreamConfig, StreamError, stream_with_retry


if TYPE_CHECKING:
    from ..client import Client
from .models import (
    GetSubscriptionsResponse,
    CreateSubscriptionRequest,
    CreateSubscriptionResponse,
    StreamResponse,
    UpdateSubscriptionRequest,
    UpdateSubscriptionResponse,
    DeleteSubscriptionResponse,
)


class ActivityClient:
    """Streaming Client for activity operations"""


    def __init__(self, client: Client):
        self.client = client


    def get_subscriptions(
        self,
    ) -> GetSubscriptionsResponse:
        """
        Get X activity subscriptions
        Get a list of active subscriptions for XAA
        Returns:
            GetSubscriptionsResponse: Response data
        """
        url = self.client.base_url + "/2/activity/subscriptions"
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Make the request
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetSubscriptionsResponse.model_validate(response_data)


    def create_subscription(
        self, body: Optional[CreateSubscriptionRequest] = None
    ) -> CreateSubscriptionResponse:
        """
        Create X activity subscription
        Creates a subscription for an X activity event
        body: Request body
        Returns:
            CreateSubscriptionResponse: Response data
        """
        url = self.client.base_url + "/2/activity/subscriptions"
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Make the request
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return CreateSubscriptionResponse.model_validate(response_data)


    def stream(
        self,
        backfill_minutes: int = None,
        start_time: str = None,
        end_time: str = None,
        stream_config: Optional[StreamConfig] = None,
    ) -> Generator[StreamResponse, None, None]:
        """
        Activity Stream (Streaming)
        Stream of X Activities
        This is a streaming endpoint that yields data in real-time as it becomes available.
        Each yielded item represents a single data point from the stream.
        The connection is automatically managed with exponential backoff retry logic.
        If the stream disconnects, the SDK will automatically reconnect without client intervention.
        Args:
            backfill_minutes: The number of minutes of backfill requested.
            start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Post labels will be provided.
            end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp from which the Post labels will be provided.
            stream_config: Optional StreamConfig for customizing retry behavior, timeouts, and callbacks.
                Configure max_retries (-1 for infinite), initial_backoff, max_backoff, and lifecycle callbacks
                (on_connect, on_disconnect, on_reconnect, on_error) for monitoring connection state.
        Yields:
            StreamResponse: Individual streaming data items
        Raises:
            StreamError: If a non-retryable error occurs (auth errors, client errors) or max retries exceeded.
        """
        url = self.client.base_url + "/2/activity/stream"
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        params = {}
        if backfill_minutes is not None:
            params["backfill_minutes"] = backfill_minutes
        if start_time is not None:
            params["start_time"] = start_time
        if end_time is not None:
            params["end_time"] = end_time
        headers = {
            "Accept": "application/json",
        }
        # Prepare request data
        json_data = None
        # Ensure params is defined (build_query_params should set it, but initialize if not)
        try:
            _ = params  # Check if params exists
        except NameError:
            params = {}  # Initialize if not defined
        # Use robust streaming with automatic retry and exponential backoff
        yield from stream_with_retry(
            session=self.client.session,
            method="get",
            url=url,
            config=stream_config,
            params=params,
            headers=headers,
            response_model=StreamResponse,
        )


    def update_subscription(
        self, subscription_id: Any, body: Optional[UpdateSubscriptionRequest] = None
    ) -> UpdateSubscriptionResponse:
        """
        Update X activity subscription
        Updates a subscription for an X activity event
        Args:
            subscription_id: The ID of the subscription to update.
            body: Request body
        Returns:
            UpdateSubscriptionResponse: Response data
        """
        url = self.client.base_url + "/2/activity/subscriptions/{subscription_id}"
        url = url.replace("{subscription_id}", str(subscription_id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Make the request
        response = self.client.session.put(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UpdateSubscriptionResponse.model_validate(response_data)


    def delete_subscription(self, subscription_id: Any) -> DeleteSubscriptionResponse:
        """
        Deletes X activity subscription
        Deletes a subscription for an X activity event
        Args:
            subscription_id: The ID of the subscription to delete.
            Returns:
            DeleteSubscriptionResponse: Response data
        """
        url = self.client.base_url + "/2/activity/subscriptions/{subscription_id}"
        url = url.replace("{subscription_id}", str(subscription_id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Make the request
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return DeleteSubscriptionResponse.model_validate(response_data)
