<!DOCTYPE html>
<!-- Generated by claude-code-log v{{ library_version }} -->
<html lang='en'>

<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>{{ title }}</title>
    {% from 'components/session_nav.html' import render_session_nav %}
    <style>
{% include 'components/global_styles.css' %}
{% include 'components/message_styles.css' %}
{% include 'components/session_nav_styles.css' %}
{% include 'components/filter_styles.css' %}
{% include 'components/todo_styles.css' %}
{% include 'components/timeline_styles.css' %}
{% include 'components/search_styles.css' %}
{% include 'components/edit_diff_styles.css' %}
{% include 'components/pygments_styles.css' %}
    </style>
</head>

<body>
    <h1 id="title">{{ title }}</h1>

    <!-- Timeline Component -->
    {% include 'components/timeline.html' %}

    <!-- Combined Search & Filter Toolbar -->
    <div class="filter-toolbar">
        <div class="toolbar-header">
            <h3>ğŸ” Search & Filter</h3>
            <button class="close-toolbar-btn" id="closeToolbar" title="Close">âœ•</button>
        </div>

        <!-- Inline Search -->
        {% include 'components/search_inline.html' %}

        <!-- Filter Section -->
        <div class="filter-section">
            <div class="filter-toggles">
                <button class="filter-toggle active" data-type="user">ğŸ¤· User <span class="count">(0)</span></button>
                <button class="filter-toggle active" data-type="system">âš™ï¸ System <span class="count">(0)</span></button>
                <button class="filter-toggle active" data-type="assistant">ğŸ¤– Assistant <span
                        class="count">(0)</span></button>
                <button class="filter-toggle active" data-type="thinking">ğŸ’­ Thinking <span
                        class="count">(0)</span></button>
                <button class="filter-toggle active" data-type="tool">ğŸ› ï¸ Tool <span
                        class="count">(0)</span></button>
                <button class="filter-toggle active" data-type="sidechain">ğŸ”— Sub-assistant <span
                        class="count">(0)</span></button>
                <button class="filter-toggle active" data-type="image">ğŸ–¼ï¸ Images <span class="count">(0)</span></button>
            </div>
            <div class="filter-actions">
                <button class="filter-action-btn" id="selectAll">All</button>
                <button class="filter-action-btn" id="selectNone">None</button>
            </div>
        </div>
    </div>


    {% if combined_transcript_link %}
    <div class="navigation">
        <a href="{{ combined_transcript_link }}" class="combined-transcript-link">
            â† View All Sessions (Combined Transcript)
        </a>
    </div>
    {% elif sessions and sessions|length > 1 %}
    {{ render_session_nav(sessions, "toc") }}
    {% endif %}

    {% for message in messages %}
    {% if message.is_session_header %}
    <div class="session-divider"></div>
    <div class='message session-header' data-message-id='{{ message.message_id }}' id='msg-{{ message.message_id }}'>
        <div class='header'>Session: {{ message.content_html }}</div>
        {% if message.session_subtitle %}
        <div class='session-subtitle'>{{
            message.session_subtitle }} ({{message.session_id}})</div>
        {% endif %}
        {% if message.has_children %}
        <div class='fold-bar' data-message-id='{{ message.message_id }}' data-border-color='session-header'>
            {% if message.immediate_children_count == message.total_descendants_count %}
            {# Same count = only one level, show single full-width button #}
            <div class='fold-bar-section fold-one-level full-width' data-action='fold-one' data-target='{{ message.message_id }}' data-title-unfolded='Fold {{ message.get_immediate_children_label() }}' data-title-folded='Unfold (1st level) {{ message.get_immediate_children_label() }}' title='Fold {{ message.get_immediate_children_label() }}'>
                <span class='fold-icon'>â–¼</span>
                <span class='fold-label'>{{ message.get_immediate_children_label() }}</span>
            </div>
            {% else %}
            {# Multiple levels, show both buttons #}
            <div class='fold-bar-section fold-one-level' data-action='fold-one' data-target='{{ message.message_id }}' data-title-unfolded='Fold (all levels) all {{ message.total_descendants_count }} descendants' data-title-folded='Unfold (1st level) {{ message.get_immediate_children_label() }}' title='Fold (all levels) all {{ message.total_descendants_count }} descendants'>
                <span class='fold-icon'>â–¼</span>
                <span class='fold-label'>{{ message.get_immediate_children_label() }}</span>
            </div>
            <div class='fold-bar-section fold-all-levels' data-action='fold-all' data-target='{{ message.message_id }}' data-title-unfolded='Fold (to 1st level) {{ message.get_immediate_children_label() }}' data-title-folded='Unfold (all levels) all {{ message.total_descendants_count }} descendants' title='Fold (to 1st level) {{ message.get_immediate_children_label() }}'>
                <span class='fold-icon'>â–¼â–¼</span>
                <span class='fold-label'>{{ message.get_total_descendants_label() }} total</span>
            </div>
            {% endif %}
        </div>
        {% endif %}
    </div>
    {% else %}
    {% set markdown = message.css_class in ['assistant', 'thinking', 'sidechain'] or (message.css_class and 'compacted' in message.css_class) %}
    <div class='message {{ message.css_class }}{% if message.is_paired %} paired-message {{ message.pair_role }}{% endif %}{% for ancestor_id in message.ancestry %} {{ ancestor_id }}{% endfor %}' data-message-id='{{ message.message_id }}' id='msg-{{ message.message_id }}{% if message.is_paired and message.pair_role %}-{{ message.pair_role.replace("pair_", "") }}{% endif %}'>
        <div class='header'>
            <span{% if message.title_hint %} title="{{ message.title_hint }}"{% endif %}>{% if message.message_title %}{%
                if message.message_title == 'Memory' %}ğŸ’­ {%
                elif message.css_class.startswith('user') %}ğŸ¤· {%
                elif message.css_class.startswith('assistant') %}ğŸ¤– {%
                elif message.css_class == 'system' %}âš™ï¸ {%
                elif message.css_class.startswith('tool_use') and not starts_with_emoji(message.message_title) %}ğŸ› ï¸ {%
                elif message.css_class == 'tool_result error' %}ğŸš¨ {%
                elif message.css_class.startswith('tool_result') %}ğŸ§° {%
                elif message.css_class.startswith('thinking') %}ğŸ’­ {%
                elif message.css_class == 'image' %}ğŸ–¼ï¸ {% endif %}{{ message.message_title | safe }}{% endif %}</span>
            <div class='header-info'>
                <div class='timestamp-row'>
                    <span class='timestamp'{% if message.raw_timestamp %} data-timestamp='{{ message.raw_timestamp }}'{% if message.pair_duration %} data-duration='{{ message.pair_duration }}'{% endif %}{% endif %}>{{ message.formatted_timestamp }}</span>
                </div>
                {% if message.token_usage %}
                <span class='token-usage'>{{ message.token_usage }}</span>
                {% endif %}
            </div>
        </div>
        <div class='content{% if markdown %} markdown{% endif %}'>{{ message.content_html | safe }}</div>
        {% if message.has_children %}
        <div class='fold-bar' data-message-id='{{ message.message_id }}' data-border-color='{{ message.css_class }}'>
            {% if message.immediate_children_count == message.total_descendants_count %}
            {# Same count = only one level, show single full-width button #}
            <div class='fold-bar-section fold-one-level full-width' data-action='fold-one' data-target='{{ message.message_id }}' data-title-unfolded='Fold {{ message.get_immediate_children_label() }}' data-title-folded='Unfold (1st level) {{ message.get_immediate_children_label() }}' title='Fold {{ message.get_immediate_children_label() }}'>
                <span class='fold-icon'>â–¼</span>
                <span class='fold-label'>{{ message.get_immediate_children_label() }}</span>
            </div>
            {% else %}
            {# Multiple levels, show both buttons #}
            <div class='fold-bar-section fold-one-level' data-action='fold-one' data-target='{{ message.message_id }}' data-title-unfolded='Fold (all levels) all {{ message.total_descendants_count }} descendants' data-title-folded='Unfold (1st level) {{ message.get_immediate_children_label() }}' title='Fold (all levels) all {{ message.total_descendants_count }} descendants'>
                <span class='fold-icon'>â–¼</span>
                <span class='fold-label'>{{ message.get_immediate_children_label() }}</span>
            </div>
            <div class='fold-bar-section fold-all-levels' data-action='fold-all' data-target='{{ message.message_id }}' data-title-unfolded='Fold (to 1st level) {{ message.get_immediate_children_label() }}' data-title-folded='Unfold (all levels) all {{ message.total_descendants_count }} descendants' title='Fold (to 1st level) {{ message.get_immediate_children_label() }}'>
                <span class='fold-icon'>â–¼â–¼</span>
                <span class='fold-label'>{{ message.get_total_descendants_label() }} total</span>
            </div>
            {% endif %}
        </div>
        {% endif %}
    </div>
    {% endif %}
    {% endfor %}

    <button class="timeline-toggle floating-btn" id="toggleTimeline" title="Show timeline">ğŸ“†</button>
    <button class="filter-messages floating-btn" id="filterMessages" title="Search & Filter">ğŸ”</button>
    <button class="toggle-details floating-btn" id="toggleDetails" title="Toggle all details">ğŸ“‹</button>
    <a class="scroll-top floating-btn" title="Scroll to top" href="#title">ğŸ”</a>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const toggleButton = document.getElementById('toggleDetails');
            const timelineButton = document.getElementById('toggleTimeline');
            const filterButton = document.getElementById('filterMessages');
            const filterToolbar = document.querySelector('.filter-toolbar');
            const selectAllButton = document.getElementById('selectAll');
            const selectNoneButton = document.getElementById('selectNone');
            const closeToolbarButton = document.getElementById('closeToolbar');
            const filterToggles = document.querySelectorAll('.filter-toggle');

            // Timezone conversion (included as component)
            {% include 'components/timezone_converter.js' %}

            // Parse URL parameters
            function getUrlParams() {
                const params = new URLSearchParams(window.location.search);
                return {
                    filter: params.get('filter')  // e.g., "user,assistant"
                };
            }

            // Apply filters from URL parameters
            function applyUrlFilters() {
                const urlParams = getUrlParams();

                // Apply message type filter
                if (urlParams.filter) {
                    const types = urlParams.filter.split(',').map(t => t.trim().toLowerCase());

                    // Deactivate all toggles first
                    filterToggles.forEach(toggle => {
                        toggle.classList.remove('active');
                    });

                    // Activate only the specified types
                    types.forEach(type => {
                        const toggle = document.querySelector(`[data-type="${type}"]`);
                        if (toggle) {
                            toggle.classList.add('active');
                        }
                    });

                    // Show filter toolbar if filters are applied
                    filterToolbar.classList.add('visible');
                    filterButton.classList.add('active');
                }
            }

            // Timeline toggle functionality
            if (timelineButton) {
                timelineButton.addEventListener('click', function () {
                    if (window.toggleTimeline) {
                        window.toggleTimeline();
                    }
                });
            }

            // Toggle details functionality
            // Selector for all collapsible details elements (multiple classes)
            const collapsibleSelector = 'details.collapsible-details, details.collapsible-code, details.tool-param-collapsible';
            const collapsibleOpenSelector = 'details[open].collapsible-details, details[open].collapsible-code, details[open].tool-param-collapsible';

            function updateToggleButton() {
                const allDetails = document.querySelectorAll(collapsibleSelector);
                const openCount = document.querySelectorAll(collapsibleOpenSelector).length;
                const totalCount = allDetails.length;

                if (totalCount === 0) {
                    toggleButton.style.display = 'none';
                    return;
                }

                // If more than half are open, show "close all" state, otherwise show "open all"
                const mostlyOpen = openCount > totalCount / 2;
                toggleButton.textContent = mostlyOpen ? 'ğŸ“¦' : 'ğŸ—ƒï¸';
                toggleButton.title = mostlyOpen ? 'Close all details' : 'Open all details';
            }

            function toggleAllDetails() {
                const allDetails = document.querySelectorAll(collapsibleSelector);
                const openCount = document.querySelectorAll(collapsibleOpenSelector).length;
                const shouldOpen = openCount <= allDetails.length / 2;

                allDetails.forEach(details => {
                    if (shouldOpen) {
                        details.setAttribute('open', '');
                    } else {
                        details.removeAttribute('open');
                    }
                });

                updateToggleButton();
            }

            toggleButton.addEventListener('click', toggleAllDetails);

            // Filter toolbar toggle functionality
            function toggleFilterToolbar() {
                const isVisible = filterToolbar.classList.contains('visible');
                if (isVisible) {
                    filterToolbar.classList.remove('visible');
                    filterButton.classList.remove('active');
                    filterButton.title = 'Search & Filter';
                } else {
                    filterToolbar.classList.add('visible');
                    filterButton.classList.add('active');
                    filterButton.title = 'Close';
                    // Focus search input when opening
                    const searchInput = document.getElementById('searchInput');
                    if (searchInput) {
                        setTimeout(() => searchInput.focus(), 100);
                    }
                }
            }

            filterButton.addEventListener('click', toggleFilterToolbar);
            if (closeToolbarButton) {
                closeToolbarButton.addEventListener('click', toggleFilterToolbar);
            }

            // Count messages by type and update button labels
            function updateMessageCounts() {
                const messageTypes = ['user', 'assistant', 'sidechain', 'system', 'thinking', 'image'];

                messageTypes.forEach(type => {
                    const messages = document.querySelectorAll(`.message.${type}:not(.session-header)`);
                    const count = messages.length;
                    const toggle = document.querySelector(`[data-type="${type}"]`);
                    const countSpan = toggle ? toggle.querySelector('.count') : null;

                    if (countSpan) {
                        countSpan.textContent = `(${count})`;

                        // Hide toggles for message types with 0 count
                        if (count === 0) {
                            toggle.style.display = 'none';
                        } else {
                            toggle.style.display = 'flex';
                        }
                    }
                });

                // Handle combined "tool" filter (tool_use + tool_result + bash messages)
                const toolMessages = document.querySelectorAll(`.message.tool_use:not(.session-header), .message.tool_result:not(.session-header), .message.bash-input:not(.session-header), .message.bash-output:not(.session-header)`);
                const toolCount = toolMessages.length;
                const toolToggle = document.querySelector(`[data-type="tool"]`);
                const toolCountSpan = toolToggle ? toolToggle.querySelector('.count') : null;

                if (toolCountSpan) {
                    toolCountSpan.textContent = `(${toolCount})`;
                    if (toolCount === 0) {
                        toolToggle.style.display = 'none';
                    } else {
                        toolToggle.style.display = 'flex';
                    }
                }
            }

            // Filter functionality
            function applyFilter() {
                const activeTypes = Array.from(filterToggles)
                    .filter(toggle => toggle.classList.contains('active'))
                    .map(toggle => toggle.dataset.type);

                // Expand "tool" to include tool_use, tool_result, and bash messages
                const expandedTypes = [];
                activeTypes.forEach(type => {
                    if (type === 'tool') {
                        expandedTypes.push('tool_use', 'tool_result', 'bash-input', 'bash-output');
                    } else {
                        expandedTypes.push(type);
                    }
                });

                // Show/hide messages based on active toggle buttons
                const allMessages = document.querySelectorAll('.message:not(.session-header)');
                allMessages.forEach(message => {
                    let shouldShow = false;

                    // Special handling for sidechain messages
                    if (message.classList.contains('sidechain')) {
                        // For sidechain messages, show if both sidechain filter is active AND their message type filter is active
                        const sidechainActive = expandedTypes.includes('sidechain');
                        const messageTypeActive = expandedTypes.some(type =>
                            type !== 'sidechain' && message.classList.contains(type)
                        );
                        shouldShow = sidechainActive && messageTypeActive;
                    } else {
                        // For non-sidechain messages, show if any of their types are active
                        shouldShow = expandedTypes.some(type => message.classList.contains(type));
                    }

                    if (shouldShow) {
                        message.classList.remove('filtered-hidden');
                    } else {
                        message.classList.add('filtered-hidden');
                    }
                });

                // Update visible counts in real-time
                updateVisibleCounts();

                // Update filter button appearance based on whether all types are selected
                const allTypesSelected = activeTypes.length === filterToggles.length;
                if (!allTypesSelected && filterToolbar.classList.contains('visible')) {
                    filterButton.classList.add('active');
                } else if (allTypesSelected && filterToolbar.classList.contains('visible')) {
                    filterButton.classList.add('active');
                }
            }

            function updateVisibleCounts() {
                const messageTypes = ['user', 'assistant', 'sidechain', 'system', 'thinking', 'image'];

                messageTypes.forEach(type => {
                    const visibleMessages = document.querySelectorAll(`.message.${type}:not(.session-header):not(.filtered-hidden)`);
                    const totalMessages = document.querySelectorAll(`.message.${type}:not(.session-header)`);
                    const visibleCount = visibleMessages.length;
                    const totalCount = totalMessages.length;

                    const toggle = document.querySelector(`[data-type="${type}"]`);
                    const countSpan = toggle ? toggle.querySelector('.count') : null;

                    if (countSpan && totalCount > 0) {
                        // Show "visible/total" format when filtering is active
                        const activeTypes = Array.from(filterToggles)
                            .filter(toggle => toggle.classList.contains('active'))
                            .map(toggle => toggle.dataset.type);

                        const isFiltering = activeTypes.length < filterToggles.length;

                        if (isFiltering && visibleCount !== totalCount) {
                            countSpan.textContent = `(${visibleCount}/${totalCount})`;
                        } else {
                            countSpan.textContent = `(${totalCount})`;
                        }
                    }
                });

                // Handle combined "tool" filter separately (includes bash messages)
                const visibleToolMessages = document.querySelectorAll(`.message.tool_use:not(.session-header):not(.filtered-hidden), .message.tool_result:not(.session-header):not(.filtered-hidden), .message.bash-input:not(.session-header):not(.filtered-hidden), .message.bash-output:not(.session-header):not(.filtered-hidden)`);
                const totalToolMessages = document.querySelectorAll(`.message.tool_use:not(.session-header), .message.tool_result:not(.session-header), .message.bash-input:not(.session-header), .message.bash-output:not(.session-header)`);
                const visibleToolCount = visibleToolMessages.length;
                const totalToolCount = totalToolMessages.length;

                const toolToggle = document.querySelector(`[data-type="tool"]`);
                const toolCountSpan = toolToggle ? toolToggle.querySelector('.count') : null;

                if (toolCountSpan && totalToolCount > 0) {
                    const activeTypes = Array.from(filterToggles)
                        .filter(toggle => toggle.classList.contains('active'))
                        .map(toggle => toggle.dataset.type);

                    const isFiltering = activeTypes.length < filterToggles.length;

                    if (isFiltering && visibleToolCount !== totalToolCount) {
                        toolCountSpan.textContent = `(${visibleToolCount}/${totalToolCount})`;
                    } else {
                        toolCountSpan.textContent = `(${totalToolCount})`;
                    }
                }
            }

            function toggleFilter(button) {
                button.classList.toggle('active');
                applyFilter();
            }

            function selectAllTypes() {
                filterToggles.forEach(toggle => {
                    toggle.classList.add('active');
                });
                applyFilter();
            }

            function selectNoTypes() {
                filterToggles.forEach(toggle => {
                    toggle.classList.remove('active');
                });
                applyFilter();
            }

            // Event listeners for filter toggles
            filterToggles.forEach(toggle => {
                toggle.addEventListener('click', () => toggleFilter(toggle));
            });

            selectAllButton.addEventListener('click', selectAllTypes);
            selectNoneButton.addEventListener('click', selectNoTypes);

            // Initialize button state and message counts
            updateToggleButton();
            updateMessageCounts();

            // Apply URL filters first (if any)
            applyUrlFilters();

            // Apply all filters on page load
            applyFilter();

            // Fold/unfold functionality with horizontal fold bars
            const foldBarSections = document.querySelectorAll('.fold-bar-section');

            foldBarSections.forEach(section => {
                section.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const action = this.getAttribute('data-action');
                    const targetId = this.getAttribute('data-target');
                    const isFolded = this.classList.contains('folded');

                    if (action === 'fold-one') {
                        // Fold/unfold immediate children only
                        handleFoldOne(targetId, isFolded, this);
                    } else if (action === 'fold-all') {
                        // Fold/unfold all descendants recursively
                        handleFoldAll(targetId, isFolded, this);
                    }
                });
            });

            // Update tooltip based on fold state
            function updateTooltip(section) {
                const isFolded = section.classList.contains('folded');
                const tooltip = isFolded
                    ? section.getAttribute('data-title-folded')
                    : section.getAttribute('data-title-unfolded');
                section.setAttribute('title', tooltip);
            }

            function handleFoldOne(targetId, isFolded, sectionElement) {
                // Find all messages in the document
                const allMessages = document.querySelectorAll('.message');

                // Find immediate children: messages that have targetId as their LAST ancestor
                const immediateChildren = Array.from(allMessages).filter(msg => {
                    const classList = Array.from(msg.classList);
                    // Check if targetId is in the class list (ancestor)
                    if (!classList.includes(targetId)) return false;

                    // Check if it's an immediate child by finding all ancestor IDs
                    // Ancestor IDs can be either d-XXX (regular messages) or session-XXX (sessions)
                    const ancestorIds = classList.filter(cls => cls.startsWith('d-') || cls.startsWith('session-'));
                    const lastAncestor = ancestorIds[ancestorIds.length - 1];
                    return lastAncestor === targetId;
                });

                if (isFolded) {
                    // Unfold: show immediate children
                    immediateChildren.forEach(msg => {
                        msg.style.display = '';

                        // Set newly revealed children to folded state
                        const foldBar = msg.querySelector('.fold-bar');
                        if (foldBar) {
                            const foldOneBtn = foldBar.querySelector('.fold-one-level');
                            const foldAllBtn = foldBar.querySelector('.fold-all-levels');

                            if (foldOneBtn) {
                                foldOneBtn.classList.add('folded');
                                foldOneBtn.querySelector('.fold-icon').textContent = 'â–¶';
                                updateTooltip(foldOneBtn);
                            }
                            if (foldAllBtn) {
                                foldAllBtn.classList.add('folded');
                                foldAllBtn.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                                updateTooltip(foldAllBtn);
                            }
                        }
                    });
                    sectionElement.classList.remove('folded');
                    sectionElement.querySelector('.fold-icon').textContent = 'â–¼';
                    updateTooltip(sectionElement);
                    // Note: Second button stays â–¶â–¶ (we haven't unfolded everything)
                } else {
                    // Fold: hide ALL descendants (same approach as handleFoldAll for O(n) performance)
                    const allDescendants = document.querySelectorAll(`.message.${targetId}`);
                    allDescendants.forEach(msg => {
                        msg.style.display = 'none';
                    });
                    sectionElement.classList.add('folded');
                    sectionElement.querySelector('.fold-icon').textContent = 'â–¶';
                    updateTooltip(sectionElement);

                    // Coordinate: If we folded immediate children, all descendants are hidden
                    // So update the "fold all" button to â–¶â–¶ state
                    const foldBar = sectionElement.parentElement;
                    const foldAllSection = foldBar.querySelector('.fold-all-levels');
                    if (foldAllSection) {
                        foldAllSection.classList.add('folded');
                        foldAllSection.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                        updateTooltip(foldAllSection);
                    }
                }
            }

            function handleFoldAll(targetId, isFolded, sectionElement) {
                // Find all descendants (messages with targetId in their class list)
                const descendants = document.querySelectorAll(`.message.${targetId}`);

                if (isFolded) {
                    // Unfold: show all descendants (State A/B â†’ State C)
                    descendants.forEach(msg => {
                        msg.style.display = '';

                        // Also update fold bars of all descendants to unfolded state
                        const foldBar = msg.querySelector('.fold-bar');
                        if (foldBar) {
                            const foldOneBtn = foldBar.querySelector('.fold-one-level');
                            const foldAllBtn = foldBar.querySelector('.fold-all-levels');

                            if (foldOneBtn) {
                                foldOneBtn.classList.remove('folded');
                                foldOneBtn.querySelector('.fold-icon').textContent = 'â–¼';
                                updateTooltip(foldOneBtn);
                            }
                            if (foldAllBtn) {
                                foldAllBtn.classList.remove('folded');
                                foldAllBtn.querySelector('.fold-icon').textContent = 'â–¼â–¼';
                                updateTooltip(foldAllBtn);
                            }
                        }
                    });
                    sectionElement.classList.remove('folded');
                    sectionElement.querySelector('.fold-icon').textContent = 'â–¼â–¼';
                    updateTooltip(sectionElement);

                    // Coordinate: If we unfolded all levels, immediate children are now visible
                    // So update the "fold one" button to â–¼ state
                    const foldBar = sectionElement.parentElement;
                    const foldOneSection = foldBar.querySelector('.fold-one-level');
                    if (foldOneSection) {
                        foldOneSection.classList.remove('folded');
                        foldOneSection.querySelector('.fold-icon').textContent = 'â–¼';
                        updateTooltip(foldOneSection);
                    }
                } else {
                    // Fold: show first level only, hide deeper descendants (State C â†’ State B)
                    descendants.forEach(msg => {
                        const classList = Array.from(msg.classList);
                        const ancestorIds = classList.filter(cls => cls.startsWith('d-') || cls.startsWith('session-'));
                        const lastAncestor = ancestorIds[ancestorIds.length - 1];

                        // Show immediate children, hide non-immediate children
                        if (lastAncestor === targetId) {
                            msg.style.display = '';  // Show immediate child

                            // Set immediate children to folded state
                            const foldBar = msg.querySelector('.fold-bar');
                            if (foldBar) {
                                const foldOneBtn = foldBar.querySelector('.fold-one-level');
                                const foldAllBtn = foldBar.querySelector('.fold-all-levels');

                                if (foldOneBtn) {
                                    foldOneBtn.classList.add('folded');
                                    foldOneBtn.querySelector('.fold-icon').textContent = 'â–¶';
                                    updateTooltip(foldOneBtn);
                                }
                                if (foldAllBtn) {
                                    foldAllBtn.classList.add('folded');
                                    foldAllBtn.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                                    updateTooltip(foldAllBtn);
                                }
                            }
                        } else {
                            msg.style.display = 'none';  // Hide deeper descendants
                        }
                    });
                    sectionElement.classList.add('folded');
                    sectionElement.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                    updateTooltip(sectionElement);

                    // Coordinate: First level is now visible, so update "fold one" button to â–¼ state
                    const foldBar = sectionElement.parentElement;
                    const foldOneSection = foldBar.querySelector('.fold-one-level');
                    if (foldOneSection) {
                        foldOneSection.classList.remove('folded');
                        foldOneSection.querySelector('.fold-icon').textContent = 'â–¼';
                        updateTooltip(foldOneSection);
                    }
                }
            }

            // Set initial fold state on page load
            function setInitialFoldState() {
                // Get all messages once
                const allMessages = document.querySelectorAll('.message');

                // Build hierarchy lookup structure in a single pass - O(n)
                const messagesByParentId = {};  // Maps parent ID -> immediate children elements
                const allDescendantsByParentId = {};  // Maps parent ID -> all descendant elements

                allMessages.forEach(msg => {
                    const classList = Array.from(msg.classList);
                    const ancestorIds = classList.filter(cls => cls.startsWith('d-') || cls.startsWith('session-'));

                    if (ancestorIds.length > 0) {
                        const lastAncestor = ancestorIds[ancestorIds.length - 1];

                        // Track immediate children
                        if (!messagesByParentId[lastAncestor]) {
                            messagesByParentId[lastAncestor] = [];
                        }
                        messagesByParentId[lastAncestor].push(msg);

                        // Track all descendants
                        ancestorIds.forEach(ancestorId => {
                            if (!allDescendantsByParentId[ancestorId]) {
                                allDescendantsByParentId[ancestorId] = [];
                            }
                            allDescendantsByParentId[ancestorId].push(msg);
                        });
                    }
                });

                // Now process each message using cached hierarchy - O(n)
                allMessages.forEach(msg => {
                    const messageId = msg.getAttribute('data-message-id');
                    if (!messageId) return;

                    const isSession = msg.classList.contains('session-header');
                    const isUser = msg.classList.contains('user');
                    const foldBar = msg.querySelector('.fold-bar');

                    if (!foldBar) return;

                    const foldOneSection = foldBar.querySelector('.fold-one-level');
                    const foldAllSection = foldBar.querySelector('.fold-all-levels');

                    // Check if user message has only tools (no assistant/system/thinking children)
                    let hasOnlyTools = false;
                    if (isUser) {
                        const immediateChildren = messagesByParentId[messageId] || [];

                        const hasNonToolChildren = immediateChildren.some(child =>
                            child.classList.contains('assistant') ||
                            child.classList.contains('system') ||
                            child.classList.contains('thinking')
                        );
                        hasOnlyTools = immediateChildren.length > 0 && !hasNonToolChildren;
                    }

                    // Sessions and user messages (unless they have only tools): unfolded at first level
                    if ((isSession || isUser) && !hasOnlyTools) {
                        // First level is visible (â–¼), all levels are not (â–¶â–¶)
                        if (foldOneSection) {
                            foldOneSection.classList.remove('folded');
                            foldOneSection.querySelector('.fold-icon').textContent = 'â–¼';
                            updateTooltip(foldOneSection);
                        }
                        if (foldAllSection) {
                            foldAllSection.classList.add('folded');
                            foldAllSection.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                            updateTooltip(foldAllSection);
                        }

                        // Show immediate children, hide deeper descendants
                        const allDescendants = allDescendantsByParentId[messageId] || [];
                        const immediateChildren = messagesByParentId[messageId] || [];

                        allDescendants.forEach(descendant => {
                            // Show immediate children, hide non-immediate children
                            if (immediateChildren.includes(descendant)) {
                                descendant.style.display = '';  // Show immediate child

                                // Set immediate children to folded state (â–¶/â–¶â–¶)
                                const childFoldBar = descendant.querySelector('.fold-bar');
                                if (childFoldBar) {
                                    const childFoldOne = childFoldBar.querySelector('.fold-one-level');
                                    const childFoldAll = childFoldBar.querySelector('.fold-all-levels');

                                    if (childFoldOne) {
                                        childFoldOne.classList.add('folded');
                                        childFoldOne.querySelector('.fold-icon').textContent = 'â–¶';
                                        updateTooltip(childFoldOne);
                                    }
                                    if (childFoldAll) {
                                        childFoldAll.classList.add('folded');
                                        childFoldAll.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                                        updateTooltip(childFoldAll);
                                    }
                                }
                            } else {
                                descendant.style.display = 'none';  // Hide deeper descendants
                            }
                        });
                    } else {
                        // Assistant, system, thinking, tools, sidechains, OR user messages with only tools: fully folded
                        if (foldOneSection) {
                            foldOneSection.classList.add('folded');
                            foldOneSection.querySelector('.fold-icon').textContent = 'â–¶';
                            updateTooltip(foldOneSection);
                        }
                        if (foldAllSection) {
                            foldAllSection.classList.add('folded');
                            foldAllSection.querySelector('.fold-icon').textContent = 'â–¶â–¶';
                            updateTooltip(foldAllSection);
                        }

                        // Hide all descendants
                        const allDescendants = allDescendantsByParentId[messageId] || [];
                        allDescendants.forEach(descendant => {
                            descendant.style.display = 'none';
                        });
                    }
                });
            }

            // Apply initial fold state
            setInitialFoldState();
        });
    </script>
    <!-- Search functionality script -->
    {% set is_transcript = True %}
    {% include 'components/search.html' %}
</body>

</html>