//! Parsing and AST-building utilities for Duper.

use std::borrow::Cow;

use base64::Engine;
use chumsky::prelude::*;

pub(crate) mod temporal;

use crate::{
    ast::{DuperIdentifier, DuperKey, DuperObject, DuperValue},
    escape::{unescape_bytes, unescape_str},
    parser::temporal::{temporal_specified, temporal_unspecified},
};

pub struct DuperParser;

impl DuperParser {
    /// Parse a Duper trunk, i.e. only an array, tuple, or object at the top level.
    ///
    /// A pretty-printed version of the error can be obtained from the
    /// [`DuperParser::prettify_error`] method.
    ///
    /// ## Example
    ///
    /// ```
    /// use duper::DuperParser;
    ///
    /// DuperParser::parse_duper_trunk(r#"
    ///     ("key", {})
    /// "#).unwrap();
    /// ```
    pub fn parse_duper_trunk<'a>(input: &'a str) -> Result<DuperValue<'a>, Vec<Rich<'a, char>>> {
        let value = duper_trunk().parse(input).into_result()?;
        debug_assert!(matches!(
            &value,
            &DuperValue::Object { .. } | &DuperValue::Array { .. } | &DuperValue::Tuple { .. }
        ));
        Ok(value)
    }

    /// Parse a Duper value at the top level.
    ///
    /// A pretty-printed version of the error can be obtained from the
    /// [`DuperParser::prettify_error`] method.
    ///
    /// ## Example
    ///
    /// ```
    /// use duper::DuperParser;
    ///
    /// DuperParser::parse_duper_value(r#"
    ///     "Hello, Duper!"
    /// "#).unwrap();
    /// ```
    pub fn parse_duper_value<'a>(input: &'a str) -> Result<DuperValue<'a>, Vec<Rich<'a, char>>> {
        duper_value().parse(input).into_result()
    }

    /// Prettifies the errors generated by this parser.
    pub fn prettify_error<'a>(
        input: &'a str,
        errors: &[Rich<'a, char>],
        filename: Option<&str>,
    ) -> std::io::Result<String> {
        let filename = filename.unwrap_or("input");
        let mut message = Vec::new();
        for rich in errors.iter() {
            let filename = filename.to_owned();
            ariadne::Report::build(
                ariadne::ReportKind::Error,
                (filename.clone(), rich.span().into_range()),
            )
            .with_config(ariadne::Config::new().with_index_type(ariadne::IndexType::Byte))
            .with_code(3)
            .with_message(rich.to_string())
            .with_label(
                ariadne::Label::new((filename.clone(), rich.span().into_range()))
                    .with_message(rich.reason().to_string())
                    .with_color(ariadne::Color::Red),
            )
            .finish()
            .write(ariadne::sources([(filename, input)]), &mut message)?;
        }
        String::try_from(message).map_err(|_| {
            std::io::Error::new(std::io::ErrorKind::InvalidData, "generated invalid UTF-8")
        })
    }
}

// Base rules

pub(crate) fn duper_trunk<'a>()
-> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    identified_trunk().then_ignore(end())
}

pub(crate) fn duper_value<'a>()
-> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    identified_value().then_ignore(end())
}

// Semantic rules

pub(crate) fn identifier_lossy<'a>()
-> impl Parser<'a, &'a str, DuperIdentifier<'static>, extra::Err<Rich<'a, char>>> + Clone {
    let skippable_characters = none_of("-_")
        .and_is(ascii_alphanumeric().not())
        .labelled("non-ASCII alphanumeric")
        .repeated()
        .ignored();

    let subsequent_characters = skippable_characters
        .clone()
        .ignore_then(
            one_of("-_")
                .or_not()
                .then_ignore(any().and_is(ascii_alphanumeric().not()).repeated())
                .then(ascii_alphanumeric())
                .padded_by(skippable_characters),
        )
        .repeated();

    one_of('A'..='Z')
        .or(one_of('a'..='z'))
        .labelled("ASCII letter")
        .map(|c: char| c.to_ascii_uppercase().to_string())
        .foldl(
            subsequent_characters,
            |mut acc: String, (underscore_or_hyphen, ascii_alphanumeric)| {
                if let Some(underscore_or_hyphen) = underscore_or_hyphen {
                    acc.push(underscore_or_hyphen);
                }
                acc.push(ascii_alphanumeric);
                acc
            },
        )
        .then_ignore(one_of("-_").repeated().then(end()))
        .map(|string| DuperIdentifier(Cow::Owned(string)))
}

/// Parse an identifier.
pub fn identifier<'a>()
-> impl Parser<'a, &'a str, DuperIdentifier<'a>, extra::Err<Rich<'a, char>>> + Clone {
    one_of('A'..='Z')
        .labelled("ASCII uppercase letter")
        .then(one_of("-_").or_not().then(ascii_alphanumeric()).repeated())
        .to_slice()
        .map(|identifier| DuperIdentifier(Cow::Borrowed(identifier)))
}

/// Parse a trunk value with an optional identifier.
pub fn identified_trunk<'a>()
-> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    let inner_trunk = choice((
        object(identified_value()),
        array(identified_value()),
        tuple(identified_value()),
    ))
    .padded_by(whitespace_and_comments());

    identifier()
        .then(inner_trunk.clone().delimited_by(just('('), just(')')))
        .map(|(identifier, value)| {
            value
                .with_identifier(Some(identifier))
                .expect("identifiers are always valid for non-Temporal values")
        })
        .or(inner_trunk)
        .padded_by(whitespace_and_comments())
}

/// Parse a Duper value with an optional identifier.
pub fn identified_value<'a>()
-> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    recursive(move |identified_value| {
        let inner_value = choice((
            object(identified_value.clone()),
            array(identified_value.clone()),
            tuple(identified_value),
            base64_bytes().map(|bytes| DuperValue::Bytes {
                identifier: None,
                inner: Cow::Owned(bytes),
            }),
            quoted_bytes().map(|cow_bytes| DuperValue::Bytes {
                identifier: None,
                inner: cow_bytes,
            }),
            raw_bytes().map(|bytes| DuperValue::Bytes {
                identifier: None,
                inner: Cow::Borrowed(bytes),
            }),
            quoted_string().map(|cow_str| DuperValue::String {
                identifier: None,
                inner: cow_str,
            }),
            raw_string().map(|str| DuperValue::String {
                identifier: None,
                inner: Cow::Borrowed(str),
            }),
            float().map(|inner| DuperValue::Float {
                identifier: None,
                inner,
            }),
            integer().map(|inner| DuperValue::Integer {
                identifier: None,
                inner,
            }),
            boolean().map(|inner| DuperValue::Boolean {
                identifier: None,
                inner,
            }),
            null().map(|_| DuperValue::Null { identifier: None }),
        ))
        .padded_by(whitespace_and_comments())
        .boxed();

        choice((
            temporal_specified(),
            identifier()
                .then(temporal_unspecified().delimited_by(just('('), just(')')))
                .try_map(|(identifier, temporal), span| {
                    temporal
                        .with_identifier(Some(identifier))
                        .map_err(|err| Rich::custom(span, err))
                }),
            identifier()
                .then(inner_value.clone().delimited_by(just('('), just(')')))
                .map(|(identifier, inner)| {
                    inner
                        .with_identifier(Some(identifier))
                        .expect("identifiers are always valid for non-Temporal values")
                }),
            temporal_unspecified(),
            inner_value,
        ))
        .padded_by(whitespace_and_comments())
    })
}

/// Parse a Duper object.
pub fn object<'a>(
    identified_value: impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone,
) -> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    object_key()
        .padded_by(whitespace_and_comments())
        .then_ignore(just(':').padded_by(whitespace_and_comments()))
        .then(identified_value.padded_by(whitespace_and_comments()))
        .separated_by(just(',').padded_by(whitespace_and_comments()))
        .allow_trailing()
        .collect::<Vec<_>>()
        .try_map(|object, span| {
            DuperObject::try_from(object)
                .map_err(|err| Rich::custom(span, err))
                .map(|object| DuperValue::Object {
                    identifier: None,
                    inner: object,
                })
        })
        .padded_by(whitespace_and_comments())
        .delimited_by(
            just('{').padded_by(whitespace_and_comments()),
            just('}').padded_by(whitespace_and_comments()),
        )
}

/// Parse a Duper object key.
pub fn object_key<'a>() -> impl Parser<'a, &'a str, DuperKey<'a>, extra::Err<Rich<'a, char>>> + Clone
{
    let plain_key = ascii_alphabetic()
        .to_slice()
        .or(just('_').then(ascii_alphanumeric()).to_slice())
        .then(one_of("-_").or_not().then(ascii_alphanumeric()).repeated())
        .to_slice()
        .map(|str| DuperKey(Cow::Borrowed(str)));

    quoted_string()
        .map(DuperKey)
        .or(raw_string().map(|str| DuperKey(Cow::Borrowed(str))))
        .or(plain_key)
}

/// Parse a Duper array.
pub fn array<'a>(
    identified_value: impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone,
) -> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    identified_value
        .padded_by(whitespace_and_comments())
        .separated_by(just(',').padded_by(whitespace_and_comments()))
        .allow_trailing()
        .collect::<Vec<_>>()
        .map(|inner| DuperValue::Array {
            identifier: None,
            inner,
        })
        .padded_by(whitespace_and_comments())
        .delimited_by(
            just('[').padded_by(whitespace_and_comments()),
            just(']').padded_by(whitespace_and_comments()),
        )
        .or(just(',')
            .padded_by(whitespace_and_comments())
            .delimited_by(
                just('[').padded_by(whitespace_and_comments()),
                just(']').padded_by(whitespace_and_comments()),
            )
            .map(|_| DuperValue::Array {
                identifier: None,
                inner: vec![],
            }))
}

/// Parse a Duper tuple.
pub fn tuple<'a>(
    identified_value: impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone,
) -> impl Parser<'a, &'a str, DuperValue<'a>, extra::Err<Rich<'a, char>>> + Clone {
    identified_value
        .padded_by(whitespace_and_comments())
        .separated_by(just(',').padded_by(whitespace_and_comments()))
        .allow_trailing()
        .collect::<Vec<_>>()
        .map(|inner| DuperValue::Tuple {
            identifier: None,
            inner,
        })
        .padded_by(whitespace_and_comments())
        .delimited_by(
            just('(').padded_by(whitespace_and_comments()),
            just(')').padded_by(whitespace_and_comments()),
        )
        .or(just(',')
            .padded_by(whitespace_and_comments())
            .delimited_by(
                just('(').padded_by(whitespace_and_comments()),
                just(')').padded_by(whitespace_and_comments()),
            )
            .map(|_| DuperValue::Tuple {
                identifier: None,
                inner: vec![],
            }))
}

/// Parse a quote-delimited Duper string.
pub fn quoted_string<'a>()
-> impl Parser<'a, &'a str, Cow<'a, str>, extra::Err<Rich<'a, char>>> + Clone {
    quoted_inner()
        .try_map(|str, span| unescape_str(str).map_err(|err| Rich::custom(span, err)))
        .delimited_by(just('"'), just('"'))
}

/// Parse a Base64 Duper byte string.
pub fn base64_bytes<'a>() -> impl Parser<'a, &'a str, Vec<u8>, extra::Err<Rich<'a, char>>> + Clone {
    base64_digit()
        .padded()
        .repeated()
        .then(just('=').repeated())
        .collect::<String>()
        .try_map(|bytes, span| {
            base64::engine::GeneralPurpose::new(
                &base64::alphabet::STANDARD,
                base64::engine::GeneralPurposeConfig::new()
                    .with_decode_padding_mode(base64::engine::DecodePaddingMode::Indifferent),
            )
            .decode(bytes)
            .map_err(|err| Rich::custom(span, err))
        })
        .delimited_by(just("b64\""), just('"'))
}

/// Parse a quote-delimited Duper byte string.
pub fn quoted_bytes<'a>()
-> impl Parser<'a, &'a str, Cow<'a, [u8]>, extra::Err<Rich<'a, char>>> + Clone {
    quoted_inner()
        .try_map(|bytes, span| unescape_bytes(bytes).map_err(|err| Rich::custom(span, err)))
        .delimited_by(just("b\""), just('"'))
}

/// Parse the inner contents of a Duper quoted string or quoted byte string.
pub fn quoted_inner<'a>() -> impl Parser<'a, &'a str, &'a str, extra::Err<Rich<'a, char>>> + Clone {
    let escaped_characters = just('\\')
        .then(choice((
            one_of("\"\\/bfnrt0").to_slice(),
            just('x').then(hex_digit().repeated().exactly(2)).to_slice(),
            just('u').then(hex_digit().repeated().exactly(4)).to_slice(),
            just('U').then(hex_digit().repeated().exactly(8)).to_slice(),
        )))
        .to_slice();

    none_of("\"\\")
        .and_is(control_character().not())
        .to_slice()
        .or(escaped_characters)
        .repeated()
        .to_slice()
}

/// Parse a raw Duper string.
pub fn raw_string<'a>() -> impl Parser<'a, &'a str, &'a str, extra::Err<Rich<'a, char>>> + Clone {
    let hashtags = just('#')
        .repeated()
        .count()
        .delimited_by(just('r'), just('"'));

    hashtags.ignore_with_ctx(
        any()
            .and_is(
                just('"')
                    .then(
                        just('#')
                            .repeated()
                            .configure(|repeated, ctx| repeated.exactly(*ctx)),
                    )
                    .ignored()
                    .or(choice((
                        one_of('\u{0000}'..='\u{0009}'),
                        one_of('\u{000b}'..='\u{001f}'),
                        just('\u{007f}'),
                    ))
                    .labelled("a control character or tab, excluding new line, excluding new line")
                    .repeated()
                    .at_least(1))
                    .not(),
            )
            .repeated()
            .to_slice()
            .then_ignore(
                just('"').then(
                    just('#')
                        .repeated()
                        .configure(|repeated, ctx| repeated.exactly(*ctx)),
                ),
            ),
    )
}

/// Parse a raw Duper byte string.
pub fn raw_bytes<'a>() -> impl Parser<'a, &'a str, &'a [u8], extra::Err<Rich<'a, char>>> + Clone {
    let hashtags = just('#')
        .repeated()
        .to_slice()
        .map(|slice: &str| slice.len())
        .delimited_by(just("br"), just('"'));

    hashtags.ignore_with_ctx(
        any()
            .and_is(
                just('"')
                    .then(
                        just('#')
                            .repeated()
                            .configure(|repeated, ctx| repeated.exactly(*ctx)),
                    )
                    .ignored()
                    .or(choice((
                        one_of('\u{0000}'..='\u{0009}'),
                        one_of('\u{000b}'..='\u{001f}'),
                        just('\u{007f}'),
                    ))
                    .labelled("a control character or tab, excluding new line")
                    .repeated()
                    .at_least(1))
                    .not(),
            )
            .repeated()
            .to_slice()
            .map(|slice: &str| slice.as_bytes())
            .then_ignore(
                just('"').then(
                    just('#')
                        .repeated()
                        .configure(|repeated, ctx| repeated.exactly(*ctx)),
                ),
            ),
    )
}

/// Parse a Duper float.
pub fn float<'a>() -> impl Parser<'a, &'a str, f64, extra::Err<Rich<'a, char>>> + Clone {
    let decimal = one_of("+-").or_not().then(integer_digits()).to_slice();

    let fractional = just('.').then(
        one_of('0'..='9').labelled("a digit").then(
            just('_')
                .or_not()
                .then(one_of('0'..='9').labelled("a digit"))
                .repeated(),
        ),
    );

    let exponent = one_of("eE")
        .then(one_of("+-").or_not())
        .then(integer_digits())
        .to_slice();

    choice((
        decimal.clone().then(exponent.clone()).to_slice(),
        decimal.then(fractional.then(exponent.or_not())).to_slice(),
    ))
    .to_slice()
    .try_map(|float: &str, span| {
        let float: f64 = float
            .replace('_', "")
            .parse()
            .map_err(|err| Rich::custom(span, err))?;
        if float.is_finite() {
            Ok(float)
        } else {
            Err(Rich::custom(span, "float cannot be represented in f64"))
        }
    })
}

/// Parse a Duper integer.
pub fn integer<'a>() -> impl Parser<'a, &'a str, i64, extra::Err<Rich<'a, char>>> + Clone {
    let decimal_integer = one_of("+-")
        .or_not()
        .then(integer_digits())
        .to_slice()
        .try_map(|integer: &str, span| {
            integer
                .replace('_', "")
                .parse()
                .map_err(|err| Rich::custom(span, err))
        });

    let hex_integer = just("0x")
        .ignore_then(
            hex_digit()
                .then(just('_').or_not().then(hex_digit()).repeated())
                .to_slice(),
        )
        .try_map(|integer: &str, span| {
            i64::from_str_radix(&integer.replace('_', ""), 16)
                .map_err(|err| Rich::custom(span, err))
        });

    let octal_integer = just("0o")
        .ignore_then(
            octal_digit()
                .then(just('_').or_not().then(octal_digit()).repeated())
                .to_slice(),
        )
        .try_map(|integer: &str, span| {
            i64::from_str_radix(&integer.replace('_', ""), 8).map_err(|err| Rich::custom(span, err))
        });

    let binary_integer = just("0b")
        .ignore_then(
            one_of("01")
                .then(just('_').or_not().then(one_of("01")).repeated())
                .to_slice(),
        )
        .try_map(|integer: &str, span| {
            i64::from_str_radix(&integer.replace('_', ""), 2).map_err(|err| Rich::custom(span, err))
        });

    choice((hex_integer, octal_integer, binary_integer, decimal_integer))
}

/// Parse a Duper boolean.
pub fn boolean<'a>() -> impl Parser<'a, &'a str, bool, extra::Err<Rich<'a, char>>> + Clone {
    choice((just("true").to(true), just("false").to(false)))
}

/// Parse a Duper null value.
pub fn null<'a>() -> impl Parser<'a, &'a str, (), extra::Err<Rich<'a, char>>> + Clone {
    just("null").to(())
}

// Atoms

pub(crate) fn whitespace_and_comments<'a>()
-> impl Parser<'a, &'a str, (), extra::Err<Rich<'a, char>>> + Clone {
    choice((
        just("//")
            .then(none_of("\r\n").repeated())
            .padded()
            .ignored(),
        just("/*")
            .then(any().and_is(just("*/").not()).repeated())
            .then(just("*/"))
            .padded()
            .ignored(),
    ))
    .repeated()
    .padded()
    .ignored()
}

pub(crate) fn base64_digit<'a>()
-> impl Parser<'a, &'a str, char, extra::Err<Rich<'a, char>>> + Clone {
    choice((
        one_of('a'..='z'),
        one_of('A'..='Z'),
        one_of('0'..='9'),
        just('+'),
        just('/'),
    ))
    .labelled("a Base64 digit")
}

pub(crate) fn ascii_alphabetic<'a>()
-> impl Parser<'a, &'a str, char, extra::Err<Rich<'a, char>>> + Clone {
    one_of('a'..='z')
        .or(one_of('A'..='Z'))
        .labelled("an ASCII letter")
}

pub(crate) fn ascii_alphanumeric<'a>()
-> impl Parser<'a, &'a str, char, extra::Err<Rich<'a, char>>> + Clone {
    choice((one_of('a'..='z'), one_of('A'..='Z'), one_of('0'..='9')))
        .labelled("an ASCII alphanumeric")
}

pub(crate) fn integer_digits<'a>()
-> impl Parser<'a, &'a str, &'a str, extra::Err<Rich<'a, char>>> + Clone {
    one_of('1'..='9')
        .labelled("a digit 1 through 9")
        .then(
            just('_')
                .or_not()
                .then(one_of('0'..='9').labelled("a digit"))
                .repeated(),
        )
        .to_slice()
        .or(one_of('0'..='9').labelled("a digit").to_slice())
}

pub(crate) fn hex_digit<'a>() -> impl Parser<'a, &'a str, char, extra::Err<Rich<'a, char>>> + Clone
{
    choice((one_of('0'..='9'), one_of('a'..='f'), one_of('A'..='F')))
        .labelled("a hexadecimal digit")
}

pub(crate) fn octal_digit<'a>() -> impl Parser<'a, &'a str, char, extra::Err<Rich<'a, char>>> + Clone
{
    one_of('0'..='7').labelled("an octal digit")
}

pub(crate) fn control_character<'a>()
-> impl Parser<'a, &'a str, char, extra::Err<Rich<'a, char>>> + Clone {
    choice((
        one_of('\u{0000}'..='\u{0009}'),
        one_of('\u{000b}'..='\u{001f}'),
        just('\u{007f}'),
    ))
    .labelled("a control character or tab, excluding new line")
}

#[cfg(test)]
mod duper_parser_tests {
    use crate::{
        DuperIdentifier, DuperKey, DuperObject, DuperParser, DuperTemporal, DuperTemporalInstant,
        DuperValue,
    };

    #[test]
    fn duper_trunk() {
        let input = r#"
            "hello"
        "#;
        assert!(DuperParser::parse_duper_trunk(input).is_err());

        let input = r#"
            br"Â¯\_(ãƒ„)_/Â¯"
        "#;
        assert!(DuperParser::parse_duper_trunk(input).is_err());

        let input = r#"
            9001
        "#;
        assert!(DuperParser::parse_duper_trunk(input).is_err());

        let input = r#"
            3.14
        "#;
        assert!(DuperParser::parse_duper_trunk(input).is_err());

        let input = r#"
            true
        "#;
        assert!(DuperParser::parse_duper_trunk(input).is_err());

        let input = r#"
            null
        "#;
        assert!(DuperParser::parse_duper_trunk(input).is_err());

        let input = r#"
            (,)
        "#;
        let duper = DuperParser::parse_duper_trunk(input).unwrap();
        assert!(matches!(duper, DuperValue::Tuple { .. }));

        let input = r#"
            {duper: 1337, _123: b"bar"}
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Object { .. }));

        let input = r#"
            [1, 2.2, null]
        "#;
        let duper = DuperParser::parse_duper_trunk(input).unwrap();
        assert!(matches!(duper, DuperValue::Array { .. }));
    }

    #[test]
    fn duper_value() {
        let input = r#"
            "hello"
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::String { .. }));

        let input = r#"
            b"\x1b\t\x00"
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Bytes { .. }));

        let input = r#"
            br"Â¯\_(ãƒ„)_/Â¯"
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Bytes { .. }));

        let input = r#"
            b64"RHVwZXI"
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Bytes { .. }));

        let input = r#"
            9001
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Integer { .. }));

        let input = r#"
            0x2001
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Integer { .. }));

        let input = r#"
            0o755
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Integer { .. }));

        let input = r#"
            0b0101_0101
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Integer { .. }));

        let input = r#"
            3.14
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Float { .. }));

        let input = r#"
            12e-10
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Float { .. }));

        let input = r#"
            1_2.3_4E5_6
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Float { .. }));

        let input = r#"
            true
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Boolean { .. }));

        let input = r#"
            null
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Null { .. }));

        let input = r#"
            (,)
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Tuple { .. }));

        let input = r#"
            {duper: 1337, _123: b"bar", _a-b_c
            :
            true, "_": false, "": null}
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Object { .. }));

        let input = r#"
            '2022-02-28'
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            '2022-02-28T11:06:00.092121729+08:00[Asia/Shanghai][u-ca=chinese]'
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            ZonedDateTime('2022-02-28T11:06:00.092121729+08:00[Asia/Shanghai][u-ca=chinese]')
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::ZonedDateTime { .. })
        ));

        let input = r#"
            '  2022-02-28T03:06:00.092121729+02:00  '
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            PlainDate('  2022-02-28T03:06:00.092121729+02:00  ')
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::PlainDate { .. })
        ));

        let input = r#"
            PlainTime('  2022-02-28T03:06:00.092121729+02:00  ')
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::PlainTime { .. })
        ));

        let input = r#"
            PlainMonthDay('--11-03')
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::PlainMonthDay { .. })
        ));

        let input = r#"
            '2020-05-22[u-ca=hebrew]'
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            PlainTimeDate('2022-11-09')  // Non-recognized identifier
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            UnknownIdent('--11-03')
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            'PT0.0021S'
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(
            duper,
            DuperValue::Temporal(DuperTemporal::Unspecified { .. })
        ));

        let input = r#"
            Instant("2022-11-09")  // Misleading identifier
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::String { .. }));

        let input = r#"
            [1, 2.2, null]
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Array { .. }));

        let input = r#"
            {
                name: "constant.other.temporal.duper",
                begin: Regex("'"),
                end: Regex("'"),
                // patterns: [
                //   {
                //     match: Regex("."),
                //   },
                // ],
            }
        "#;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert!(matches!(duper, DuperValue::Object { .. }));
    }

    #[test]
    fn parsing_errors() {
        // No values
        let input = "";
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            // Only a line comment
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            /*
                Only a multiline comment
            */
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Strings and bytes
        let input = r#"
            "unclosed
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            unopened"
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            b"unclosed bytes
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            r"unclosed raw
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            br"unclosed raw bytes
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            "invalid UTF-8 \xF0\x90\x80"
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            "unknown escape \e"
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            b64"RHVwZXI=="  // Too much padding
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            b64"RHV=wZXI"  // Padding character in incorrect position
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            b64"ABC-"  // Invalid character
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Temporal
        let input = r#"
            'invalid'
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            '2025-02-29'  // Inexistent date
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            ZonedDateTime('2022-02-28T11:06:00.092121729+08:00[u-ca=chinese]')  // Missing timezone
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            PlainDateTime('2022-02-28T03:06:00Z')  // Z offset not allowed in conversion from Instant
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Floats and decimal
        let input = r#"
            +
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            -
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            01  // No trailing zero
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            _
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            _12
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            1__2
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12f
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12.
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e+
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"12e-"#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12.34.56
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e34e56
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12.3a4
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            e10
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            .
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            -.5
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            +.5
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            _.123
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12._34
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e_34
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e+_34
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            1__2.34
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12.3__4
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e3__4
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12.34_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e34_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            12e3.4
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            1e1000  // Too big to represent
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Hexadecimal
        let input = r#"
            0x
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0xg
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0x_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0x1_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0x_1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0x1.2
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0x-1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            -0x1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Octal
        let input = r#"
            0o
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0o8
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0o_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0o1_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0o_1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0o1.2
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0o-1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            -0o1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Binary
        let input = r#"
            0b
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0b2
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0b_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0b1_
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0b_1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0b1.1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            0b-1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            -0b1
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Objects
        let input = r#"
            {,}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {,,}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {1a: "no starting digit in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {-a: "no starting hyphen in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {a-: "no ending hyphen in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {a_: "no ending underscore in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {a--b: "no consecutive hyphens in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {a__b: "no consecutive underscores in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {a_-b: "no underscore followed by hyphen in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {a-_b: "no hyphen followed by underscore in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {_-a: "no starting underscore followed by hyphen in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {__a: "no starting double underscore in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {_: "no singular underscore in key"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {b"value as key": null}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {"missing" "colon"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {"missing_value"}
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            {
                name: "duplicated",
                "n\x61me": "duplicated",
            }
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Arrays and tuples
        let input = r#"
            [,,]
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            (,,)
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());

        // Identifiers and values
        let input = r#"
            NoÃœnicodeÃ‡haracters({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            1NoStartingNumber({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            noStartingLowercase({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            No Space({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            -NoStartingHyphen({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            _NoStartingUnderscore({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            NoEndingHyphen-({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            NoEndingUnderscore_({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            No-_HyphenThenUnderscore({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            No_-UnderscoreThenHyphen({})
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            NoParenthesis[]
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            NoValue()
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            null,
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            ,null
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
        let input = r#"
            true,false
        "#;
        assert!(DuperParser::parse_duper_value(input).is_err());
    }

    #[test]
    fn example() {
        use std::borrow::Cow;

        let input = r##"
            Product({
                product_id: Uuid("1dd7b7aa-515e-405f-85a9-8ac812242609"),
                name: "Wireless Bluetooth Headphones",
                brand: "AudioTech",
                price: Decimal("129.99"),
                dimensions: (18.5, 15.2, 7.8),  // In centimeters
                weight: Kilograms(0.285),
                in_stock: true,
                specifications: {
                    battery_life: Duration("30h"),
                    noise_cancellation: true,
                    connectivity: ["Bluetooth 5.0", "3.5mm Jack"],
                },
                image_thumbnail: Png(b64"iVBORw0KGgoAAAANSUhEUgAAAGQ="),
                tags: ["electronics", "audio", "wireless"],
                release_date: Date("2023-11-15"),
                /* Warranty is optional */
                warranty_period: null,
                customer_ratings: {
                    latest_review: r#"Absolutely ""astounding""!! ðŸ˜Ž"#,
                    average: 4.5,
                    count: 127,
                },
                created_at: Instant('2023-11-17T21:50:43+00:00'),
            })
        "##;
        let duper = DuperParser::parse_duper_value(input).unwrap();
        assert_eq!(
            duper,
            DuperValue::Object {
                identifier: Some(DuperIdentifier(Cow::Borrowed("Product"))),
                inner: DuperObject::try_from(vec![
                    (
                        DuperKey(Cow::Borrowed("product_id")),
                        DuperValue::String {
                            identifier: Some(DuperIdentifier(Cow::Borrowed("Uuid"))),
                            inner: Cow::Borrowed("1dd7b7aa-515e-405f-85a9-8ac812242609"),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("name")),
                        DuperValue::String {
                            identifier: None,
                            inner: Cow::Borrowed("Wireless Bluetooth Headphones"),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("brand")),
                        DuperValue::String {
                            identifier: None,
                            inner: Cow::Borrowed("AudioTech"),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("price")),
                        DuperValue::String {
                            identifier: Some(DuperIdentifier(Cow::Borrowed("Decimal"))),
                            inner: Cow::Borrowed("129.99"),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("dimensions")),
                        DuperValue::Tuple {
                            identifier: None,
                            inner: vec![
                                DuperValue::Float {
                                    identifier: None,
                                    inner: 18.5
                                },
                                DuperValue::Float {
                                    identifier: None,
                                    inner: 15.2
                                },
                                DuperValue::Float {
                                    identifier: None,
                                    inner: 7.8
                                },
                            ],
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("weight")),
                        DuperValue::Float {
                            identifier: Some(DuperIdentifier(Cow::Borrowed("Weight"))),
                            inner: 0.285
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("in_stock")),
                        DuperValue::Boolean {
                            identifier: None,
                            inner: true
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("specifications")),
                        DuperValue::Object {
                            identifier: None,
                            inner: DuperObject::try_from(vec![
                                (
                                    DuperKey(Cow::Borrowed("battery_life")),
                                    DuperValue::String {
                                        identifier: Some(DuperIdentifier(Cow::Borrowed(
                                            "Duration"
                                        ))),
                                        inner: Cow::Borrowed("30h"),
                                    }
                                ),
                                (
                                    DuperKey(Cow::Borrowed("noise_cancellation")),
                                    DuperValue::Boolean {
                                        identifier: None,
                                        inner: true
                                    }
                                ),
                                (
                                    DuperKey(Cow::Borrowed("connectivity")),
                                    DuperValue::Array {
                                        identifier: None,
                                        inner: vec![
                                            DuperValue::String {
                                                identifier: None,
                                                inner: Cow::Borrowed("Bluetooth 5.0")
                                            },
                                            DuperValue::String {
                                                identifier: None,
                                                inner: Cow::Borrowed("3.5mm Jack")
                                            },
                                        ],
                                    }
                                ),
                            ])
                            .unwrap(),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("image_thumbnail")),
                        DuperValue::Bytes {
                            identifier: Some(DuperIdentifier(Cow::Borrowed("Png"))),
                            inner: Cow::Borrowed(
                                b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x64"
                            ),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("tags")),
                        DuperValue::Array {
                            identifier: None,
                            inner: vec![
                                DuperValue::String {
                                    identifier: None,
                                    inner: Cow::Borrowed("electronics")
                                },
                                DuperValue::String {
                                    identifier: None,
                                    inner: Cow::Borrowed("audio")
                                },
                                DuperValue::String {
                                    identifier: None,
                                    inner: Cow::Borrowed("wireless")
                                },
                            ],
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("release_date")),
                        DuperValue::String {
                            identifier: Some(DuperIdentifier(Cow::Borrowed("Date"))),
                            inner: Cow::Borrowed("2023-11-15"),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("warranty_period")),
                        DuperValue::Null { identifier: None }
                    ),
                    (
                        DuperKey(Cow::Borrowed("customer_ratings")),
                        DuperValue::Object {
                            identifier: None,
                            inner: DuperObject::try_from(vec![
                                (
                                    DuperKey(Cow::Borrowed("latest_review")),
                                    DuperValue::String {
                                        identifier: None,
                                        inner: Cow::Borrowed(r#"Absolutely ""astounding""!! ðŸ˜Ž"#),
                                    }
                                ),
                                (
                                    DuperKey(Cow::Borrowed("average")),
                                    DuperValue::Float {
                                        identifier: None,
                                        inner: 4.5,
                                    }
                                ),
                                (
                                    DuperKey(Cow::Borrowed("count")),
                                    DuperValue::Integer {
                                        identifier: None,
                                        inner: 127
                                    }
                                ),
                            ])
                            .unwrap(),
                        }
                    ),
                    (
                        DuperKey(Cow::Borrowed("created_at")),
                        DuperValue::Temporal(DuperTemporal::Instant {
                            inner: DuperTemporalInstant(Cow::Borrowed("2023-11-17T21:50:43+00:00")),
                        })
                    ),
                ])
                .unwrap()
            }
        );
    }
}
