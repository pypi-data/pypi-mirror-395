Metadata-Version: 2.4
Name: sopy-quantum
Version: 1.4.0
Summary: Representation and Decomposition with Sums of Product for Operations in separated dimensions. Now using bandlimit place data on lattice.
Author-email: Jonathan Jerke <jonathan@quantumgalaxies.org>
License-Expression: MIT
Project-URL: Homepage, https://sopy.quantumgalaxies.org
Project-URL: Issues, https://github.com/quantumgalaxies/sopy/issues
Classifier: Programming Language :: Python :: 3
Classifier: Operating System :: OS Independent
Classifier: Intended Audience :: Science/Research
Classifier: Intended Audience :: Developers
Requires-Python: >=3.11
Description-Content-Type: text/markdown
License-File: LICENSE.txt
Requires-Dist: tensorflow>=2.16.1
Requires-Dist: scikit-learn>=1.6.1
Requires-Dist: bandlimit>=1.2.4
Provides-Extra: pyscf
Requires-Dist: pyscf>=2.11.0; extra == "pyscf"
Provides-Extra: tensorly
Requires-Dist: tensorly>=0.9.0; extra == "tensorly"
Dynamic: license-file

# Sums Of Product
## SoPy

## Sums of Products for data and science

### Conceptual

Let multidimensional distributions be handled in the new-old fashion way... Methods as old as the census and modernized by Beylkin and Mohlenkamp 2005 for physics. Wherein is a suite of code to hold and decompose SoP vectors. We engage with the word *decomposition* not as a dimensional reduction, but as a canonical-rank reducer. See, data already is in SoP form, why write it in dense hyper dimensions?

Since 2018, we have been aware that Coulomb and other functions can be written in SoP ways, but thats the published secret sauce.
We simply are publishing our best understanding of how the SoP vector should be decomposed.  Including some tricks which have not seen the light of day before that fundamentally improve the process, see Fibonacci.

Expect a paper to be published when time can be found to do so.

### How to install

`pip install sopy-quantum`

`import sopy as sp`

# New features

## pySCF

Take an arbitrary electronic structure system defined in pySCF, you can put it into SoP 3D space.
A stage towards various applications. Go to examples/pySCF_wavefunction.ipynb to follow my logic.

## Fourier Transform

The work here, should not fall into the trap of native-Fast Fourier Transform. Multiply an arbritary vector by exp(i k X^).
Using really sophisicated operator logic embedded in recent work.

## Gaussian Blurr Transform

Multiply an arbritary vector by exp(-0.5 alpha  (X^-position)**2 ).
Using really sophisicated operator logic embedded in recent work.

## Tensorly interface

Unclear when its appropriate, but you can use examples/ext to expand SoP into space and use Tensorly to reduce it again.

### Functions

First set a lattice, 
	
 	lattices = 2*[np.linspace(-10,10,100)]

2D gaussian at (2,6) with sigmas (1,1), and polynominal 0,0

	u = sp.vector().gaussian(a = 1,positions = [2,6],sigmas = [1,1],ls = [0,0], lattices = lattices)

2D gaussian at (0.1,-0.6) with sigmas (1,1), and polynominal 0,0

	k = sp.vector().gaussian(a = 1,positions = [0.1,-0.6],sigmas = [1,1],ls = [0,0], lattices = lattices)

2D gaussian at (-1,-2) with sigmas (1,1), and polynominal 1,1

	k = k.gaussian(a = 2,positions = [-1,-2],sigmas = [1,1],ls = [1,1], lattices = lattices)

2D gaussian at (-2,-5) with sigmas (1,1), and polynominal 1,0

	v = k.copy().gaussian(a = 2,positions = [-2,-5],sigmas = [1,1],ls = [1,0], lattices = lattices)

 Multiply operand by exp_i(k ^X ) for k = (1,0)

 	cv = sp.operand( u, sp.vector() )
  
  	cv.exp_i([1,0]).cot(cv)
 

linear dependence factor...

	alpha = 0

take v and remove k from it, and decompose into vector u ; outputing to vector q

	q = u.learn(v-k,  alpha = alpha, iterate = 1)

Get the Euclidean distance from vector v-k and q
 	
  	q.dist(v-k)

Reduce v with Fibonacci procedure

	[ v.fibonacci( partition = partition, iterate = 10, total_iterate = 10).dist(v) for partition in range(1,len(v))]

Compare with standard approaches

	[ v.decompose( partition = partition, iterate = 10, total_iterate = 10).dist(v) for partition in range(1,len(v))]

Use boost

	[ v.boost().fibonacci(  partition = partition, iterate = 10 ,alpha = 1e-2).unboost().dist(v) for partition in range(1,len(v))]

### How to Contribute
* Write to disk/database/json
* Develop amplitude/component to various non-local resources
  * Engage with Quantum Galaxies deploying matrices in separated dimensions

### Contact Info

[ SoPy Website ](https://sopy.quantumgalaxies.org)

[ Quantum Galaxies Articles ](https://www.quantumgalaxies.org/articles)

[ Quantum Galaxies Corporation ](https://www.quantumgalaxies.com)
