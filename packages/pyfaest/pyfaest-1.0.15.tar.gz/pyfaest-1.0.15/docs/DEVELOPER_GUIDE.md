# PyFAEST Development Guide

This guide explains the implementation details of PyFAEST for developers who want to understand or extend the wrapper.

## Architecture Overview

### Three-Layer Design

```
┌─────────────────────────────────────────────┐
│         Python Application Layer            │
│     (User code using PyFAEST API)           │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│      Python Wrapper Layer (core.py)         │
│  - Keypair, PublicKey, PrivateKey classes   │
│  - Memory management & type conversion      │
│  - Error handling & validation              │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│      CFFI Binding Layer (_faest_cffi)       │
│  - Generated by faest_build.py              │
│  - FFI declarations and C function mapping  │
└──────────────────┬──────────────────────────┘
                   │
┌──────────────────▼──────────────────────────┐
│       C Library Layer (libfaest.so)         │
│  - FAEST reference implementation           │
│  - Low-level cryptographic operations       │
└─────────────────────────────────────────────┘
```

## File Structure Explained

### Core Files

1. **`faest_api.h`** - Clean C API header
   - Simplified declarations for CFFI
   - Removes FAEST_EXPORT and FAEST_CALLING_CONVENTION macros
   - Documents all parameter sets and their constants

2. **`faest_build.py`** - CFFI builder script
   - Defines C function signatures for Python
   - Links to libfaest library
   - Generates `_faest_cffi` module during installation

3. **`faest/core.py`** - Main Python implementation
   - `Keypair`, `PublicKey`, `PrivateKey` classes
   - `sign()` and `verify()` functions
   - Memory management with `weakref.finalize`
   - Type checking and error handling

4. **`faest/__init__.py`** - Package interface
   - Public API exports
   - Version information
   - Documentation

### Configuration Files

- **`setup.py`** - Traditional setuptools configuration
- **`pyproject.toml`** - Modern Python packaging metadata
- **`MANIFEST.in`** - Files to include in distribution
- **`requirements.txt`** - Python dependencies

## Key Implementation Details

### Memory Management

The `PrivateKey` class uses Python's `weakref.finalize` for secure cleanup:

```python
class PrivateKey:
    def __init__(self, key_bytes: bytes, param_set: str):
        # Allocate C memory
        self._sk_buf = ffi.new(f"uint8_t[{size}]")
        
        # Register cleanup
        self._finalizer = weakref.finalize(
            self, 
            self._clear_key,
            self._sk_buf, 
            clear_func
        )
```

**Why this approach?**
- Automatic cleanup when object is garbage collected
- Secure zeroing of private key memory
- Works even if user forgets to delete the key
- No reliance on `__del__` (which is unreliable)

### Type Safety

All functions enforce strict type checking:

```python
def sign(message: bytes, private_key: PrivateKey) -> bytes:
    if not isinstance(message, bytes):
        raise TypeError("Message must be bytes")
    # ...
```

**Why?**
- Cryptographic operations require exact byte sequences
- Prevents accidental string/bytes confusion
- Catches errors early before passing to C

### Parameter Set Configuration

Uses a dictionary-based configuration system:

```python
PARAMETER_SETS = {
    '128f': {
        'pk_size': lib.FAEST_128F_PUBLIC_KEY_SIZE,
        'keygen': lib.faest_128f_keygen,
        # ...
    },
    # ...
}
```

**Benefits:**
- Single source of truth for all parameter sets
- Easy to add new parameter sets
- Runtime selection of crypto parameters
- Consistent interface across all variants

### Error Handling

Custom exception hierarchy:

```
FaestError (base)
├── KeyGenerationError
├── SignatureError
├── VerificationError
└── InvalidKeyPairError
```

**Design rationale:**
- Specific exceptions for different failure modes
- Allows fine-grained error handling
- Better debugging information

## CFFI Integration

### The ffi Object

CFFI provides two key objects:

1. **`ffi`** - Foreign Function Interface builder
   - `ffi.new()` - Allocate C memory
   - `ffi.buffer()` - Access C memory as Python buffer
   - `ffi.memmove()` - Copy data between Python and C

2. **`lib`** - Library of C functions
   - `lib.faest_128f_keygen()` - Direct C function calls
   - `lib.FAEST_128F_PUBLIC_KEY_SIZE` - C constants

### Memory Conversion Pattern

Standard pattern for all operations:

```python
# 1. Allocate C buffers
buf = ffi.new("uint8_t[32]")

# 2. Call C function
result = lib.faest_128f_keygen(pk_buf, sk_buf)

# 3. Check result
if result != 0:
    raise Error()

# 4. Convert to Python bytes
pk_bytes = bytes(ffi.buffer(pk_buf, 32))
```

## Adding New Features

### Adding a New Parameter Set

1. **Update `faest_api.h`:**
```c
#define FAEST_NEW_PUBLIC_KEY_SIZE 40
int faest_new_keygen(uint8_t* pk, uint8_t* sk);
// ... other functions
```

2. **Update `faest_build.py`:**
```python
ffibuilder.cdef("""
    #define FAEST_NEW_PUBLIC_KEY_SIZE 40
    int faest_new_keygen(uint8_t* pk, uint8_t* sk);
    // ...
""")
```

3. **Update `core.py`:**
```python
PARAMETER_SETS['new'] = {
    'pk_size': lib.FAEST_NEW_PUBLIC_KEY_SIZE,
    'keygen': lib.faest_new_keygen,
    # ...
}
```

### Adding New Functionality

Example: Add signature with custom randomness

1. **Declare in `faest_build.py`:**
```python
ffibuilder.cdef("""
    int faest_128f_sign_with_randomness(
        const uint8_t* sk, 
        const uint8_t* message, 
        size_t message_len,
        const uint8_t* rho,
        size_t rho_len,
        uint8_t* signature, 
        size_t* signature_len
    );
""")
```

2. **Add to `core.py`:**
```python
def sign_with_randomness(message: bytes, 
                         private_key: PrivateKey,
                         randomness: bytes) -> bytes:
    """Sign with additional randomness"""
    # Implementation here
```

## Testing Strategy

### Unit Tests (`tests/test_pyfaest.py`)

Tests are organized by functionality:
- **TestKeyGeneration** - Key generation for all parameter sets
- **TestSigning** - Signature generation
- **TestVerification** - Signature verification
- **TestSerialization** - Key import/export
- **TestParameterSets** - Parametrized tests for all variants
- **TestEdgeCases** - Error conditions
- **TestMemorySafety** - Memory management
- **TestCrossParameterSet** - Cross-variant behavior

### Running Tests

```bash
# All tests
pytest tests/ -v

# Specific test class
pytest tests/test_pyfaest.py::TestKeyGeneration -v

# With coverage
pytest tests/ --cov=faest --cov-report=html
```

## Debugging

### Common Issues

1. **ImportError: _faest_cffi**
   - Solution: Run `python faest_build.py`
   - Cause: Bindings not generated

2. **Library not found**
   - Solution: Check `library_dirs` in `faest_build.py`
   - Cause: Wrong path to libfaest.so

3. **Segmentation fault**
   - Solution: Check buffer sizes in C calls
   - Cause: Buffer overflow or incorrect size

### Debug Mode

Add verbose output:

```python
# In faest_build.py
ffibuilder.compile(verbose=True)

# In core.py
def sign(message, private_key):
    print(f"Signing {len(message)} byte message")
    print(f"Using param set: {private_key.param_set}")
    # ...
```

## Performance Considerations

### Bottlenecks

1. **Key generation** - Most expensive operation
2. **FFI boundary crossing** - Some overhead
3. **Memory allocation** - `ffi.new()` has cost

### Optimization Tips

1. **Reuse keypairs** when possible
2. **Batch operations** if signing multiple messages
3. **Use 'f' variants** for speed-critical code
4. **Profile before optimizing** - measure actual bottlenecks

### Benchmarking

```python
import time

def benchmark_signing(param_set, iterations=100):
    keypair = Keypair.generate(param_set)
    message = b"x" * 1000
    
    start = time.time()
    for _ in range(iterations):
        sign(message, keypair.private_key)
    elapsed = time.time() - start
    
    print(f"{param_set}: {elapsed/iterations*1000:.2f} ms/op")
```

## Security Considerations

### DO's

✓ Always use `bytes` for cryptographic data  
✓ Clear private keys (handled automatically)  
✓ Validate inputs before operations  
✓ Use secure random for key generation (C library handles this)  
✓ Handle exceptions properly  

### DON'Ts

✗ Don't store private keys in logs  
✗ Don't use strings instead of bytes  
✗ Don't ignore verification results  
✗ Don't reuse signatures across contexts  
✗ Don't assume implementation is constant-time (it's a reference)  

## Contributing

### Code Style

- Follow PEP 8
- Use type hints
- Write docstrings (Google style)
- Add tests for new features

### Pull Request Checklist

- [ ] Tests pass (`pytest tests/`)
- [ ] Examples work
- [ ] Documentation updated
- [ ] Code formatted (black)
- [ ] Type checking passes (mypy)

## Resources

- [CFFI Documentation](https://cffi.readthedocs.io/)
- [FAEST Specification](https://faest.info/)
- [Python Packaging Guide](https://packaging.python.org/)
- [C/Python Interface Best Practices](https://docs.python.org/3/extending/index.html)

## Future Enhancements

Potential improvements:

1. **Cython alternative** - For even better performance
2. **Async support** - Non-blocking operations
3. **Batch operations** - Sign/verify multiple at once
4. **Hardware acceleration** - If FAEST adds it
5. **Key derivation** - From passwords/seeds
6. **Streaming signatures** - For large files

---

*Last updated: November 2025*
