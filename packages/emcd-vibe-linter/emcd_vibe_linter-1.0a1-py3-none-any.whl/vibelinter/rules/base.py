# vim: set filetype=python fileencoding=utf-8:
# -*- coding: utf-8 -*-

#============================================================================#
#                                                                            #
#  Licensed under the Apache License, Version 2.0 (the "License");           #
#  you may not use this file except in compliance with the License.          #
#  You may obtain a copy of the License at                                   #
#                                                                            #
#      http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                            #
#  Unless required by applicable law or agreed to in writing, software       #
#  distributed under the License is distributed on an "AS IS" BASIS,         #
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
#  See the License for the specific language governing permissions and       #
#  limitations under the License.                                            #
#                                                                            #
#============================================================================#


''' Base rule framework with collection-then-analysis pattern. '''


from . import __
from . import violations as _violations


class BaseRule( __.libcst.CSTVisitor ):
    ''' Abstract base class for linting rules.

        Implements collection-then-analysis pattern where rules collect data
        during CST traversal and perform analysis in leave_Module to generate
        violations. Supports complex rules requiring complete file information.

        Note: Cannot inherit from abc.ABC due to metaclass conflict with
        CSTVisitor. However, @abstractmethod decorators still enforce
        abstract method requirements.
    '''

    METADATA_DEPENDENCIES = (
        __.libcst.metadata.PositionProvider,
        __.libcst.metadata.ScopeProvider,
        __.libcst.metadata.QualifiedNameProvider,
    )

    def __init__(
        self,
        filename: __.typx.Annotated[
            str,
            __.ddoc.Doc( 'Path to source file being analyzed.' ) ],
        wrapper: __.typx.Annotated[
            __.libcst.metadata.MetadataWrapper,
            __.ddoc.Doc(
                'LibCST metadata wrapper providing position and scope.'
            ) ],
        source_lines: __.typx.Annotated[
            tuple[ str, ... ],
            __.ddoc.Doc( 'Source file lines for context extraction.' ) ],
    ) -> None:
        super( ).__init__( )
        self.filename = filename
        self.wrapper = wrapper
        self.source_lines = source_lines
        self._violations: list[ _violations.Violation ] = [ ]

    @property
    @__.abc.abstractmethod
    def rule_id( self ) -> __.typx.Annotated[
        str,
        __.ddoc.Doc( 'Unique identifier for rule (VBL code).' ) ]:
        ''' Returns the VBL code for this rule. '''

    @property
    def violations( self ) -> tuple[ _violations.Violation, ... ]:
        ''' Returns violations generated by rule analysis. '''
        return tuple( self._violations )

    def leave_Module(
        self, original_node: __.libcst.Module
    ) -> None:
        ''' Performs analysis after CST traversal completes.

            Subclasses must override _analyze_collections to implement
            rule-specific analysis logic using collected data.
        '''
        _ = original_node  # Required by LibCST interface
        self._analyze_collections( )

    @__.abc.abstractmethod
    def _analyze_collections( self ) -> None:
        ''' Analyzes collected data and generates violations.

            Called by leave_Module after traversal completes.
            Implementations should examine collected data and call
            _produce_violation for any violations discovered.
        '''

    def _produce_violation(
        self,
        node: __.typx.Annotated[
            __.libcst.CSTNode,
            __.ddoc.Doc( 'CST node where violation occurred.' ) ],
        message: __.typx.Annotated[
            str,
            __.ddoc.Doc( 'Human-readable violation description.' ) ],
        severity: __.typx.Annotated[
            str,
            __.ddoc.Doc(
                "Severity level: 'error', 'warning', or 'info'."
            ) ] = 'error',
    ) -> None:
        ''' Creates violation from CST node with precise positioning. '''
        line, column = self._position_from_node( node )
        violation = _violations.Violation(
            rule_id = self.rule_id,
            filename = self.filename,
            line = line,
            column = column,
            message = message,
            severity = severity,
        )
        self._violations.append( violation )

    def _extract_context(
        self,
        line: __.typx.Annotated[
            int,
            __.ddoc.Doc( 'One-indexed line number.' ) ],
        context_size: __.typx.Annotated[
            int,
            __.ddoc.Doc(
                'Number of lines to show before and after violation.'
            ) ] = 2,
    ) -> _violations.ViolationContext:
        ''' Extracts source code context around violation. '''
        start_line = max( 1, line - context_size )
        end_line = min( len( self.source_lines ), line + context_size )
        context_lines = tuple(
            self.source_lines[ i ]
            for i in range( start_line - 1, end_line ) )
        if self._violations:
            violation = self._violations[ -1 ]
            return _violations.ViolationContext(
                violation = violation,
                context_lines = context_lines,
                context_start_line = start_line )
        raise __.immut.exceptions.Omnierror( )

    def _position_from_node(
        self, node: __.libcst.CSTNode
    ) -> tuple[ int, int ]:
        ''' Extracts (line, column) position from CST node.

            Returns one-indexed line and column numbers for consistency.
        '''
        try:
            position = self.wrapper.resolve(
                __.libcst.metadata.PositionProvider )[ node ]
            return ( position.start.line, position.start.column + 1 )
        except KeyError: return ( 1, 1 )
