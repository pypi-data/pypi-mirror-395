#!/usr/bin/env python3
"""
WSHawk Vulnerability Verification Module
Real execution detection, not just reflection
"""

import re
import time
import asyncio
from typing import Dict, List, Optional, Tuple
from enum import Enum

class ConfidenceLevel(Enum):
    LOW = "LOW"
    MEDIUM = "MEDIUM"
    HIGH = "HIGH"
    CRITICAL = "CRITICAL"

class VulnerabilityVerifier:
    """
    Verify actual vulnerability execution, not just payload reflection
    """
    
    # SQL Error Signatures
    SQL_ERROR_PATTERNS = [
        # MySQL
        r"You have an error in your SQL syntax",
        r"Warning: mysql_",
        r"MySQLSyntaxErrorException",
        r"valid MySQL result",
        r"check the manual that corresponds to your MySQL",
        
        # PostgreSQL
        r"PostgreSQL.*ERROR",
        r"Warning: pg_",
        r"valid PostgreSQL result",
        r"Npgsql\.",
        
        # MSSQL
        r"Driver.*SQL[\-\_\ ]*Server",
        r"OLE DB.*SQL Server",
        r"(\W|\A)SQL Server.*Driver",
        r"Warning.*mssql_",
        r"Microsoft SQL Native Client error",
        
        # Oracle
        r"ORA-[0-9][0-9][0-9][0-9]",
        r"Oracle error",
        r"Oracle.*Driver",
        r"Warning.*oci_",
        
        # SQLite
        r"SQLite/JDBCDriver",
        r"SQLite.Exception",
        r"System.Data.SQLite.SQLiteException",
        
        # Generic
        r"syntax error.*SQL",
        r"unclosed quotation mark",
        r"quoted string not properly terminated",
    ]
    
    # Command Injection Error Patterns
    CMD_ERROR_PATTERNS = [
        r"sh: .*: command not found",
        r"bash: .*: command not found",
        r"/bin/(ba)?sh",
        r"root@",
        r"uid=\d+",
        r"gid=\d+",
        r"groups=\d+",
        r"'cmd' is not recognized",
        r"The system cannot find the path specified",
    ]
    
    # Path Traversal Indicators
    PATH_TRAVERSAL_PATTERNS = [
        r"root:.*:0:0:",  # /etc/passwd
        r"\[boot loader\]",  # boot.ini
        r"\[extensions\]",  # win.ini
        r"<\?xml",  # XML files
        r"BEGIN (RSA|DSA) PRIVATE KEY",  # SSH keys
    ]
    
    # Stack Trace Patterns
    STACK_TRACE_PATTERNS = [
        r"Traceback \(most recent call last\)",  # Python
        r"at .*\(.*\.java:\d+\)",  # Java
        r"Error: .*\n\s+at",  # Node.js
        r"Fatal error:",  # PHP
        r"Stack trace:",
    ]
    
    def __init__(self):
        self.baseline_response_time = None
    
    def verify_sql_injection(self, response: str, payload: str) -> Tuple[bool, ConfidenceLevel, str]:
        """
        Verify SQL injection through error signatures
        """
        # Check for SQL error patterns
        for pattern in self.SQL_ERROR_PATTERNS:
            if re.search(pattern, response, re.IGNORECASE):
                return (True, ConfidenceLevel.HIGH, 
                       f"SQL error detected: {pattern}")
        
        # Check for reflection (lower confidence)
        if payload in response:
            return (True, ConfidenceLevel.LOW,
                   "Payload reflected (potential SQLi, needs verification)")
        
        return (False, ConfidenceLevel.LOW, "No SQL injection detected")
    
    async def verify_sql_timing(self, send_func, base_payload: str, delay: int = 5) -> Tuple[bool, ConfidenceLevel]:
        """
        Time-based SQL injection detection
        """
        # Baseline timing
        start = time.time()
        await send_func(base_payload)
        baseline = time.time() - start
        
        # Test with sleep payload
        sleep_payloads = [
            f"'; WAITFOR DELAY '00:00:{delay:02d}' --",  # MSSQL
            f"' OR SLEEP({delay}) --",  # MySQL
            f"' OR pg_sleep({delay}) --",  # PostgreSQL
        ]
        
        for sleep_payload in sleep_payloads:
            start = time.time()
            await send_func(sleep_payload)
            elapsed = time.time() - start
            
            # If response is significantly delayed
            if elapsed >= (delay - 1):  # Allow 1s tolerance
                return (True, ConfidenceLevel.HIGH)
        
        return (False, ConfidenceLevel.LOW)
    
    def verify_xss(self, response: str, payload: str) -> Tuple[bool, ConfidenceLevel, str]:
        """
        Verify XSS through context analysis
        """
        if payload not in response:
            return (False, ConfidenceLevel.LOW, "Payload not reflected")
        
        # Check if payload is in dangerous context
        dangerous_contexts = [
            (r'<script[^>]*>' + re.escape(payload), ConfidenceLevel.CRITICAL, "Payload in <script> tag"),
            (r'on\w+\s*=\s*["\']?' + re.escape(payload), ConfidenceLevel.HIGH, "Payload in event handler"),
            (r'<[^>]+\s+' + re.escape(payload), ConfidenceLevel.MEDIUM, "Payload in HTML attribute"),
            (r'<[^>]*>' + re.escape(payload) + r'</', ConfidenceLevel.MEDIUM, "Payload in HTML content"),
        ]
        
        for pattern, confidence, description in dangerous_contexts:
            if re.search(pattern, response, re.IGNORECASE):
                return (True, confidence, description)
        
        # Check if payload is encoded/escaped
        encoded_forms = [
            payload.replace('<', '&lt;').replace('>', '&gt;'),
            payload.replace('<', '\\u003c').replace('>', '\\u003e'),
            payload.replace('"', '&quot;').replace("'", '&#39;'),
        ]
        
        for encoded in encoded_forms:
            if encoded in response:
                return (False, ConfidenceLevel.LOW, 
                       "Payload reflected but encoded (not exploitable)")
        
        return (True, ConfidenceLevel.MEDIUM, 
               "Payload reflected in potentially exploitable context")
    
    def verify_command_injection(self, response: str, payload: str) -> Tuple[bool, ConfidenceLevel, str]:
        """
        Verify command injection through error patterns
        """
        # Check for command execution errors
        for pattern in self.CMD_ERROR_PATTERNS:
            if re.search(pattern, response, re.IGNORECASE):
                return (True, ConfidenceLevel.HIGH,
                       f"Command injection evidence: {pattern}")
        
        # Check for command output patterns
        if re.search(r'uid=\d+.*gid=\d+', response):
            return (True, ConfidenceLevel.CRITICAL,
                   "Command execution confirmed (id command output)")
        
        return (False, ConfidenceLevel.LOW, "No command injection detected")
    
    async def verify_command_timing(self, send_func, delay: int = 5) -> Tuple[bool, ConfidenceLevel]:
        """
        Time-based command injection detection
        """
        timing_payloads = [
            f"; sleep {delay} #",
            f"| sleep {delay} #",
            f"& timeout {delay} &",
            f"`sleep {delay}`",
        ]
        
        for payload in timing_payloads:
            start = time.time()
            await send_func(payload)
            elapsed = time.time() - start
            
            if elapsed >= (delay - 1):
                return (True, ConfidenceLevel.HIGH)
        
        return (False, ConfidenceLevel.LOW)
    
    def verify_path_traversal(self, response: str, payload: str) -> Tuple[bool, ConfidenceLevel, str]:
        """
        Verify path traversal through file content detection
        """
        # Check for file disclosure patterns
        for pattern in self.PATH_TRAVERSAL_PATTERNS:
            if re.search(pattern, response):
                return (True, ConfidenceLevel.CRITICAL,
                       f"File disclosure detected: {pattern}")
        
        return (False, ConfidenceLevel.LOW, "No path traversal detected")
    
    def detect_stack_trace(self, response: str) -> Tuple[bool, str]:
        """
        Detect stack traces in response
        """
        for pattern in self.STACK_TRACE_PATTERNS:
            if re.search(pattern, response, re.MULTILINE):
                return (True, f"Stack trace detected: {pattern}")
        
        return (False, "")
    
    def analyze_response_context(self, response: str, payload: str) -> Dict:
        """
        Comprehensive response analysis
        """
        analysis = {
            'payload_reflected': payload in response,
            'has_sql_errors': any(re.search(p, response, re.IGNORECASE) 
                                 for p in self.SQL_ERROR_PATTERNS),
            'has_cmd_errors': any(re.search(p, response, re.IGNORECASE)
                                 for p in self.CMD_ERROR_PATTERNS),
            'has_stack_trace': self.detect_stack_trace(response)[0],
            'response_length': len(response),
            'contains_html': bool(re.search(r'<[^>]+>', response)),
            'contains_json': self._is_json(response),
        }
        
        return analysis
    
    def _is_json(self, text: str) -> bool:
        """Check if text is valid JSON"""
        try:
            import json
            json.loads(text)
            return True
        except:
            return False
    
    def calculate_confidence(self, analysis: Dict, vuln_type: str) -> ConfidenceLevel:
        """
        Calculate overall confidence level
        """
        if vuln_type == 'sql':
            if analysis['has_sql_errors']:
                return ConfidenceLevel.HIGH
            elif analysis['payload_reflected']:
                return ConfidenceLevel.LOW
        
        elif vuln_type == 'xss':
            if analysis['payload_reflected'] and analysis['contains_html']:
                return ConfidenceLevel.MEDIUM
            elif analysis['payload_reflected']:
                return ConfidenceLevel.LOW
        
        elif vuln_type == 'cmd':
            if analysis['has_cmd_errors']:
                return ConfidenceLevel.HIGH
            elif analysis['payload_reflected']:
                return ConfidenceLevel.LOW
        
        return ConfidenceLevel.LOW
