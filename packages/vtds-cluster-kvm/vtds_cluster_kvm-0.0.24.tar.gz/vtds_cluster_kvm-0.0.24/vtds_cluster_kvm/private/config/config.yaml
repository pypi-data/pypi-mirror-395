#
# MIT License
#
# (C) Copyright 2025 Hewlett Packard Enterprise Development LP
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
cluster:
  # The 'host_blade_network' specifies the parameters for a
  # blade-local network used only among Virtual Nodes that share a
  # single blade and the blade itself. The addresses here are
  # potentially duplicated on each blade. Traffic using those IP
  # addresses is not permitted beyond the blade. This network is used
  # internally as a reliable way to connect to Virtual Nodes without
  # imposing any requirements on the configured cluster's network
  # connectivity.
  host_blade_network:
    # The network name by which the network is known. This network
    # will be added to the set of configured virtual networks
    # automatically. This default configuration should work in most
    # cases, but can be modified as needed.
    network_name: bladenet
    # This is not a cluster network (i.e. it should not be used by
    # applications running on the cluster for anything). It is here to
    # aid in setting up the cluster during deployment.
    non_cluster: true
    # Do not set 'delete' to true here or in an overlay. This network
    # must be defined or the Cluster layer APIs that support
    # deployment at the Application layer will not all work correctly.
    delete: false
    # The 'blade_local' flag tells the deploy logic to set this
    # network up as strictly local on each Virtual Blade.
    blade_local: true
    # List of devices on which the network appears on each virtual
    # blade.
    devices:
      # The layer 2 device. For this network the device will be a
      # Virtual Ethernet ('veth') device allowing the blade to host
      # the network with no direct external connectivity.
      layer2: bladenet
      # The bridge device on which Virtual Nodes will plug into the
      # network.
      bridge: br-bladenet
      # The names of the peer device and interface that give the
      # device presence on the the blade.
      local:
        peer: bl-bladenet-p
        interface: bl-bladenet
    # The network tunnel ID of this network. Since this is a
    # blade_local network, there is no tunnel. Set this to null.
    tunnel_id: None
    # The name of the Blade Interconnect network underlying this
    # Virtual Network. Since this is a blade_local network, there is
    # no underlying interconnect. Set this to null.
    blade_interconnect: null
    address_families:
      ipv4:
        family: AF_INET
        # By default we take a /16 network from a (hopefully) low
        # traffic part of the 10.0.0.0 class A space and use
        # it. Since the networks are strictly blade / guest local,
        # all blades will use the '.1' address of the network. It is
        # too complicated to re-use addresses for guests (Virtual
        # Nodes), so we just hand them out sequentially from
        # there. With a /16 we can have nearly 64K Virtual Nodes
        # without exhausting the pool, which should be way more than
        # we ever actually use. If this network conflicts with
        # something in your application, feel free to move it or
        # resize it, just keep it big enough to support all of your
        # Virtual Nodes.
        cidr: 10.234.0.0/16
        # No gateway. This network has no external reach.
        gateway: null
        # No name servers. This network has no external reach.
        name_servers: []
        # No DHCP. Addressing will be static and generated by the
        # prepare stage of deployment.
        dhcp: {}
  # The 'networks' section defines virtual networks to be deployed to
  # construct the cluster. The example network shown here is meant to
  # be illutrative, but will not show up in your configuration. An
  # appropriate set of network configurations should be built into
  # overlay configs at the cluster layer.
  networks:
    # This is an annotated example network configuration provided to
    # document how Virtual Networks are defined. It will not be
    # included in your final configuration.
    example_network:
      # The 'delete' field can be specified with this network
      # in overlay configs to delete this network from the cluster. It
      # is shown here as true because this network example is not
      # intended to be functional but as an example. By setting it to
      # true here, we prevent this network from being in any actual
      # configuration.
      delete: true
      # The name of the Virtual Network
      network_name: examplenet
      # The 'blade_local' flag tells the deploy logic to set this
      # network up as strictly local on each Virtual Blade where it
      # appears.
      blade_local: false
      # List of devices that comprise the network presence on a node
      devices:
        # The name of the device that hosts the network's layer 2
        # connectivity on the blade. For non-blade-local networks,
        # this will be the name of the VxLAN tunnel device on which
        # the network is built. For blade-local networks, this will be
        # the name of the local virtual ethernet ('veth') on which the
        # network is built.
        layer_2: example
        # The name of the device on which the network's bridge (used by
        # Virtual Nodes) appears on each Virtual Blade
        bridge: br-example
        # The names of the peer device and interface that give the
        # device presence on the the blade if any. Set to empty map or
        # omit to avoid creating a blade presence.
        local:
          peer: bl-example-p
          interface: bl-example
      # The network tunnel ID of this network, this number must be
      # unique for each network in the cluster. Set this to null for
      # blade-local networks.
      tunnel_id: 10
      # The name of the Blade Interconnect network underlying this
      # Virtual Network. Set this to null for blade-local networks.
      blade_interconnect: base-interconnect
      # Configuration for things that are specific to a given address
      # family being used on the network.
      address_families:
        ipv4:
          family: AF_INET
          cidr: 10.254.0.0/16
          gateway: 10.254.0.1
          name_servers:
            - 10.1.1.1
            - 10.1.1.2
            - 10.1.1.3
          # Connected blades are assigned IP addresses by blade class
          # which are indexed by instance number.
          connected_blades:
            - blade_class: base-blade
              # Each connected blade instance is assigned an IP
              # address on the Virtual Network using the following
              # list of blade IPs matched one-to-one with blade
              # instances. If this list runs out early, no IP
              # address is assigned to remaining blade instances.
              addresses:
                - 10.254.0.1
              # If this blade class provides a DHCP server on this
              # Virtual Network, the blade instance where the DHCP
              # server runs is set here. This number must be one of
              # the blade instances listed above.
              dhcp_server_instance: 0
          dhcp:
            # DHCP configuration for this network. DHCP configured
            # here is served by DHCP servers running on Virtual
            # Blades. The cluster layer configures and starts DHCP on
            # the Virtual Blades where it is required.
            #
            # Setting 'enabled' to 'true' causes this DHCP
            # configuration to be installed on the host Virtual
            # Blade. Setting 'enabled' to false declares that either
            # all Virtual Nodes in the network are statically
            # configured or that your application provides dynamic
            # configuration of nodes in this network.
            enabled: true
            # The 'dynamic_range' field sets the range of dynamically
            # assignable addresses in this network.
            pools:
              - start: 10.254.1.0
                end: 10.254.255.254
      # Applications sometimes need concrete configuration information
      # that is most appropriately stored with the objects implemented
      # within the layers instead of trying to map information onto
      # those objects abstractly at the application layer. The
      # application_metadata section of the configuration is only
      # understood by a given application layer and provides a place to
      # put such information. The intent here is that a specific
      # configuration set used for a given application may place
      # metadata with API objects for use by the application itself. Use
      # of application_metadata should be done sparingly and with
      # caution because it has the power to entangle a given vTDS stack
      # and make it non-portable.
      application_metadata: {}
  node_classes:
    ubuntu_24_04_node:
      # If 'pure_base_class' is present and 'true' this Virtual Node
      # class is a template for other node classes. It will not show
      # up in your cluster on its own, but it can
      pure_base_class: true
      # If 'parent_class' is present and true, this Virtual Node class
      # is derived from another Virtual Node class and values here
      # simply overlay that class to make a new class.
      parent_class: null
      # The 'node_count' field indicates how many nodes of this type
      # to instantiate on the cluster.
      node_count: 0
      # The 'distro' section contains settings that are specific to the
      # Linux distribution running on the nodes of this class.
      distro:
        # The family of a distro indicates its closest affiliation in
        # the Linux distro space. At the moment, what is supported are
        # Debian style (ubuntu, for example) and RedHat style (CentOs,
        # or Rocky for example). This tells the deployment script what
        # installation mechanism is being used for the Virtual Node
        family: Debian
      # The 'host_blade' settings determine what class of Virtual
      # Blade hosts Virtual Nodes of this class and maximum number of Virtual
      # Nodes of this class that may be hosted per Virtual Blade.
      host_blade:
        # The 'blade_class' field is the Virtual Blade class on which
        # Virtual Nodes are placed.
        blade_class: base-blade  # need to replace this in a derived
        # class The 'instance_capacity' field indicates the maximum
        # number of instances of this class that can be hosted on a
        # given host blade.
        instance_capacity: 1
      # The 'virtual_machine' block specifies attributes of the
      # virtual machine implementing the Virtual Node.
      virtual_machine:
        # The 'architecture' field specifies the CPU architecture of
        # the Virtual Node. If it is null, the architecture of the
        # underlying host is used.
        #
        # NOTE: at present specifying the architecture does nothing.
        architecture: null
        # The 'cpu_count' field specifies the number of virtual CPUs the
        # Virtual Node has.
        cpu_count: 1
        # The 'memory_size_mib' field specifies the size in Mibibytes
        # (MiB - multiples of 1024*1024 bytes) of the Virtual Node
        # memory.
        memory_size_mib: 4192
        # The 'boot_info' block contains information about booting the
        # VM. This virtual machine class sets up for a standard boot
        # from a hard disk image. See 'ubuntu_net_boot' below for a more
        # fully featured example.
        boot_info:
          # Firmware optionally tells KVM what kind of firmware to use
          # (if any) for a BIOS boot. You can also specify 'loader'
          # information for finer grained control of BIOS settings,
          # or leave both empty to use the KVM default boot mechanism.
          firmware: ""
          # Loader
          loader: {}
          # For loaders that require NVRAM the nvram block sets up the
          # appropriate information.
          nvram: {}
          # Boot from disk (see boot_disk below) by default. Options are:
          # - hd (disk)
          # - fd (floppy)
          # - cdrom
          # - network
          dev: hd
          # Interfaces lists the names of network interfaces on which to
          # try to boot, in the order they are to be used.
          interfaces: []
          # Bootmenu specifies whether to put up a boot menu
          # (interactive booting) or not and what timeout in miliseconds
          # to use on the boot menu. Since booting is generally done
          # non-interactively, this defaults to disabled, but it can be
          # set for debugging purposes. The default value makes it
          # wait for one minute (range 0 - 65535 milliseconds) before
          # booting.
          boot_menu:
            enabled: 'no'
            timeout: '60000'
          # The start_on_creation flag tells the cluster whether to
          # start the node running during cluster creation or let the
          # application take care of it at an appropriate time. Disk
          # booted nodes are probably part of the application
          # infrastructure so default to yes.
          start_on_creation: "yes"
        # The 'boot_disk' block describes the characteristics of the
        # boot disk, including the OS image it should be created from.
        boot_disk:
          # The 'source_image' field specifies the URL of the OS or
          # installation media image from which the boot disk for each
          # Virtual Node of this class should be built.
          source_image: http://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img
          # The source checksum allows the source to be signed for
          # security purposes. The elements of this are the URL from
          # which the checksum information can be downloaded and the
          # (optional) algorithm used to produce the checksum.
          source_checksum:
            # The URL locates the file containing the checksum
            url: http://cloud-images.ubuntu.com/focal/current/SHA256SUMS
            # The algorithm field defaults to SHA256 but can be
            # provided. If the checksum file identifies the actual
            # algorithm used, that information is used and this setting
            # is ignored. In cases where the file does not identify the
            # algorithm, this is used. Supported options are MD5 and
            # SHA256.
            algorithm: SHA256
          # Media type specifies what the medium of the boot disk is at
          # download and installation time. Supported media types at the
          # moment are qcow2 and iso. For a qcow2 image, the disk is
          # presumed to be installable simply by constructing a Virtual
          # Node disk image using qemu-img and customizing it using
          # virt-customize. For an iso image, the image needs to be
          # booted into a VM and then the resulting disk image (now a
          # qcow2 image) can be customized.
          #
          # The image type interacts with distro.style because, while
          # Ubuntu and other Debian style distros seem to be available
          # as live qcow2 images, RedHat style seem to be available only
          # as iso installation images that need to be booted into and
          # (generally) installed using kickstart. For RedHat images,
          # then, the customization is done using and no virt-customize
          # steps are used. For Ubuntu, if the image is an iso image, it
          # will be booted to get the qcow, then customized using
          # virt-customize.
          media_type: qcow2
          # The 'disk_size_mb' field specifies the size in megabytes
          # (MB -- multiples of 1,000,000 bytes) of the disk and file
          # system to be created from the source image.
          disk_size_mb: 50000 # 50GB gives us some room to work with
          # The target device tells libvirt what disk device to attach
          # this disk to when creating the Virtual Node. This needs to
          # be unique among additional disks and the boot disk
          target_device: vda
        additional_disks:
          first_scratch_disk:
            # The 'source_image' field specifies the URL of an
            # optional QCOW image from which this disk should be
            # initialized. If this is null or not provided, the disk
            # will be an empty disk.
            source_image: null
            # The source checksum block can be used to validate a source
            # image. See the 'boot_disk' source information for more
            # details.
            source_checksum: {}
            # The source checksum allows the source to be signed for
            # security purposes. None specified here because no image
            # was specified. If one were specified it would be a URL to
            # a checksum file generated by the provider of the source
            # image.
            source_checksum: null
            # The source checksum algorithm defaults to SHA256 but can
            # be specified here. If the checksum file indicates a the
            # actual algorithm used, that information is used and this
            # setting is ignored. In cases where the file does not
            # identify the algorithm, this is used. Supported options
            # are MD5 and SHA256.
            source_checksum_algorithm: SHA256
            # Media type specifies what medium the disk image
            # is. For non-boot disks, the only medium that is currently
            # supported is qcow2.
            media_type: qcow2
            # The 'disk_size_mb' field specifies the size in megabytes
            # (MB -- multiples of 1,000,000 bytes) of the disk.
            disk_size_mb: 50000 # 50GB
            # The target device tells libvirt what disk device to attach
            # this disk to when creating the Virtual Node. This needs to
            # be unique among additional disks and the boot disk
            target_device: vdb
            # The 'delete' flag can be specified in a derived class to
            # delete this additional disk from the derived class. It
            # is shown here as 'true' so that derived classes won't
            # inherit an additional disk by default.
            delete: true
            # The 'partitions' block specifies the characteristics of
            # any partitions to be created on the disk.
            partitions:
              whole_disk:
                # The 'partition_number' field identifies the partition
                # number in the partition table of the disk to which the
                # partition is assigned.
                partition_number: 0
                # The 'partition_size_gb' field specifies the size of
                # the partition in gigabytes (GB). If it is missing or
                # null, this partition fills up all remaining space on
                # the disk once all partitions with specified sizes are
                # created. There can only be one partition with a null
                # or missing size.
                partition_size_gb: null
                # The 'fs_type' field specifies the type of file system
                # (if any) to be created on the partition.
                fs_type: ext4
                # The 'delete' flag can be specified in a derived
                # class to delete this partition from the disk. It is
                # shown here as 'false' for completeness.
                delete: false
      node_naming:
        # This block drives naming of nodes of this type within the
        # context of libvirt (i.e. the virtual machine name). At a
        # minimum, this block must contain a 'base_name' field that
        # specifies the base name for numbered instances of nodes. An
        # optional 'node_names' list may be specified as well. Virtual
        # Nodes created from this class will be named first from the
        # list of node names until that is exhausted, then will be
        # assigned a 'numbered' node name composed as follows:
        #
        #     <base-name>-<instance number>
        #
        # for all instances for which a 'node_name' entry does not
        # exist.
        base_name: ubuntu-node
        node_names: []
      host_naming: {}
        # This block drives network host naming of nodes of this type. At a
        # minimum, this block must contain a 'base_name' field that
        # specifies the base name for numbered instances of nodes. An
        # optional 'hostnames' list may be specified as well. Virtual
        # Nodes created from this class will assigned host namesn first
        # from the list of host names until that is exhausted, then will be
        # assigned a 'numbered' host name composed as follows:
        #
        #     <base-name>-<instance number>
        #
        # for all instances for which a 'host_name' entry does not
        # exist. In adition to the naming rules above, there is also an
        # optional per-network suffix that can be applied to a host name
        # to differentiate the host on that network in DNS. See
        #
        #    network_interfaces.addr_info.hostname_suffix
        #
        # below.
        #
        # The following are example values:
        #
        # base_name: ubuntu-host
        # hostnames: []
      network_interfaces:
        # The list of network interfaces to nodes of this type and the
        # configuration for each network connection. These associate
        # an interface on the Virtual Node with a Virtual Network
        # defined in the 'networks' section above.
        my_network:
          # The 'delete' flag can be specified in a derived class to
          # delete this interface from the configuration for Virtual
          # Nodes of the derived class. It is set to 'true' here
          # because this network interface is here as an example
          # only. A derived Virtual Node class should define real,
          # valid network interfaces.
          delete: true
          # The 'cluster_network' field identifies the network (from
          # the networks configuration above) to which this interface
          # is connected.
          cluster_network: examplenet
          # class The 'addr_info' block assigns addresses to the
          # interface. Each sub-block can define addressing for a
          # different address family.
          #
          # At the moment only AF_INET is implemented.
          addr_info:
            ipv4:
              # Address family identifies the address family to
              # associate this configuration with in the corresponding
              # cluster (Layer 3) network definition. It should match
              # one of the entries there.
              family: AF_INET
              # The addressing mode ('mode') may be 'static',
              # 'reserved' or 'dynamic'.
              #
              # Nodes in a 'static' node class have their configuration
              # written into their netplan configuration and do not
              # require a DHCP server.  Nodes in a 'reserved' node class
              # have DHCP reservations containing their
              # configuration. Nodes in a 'dynamic' node class receive
              # dynamic configuration from a DHCP server.
              mode: reserved
              # The 'addresses' list contains 'static' or
              # 'reserved' IP addresses to be assigned
              # one-to-one to node instances in that class. If the
              # number of node instances exceeds the number of
              # configured IP addresses, all node instances beyond the
              # number of configured addresses fall back to 'dynamic'
              # configuration.
              addresses: []
              # The 'hostname_suffix' field specifies a local hostname
              # suffix that will be appended to the generated node
              # hostname for hostname computations that specify this
              # network. If it is an empty string or unspecified, the
              # node hostname will be used unmodified on this network.
              hostname_suffix: "-mynet"
      # Applications sometimes need concrete configuration information
      # that is most appropriately stored with the objects implemented
      # within the layers instead of trying to map information onto
      # those objects abstractly at the application layer. The
      # application_metadata section of the configuration is only
      # understood by a given application layer and provides a place to
      # put such information. The intent here is that a specific
      # configuration set used for a given application may place
      # metadata with API objects for use by the application itself. Use
      # of application_metadata should be done sparingly and with
      # caution because it has the power to entangle a given vTDS stack
      # and make it non-portable.
      application_metadata: {}
    ubuntu_net_boot:
      pure_base_class: true
      # Use the ubuntu_24_04_node class as a base class and tweak it for
      # network booting
      parent_class: ubuntu_24_04_node
      virtual_machine:
        boot_info:
          # Firmware optionally tells KVM what kind of firmware to use
          # (if any) for a BIOS boot. You can also specify 'loader'
          # information for finer grained control of BIOS settings,
          # or leave both empty to use the KVM default boot mechanism.
          firmware: ""
          # Loader
          loader:
            path: /usr/share/OVMF/OVMF_CODE.secboot.fd
            readonly: "yes"
            secure: "no"
            type: pflash
          # For loaders that require NVRAM the nvram block sets up the
          # appropriate information.
          nvram:
            template: /usr/share/OVMF/OVMF_VARS.fd
            template_format: ""
          # Boot from network
          dev: network
          # Interfaces lists the names of network interfaces on which to
          # try to boot, in the order they are to be used.
          interfaces:
            - my_network
          # The start_on_creation flag tells the cluster whether to
          # start the node running during cluster creation or let the
          # application take care of it at an appropriate time. For
          # net-booting the assumption is that the application will
          # provide the net-boot infrastructure, so we don't need / want
          # to start the node on creation of the cluster. Default to 'no'.
          start_on_creation: "no"
        # The 'boot_disk' block describes the characteristics of the
        # boot disk, including the OS image it should be created
        # from. In this case, there is no boot disk specified, so there
        # is no block here.
        boot_disk:
          __replace_dict:
            media_type: null
    rocky_linux_node:
      pure_base_class: true
      # Use the ubuntu_24_04_node class as a base class and tweak it for
      # Rocky Linux (which is RedHat based)
      parent_class: ubuntu_24_04_node
      distro:
        family: RedHat
      virtual_machine:
        boot_disk:
          # The distro is Rocky, so use that instead of Ubuntu.
          source_image: https://dl.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9-latest-x86_64-minimal.iso
          source_checksum:
            # The URL locates the file containing the checksum
            url: |
              https://dl.rockylinux.org/pub/rocky/9/isos/x86_64/Rocky-9-latest-x86_64-minimal.iso.CHECKSUM
            # The algorithm field defaults to SHA256 but can be
            # provided. If the checksum file identifies the actual
            # algorithm used, that information is used and this setting
            # is ignored. In cases where the file does not identify the
            # algorithm, this is used. Supported options are MD5 and
            # SHA256.
            algorithm: SHA256
          media_type: iso
    rocky_net_boot:
      pure_base_class: true
      parent_class: ubuntu_net_boot
      distro:
        family: RedHat
