# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'CatalogTemplateResourceArgs',
    'CatalogTemplateResourceArgsDict',
    'CloudAccountAwsArgs',
    'CloudAccountAwsArgsDict',
    'CloudAccountAzureArgs',
    'CloudAccountAzureArgsDict',
    'CloudAccountGcpArgs',
    'CloudAccountGcpArgsDict',
    'CloudAccountNgsArgs',
    'CloudAccountNgsArgsDict',
    'DomainRouteHeadersArgs',
    'DomainRouteHeadersArgsDict',
    'DomainRouteHeadersRequestArgs',
    'DomainRouteHeadersRequestArgsDict',
    'DomainSpecArgs',
    'DomainSpecArgsDict',
    'DomainSpecPortArgs',
    'DomainSpecPortArgsDict',
    'DomainSpecPortCorsArgs',
    'DomainSpecPortCorsArgsDict',
    'DomainSpecPortCorsAllowOriginArgs',
    'DomainSpecPortCorsAllowOriginArgsDict',
    'DomainSpecPortTlsArgs',
    'DomainSpecPortTlsArgsDict',
    'DomainSpecPortTlsClientCertificateArgs',
    'DomainSpecPortTlsClientCertificateArgsDict',
    'DomainSpecPortTlsServerCertificateArgs',
    'DomainSpecPortTlsServerCertificateArgsDict',
    'DomainStatusArgs',
    'DomainStatusArgsDict',
    'DomainStatusDnsConfigArgs',
    'DomainStatusDnsConfigArgsDict',
    'DomainStatusEndpointArgs',
    'DomainStatusEndpointArgsDict',
    'DomainStatusLocationArgs',
    'DomainStatusLocationArgsDict',
    'GroupIdentityMatcherArgs',
    'GroupIdentityMatcherArgsDict',
    'GroupMemberQueryArgs',
    'GroupMemberQueryArgsDict',
    'GroupMemberQuerySpecArgs',
    'GroupMemberQuerySpecArgsDict',
    'GroupMemberQuerySpecTermArgs',
    'GroupMemberQuerySpecTermArgsDict',
    'GvcControlplaneTracingArgs',
    'GvcControlplaneTracingArgsDict',
    'GvcKedaArgs',
    'GvcKedaArgsDict',
    'GvcLightstepTracingArgs',
    'GvcLightstepTracingArgsDict',
    'GvcLoadBalancerArgs',
    'GvcLoadBalancerArgsDict',
    'GvcLoadBalancerMultiZoneArgs',
    'GvcLoadBalancerMultiZoneArgsDict',
    'GvcLoadBalancerRedirectArgs',
    'GvcLoadBalancerRedirectArgsDict',
    'GvcLoadBalancerRedirectClassArgs',
    'GvcLoadBalancerRedirectClassArgsDict',
    'GvcOtelTracingArgs',
    'GvcOtelTracingArgsDict',
    'GvcSidecarArgs',
    'GvcSidecarArgsDict',
    'IdentityAwsAccessPolicyArgs',
    'IdentityAwsAccessPolicyArgsDict',
    'IdentityAwsAccessPolicyTrustPolicyArgs',
    'IdentityAwsAccessPolicyTrustPolicyArgsDict',
    'IdentityAzureAccessPolicyArgs',
    'IdentityAzureAccessPolicyArgsDict',
    'IdentityAzureAccessPolicyRoleAssignmentArgs',
    'IdentityAzureAccessPolicyRoleAssignmentArgsDict',
    'IdentityGcpAccessPolicyArgs',
    'IdentityGcpAccessPolicyArgsDict',
    'IdentityGcpAccessPolicyBindingArgs',
    'IdentityGcpAccessPolicyBindingArgsDict',
    'IdentityNativeNetworkResourceArgs',
    'IdentityNativeNetworkResourceArgsDict',
    'IdentityNativeNetworkResourceAwsPrivateLinkArgs',
    'IdentityNativeNetworkResourceAwsPrivateLinkArgsDict',
    'IdentityNativeNetworkResourceGcpServiceConnectArgs',
    'IdentityNativeNetworkResourceGcpServiceConnectArgsDict',
    'IdentityNetworkResourceArgs',
    'IdentityNetworkResourceArgsDict',
    'IdentityNgsAccessPolicyArgs',
    'IdentityNgsAccessPolicyArgsDict',
    'IdentityNgsAccessPolicyPubArgs',
    'IdentityNgsAccessPolicyPubArgsDict',
    'IdentityNgsAccessPolicyRespArgs',
    'IdentityNgsAccessPolicyRespArgsDict',
    'IdentityNgsAccessPolicySubArgs',
    'IdentityNgsAccessPolicySubArgsDict',
    'IpSetLocationArgs',
    'IpSetLocationArgsDict',
    'IpSetStatusArgs',
    'IpSetStatusArgsDict',
    'IpSetStatusIpAddressArgs',
    'IpSetStatusIpAddressArgsDict',
    'LocationGeoArgs',
    'LocationGeoArgsDict',
    'Mk8sAddOnsArgs',
    'Mk8sAddOnsArgsDict',
    'Mk8sAddOnsAwsEcrArgs',
    'Mk8sAddOnsAwsEcrArgsDict',
    'Mk8sAddOnsAwsEfsArgs',
    'Mk8sAddOnsAwsEfsArgsDict',
    'Mk8sAddOnsAwsElbArgs',
    'Mk8sAddOnsAwsElbArgsDict',
    'Mk8sAddOnsAzureAcrArgs',
    'Mk8sAddOnsAzureAcrArgsDict',
    'Mk8sAddOnsAzureWorkloadIdentityArgs',
    'Mk8sAddOnsAzureWorkloadIdentityArgsDict',
    'Mk8sAddOnsByokArgs',
    'Mk8sAddOnsByokArgsDict',
    'Mk8sAddOnsByokConfigArgs',
    'Mk8sAddOnsByokConfigArgsDict',
    'Mk8sAddOnsByokConfigActuatorArgs',
    'Mk8sAddOnsByokConfigActuatorArgsDict',
    'Mk8sAddOnsByokConfigCommonArgs',
    'Mk8sAddOnsByokConfigCommonArgsDict',
    'Mk8sAddOnsByokConfigCommonPdbArgs',
    'Mk8sAddOnsByokConfigCommonPdbArgsDict',
    'Mk8sAddOnsByokConfigIngressArgs',
    'Mk8sAddOnsByokConfigIngressArgsDict',
    'Mk8sAddOnsByokConfigInternalDnsArgs',
    'Mk8sAddOnsByokConfigInternalDnsArgsDict',
    'Mk8sAddOnsByokConfigIstioArgs',
    'Mk8sAddOnsByokConfigIstioArgsDict',
    'Mk8sAddOnsByokConfigIstioIngressGatewayArgs',
    'Mk8sAddOnsByokConfigIstioIngressGatewayArgsDict',
    'Mk8sAddOnsByokConfigIstioIstiodArgs',
    'Mk8sAddOnsByokConfigIstioIstiodArgsDict',
    'Mk8sAddOnsByokConfigIstioSidecarArgs',
    'Mk8sAddOnsByokConfigIstioSidecarArgsDict',
    'Mk8sAddOnsByokConfigLogSplitterArgs',
    'Mk8sAddOnsByokConfigLogSplitterArgsDict',
    'Mk8sAddOnsByokConfigLonghornArgs',
    'Mk8sAddOnsByokConfigLonghornArgsDict',
    'Mk8sAddOnsByokConfigMiddleboxArgs',
    'Mk8sAddOnsByokConfigMiddleboxArgsDict',
    'Mk8sAddOnsByokConfigMonitoringArgs',
    'Mk8sAddOnsByokConfigMonitoringArgsDict',
    'Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgs',
    'Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgsDict',
    'Mk8sAddOnsByokConfigMonitoringPrometheusArgs',
    'Mk8sAddOnsByokConfigMonitoringPrometheusArgsDict',
    'Mk8sAddOnsByokConfigMonitoringPrometheusMainArgs',
    'Mk8sAddOnsByokConfigMonitoringPrometheusMainArgsDict',
    'Mk8sAddOnsByokConfigRedisArgs',
    'Mk8sAddOnsByokConfigRedisArgsDict',
    'Mk8sAddOnsByokConfigRedisHaArgs',
    'Mk8sAddOnsByokConfigRedisHaArgsDict',
    'Mk8sAddOnsByokConfigRedisSentinelArgs',
    'Mk8sAddOnsByokConfigRedisSentinelArgsDict',
    'Mk8sAddOnsByokConfigTempoAgentArgs',
    'Mk8sAddOnsByokConfigTempoAgentArgsDict',
    'Mk8sAddOnsLogsArgs',
    'Mk8sAddOnsLogsArgsDict',
    'Mk8sAddOnsMetricsArgs',
    'Mk8sAddOnsMetricsArgsDict',
    'Mk8sAddOnsMetricsScrapeAnnotatedArgs',
    'Mk8sAddOnsMetricsScrapeAnnotatedArgsDict',
    'Mk8sAddOnsNvidiaArgs',
    'Mk8sAddOnsNvidiaArgsDict',
    'Mk8sAddOnsRegistryMirrorArgs',
    'Mk8sAddOnsRegistryMirrorArgsDict',
    'Mk8sAddOnsRegistryMirrorMirrorArgs',
    'Mk8sAddOnsRegistryMirrorMirrorArgsDict',
    'Mk8sAwsProviderArgs',
    'Mk8sAwsProviderArgsDict',
    'Mk8sAwsProviderAutoscalerArgs',
    'Mk8sAwsProviderAutoscalerArgsDict',
    'Mk8sAwsProviderDeployRoleChainArgs',
    'Mk8sAwsProviderDeployRoleChainArgsDict',
    'Mk8sAwsProviderImageArgs',
    'Mk8sAwsProviderImageArgsDict',
    'Mk8sAwsProviderNetworkingArgs',
    'Mk8sAwsProviderNetworkingArgsDict',
    'Mk8sAwsProviderNodePoolArgs',
    'Mk8sAwsProviderNodePoolArgsDict',
    'Mk8sAwsProviderNodePoolOverrideImageArgs',
    'Mk8sAwsProviderNodePoolOverrideImageArgsDict',
    'Mk8sAwsProviderNodePoolTaintArgs',
    'Mk8sAwsProviderNodePoolTaintArgsDict',
    'Mk8sAzureProviderArgs',
    'Mk8sAzureProviderArgsDict',
    'Mk8sAzureProviderAutoscalerArgs',
    'Mk8sAzureProviderAutoscalerArgsDict',
    'Mk8sAzureProviderImageArgs',
    'Mk8sAzureProviderImageArgsDict',
    'Mk8sAzureProviderImageReferenceArgs',
    'Mk8sAzureProviderImageReferenceArgsDict',
    'Mk8sAzureProviderNetworkingArgs',
    'Mk8sAzureProviderNetworkingArgsDict',
    'Mk8sAzureProviderNodePoolArgs',
    'Mk8sAzureProviderNodePoolArgsDict',
    'Mk8sAzureProviderNodePoolOverrideImageArgs',
    'Mk8sAzureProviderNodePoolOverrideImageArgsDict',
    'Mk8sAzureProviderNodePoolOverrideImageReferenceArgs',
    'Mk8sAzureProviderNodePoolOverrideImageReferenceArgsDict',
    'Mk8sAzureProviderNodePoolTaintArgs',
    'Mk8sAzureProviderNodePoolTaintArgsDict',
    'Mk8sDigitalOceanProviderArgs',
    'Mk8sDigitalOceanProviderArgsDict',
    'Mk8sDigitalOceanProviderAutoscalerArgs',
    'Mk8sDigitalOceanProviderAutoscalerArgsDict',
    'Mk8sDigitalOceanProviderNetworkingArgs',
    'Mk8sDigitalOceanProviderNetworkingArgsDict',
    'Mk8sDigitalOceanProviderNodePoolArgs',
    'Mk8sDigitalOceanProviderNodePoolArgsDict',
    'Mk8sDigitalOceanProviderNodePoolTaintArgs',
    'Mk8sDigitalOceanProviderNodePoolTaintArgsDict',
    'Mk8sEphemeralProviderArgs',
    'Mk8sEphemeralProviderArgsDict',
    'Mk8sEphemeralProviderNodePoolArgs',
    'Mk8sEphemeralProviderNodePoolArgsDict',
    'Mk8sEphemeralProviderNodePoolTaintArgs',
    'Mk8sEphemeralProviderNodePoolTaintArgsDict',
    'Mk8sFirewallArgs',
    'Mk8sFirewallArgsDict',
    'Mk8sGcpProviderArgs',
    'Mk8sGcpProviderArgsDict',
    'Mk8sGcpProviderAutoscalerArgs',
    'Mk8sGcpProviderAutoscalerArgsDict',
    'Mk8sGcpProviderImageArgs',
    'Mk8sGcpProviderImageArgsDict',
    'Mk8sGcpProviderImageFamilyArgs',
    'Mk8sGcpProviderImageFamilyArgsDict',
    'Mk8sGcpProviderNetworkingArgs',
    'Mk8sGcpProviderNetworkingArgsDict',
    'Mk8sGcpProviderNodePoolArgs',
    'Mk8sGcpProviderNodePoolArgsDict',
    'Mk8sGcpProviderNodePoolOverrideImageArgs',
    'Mk8sGcpProviderNodePoolOverrideImageArgsDict',
    'Mk8sGcpProviderNodePoolOverrideImageFamilyArgs',
    'Mk8sGcpProviderNodePoolOverrideImageFamilyArgsDict',
    'Mk8sGcpProviderNodePoolTaintArgs',
    'Mk8sGcpProviderNodePoolTaintArgsDict',
    'Mk8sGenericProviderArgs',
    'Mk8sGenericProviderArgsDict',
    'Mk8sGenericProviderNetworkingArgs',
    'Mk8sGenericProviderNetworkingArgsDict',
    'Mk8sGenericProviderNodePoolArgs',
    'Mk8sGenericProviderNodePoolArgsDict',
    'Mk8sGenericProviderNodePoolTaintArgs',
    'Mk8sGenericProviderNodePoolTaintArgsDict',
    'Mk8sHetznerProviderArgs',
    'Mk8sHetznerProviderArgsDict',
    'Mk8sHetznerProviderAutoscalerArgs',
    'Mk8sHetznerProviderAutoscalerArgsDict',
    'Mk8sHetznerProviderDedicatedServerNodePoolArgs',
    'Mk8sHetznerProviderDedicatedServerNodePoolArgsDict',
    'Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs',
    'Mk8sHetznerProviderDedicatedServerNodePoolTaintArgsDict',
    'Mk8sHetznerProviderNetworkingArgs',
    'Mk8sHetznerProviderNetworkingArgsDict',
    'Mk8sHetznerProviderNodePoolArgs',
    'Mk8sHetznerProviderNodePoolArgsDict',
    'Mk8sHetznerProviderNodePoolTaintArgs',
    'Mk8sHetznerProviderNodePoolTaintArgsDict',
    'Mk8sLambdalabsProviderArgs',
    'Mk8sLambdalabsProviderArgsDict',
    'Mk8sLambdalabsProviderAutoscalerArgs',
    'Mk8sLambdalabsProviderAutoscalerArgsDict',
    'Mk8sLambdalabsProviderNodePoolArgs',
    'Mk8sLambdalabsProviderNodePoolArgsDict',
    'Mk8sLambdalabsProviderNodePoolTaintArgs',
    'Mk8sLambdalabsProviderNodePoolTaintArgsDict',
    'Mk8sLambdalabsProviderUnmanagedNodePoolArgs',
    'Mk8sLambdalabsProviderUnmanagedNodePoolArgsDict',
    'Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs',
    'Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgsDict',
    'Mk8sLinodeProviderArgs',
    'Mk8sLinodeProviderArgsDict',
    'Mk8sLinodeProviderAutoscalerArgs',
    'Mk8sLinodeProviderAutoscalerArgsDict',
    'Mk8sLinodeProviderNetworkingArgs',
    'Mk8sLinodeProviderNetworkingArgsDict',
    'Mk8sLinodeProviderNodePoolArgs',
    'Mk8sLinodeProviderNodePoolArgsDict',
    'Mk8sLinodeProviderNodePoolTaintArgs',
    'Mk8sLinodeProviderNodePoolTaintArgsDict',
    'Mk8sOblivusProviderArgs',
    'Mk8sOblivusProviderArgsDict',
    'Mk8sOblivusProviderAutoscalerArgs',
    'Mk8sOblivusProviderAutoscalerArgsDict',
    'Mk8sOblivusProviderNodePoolArgs',
    'Mk8sOblivusProviderNodePoolArgsDict',
    'Mk8sOblivusProviderNodePoolTaintArgs',
    'Mk8sOblivusProviderNodePoolTaintArgsDict',
    'Mk8sOblivusProviderUnmanagedNodePoolArgs',
    'Mk8sOblivusProviderUnmanagedNodePoolArgsDict',
    'Mk8sOblivusProviderUnmanagedNodePoolTaintArgs',
    'Mk8sOblivusProviderUnmanagedNodePoolTaintArgsDict',
    'Mk8sPaperspaceProviderArgs',
    'Mk8sPaperspaceProviderArgsDict',
    'Mk8sPaperspaceProviderAutoscalerArgs',
    'Mk8sPaperspaceProviderAutoscalerArgsDict',
    'Mk8sPaperspaceProviderNodePoolArgs',
    'Mk8sPaperspaceProviderNodePoolArgsDict',
    'Mk8sPaperspaceProviderNodePoolTaintArgs',
    'Mk8sPaperspaceProviderNodePoolTaintArgsDict',
    'Mk8sPaperspaceProviderUnmanagedNodePoolArgs',
    'Mk8sPaperspaceProviderUnmanagedNodePoolArgsDict',
    'Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs',
    'Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgsDict',
    'Mk8sStatusArgs',
    'Mk8sStatusArgsDict',
    'Mk8sStatusAddOnArgs',
    'Mk8sStatusAddOnArgsDict',
    'Mk8sStatusAddOnAwsEcrArgs',
    'Mk8sStatusAddOnAwsEcrArgsDict',
    'Mk8sStatusAddOnAwsEfArgs',
    'Mk8sStatusAddOnAwsEfArgsDict',
    'Mk8sStatusAddOnAwsElbArgs',
    'Mk8sStatusAddOnAwsElbArgsDict',
    'Mk8sStatusAddOnAwsWorkloadIdentityArgs',
    'Mk8sStatusAddOnAwsWorkloadIdentityArgsDict',
    'Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgs',
    'Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgsDict',
    'Mk8sStatusAddOnDashboardArgs',
    'Mk8sStatusAddOnDashboardArgsDict',
    'Mk8sStatusAddOnHeadlampArgs',
    'Mk8sStatusAddOnHeadlampArgsDict',
    'Mk8sStatusAddOnLogArgs',
    'Mk8sStatusAddOnLogArgsDict',
    'Mk8sStatusAddOnMetricArgs',
    'Mk8sStatusAddOnMetricArgsDict',
    'Mk8sTritonProviderArgs',
    'Mk8sTritonProviderArgsDict',
    'Mk8sTritonProviderAutoscalerArgs',
    'Mk8sTritonProviderAutoscalerArgsDict',
    'Mk8sTritonProviderConnectionArgs',
    'Mk8sTritonProviderConnectionArgsDict',
    'Mk8sTritonProviderLoadBalancerArgs',
    'Mk8sTritonProviderLoadBalancerArgsDict',
    'Mk8sTritonProviderLoadBalancerGatewayArgs',
    'Mk8sTritonProviderLoadBalancerGatewayArgsDict',
    'Mk8sTritonProviderLoadBalancerManualArgs',
    'Mk8sTritonProviderLoadBalancerManualArgsDict',
    'Mk8sTritonProviderLoadBalancerManualLoggingArgs',
    'Mk8sTritonProviderLoadBalancerManualLoggingArgsDict',
    'Mk8sTritonProviderLoadBalancerNoneArgs',
    'Mk8sTritonProviderLoadBalancerNoneArgsDict',
    'Mk8sTritonProviderNetworkingArgs',
    'Mk8sTritonProviderNetworkingArgsDict',
    'Mk8sTritonProviderNodePoolArgs',
    'Mk8sTritonProviderNodePoolArgsDict',
    'Mk8sTritonProviderNodePoolTaintArgs',
    'Mk8sTritonProviderNodePoolTaintArgsDict',
    'OrgAuthConfigArgs',
    'OrgAuthConfigArgsDict',
    'OrgLoggingCloudWatchLoggingArgs',
    'OrgLoggingCloudWatchLoggingArgsDict',
    'OrgLoggingCoralogixLoggingArgs',
    'OrgLoggingCoralogixLoggingArgsDict',
    'OrgLoggingDatadogLoggingArgs',
    'OrgLoggingDatadogLoggingArgsDict',
    'OrgLoggingElasticLoggingArgs',
    'OrgLoggingElasticLoggingArgsDict',
    'OrgLoggingElasticLoggingAwsArgs',
    'OrgLoggingElasticLoggingAwsArgsDict',
    'OrgLoggingElasticLoggingElasticCloudArgs',
    'OrgLoggingElasticLoggingElasticCloudArgsDict',
    'OrgLoggingElasticLoggingGenericArgs',
    'OrgLoggingElasticLoggingGenericArgsDict',
    'OrgLoggingFluentdLoggingArgs',
    'OrgLoggingFluentdLoggingArgsDict',
    'OrgLoggingLogzioLoggingArgs',
    'OrgLoggingLogzioLoggingArgsDict',
    'OrgLoggingS3LoggingArgs',
    'OrgLoggingS3LoggingArgsDict',
    'OrgLoggingStackdriverLoggingArgs',
    'OrgLoggingStackdriverLoggingArgsDict',
    'OrgLoggingSyslogLoggingArgs',
    'OrgLoggingSyslogLoggingArgsDict',
    'OrgObservabilityArgs',
    'OrgObservabilityArgsDict',
    'OrgSecurityArgs',
    'OrgSecurityArgsDict',
    'OrgSecurityThreatDetectionArgs',
    'OrgSecurityThreatDetectionArgsDict',
    'OrgSecurityThreatDetectionSyslogArgs',
    'OrgSecurityThreatDetectionSyslogArgsDict',
    'OrgStatusArgs',
    'OrgStatusArgsDict',
    'OrgTracingControlplaneTracingArgs',
    'OrgTracingControlplaneTracingArgsDict',
    'OrgTracingLightstepTracingArgs',
    'OrgTracingLightstepTracingArgsDict',
    'OrgTracingOtelTracingArgs',
    'OrgTracingOtelTracingArgsDict',
    'PolicyBindingArgs',
    'PolicyBindingArgsDict',
    'PolicyTargetQueryArgs',
    'PolicyTargetQueryArgsDict',
    'PolicyTargetQuerySpecArgs',
    'PolicyTargetQuerySpecArgsDict',
    'PolicyTargetQuerySpecTermArgs',
    'PolicyTargetQuerySpecTermArgsDict',
    'SecretAwsArgs',
    'SecretAwsArgsDict',
    'SecretAzureConnectorArgs',
    'SecretAzureConnectorArgsDict',
    'SecretEcrArgs',
    'SecretEcrArgsDict',
    'SecretKeypairArgs',
    'SecretKeypairArgsDict',
    'SecretNatsAccountArgs',
    'SecretNatsAccountArgsDict',
    'SecretOpaqueArgs',
    'SecretOpaqueArgsDict',
    'SecretTlsArgs',
    'SecretTlsArgsDict',
    'SecretUserpassArgs',
    'SecretUserpassArgsDict',
    'VolumeSetAutoscalingArgs',
    'VolumeSetAutoscalingArgsDict',
    'VolumeSetCustomEncryptionArgs',
    'VolumeSetCustomEncryptionArgsDict',
    'VolumeSetCustomEncryptionRegionsArgs',
    'VolumeSetCustomEncryptionRegionsArgsDict',
    'VolumeSetMountOptionsArgs',
    'VolumeSetMountOptionsArgsDict',
    'VolumeSetMountOptionsResourcesArgs',
    'VolumeSetMountOptionsResourcesArgsDict',
    'VolumeSetSnapshotsArgs',
    'VolumeSetSnapshotsArgsDict',
    'VolumeSetStatusArgs',
    'VolumeSetStatusArgsDict',
    'WorkloadContainerArgs',
    'WorkloadContainerArgsDict',
    'WorkloadContainerGpuCustomArgs',
    'WorkloadContainerGpuCustomArgsDict',
    'WorkloadContainerGpuNvidiaArgs',
    'WorkloadContainerGpuNvidiaArgsDict',
    'WorkloadContainerLifecycleArgs',
    'WorkloadContainerLifecycleArgsDict',
    'WorkloadContainerLifecyclePostStartArgs',
    'WorkloadContainerLifecyclePostStartArgsDict',
    'WorkloadContainerLifecyclePostStartExecArgs',
    'WorkloadContainerLifecyclePostStartExecArgsDict',
    'WorkloadContainerLifecyclePreStopArgs',
    'WorkloadContainerLifecyclePreStopArgsDict',
    'WorkloadContainerLifecyclePreStopExecArgs',
    'WorkloadContainerLifecyclePreStopExecArgsDict',
    'WorkloadContainerLivenessProbeArgs',
    'WorkloadContainerLivenessProbeArgsDict',
    'WorkloadContainerLivenessProbeExecArgs',
    'WorkloadContainerLivenessProbeExecArgsDict',
    'WorkloadContainerLivenessProbeGrpcArgs',
    'WorkloadContainerLivenessProbeGrpcArgsDict',
    'WorkloadContainerLivenessProbeHttpGetArgs',
    'WorkloadContainerLivenessProbeHttpGetArgsDict',
    'WorkloadContainerLivenessProbeTcpSocketArgs',
    'WorkloadContainerLivenessProbeTcpSocketArgsDict',
    'WorkloadContainerMetricsArgs',
    'WorkloadContainerMetricsArgsDict',
    'WorkloadContainerPortArgs',
    'WorkloadContainerPortArgsDict',
    'WorkloadContainerReadinessProbeArgs',
    'WorkloadContainerReadinessProbeArgsDict',
    'WorkloadContainerReadinessProbeExecArgs',
    'WorkloadContainerReadinessProbeExecArgsDict',
    'WorkloadContainerReadinessProbeGrpcArgs',
    'WorkloadContainerReadinessProbeGrpcArgsDict',
    'WorkloadContainerReadinessProbeHttpGetArgs',
    'WorkloadContainerReadinessProbeHttpGetArgsDict',
    'WorkloadContainerReadinessProbeTcpSocketArgs',
    'WorkloadContainerReadinessProbeTcpSocketArgsDict',
    'WorkloadContainerVolumeArgs',
    'WorkloadContainerVolumeArgsDict',
    'WorkloadFirewallSpecArgs',
    'WorkloadFirewallSpecArgsDict',
    'WorkloadFirewallSpecExternalArgs',
    'WorkloadFirewallSpecExternalArgsDict',
    'WorkloadFirewallSpecExternalHttpArgs',
    'WorkloadFirewallSpecExternalHttpArgsDict',
    'WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs',
    'WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict',
    'WorkloadFirewallSpecExternalOutboundAllowPortArgs',
    'WorkloadFirewallSpecExternalOutboundAllowPortArgsDict',
    'WorkloadFirewallSpecInternalArgs',
    'WorkloadFirewallSpecInternalArgsDict',
    'WorkloadJobArgs',
    'WorkloadJobArgsDict',
    'WorkloadLoadBalancerArgs',
    'WorkloadLoadBalancerArgsDict',
    'WorkloadLoadBalancerDirectArgs',
    'WorkloadLoadBalancerDirectArgsDict',
    'WorkloadLoadBalancerDirectPortArgs',
    'WorkloadLoadBalancerDirectPortArgsDict',
    'WorkloadLoadBalancerGeoLocationArgs',
    'WorkloadLoadBalancerGeoLocationArgsDict',
    'WorkloadLoadBalancerGeoLocationHeadersArgs',
    'WorkloadLoadBalancerGeoLocationHeadersArgsDict',
    'WorkloadLocalOptionArgs',
    'WorkloadLocalOptionArgsDict',
    'WorkloadLocalOptionAutoscalingArgs',
    'WorkloadLocalOptionAutoscalingArgsDict',
    'WorkloadLocalOptionAutoscalingKedaArgs',
    'WorkloadLocalOptionAutoscalingKedaArgsDict',
    'WorkloadLocalOptionAutoscalingKedaAdvancedArgs',
    'WorkloadLocalOptionAutoscalingKedaAdvancedArgsDict',
    'WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgs',
    'WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgsDict',
    'WorkloadLocalOptionAutoscalingKedaTriggerArgs',
    'WorkloadLocalOptionAutoscalingKedaTriggerArgsDict',
    'WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs',
    'WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict',
    'WorkloadLocalOptionAutoscalingMultiArgs',
    'WorkloadLocalOptionAutoscalingMultiArgsDict',
    'WorkloadLocalOptionMultiZoneArgs',
    'WorkloadLocalOptionMultiZoneArgsDict',
    'WorkloadOptionsArgs',
    'WorkloadOptionsArgsDict',
    'WorkloadOptionsAutoscalingArgs',
    'WorkloadOptionsAutoscalingArgsDict',
    'WorkloadOptionsAutoscalingKedaArgs',
    'WorkloadOptionsAutoscalingKedaArgsDict',
    'WorkloadOptionsAutoscalingKedaAdvancedArgs',
    'WorkloadOptionsAutoscalingKedaAdvancedArgsDict',
    'WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgs',
    'WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgsDict',
    'WorkloadOptionsAutoscalingKedaTriggerArgs',
    'WorkloadOptionsAutoscalingKedaTriggerArgsDict',
    'WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgs',
    'WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgsDict',
    'WorkloadOptionsAutoscalingMultiArgs',
    'WorkloadOptionsAutoscalingMultiArgsDict',
    'WorkloadOptionsMultiZoneArgs',
    'WorkloadOptionsMultiZoneArgsDict',
    'WorkloadRequestRetryPolicyArgs',
    'WorkloadRequestRetryPolicyArgsDict',
    'WorkloadRolloutOptionArgs',
    'WorkloadRolloutOptionArgsDict',
    'WorkloadSecurityOptionsArgs',
    'WorkloadSecurityOptionsArgsDict',
    'WorkloadSidecarArgs',
    'WorkloadSidecarArgsDict',
    'WorkloadStatusArgs',
    'WorkloadStatusArgsDict',
    'WorkloadStatusHealthCheckArgs',
    'WorkloadStatusHealthCheckArgsDict',
    'WorkloadStatusLoadBalancerArgs',
    'WorkloadStatusLoadBalancerArgsDict',
    'WorkloadStatusResolvedImageArgs',
    'WorkloadStatusResolvedImageArgsDict',
    'WorkloadStatusResolvedImageImageArgs',
    'WorkloadStatusResolvedImageImageArgsDict',
    'WorkloadStatusResolvedImageImageManifestArgs',
    'WorkloadStatusResolvedImageImageManifestArgsDict',
    'GetGvcControlplaneTracingArgs',
    'GetGvcControlplaneTracingArgsDict',
    'GetGvcKedaArgs',
    'GetGvcKedaArgsDict',
    'GetGvcLightstepTracingArgs',
    'GetGvcLightstepTracingArgsDict',
    'GetGvcLoadBalancerArgs',
    'GetGvcLoadBalancerArgsDict',
    'GetGvcLoadBalancerMultiZoneArgs',
    'GetGvcLoadBalancerMultiZoneArgsDict',
    'GetGvcLoadBalancerRedirectArgs',
    'GetGvcLoadBalancerRedirectArgsDict',
    'GetGvcLoadBalancerRedirectClassArgs',
    'GetGvcLoadBalancerRedirectClassArgsDict',
    'GetGvcOtelTracingArgs',
    'GetGvcOtelTracingArgsDict',
    'GetGvcSidecarArgs',
    'GetGvcSidecarArgsDict',
    'GetImagesQueryArgs',
    'GetImagesQueryArgsDict',
    'GetImagesQuerySpecArgs',
    'GetImagesQuerySpecArgsDict',
    'GetImagesQuerySpecTermArgs',
    'GetImagesQuerySpecTermArgsDict',
    'GetOrgAuthConfigArgs',
    'GetOrgAuthConfigArgsDict',
    'GetOrgObservabilityArgs',
    'GetOrgObservabilityArgsDict',
    'GetOrgSecurityArgs',
    'GetOrgSecurityArgsDict',
    'GetOrgSecurityThreatDetectionArgs',
    'GetOrgSecurityThreatDetectionArgsDict',
    'GetOrgSecurityThreatDetectionSyslogArgs',
    'GetOrgSecurityThreatDetectionSyslogArgsDict',
    'GetSecretAwArgs',
    'GetSecretAwArgsDict',
    'GetSecretAzureConnectorArgs',
    'GetSecretAzureConnectorArgsDict',
    'GetSecretEcrArgs',
    'GetSecretEcrArgsDict',
    'GetSecretKeypairArgs',
    'GetSecretKeypairArgsDict',
    'GetSecretNatsAccountArgs',
    'GetSecretNatsAccountArgsDict',
    'GetSecretOpaqueArgs',
    'GetSecretOpaqueArgsDict',
    'GetSecretTlArgs',
    'GetSecretTlArgsDict',
    'GetSecretUserpassArgs',
    'GetSecretUserpassArgsDict',
    'GetWorkloadContainerArgs',
    'GetWorkloadContainerArgsDict',
    'GetWorkloadContainerGpuCustomArgs',
    'GetWorkloadContainerGpuCustomArgsDict',
    'GetWorkloadContainerGpuNvidiaArgs',
    'GetWorkloadContainerGpuNvidiaArgsDict',
    'GetWorkloadContainerLifecycleArgs',
    'GetWorkloadContainerLifecycleArgsDict',
    'GetWorkloadContainerLifecyclePostStartArgs',
    'GetWorkloadContainerLifecyclePostStartArgsDict',
    'GetWorkloadContainerLifecyclePostStartExecArgs',
    'GetWorkloadContainerLifecyclePostStartExecArgsDict',
    'GetWorkloadContainerLifecyclePreStopArgs',
    'GetWorkloadContainerLifecyclePreStopArgsDict',
    'GetWorkloadContainerLifecyclePreStopExecArgs',
    'GetWorkloadContainerLifecyclePreStopExecArgsDict',
    'GetWorkloadContainerLivenessProbeArgs',
    'GetWorkloadContainerLivenessProbeArgsDict',
    'GetWorkloadContainerLivenessProbeExecArgs',
    'GetWorkloadContainerLivenessProbeExecArgsDict',
    'GetWorkloadContainerLivenessProbeGrpcArgs',
    'GetWorkloadContainerLivenessProbeGrpcArgsDict',
    'GetWorkloadContainerLivenessProbeHttpGetArgs',
    'GetWorkloadContainerLivenessProbeHttpGetArgsDict',
    'GetWorkloadContainerLivenessProbeTcpSocketArgs',
    'GetWorkloadContainerLivenessProbeTcpSocketArgsDict',
    'GetWorkloadContainerMetricArgs',
    'GetWorkloadContainerMetricArgsDict',
    'GetWorkloadContainerPortArgs',
    'GetWorkloadContainerPortArgsDict',
    'GetWorkloadContainerReadinessProbeArgs',
    'GetWorkloadContainerReadinessProbeArgsDict',
    'GetWorkloadContainerReadinessProbeExecArgs',
    'GetWorkloadContainerReadinessProbeExecArgsDict',
    'GetWorkloadContainerReadinessProbeGrpcArgs',
    'GetWorkloadContainerReadinessProbeGrpcArgsDict',
    'GetWorkloadContainerReadinessProbeHttpGetArgs',
    'GetWorkloadContainerReadinessProbeHttpGetArgsDict',
    'GetWorkloadContainerReadinessProbeTcpSocketArgs',
    'GetWorkloadContainerReadinessProbeTcpSocketArgsDict',
    'GetWorkloadContainerVolumeArgs',
    'GetWorkloadContainerVolumeArgsDict',
    'GetWorkloadFirewallSpecArgs',
    'GetWorkloadFirewallSpecArgsDict',
    'GetWorkloadFirewallSpecExternalArgs',
    'GetWorkloadFirewallSpecExternalArgsDict',
    'GetWorkloadFirewallSpecExternalHttpArgs',
    'GetWorkloadFirewallSpecExternalHttpArgsDict',
    'GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs',
    'GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict',
    'GetWorkloadFirewallSpecExternalOutboundAllowPortArgs',
    'GetWorkloadFirewallSpecExternalOutboundAllowPortArgsDict',
    'GetWorkloadFirewallSpecInternalArgs',
    'GetWorkloadFirewallSpecInternalArgsDict',
    'GetWorkloadJobArgs',
    'GetWorkloadJobArgsDict',
    'GetWorkloadLoadBalancerArgs',
    'GetWorkloadLoadBalancerArgsDict',
    'GetWorkloadLoadBalancerDirectArgs',
    'GetWorkloadLoadBalancerDirectArgsDict',
    'GetWorkloadLoadBalancerDirectPortArgs',
    'GetWorkloadLoadBalancerDirectPortArgsDict',
    'GetWorkloadLoadBalancerGeoLocationArgs',
    'GetWorkloadLoadBalancerGeoLocationArgsDict',
    'GetWorkloadLoadBalancerGeoLocationHeaderArgs',
    'GetWorkloadLoadBalancerGeoLocationHeaderArgsDict',
    'GetWorkloadLocalOptionArgs',
    'GetWorkloadLocalOptionArgsDict',
    'GetWorkloadLocalOptionAutoscalingArgs',
    'GetWorkloadLocalOptionAutoscalingArgsDict',
    'GetWorkloadLocalOptionAutoscalingKedaArgs',
    'GetWorkloadLocalOptionAutoscalingKedaArgsDict',
    'GetWorkloadLocalOptionAutoscalingKedaAdvancedArgs',
    'GetWorkloadLocalOptionAutoscalingKedaAdvancedArgsDict',
    'GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgs',
    'GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgsDict',
    'GetWorkloadLocalOptionAutoscalingKedaTriggerArgs',
    'GetWorkloadLocalOptionAutoscalingKedaTriggerArgsDict',
    'GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs',
    'GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict',
    'GetWorkloadLocalOptionAutoscalingMultiArgs',
    'GetWorkloadLocalOptionAutoscalingMultiArgsDict',
    'GetWorkloadLocalOptionMultiZoneArgs',
    'GetWorkloadLocalOptionMultiZoneArgsDict',
    'GetWorkloadOptionArgs',
    'GetWorkloadOptionArgsDict',
    'GetWorkloadOptionAutoscalingArgs',
    'GetWorkloadOptionAutoscalingArgsDict',
    'GetWorkloadOptionAutoscalingKedaArgs',
    'GetWorkloadOptionAutoscalingKedaArgsDict',
    'GetWorkloadOptionAutoscalingKedaAdvancedArgs',
    'GetWorkloadOptionAutoscalingKedaAdvancedArgsDict',
    'GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgs',
    'GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgsDict',
    'GetWorkloadOptionAutoscalingKedaTriggerArgs',
    'GetWorkloadOptionAutoscalingKedaTriggerArgsDict',
    'GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgs',
    'GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgsDict',
    'GetWorkloadOptionAutoscalingMultiArgs',
    'GetWorkloadOptionAutoscalingMultiArgsDict',
    'GetWorkloadOptionMultiZoneArgs',
    'GetWorkloadOptionMultiZoneArgsDict',
    'GetWorkloadRequestRetryPolicyArgs',
    'GetWorkloadRequestRetryPolicyArgsDict',
    'GetWorkloadRolloutOptionArgs',
    'GetWorkloadRolloutOptionArgsDict',
    'GetWorkloadSecurityOptionArgs',
    'GetWorkloadSecurityOptionArgsDict',
    'GetWorkloadSidecarArgs',
    'GetWorkloadSidecarArgsDict',
]

MYPY = False

if not MYPY:
    class CatalogTemplateResourceArgsDict(TypedDict):
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The kind of resource (e.g., 'workload', 'secret', 'gvc').
        """
        link: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full Control Plane link to the resource.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the resource.
        """
elif False:
    CatalogTemplateResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CatalogTemplateResourceArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 link: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] kind: The kind of resource (e.g., 'workload', 'secret', 'gvc').
        :param pulumi.Input[_builtins.str] link: The full Control Plane link to the resource.
        :param pulumi.Input[_builtins.str] name: The name of the resource.
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The kind of resource (e.g., 'workload', 'secret', 'gvc').
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full Control Plane link to the resource.
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "link", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CloudAccountAwsArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Amazon Resource Name (ARN) Role.
        """
elif False:
    CloudAccountAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccountAwsArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] role_arn: Amazon Resource Name (ARN) Role.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Amazon Resource Name (ARN) Role.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class CloudAccountAzureArgsDict(TypedDict):
        secret_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full link to an Azure secret. (e.g., /org/ORG_NAME/secret/AZURE_SECRET).
        """
elif False:
    CloudAccountAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccountAzureArgs:
    def __init__(__self__, *,
                 secret_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_link: Full link to an Azure secret. (e.g., /org/ORG_NAME/secret/AZURE_SECRET).
        """
        if secret_link is not None:
            pulumi.set(__self__, "secret_link", secret_link)

    @_builtins.property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full link to an Azure secret. (e.g., /org/ORG_NAME/secret/AZURE_SECRET).
        """
        return pulumi.get(self, "secret_link")

    @secret_link.setter
    def secret_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_link", value)


if not MYPY:
    class CloudAccountGcpArgsDict(TypedDict):
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        GCP project ID. Obtained from the GCP cloud console.
        """
elif False:
    CloudAccountGcpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccountGcpArgs:
    def __init__(__self__, *,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] project_id: GCP project ID. Obtained from the GCP cloud console.
        """
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GCP project ID. Obtained from the GCP cloud console.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class CloudAccountNgsArgsDict(TypedDict):
        secret_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full link to a NATS Account Secret secret. (e.g., /org/ORG_NAME/secret/NATS_ACCOUNT_SECRET).
        """
elif False:
    CloudAccountNgsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudAccountNgsArgs:
    def __init__(__self__, *,
                 secret_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_link: Full link to a NATS Account Secret secret. (e.g., /org/ORG_NAME/secret/NATS_ACCOUNT_SECRET).
        """
        if secret_link is not None:
            pulumi.set(__self__, "secret_link", secret_link)

    @_builtins.property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full link to a NATS Account Secret secret. (e.g., /org/ORG_NAME/secret/NATS_ACCOUNT_SECRET).
        """
        return pulumi.get(self, "secret_link")

    @secret_link.setter
    def secret_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_link", value)


if not MYPY:
    class DomainRouteHeadersArgsDict(TypedDict):
        request: NotRequired[pulumi.Input['DomainRouteHeadersRequestArgsDict']]
        """
        Manipulates HTTP headers.
        """
elif False:
    DomainRouteHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRouteHeadersArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input['DomainRouteHeadersRequestArgs']] = None):
        """
        :param pulumi.Input['DomainRouteHeadersRequestArgs'] request: Manipulates HTTP headers.
        """
        if request is not None:
            pulumi.set(__self__, "request", request)

    @_builtins.property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['DomainRouteHeadersRequestArgs']]:
        """
        Manipulates HTTP headers.
        """
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['DomainRouteHeadersRequestArgs']]):
        pulumi.set(self, "request", value)


if not MYPY:
    class DomainRouteHeadersRequestArgsDict(TypedDict):
        set: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Sets or overrides headers to all http requests for this route.
        """
elif False:
    DomainRouteHeadersRequestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainRouteHeadersRequestArgs:
    def __init__(__self__, *,
                 set: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] set: Sets or overrides headers to all http requests for this route.
        """
        if set is not None:
            pulumi.set(__self__, "set", set)

    @_builtins.property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Sets or overrides headers to all http requests for this route.
        """
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "set", value)


if not MYPY:
    class DomainSpecArgsDict(TypedDict):
        accept_all_hosts: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Allows domain to accept wildcards. The associated GVC must have dedicated load balancing enabled.
        """
        accept_all_subdomains: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Accept all subdomains will accept any host that is a sub domain of the domain so *.$DOMAIN
        """
        cert_challenge_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the method used to prove domain ownership for certificate issuance.
        """
        dns_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        In `cname` dnsMode, Control Plane will configure workloads to accept traffic for the domain but will not manage DNS records for the domain. End users must configure CNAME records in their own DNS pointed to the canonical workload endpoint. Currently `cname` dnsMode requires that a TLS server certificate be configured when subdomain based routing is used. In `ns` dnsMode, Control Plane will manage the subdomains and create all necessary DNS records. End users configure NS records to forward DNS requests to the Control Plane managed DNS servers. Valid values: `cname`, `ns`. Default: `cname`.
        """
        gvc_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        This value is set to a target GVC (using a full link) for use by subdomain based routing. Each workload in the GVC will receive a subdomain in the form ${workload.name}.${domain.name}. **Do not include if path based routing is used.**
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortArgsDict']]]]
        """
        Domain port specifications.
        """
        workload_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creates a unique subdomain for each replica of a stateful workload, enabling direct access to individual instances.
        """
elif False:
    DomainSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecArgs:
    def __init__(__self__, *,
                 accept_all_hosts: Optional[pulumi.Input[_builtins.bool]] = None,
                 accept_all_subdomains: Optional[pulumi.Input[_builtins.bool]] = None,
                 cert_challenge_type: Optional[pulumi.Input[_builtins.str]] = None,
                 dns_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 gvc_link: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortArgs']]]] = None,
                 workload_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] accept_all_hosts: Allows domain to accept wildcards. The associated GVC must have dedicated load balancing enabled.
        :param pulumi.Input[_builtins.bool] accept_all_subdomains: Accept all subdomains will accept any host that is a sub domain of the domain so *.$DOMAIN
        :param pulumi.Input[_builtins.str] cert_challenge_type: Defines the method used to prove domain ownership for certificate issuance.
        :param pulumi.Input[_builtins.str] dns_mode: In `cname` dnsMode, Control Plane will configure workloads to accept traffic for the domain but will not manage DNS records for the domain. End users must configure CNAME records in their own DNS pointed to the canonical workload endpoint. Currently `cname` dnsMode requires that a TLS server certificate be configured when subdomain based routing is used. In `ns` dnsMode, Control Plane will manage the subdomains and create all necessary DNS records. End users configure NS records to forward DNS requests to the Control Plane managed DNS servers. Valid values: `cname`, `ns`. Default: `cname`.
        :param pulumi.Input[_builtins.str] gvc_link: This value is set to a target GVC (using a full link) for use by subdomain based routing. Each workload in the GVC will receive a subdomain in the form ${workload.name}.${domain.name}. **Do not include if path based routing is used.**
        :param pulumi.Input[Sequence[pulumi.Input['DomainSpecPortArgs']]] ports: Domain port specifications.
        :param pulumi.Input[_builtins.str] workload_link: Creates a unique subdomain for each replica of a stateful workload, enabling direct access to individual instances.
        """
        if accept_all_hosts is not None:
            pulumi.set(__self__, "accept_all_hosts", accept_all_hosts)
        if accept_all_subdomains is not None:
            pulumi.set(__self__, "accept_all_subdomains", accept_all_subdomains)
        if cert_challenge_type is not None:
            pulumi.set(__self__, "cert_challenge_type", cert_challenge_type)
        if dns_mode is not None:
            pulumi.set(__self__, "dns_mode", dns_mode)
        if gvc_link is not None:
            pulumi.set(__self__, "gvc_link", gvc_link)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if workload_link is not None:
            pulumi.set(__self__, "workload_link", workload_link)

    @_builtins.property
    @pulumi.getter(name="acceptAllHosts")
    def accept_all_hosts(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Allows domain to accept wildcards. The associated GVC must have dedicated load balancing enabled.
        """
        return pulumi.get(self, "accept_all_hosts")

    @accept_all_hosts.setter
    def accept_all_hosts(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_all_hosts", value)

    @_builtins.property
    @pulumi.getter(name="acceptAllSubdomains")
    def accept_all_subdomains(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Accept all subdomains will accept any host that is a sub domain of the domain so *.$DOMAIN
        """
        return pulumi.get(self, "accept_all_subdomains")

    @accept_all_subdomains.setter
    def accept_all_subdomains(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "accept_all_subdomains", value)

    @_builtins.property
    @pulumi.getter(name="certChallengeType")
    def cert_challenge_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the method used to prove domain ownership for certificate issuance.
        """
        return pulumi.get(self, "cert_challenge_type")

    @cert_challenge_type.setter
    def cert_challenge_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert_challenge_type", value)

    @_builtins.property
    @pulumi.getter(name="dnsMode")
    def dns_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        In `cname` dnsMode, Control Plane will configure workloads to accept traffic for the domain but will not manage DNS records for the domain. End users must configure CNAME records in their own DNS pointed to the canonical workload endpoint. Currently `cname` dnsMode requires that a TLS server certificate be configured when subdomain based routing is used. In `ns` dnsMode, Control Plane will manage the subdomains and create all necessary DNS records. End users configure NS records to forward DNS requests to the Control Plane managed DNS servers. Valid values: `cname`, `ns`. Default: `cname`.
        """
        return pulumi.get(self, "dns_mode")

    @dns_mode.setter
    def dns_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_mode", value)

    @_builtins.property
    @pulumi.getter(name="gvcLink")
    def gvc_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        This value is set to a target GVC (using a full link) for use by subdomain based routing. Each workload in the GVC will receive a subdomain in the form ${workload.name}.${domain.name}. **Do not include if path based routing is used.**
        """
        return pulumi.get(self, "gvc_link")

    @gvc_link.setter
    def gvc_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gvc_link", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortArgs']]]]:
        """
        Domain port specifications.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="workloadLink")
    def workload_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creates a unique subdomain for each replica of a stateful workload, enabling direct access to individual instances.
        """
        return pulumi.get(self, "workload_link")

    @workload_link.setter
    def workload_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_link", value)


if not MYPY:
    class DomainSpecPortArgsDict(TypedDict):
        cors: NotRequired[pulumi.Input['DomainSpecPortCorsArgsDict']]
        """
        A security feature implemented by web browsers to allow resources on a web page to be requested from another domain outside the domain from which the resource originated.
        """
        number: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sets or overrides headers to all http requests for this route.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allowed protocol. Valid values: `http`, `http2`, `tcp`. Default: `http2`.
        """
        tls: NotRequired[pulumi.Input['DomainSpecPortTlsArgsDict']]
        """
        Used for TLS connections for this Domain. End users are responsible for certificate updates.
        """
elif False:
    DomainSpecPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecPortArgs:
    def __init__(__self__, *,
                 cors: Optional[pulumi.Input['DomainSpecPortCorsArgs']] = None,
                 number: Optional[pulumi.Input[_builtins.int]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 tls: Optional[pulumi.Input['DomainSpecPortTlsArgs']] = None):
        """
        :param pulumi.Input['DomainSpecPortCorsArgs'] cors: A security feature implemented by web browsers to allow resources on a web page to be requested from another domain outside the domain from which the resource originated.
        :param pulumi.Input[_builtins.int] number: Sets or overrides headers to all http requests for this route.
        :param pulumi.Input[_builtins.str] protocol: Allowed protocol. Valid values: `http`, `http2`, `tcp`. Default: `http2`.
        :param pulumi.Input['DomainSpecPortTlsArgs'] tls: Used for TLS connections for this Domain. End users are responsible for certificate updates.
        """
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['DomainSpecPortCorsArgs']]:
        """
        A security feature implemented by web browsers to allow resources on a web page to be requested from another domain outside the domain from which the resource originated.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['DomainSpecPortCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sets or overrides headers to all http requests for this route.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allowed protocol. Valid values: `http`, `http2`, `tcp`. Default: `http2`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['DomainSpecPortTlsArgs']]:
        """
        Used for TLS connections for this Domain. End users are responsible for certificate updates.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['DomainSpecPortTlsArgs']]):
        pulumi.set(self, "tls", value)


if not MYPY:
    class DomainSpecPortCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether the client-side code (typically running in a web browser) is allowed to include credentials (such as cookies, HTTP authentication, or client-side SSL certificates) in cross-origin requests.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the custom HTTP headers that are allowed in a cross-origin request to a specific resource.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the HTTP methods (such as `GET`, `POST`, `PUT`, `DELETE`, etc.) that are allowed for a cross-origin request to a specific resource.
        """
        allow_origins: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortCorsAllowOriginArgsDict']]]]
        """
        Determines which origins are allowed to access a particular resource on a server from a web browser.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The HTTP headers that a server allows to be exposed to the client in response to a cross-origin request. These headers provide additional information about the server's capabilities or requirements, aiding in proper handling of the request by the client's browser or application.
        """
        max_age: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum amount of time that a preflight request result can be cached by the client browser. Input is expected as a duration string (i.e, 24h, 20m, etc.).
        """
elif False:
    DomainSpecPortCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecPortCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortCorsAllowOriginArgs']]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Determines whether the client-side code (typically running in a web browser) is allowed to include credentials (such as cookies, HTTP authentication, or client-side SSL certificates) in cross-origin requests.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: Specifies the custom HTTP headers that are allowed in a cross-origin request to a specific resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: Specifies the HTTP methods (such as `GET`, `POST`, `PUT`, `DELETE`, etc.) that are allowed for a cross-origin request to a specific resource.
        :param pulumi.Input[Sequence[pulumi.Input['DomainSpecPortCorsAllowOriginArgs']]] allow_origins: Determines which origins are allowed to access a particular resource on a server from a web browser.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: The HTTP headers that a server allows to be exposed to the client in response to a cross-origin request. These headers provide additional information about the server's capabilities or requirements, aiding in proper handling of the request by the client's browser or application.
        :param pulumi.Input[_builtins.str] max_age: Maximum amount of time that a preflight request result can be cached by the client browser. Input is expected as a duration string (i.e, 24h, 20m, etc.).
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether the client-side code (typically running in a web browser) is allowed to include credentials (such as cookies, HTTP authentication, or client-side SSL certificates) in cross-origin requests.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the custom HTTP headers that are allowed in a cross-origin request to a specific resource.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the HTTP methods (such as `GET`, `POST`, `PUT`, `DELETE`, etc.) that are allowed for a cross-origin request to a specific resource.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortCorsAllowOriginArgs']]]]:
        """
        Determines which origins are allowed to access a particular resource on a server from a web browser.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainSpecPortCorsAllowOriginArgs']]]]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The HTTP headers that a server allows to be exposed to the client in response to a cross-origin request. These headers provide additional information about the server's capabilities or requirements, aiding in proper handling of the request by the client's browser or application.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum amount of time that a preflight request result can be cached by the client browser. Input is expected as a duration string (i.e, 24h, 20m, etc.).
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class DomainSpecPortCorsAllowOriginArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of allowed origin.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    DomainSpecPortCorsAllowOriginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecPortCorsAllowOriginArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: Value of allowed origin.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of allowed origin.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class DomainSpecPortTlsArgsDict(TypedDict):
        cipher_suites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Allowed cipher suites. Refer to the [Domain Reference](https://docs.controlplane.com/reference/domain#cipher-suites) for details.
        """
        client_certificate: NotRequired[pulumi.Input['DomainSpecPortTlsClientCertificateArgsDict']]
        """
        The certificate authority PEM, stored as a TLS Secret, used to verify the authority of the client certificate. The only verification performed checks that the CN of the PEM matches the Domain (i.e., CN=*.DOMAIN).
        """
        min_protocol_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum TLS version to accept. Minimum is `1.0`. Default: `1.2`.
        """
        server_certificate: NotRequired[pulumi.Input['DomainSpecPortTlsServerCertificateArgsDict']]
        """
        Configure an optional custom server certificate for the domain. When the port number is 443 and this is not supplied, a certificate is provisioned automatically.
        """
elif False:
    DomainSpecPortTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecPortTlsArgs:
    def __init__(__self__, *,
                 cipher_suites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 client_certificate: Optional[pulumi.Input['DomainSpecPortTlsClientCertificateArgs']] = None,
                 min_protocol_version: Optional[pulumi.Input[_builtins.str]] = None,
                 server_certificate: Optional[pulumi.Input['DomainSpecPortTlsServerCertificateArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] cipher_suites: Allowed cipher suites. Refer to the [Domain Reference](https://docs.controlplane.com/reference/domain#cipher-suites) for details.
        :param pulumi.Input['DomainSpecPortTlsClientCertificateArgs'] client_certificate: The certificate authority PEM, stored as a TLS Secret, used to verify the authority of the client certificate. The only verification performed checks that the CN of the PEM matches the Domain (i.e., CN=*.DOMAIN).
        :param pulumi.Input[_builtins.str] min_protocol_version: Minimum TLS version to accept. Minimum is `1.0`. Default: `1.2`.
        :param pulumi.Input['DomainSpecPortTlsServerCertificateArgs'] server_certificate: Configure an optional custom server certificate for the domain. When the port number is 443 and this is not supplied, a certificate is provisioned automatically.
        """
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if server_certificate is not None:
            pulumi.set(__self__, "server_certificate", server_certificate)

    @_builtins.property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Allowed cipher suites. Refer to the [Domain Reference](https://docs.controlplane.com/reference/domain#cipher-suites) for details.
        """
        return pulumi.get(self, "cipher_suites")

    @cipher_suites.setter
    def cipher_suites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "cipher_suites", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input['DomainSpecPortTlsClientCertificateArgs']]:
        """
        The certificate authority PEM, stored as a TLS Secret, used to verify the authority of the client certificate. The only verification performed checks that the CN of the PEM matches the Domain (i.e., CN=*.DOMAIN).
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input['DomainSpecPortTlsClientCertificateArgs']]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum TLS version to accept. Minimum is `1.0`. Default: `1.2`.
        """
        return pulumi.get(self, "min_protocol_version")

    @min_protocol_version.setter
    def min_protocol_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_protocol_version", value)

    @_builtins.property
    @pulumi.getter(name="serverCertificate")
    def server_certificate(self) -> Optional[pulumi.Input['DomainSpecPortTlsServerCertificateArgs']]:
        """
        Configure an optional custom server certificate for the domain. When the port number is 443 and this is not supplied, a certificate is provisioned automatically.
        """
        return pulumi.get(self, "server_certificate")

    @server_certificate.setter
    def server_certificate(self, value: Optional[pulumi.Input['DomainSpecPortTlsServerCertificateArgs']]):
        pulumi.set(self, "server_certificate", value)


if not MYPY:
    class DomainSpecPortTlsClientCertificateArgsDict(TypedDict):
        secret_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        The secret will include a client certificate authority cert in PEM format used to verify requests which include client certificates. The key subject must match the domain and the key usage properties must be configured for client certificate authorization. The secret type must be keypair.
        """
elif False:
    DomainSpecPortTlsClientCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecPortTlsClientCertificateArgs:
    def __init__(__self__, *,
                 secret_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_link: The secret will include a client certificate authority cert in PEM format used to verify requests which include client certificates. The key subject must match the domain and the key usage properties must be configured for client certificate authorization. The secret type must be keypair.
        """
        if secret_link is not None:
            pulumi.set(__self__, "secret_link", secret_link)

    @_builtins.property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The secret will include a client certificate authority cert in PEM format used to verify requests which include client certificates. The key subject must match the domain and the key usage properties must be configured for client certificate authorization. The secret type must be keypair.
        """
        return pulumi.get(self, "secret_link")

    @secret_link.setter
    def secret_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_link", value)


if not MYPY:
    class DomainSpecPortTlsServerCertificateArgsDict(TypedDict):
        secret_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        When provided, this is used as the server certificate authority. The secret type must be keypair and the content must be PEM encoded.
        """
elif False:
    DomainSpecPortTlsServerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainSpecPortTlsServerCertificateArgs:
    def __init__(__self__, *,
                 secret_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_link: When provided, this is used as the server certificate authority. The secret type must be keypair and the content must be PEM encoded.
        """
        if secret_link is not None:
            pulumi.set(__self__, "secret_link", secret_link)

    @_builtins.property
    @pulumi.getter(name="secretLink")
    def secret_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When provided, this is used as the server certificate authority. The secret type must be keypair and the content must be PEM encoded.
        """
        return pulumi.get(self, "secret_link")

    @secret_link.setter
    def secret_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_link", value)


if not MYPY:
    class DomainStatusArgsDict(TypedDict):
        dns_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainStatusDnsConfigArgsDict']]]]
        """
        List of required DNS record entries.
        """
        endpoints: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainStatusEndpointArgsDict']]]]
        """
        List of configured domain endpoints.
        """
        fingerprint: NotRequired[pulumi.Input[_builtins.str]]
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['DomainStatusLocationArgsDict']]]]
        """
        Contains the cloud provider name, region, and certificate status.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of Domain. Possible values: `initializing`, `ready`, `pendingDnsConfig`, `pendingCertificate`, `usedByGvc`.
        """
        warning: NotRequired[pulumi.Input[_builtins.str]]
        """
        Warning message.
        """
elif False:
    DomainStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainStatusArgs:
    def __init__(__self__, *,
                 dns_configs: Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusDnsConfigArgs']]]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusEndpointArgs']]]] = None,
                 fingerprint: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusLocationArgs']]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 warning: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DomainStatusDnsConfigArgs']]] dns_configs: List of required DNS record entries.
        :param pulumi.Input[Sequence[pulumi.Input['DomainStatusEndpointArgs']]] endpoints: List of configured domain endpoints.
        :param pulumi.Input[Sequence[pulumi.Input['DomainStatusLocationArgs']]] locations: Contains the cloud provider name, region, and certificate status.
        :param pulumi.Input[_builtins.str] status: Status of Domain. Possible values: `initializing`, `ready`, `pendingDnsConfig`, `pendingCertificate`, `usedByGvc`.
        :param pulumi.Input[_builtins.str] warning: Warning message.
        """
        if dns_configs is not None:
            pulumi.set(__self__, "dns_configs", dns_configs)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if fingerprint is not None:
            pulumi.set(__self__, "fingerprint", fingerprint)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @_builtins.property
    @pulumi.getter(name="dnsConfigs")
    def dns_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusDnsConfigArgs']]]]:
        """
        List of required DNS record entries.
        """
        return pulumi.get(self, "dns_configs")

    @dns_configs.setter
    def dns_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusDnsConfigArgs']]]]):
        pulumi.set(self, "dns_configs", value)

    @_builtins.property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusEndpointArgs']]]]:
        """
        List of configured domain endpoints.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusEndpointArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "fingerprint")

    @fingerprint.setter
    def fingerprint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fingerprint", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusLocationArgs']]]]:
        """
        Contains the cloud provider name, region, and certificate status.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DomainStatusLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of Domain. Possible values: `initializing`, `ready`, `pendingDnsConfig`, `pendingCertificate`, `usedByGvc`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Warning message.
        """
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class DomainStatusDnsConfigArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The host in DNS terminology refers to the domain or subdomain that the DNS record is associated with. It's essentially the name that is being queried or managed. For example, in a DNS record for `www.example.com`, `www` is a host in the domain `example.com`.
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time to live (TTL) is a value that signifies how long (in seconds) a DNS record should be cached by a resolver or a browser before a new request should be sent to refresh the data. Lower TTL values mean records are updated more frequently, which is beneficial for dynamic DNS configurations or during DNS migrations. Higher TTL values reduce the load on DNS servers and improve the speed of name resolution for end users by relying on cached data.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DNS record type specifies the type of data the DNS record contains. Valid values: `CNAME`, `NS`, `TXT`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of a DNS record contains the data the record is meant to convey, based on the type of the record.
        """
elif False:
    DomainStatusDnsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainStatusDnsConfigArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The host in DNS terminology refers to the domain or subdomain that the DNS record is associated with. It's essentially the name that is being queried or managed. For example, in a DNS record for `www.example.com`, `www` is a host in the domain `example.com`.
        :param pulumi.Input[_builtins.int] ttl: Time to live (TTL) is a value that signifies how long (in seconds) a DNS record should be cached by a resolver or a browser before a new request should be sent to refresh the data. Lower TTL values mean records are updated more frequently, which is beneficial for dynamic DNS configurations or during DNS migrations. Higher TTL values reduce the load on DNS servers and improve the speed of name resolution for end users by relying on cached data.
        :param pulumi.Input[_builtins.str] type: The DNS record type specifies the type of data the DNS record contains. Valid values: `CNAME`, `NS`, `TXT`.
        :param pulumi.Input[_builtins.str] value: The value of a DNS record contains the data the record is meant to convey, based on the type of the record.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The host in DNS terminology refers to the domain or subdomain that the DNS record is associated with. It's essentially the name that is being queried or managed. For example, in a DNS record for `www.example.com`, `www` is a host in the domain `example.com`.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time to live (TTL) is a value that signifies how long (in seconds) a DNS record should be cached by a resolver or a browser before a new request should be sent to refresh the data. Lower TTL values mean records are updated more frequently, which is beneficial for dynamic DNS configurations or during DNS migrations. Higher TTL values reduce the load on DNS servers and improve the speed of name resolution for end users by relying on cached data.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DNS record type specifies the type of data the DNS record contains. Valid values: `CNAME`, `NS`, `TXT`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of a DNS record contains the data the record is meant to convey, based on the type of the record.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DomainStatusEndpointArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of endpoint.
        """
        workload_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full link to associated workload.
        """
elif False:
    DomainStatusEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainStatusEndpointArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 workload_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: URL of endpoint.
        :param pulumi.Input[_builtins.str] workload_link: Full link to associated workload.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)
        if workload_link is not None:
            pulumi.set(__self__, "workload_link", workload_link)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of endpoint.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="workloadLink")
    def workload_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full link to associated workload.
        """
        return pulumi.get(self, "workload_link")

    @workload_link.setter
    def workload_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "workload_link", value)


if not MYPY:
    class DomainStatusLocationArgsDict(TypedDict):
        certificate_status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The current validity or status of the SSL/TLS certificate.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the location.
        """
elif False:
    DomainStatusLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DomainStatusLocationArgs:
    def __init__(__self__, *,
                 certificate_status: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] certificate_status: The current validity or status of the SSL/TLS certificate.
        :param pulumi.Input[_builtins.str] name: The name of the location.
        """
        if certificate_status is not None:
            pulumi.set(__self__, "certificate_status", certificate_status)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="certificateStatus")
    def certificate_status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The current validity or status of the SSL/TLS certificate.
        """
        return pulumi.get(self, "certificate_status")

    @certificate_status.setter
    def certificate_status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_status", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class GroupIdentityMatcherArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        Executes the expression against the users' claims to decide whether a user belongs to this group. This method is useful for managing the grouping of users logged in with SAML providers.
        """
        language: NotRequired[pulumi.Input[_builtins.str]]
        """
        Language of the expression. Either `jmespath` or `javascript`. Default: `jmespath`.
        """
elif False:
    GroupIdentityMatcherArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupIdentityMatcherArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 language: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: Executes the expression against the users' claims to decide whether a user belongs to this group. This method is useful for managing the grouping of users logged in with SAML providers.
        :param pulumi.Input[_builtins.str] language: Language of the expression. Either `jmespath` or `javascript`. Default: `jmespath`.
        """
        pulumi.set(__self__, "expression", expression)
        if language is not None:
            pulumi.set(__self__, "language", language)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Executes the expression against the users' claims to decide whether a user belongs to this group. This method is useful for managing the grouping of users logged in with SAML providers.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Language of the expression. Either `jmespath` or `javascript`. Default: `jmespath`.
        """
        return pulumi.get(self, "language")

    @language.setter
    def language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language", value)


if not MYPY:
    class GroupMemberQueryArgsDict(TypedDict):
        fetch: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        spec: NotRequired[pulumi.Input['GroupMemberQuerySpecArgsDict']]
elif False:
    GroupMemberQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupMemberQueryArgs:
    def __init__(__self__, *,
                 fetch: Optional[pulumi.Input[_builtins.str]] = None,
                 spec: Optional[pulumi.Input['GroupMemberQuerySpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] fetch: Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        if fetch is not None:
            pulumi.set(__self__, "fetch", fetch)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def fetch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        return pulumi.get(self, "fetch")

    @fetch.setter
    def fetch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fetch", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['GroupMemberQuerySpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['GroupMemberQuerySpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class GroupMemberQuerySpecArgsDict(TypedDict):
        match: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        terms: NotRequired[pulumi.Input[Sequence[pulumi.Input['GroupMemberQuerySpecTermArgsDict']]]]
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
elif False:
    GroupMemberQuerySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupMemberQuerySpecArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[_builtins.str]] = None,
                 terms: Optional[pulumi.Input[Sequence[pulumi.Input['GroupMemberQuerySpecTermArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] match: Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        :param pulumi.Input[Sequence[pulumi.Input['GroupMemberQuerySpecTermArgs']]] terms: Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GroupMemberQuerySpecTermArgs']]]]:
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        return pulumi.get(self, "terms")

    @terms.setter
    def terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GroupMemberQuerySpecTermArgs']]]]):
        pulumi.set(self, "terms", value)


if not MYPY:
    class GroupMemberQuerySpecTermArgsDict(TypedDict):
        op: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        property: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property to use for query evaluation.
        """
        rel: NotRequired[pulumi.Input[_builtins.str]]
        """
        Relation to use for query evaluation.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tag key to use for query evaluation.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Testing value for query evaluation.
        """
elif False:
    GroupMemberQuerySpecTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupMemberQuerySpecTermArgs:
    def __init__(__self__, *,
                 op: Optional[pulumi.Input[_builtins.str]] = None,
                 property: Optional[pulumi.Input[_builtins.str]] = None,
                 rel: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] op: Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        :param pulumi.Input[_builtins.str] property: Property to use for query evaluation.
        :param pulumi.Input[_builtins.str] rel: Relation to use for query evaluation.
        :param pulumi.Input[_builtins.str] tag: Tag key to use for query evaluation.
        :param pulumi.Input[_builtins.str] value: Testing value for query evaluation.
        """
        if op is not None:
            pulumi.set(__self__, "op", op)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property to use for query evaluation.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Relation to use for query evaluation.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rel", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tag key to use for query evaluation.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Testing value for query evaluation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GvcControlplaneTracingArgsDict(TypedDict):
        sampling: pulumi.Input[_builtins.float]
        """
        Determines what percentage of requests should be traced.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of custom tags.
        """
elif False:
    GvcControlplaneTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcControlplaneTracingArgs:
    def __init__(__self__, *,
                 sampling: pulumi.Input[_builtins.float],
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.float] sampling: Determines what percentage of requests should be traced.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> pulumi.Input[_builtins.float]:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GvcKedaArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable KEDA for this GVC. KEDA is a Kubernetes-based event-driven autoscaler that allows you to scale workloads based on external events. When enabled, a keda operator will be deployed in the GVC and workloads in the GVC can use KEDA to scale based on external metrics.
        """
        identity_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        A link to an Identity resource that will be used for KEDA. This will allow the keda operator to access cloud and network resources.
        """
        secrets: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of secrets to be used as TriggerAuthentication objects. The TriggerAuthentication object will be named after the secret and can be used by triggers on workloads in this GVC.
        """
elif False:
    GvcKedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcKedaArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 identity_link: Optional[pulumi.Input[_builtins.str]] = None,
                 secrets: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable KEDA for this GVC. KEDA is a Kubernetes-based event-driven autoscaler that allows you to scale workloads based on external events. When enabled, a keda operator will be deployed in the GVC and workloads in the GVC can use KEDA to scale based on external metrics.
        :param pulumi.Input[_builtins.str] identity_link: A link to an Identity resource that will be used for KEDA. This will allow the keda operator to access cloud and network resources.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] secrets: A list of secrets to be used as TriggerAuthentication objects. The TriggerAuthentication object will be named after the secret and can be used by triggers on workloads in this GVC.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if identity_link is not None:
            pulumi.set(__self__, "identity_link", identity_link)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable KEDA for this GVC. KEDA is a Kubernetes-based event-driven autoscaler that allows you to scale workloads based on external events. When enabled, a keda operator will be deployed in the GVC and workloads in the GVC can use KEDA to scale based on external metrics.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="identityLink")
    def identity_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A link to an Identity resource that will be used for KEDA. This will allow the keda operator to access cloud and network resources.
        """
        return pulumi.get(self, "identity_link")

    @identity_link.setter
    def identity_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "identity_link", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of secrets to be used as TriggerAuthentication objects. The TriggerAuthentication object will be named after the secret and can be used by triggers on workloads in this GVC.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class GvcLightstepTracingArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        sampling: pulumi.Input[_builtins.float]
        """
        Determines what percentage of requests should be traced.
        """
        credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full link to referenced Opaque Secret.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of custom tags.
        """
elif False:
    GvcLightstepTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcLightstepTracingArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 sampling: pulumi.Input[_builtins.float],
                 credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param pulumi.Input[_builtins.float] sampling: Determines what percentage of requests should be traced.
        :param pulumi.Input[_builtins.str] credentials: Full link to referenced Opaque Secret.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> pulumi.Input[_builtins.float]:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GvcLoadBalancerArgsDict(TypedDict):
        dedicated: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        """
        ipset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The link or the name of the IP Set that will be used for this load balancer.
        """
        multi_zone: NotRequired[pulumi.Input['GvcLoadBalancerMultiZoneArgsDict']]
        redirect: NotRequired[pulumi.Input['GvcLoadBalancerRedirectArgsDict']]
        """
        Specify the url to be redirected to for different http status codes.
        """
        trusted_proxies: NotRequired[pulumi.Input[_builtins.int]]
        """
        Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
elif False:
    GvcLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcLoadBalancerArgs:
    def __init__(__self__, *,
                 dedicated: Optional[pulumi.Input[_builtins.bool]] = None,
                 ipset: Optional[pulumi.Input[_builtins.str]] = None,
                 multi_zone: Optional[pulumi.Input['GvcLoadBalancerMultiZoneArgs']] = None,
                 redirect: Optional[pulumi.Input['GvcLoadBalancerRedirectArgs']] = None,
                 trusted_proxies: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] dedicated: Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        :param pulumi.Input[_builtins.str] ipset: The link or the name of the IP Set that will be used for this load balancer.
        :param pulumi.Input['GvcLoadBalancerRedirectArgs'] redirect: Specify the url to be redirected to for different http status codes.
        :param pulumi.Input[_builtins.int] trusted_proxies: Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if ipset is not None:
            pulumi.set(__self__, "ipset", ipset)
        if multi_zone is not None:
            pulumi.set(__self__, "multi_zone", multi_zone)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if trusted_proxies is not None:
            pulumi.set(__self__, "trusted_proxies", trusted_proxies)

    @_builtins.property
    @pulumi.getter
    def dedicated(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dedicated", value)

    @_builtins.property
    @pulumi.getter
    def ipset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The link or the name of the IP Set that will be used for this load balancer.
        """
        return pulumi.get(self, "ipset")

    @ipset.setter
    def ipset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipset", value)

    @_builtins.property
    @pulumi.getter(name="multiZone")
    def multi_zone(self) -> Optional[pulumi.Input['GvcLoadBalancerMultiZoneArgs']]:
        return pulumi.get(self, "multi_zone")

    @multi_zone.setter
    def multi_zone(self, value: Optional[pulumi.Input['GvcLoadBalancerMultiZoneArgs']]):
        pulumi.set(self, "multi_zone", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['GvcLoadBalancerRedirectArgs']]:
        """
        Specify the url to be redirected to for different http status codes.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['GvcLoadBalancerRedirectArgs']]):
        pulumi.set(self, "redirect", value)

    @_builtins.property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        return pulumi.get(self, "trusted_proxies")

    @trusted_proxies.setter
    def trusted_proxies(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "trusted_proxies", value)


if not MYPY:
    class GvcLoadBalancerMultiZoneArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    GvcLoadBalancerMultiZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcLoadBalancerMultiZoneArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GvcLoadBalancerRedirectArgsDict(TypedDict):
        class_: NotRequired[pulumi.Input['GvcLoadBalancerRedirectClassArgsDict']]
        """
        Specify the redirect url for all status codes in a class.
        """
elif False:
    GvcLoadBalancerRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcLoadBalancerRedirectArgs:
    def __init__(__self__, *,
                 class_: Optional[pulumi.Input['GvcLoadBalancerRedirectClassArgs']] = None):
        """
        :param pulumi.Input['GvcLoadBalancerRedirectClassArgs'] class_: Specify the redirect url for all status codes in a class.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional[pulumi.Input['GvcLoadBalancerRedirectClassArgs']]:
        """
        Specify the redirect url for all status codes in a class.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional[pulumi.Input['GvcLoadBalancerRedirectClassArgs']]):
        pulumi.set(self, "class_", value)


if not MYPY:
    class GvcLoadBalancerRedirectClassArgsDict(TypedDict):
        status401: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional url redirect for 401 responses. Supports envoy format strings to include request information. E.g. https://your-oauth-server/oauth2/authorize?return_to=%REQ(:path)%&client_id=your-client-id
        """
        status5xx: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specify the redirect url for any 500 level status code.
        """
elif False:
    GvcLoadBalancerRedirectClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcLoadBalancerRedirectClassArgs:
    def __init__(__self__, *,
                 status401: Optional[pulumi.Input[_builtins.str]] = None,
                 status5xx: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status401: An optional url redirect for 401 responses. Supports envoy format strings to include request information. E.g. https://your-oauth-server/oauth2/authorize?return_to=%REQ(:path)%&client_id=your-client-id
        :param pulumi.Input[_builtins.str] status5xx: Specify the redirect url for any 500 level status code.
        """
        if status401 is not None:
            pulumi.set(__self__, "status401", status401)
        if status5xx is not None:
            pulumi.set(__self__, "status5xx", status5xx)

    @_builtins.property
    @pulumi.getter
    def status401(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional url redirect for 401 responses. Supports envoy format strings to include request information. E.g. https://your-oauth-server/oauth2/authorize?return_to=%REQ(:path)%&client_id=your-client-id
        """
        return pulumi.get(self, "status401")

    @status401.setter
    def status401(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status401", value)

    @_builtins.property
    @pulumi.getter
    def status5xx(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specify the redirect url for any 500 level status code.
        """
        return pulumi.get(self, "status5xx")

    @status5xx.setter
    def status5xx(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status5xx", value)


if not MYPY:
    class GvcOtelTracingArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        sampling: pulumi.Input[_builtins.float]
        """
        Determines what percentage of requests should be traced.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of custom tags.
        """
elif False:
    GvcOtelTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcOtelTracingArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 sampling: pulumi.Input[_builtins.float],
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param pulumi.Input[_builtins.float] sampling: Determines what percentage of requests should be traced.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> pulumi.Input[_builtins.float]:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GvcSidecarArgsDict(TypedDict):
        envoy: pulumi.Input[_builtins.str]
elif False:
    GvcSidecarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GvcSidecarArgs:
    def __init__(__self__, *,
                 envoy: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "envoy", envoy)

    @_builtins.property
    @pulumi.getter
    def envoy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "envoy")

    @envoy.setter
    def envoy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "envoy", value)


if not MYPY:
    class IdentityAwsAccessPolicyArgsDict(TypedDict):
        cloud_account_link: pulumi.Input[_builtins.str]
        """
        Full link to referenced cloud account.
        """
        policy_refs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of policies.
        """
        role_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role name.
        """
        trust_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdentityAwsAccessPolicyTrustPolicyArgsDict']]]]
        """
        The trust policy for the role.
        """
elif False:
    IdentityAwsAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAwsAccessPolicyArgs:
    def __init__(__self__, *,
                 cloud_account_link: pulumi.Input[_builtins.str],
                 policy_refs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role_name: Optional[pulumi.Input[_builtins.str]] = None,
                 trust_policies: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityAwsAccessPolicyTrustPolicyArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_account_link: Full link to referenced cloud account.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] policy_refs: List of policies.
        :param pulumi.Input[_builtins.str] role_name: Role name.
        :param pulumi.Input[Sequence[pulumi.Input['IdentityAwsAccessPolicyTrustPolicyArgs']]] trust_policies: The trust policy for the role.
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if policy_refs is not None:
            pulumi.set(__self__, "policy_refs", policy_refs)
        if role_name is not None:
            pulumi.set(__self__, "role_name", role_name)
        if trust_policies is not None:
            pulumi.set(__self__, "trust_policies", trust_policies)

    @_builtins.property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @cloud_account_link.setter
    def cloud_account_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_account_link", value)

    @_builtins.property
    @pulumi.getter(name="policyRefs")
    def policy_refs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of policies.
        """
        return pulumi.get(self, "policy_refs")

    @policy_refs.setter
    def policy_refs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "policy_refs", value)

    @_builtins.property
    @pulumi.getter(name="roleName")
    def role_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role name.
        """
        return pulumi.get(self, "role_name")

    @role_name.setter
    def role_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_name", value)

    @_builtins.property
    @pulumi.getter(name="trustPolicies")
    def trust_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdentityAwsAccessPolicyTrustPolicyArgs']]]]:
        """
        The trust policy for the role.
        """
        return pulumi.get(self, "trust_policies")

    @trust_policies.setter
    def trust_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityAwsAccessPolicyTrustPolicyArgs']]]]):
        pulumi.set(self, "trust_policies", value)


if not MYPY:
    class IdentityAwsAccessPolicyTrustPolicyArgsDict(TypedDict):
        statements: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        List of statements.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of the policy.
        """
elif False:
    IdentityAwsAccessPolicyTrustPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAwsAccessPolicyTrustPolicyArgs:
    def __init__(__self__, *,
                 statements: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] statements: List of statements.
        :param pulumi.Input[_builtins.str] version: Version of the policy.
        """
        if statements is not None:
            pulumi.set(__self__, "statements", statements)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def statements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        List of statements.
        """
        return pulumi.get(self, "statements")

    @statements.setter
    def statements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "statements", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of the policy.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class IdentityAzureAccessPolicyArgsDict(TypedDict):
        cloud_account_link: pulumi.Input[_builtins.str]
        """
        Full link to referenced cloud account.
        """
        role_assignments: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdentityAzureAccessPolicyRoleAssignmentArgsDict']]]]
        """
        The process of assigning specific roles or permissions to an entity, such as a user or a service principal, within the system.
        """
elif False:
    IdentityAzureAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAzureAccessPolicyArgs:
    def __init__(__self__, *,
                 cloud_account_link: pulumi.Input[_builtins.str],
                 role_assignments: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityAzureAccessPolicyRoleAssignmentArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_account_link: Full link to referenced cloud account.
        :param pulumi.Input[Sequence[pulumi.Input['IdentityAzureAccessPolicyRoleAssignmentArgs']]] role_assignments: The process of assigning specific roles or permissions to an entity, such as a user or a service principal, within the system.
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if role_assignments is not None:
            pulumi.set(__self__, "role_assignments", role_assignments)

    @_builtins.property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @cloud_account_link.setter
    def cloud_account_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_account_link", value)

    @_builtins.property
    @pulumi.getter(name="roleAssignments")
    def role_assignments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdentityAzureAccessPolicyRoleAssignmentArgs']]]]:
        """
        The process of assigning specific roles or permissions to an entity, such as a user or a service principal, within the system.
        """
        return pulumi.get(self, "role_assignments")

    @role_assignments.setter
    def role_assignments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityAzureAccessPolicyRoleAssignmentArgs']]]]):
        pulumi.set(self, "role_assignments", value)


if not MYPY:
    class IdentityAzureAccessPolicyRoleAssignmentArgsDict(TypedDict):
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of assigned roles.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Scope of roles.
        """
elif False:
    IdentityAzureAccessPolicyRoleAssignmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityAzureAccessPolicyRoleAssignmentArgs:
    def __init__(__self__, *,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] roles: List of assigned roles.
        :param pulumi.Input[_builtins.str] scope: Scope of roles.
        """
        if roles is not None:
            pulumi.set(__self__, "roles", roles)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of assigned roles.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "roles", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Scope of roles.
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)


if not MYPY:
    class IdentityGcpAccessPolicyArgsDict(TypedDict):
        cloud_account_link: pulumi.Input[_builtins.str]
        """
        Full link to referenced cloud account.
        """
        bindings: NotRequired[pulumi.Input[Sequence[pulumi.Input['IdentityGcpAccessPolicyBindingArgsDict']]]]
        """
        The association or connection between a particular identity, such as a user or a group, and a set of permissions or roles within the system.
        """
        scopes: NotRequired[pulumi.Input[_builtins.str]]
        """
        Comma delimited list of GCP scope URLs.
        """
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of existing GCP service account.
        """
elif False:
    IdentityGcpAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityGcpAccessPolicyArgs:
    def __init__(__self__, *,
                 cloud_account_link: pulumi.Input[_builtins.str],
                 bindings: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityGcpAccessPolicyBindingArgs']]]] = None,
                 scopes: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_account_link: Full link to referenced cloud account.
        :param pulumi.Input[Sequence[pulumi.Input['IdentityGcpAccessPolicyBindingArgs']]] bindings: The association or connection between a particular identity, such as a user or a group, and a set of permissions or roles within the system.
        :param pulumi.Input[_builtins.str] scopes: Comma delimited list of GCP scope URLs.
        :param pulumi.Input[_builtins.str] service_account: Name of existing GCP service account.
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if bindings is not None:
            pulumi.set(__self__, "bindings", bindings)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @cloud_account_link.setter
    def cloud_account_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_account_link", value)

    @_builtins.property
    @pulumi.getter
    def bindings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IdentityGcpAccessPolicyBindingArgs']]]]:
        """
        The association or connection between a particular identity, such as a user or a group, and a set of permissions or roles within the system.
        """
        return pulumi.get(self, "bindings")

    @bindings.setter
    def bindings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IdentityGcpAccessPolicyBindingArgs']]]]):
        pulumi.set(self, "bindings", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Comma delimited list of GCP scope URLs.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of existing GCP service account.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class IdentityGcpAccessPolicyBindingArgsDict(TypedDict):
        resource: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of resource for binding.
        """
        roles: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of allowed roles.
        """
elif False:
    IdentityGcpAccessPolicyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityGcpAccessPolicyBindingArgs:
    def __init__(__self__, *,
                 resource: Optional[pulumi.Input[_builtins.str]] = None,
                 roles: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] resource: Name of resource for binding.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] roles: List of allowed roles.
        """
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if roles is not None:
            pulumi.set(__self__, "roles", roles)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of resource for binding.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter
    def roles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allowed roles.
        """
        return pulumi.get(self, "roles")

    @roles.setter
    def roles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "roles", value)


if not MYPY:
    class IdentityNativeNetworkResourceArgsDict(TypedDict):
        fqdn: pulumi.Input[_builtins.str]
        """
        Fully qualified domain name.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the Native Network Resource.
        """
        ports: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        Ports to expose. At least one port is required.
        """
        aws_private_link: NotRequired[pulumi.Input['IdentityNativeNetworkResourceAwsPrivateLinkArgsDict']]
        """
        A feature provided by AWS that enables private connectivity between private VPCs and compute running at Control Plane without traversing the public internet.
        """
        gcp_service_connect: NotRequired[pulumi.Input['IdentityNativeNetworkResourceGcpServiceConnectArgsDict']]
        """
        Capability provided by GCP that allows private communication between private VPC networks and compute running at Control Plane.
        """
elif False:
    IdentityNativeNetworkResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNativeNetworkResourceArgs:
    def __init__(__self__, *,
                 fqdn: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 ports: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 aws_private_link: Optional[pulumi.Input['IdentityNativeNetworkResourceAwsPrivateLinkArgs']] = None,
                 gcp_service_connect: Optional[pulumi.Input['IdentityNativeNetworkResourceGcpServiceConnectArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] fqdn: Fully qualified domain name.
        :param pulumi.Input[_builtins.str] name: Name of the Native Network Resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ports: Ports to expose. At least one port is required.
        :param pulumi.Input['IdentityNativeNetworkResourceAwsPrivateLinkArgs'] aws_private_link: A feature provided by AWS that enables private connectivity between private VPCs and compute running at Control Plane without traversing the public internet.
        :param pulumi.Input['IdentityNativeNetworkResourceGcpServiceConnectArgs'] gcp_service_connect: Capability provided by GCP that allows private communication between private VPC networks and compute running at Control Plane.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)
        if aws_private_link is not None:
            pulumi.set(__self__, "aws_private_link", aws_private_link)
        if gcp_service_connect is not None:
            pulumi.set(__self__, "gcp_service_connect", gcp_service_connect)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> pulumi.Input[_builtins.str]:
        """
        Fully qualified domain name.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Native Network Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        Ports to expose. At least one port is required.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="awsPrivateLink")
    def aws_private_link(self) -> Optional[pulumi.Input['IdentityNativeNetworkResourceAwsPrivateLinkArgs']]:
        """
        A feature provided by AWS that enables private connectivity between private VPCs and compute running at Control Plane without traversing the public internet.
        """
        return pulumi.get(self, "aws_private_link")

    @aws_private_link.setter
    def aws_private_link(self, value: Optional[pulumi.Input['IdentityNativeNetworkResourceAwsPrivateLinkArgs']]):
        pulumi.set(self, "aws_private_link", value)

    @_builtins.property
    @pulumi.getter(name="gcpServiceConnect")
    def gcp_service_connect(self) -> Optional[pulumi.Input['IdentityNativeNetworkResourceGcpServiceConnectArgs']]:
        """
        Capability provided by GCP that allows private communication between private VPC networks and compute running at Control Plane.
        """
        return pulumi.get(self, "gcp_service_connect")

    @gcp_service_connect.setter
    def gcp_service_connect(self, value: Optional[pulumi.Input['IdentityNativeNetworkResourceGcpServiceConnectArgs']]):
        pulumi.set(self, "gcp_service_connect", value)


if not MYPY:
    class IdentityNativeNetworkResourceAwsPrivateLinkArgsDict(TypedDict):
        endpoint_service_name: pulumi.Input[_builtins.str]
        """
        Endpoint service name.
        """
elif False:
    IdentityNativeNetworkResourceAwsPrivateLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNativeNetworkResourceAwsPrivateLinkArgs:
    def __init__(__self__, *,
                 endpoint_service_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint_service_name: Endpoint service name.
        """
        pulumi.set(__self__, "endpoint_service_name", endpoint_service_name)

    @_builtins.property
    @pulumi.getter(name="endpointServiceName")
    def endpoint_service_name(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint service name.
        """
        return pulumi.get(self, "endpoint_service_name")

    @endpoint_service_name.setter
    def endpoint_service_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint_service_name", value)


if not MYPY:
    class IdentityNativeNetworkResourceGcpServiceConnectArgsDict(TypedDict):
        target_service: pulumi.Input[_builtins.str]
        """
        Target service name.
        """
elif False:
    IdentityNativeNetworkResourceGcpServiceConnectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNativeNetworkResourceGcpServiceConnectArgs:
    def __init__(__self__, *,
                 target_service: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_service: Target service name.
        """
        pulumi.set(__self__, "target_service", target_service)

    @_builtins.property
    @pulumi.getter(name="targetService")
    def target_service(self) -> pulumi.Input[_builtins.str]:
        """
        Target service name.
        """
        return pulumi.get(self, "target_service")

    @target_service.setter
    def target_service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_service", value)


if not MYPY:
    class IdentityNetworkResourceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the Network Resource.
        """
        ports: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        Ports to expose.
        """
        agent_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full link to referenced Agent.
        """
        fqdn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Fully qualified domain name.
        """
        ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of IP addresses.
        """
        resolver_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resolver IP.
        """
elif False:
    IdentityNetworkResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNetworkResourceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 ports: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 agent_link: Optional[pulumi.Input[_builtins.str]] = None,
                 fqdn: Optional[pulumi.Input[_builtins.str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resolver_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the Network Resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ports: Ports to expose.
        :param pulumi.Input[_builtins.str] agent_link: Full link to referenced Agent.
        :param pulumi.Input[_builtins.str] fqdn: Fully qualified domain name.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ips: List of IP addresses.
        :param pulumi.Input[_builtins.str] resolver_ip: Resolver IP.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ports", ports)
        if agent_link is not None:
            pulumi.set(__self__, "agent_link", agent_link)
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if resolver_ip is not None:
            pulumi.set(__self__, "resolver_ip", resolver_ip)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Network Resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        Ports to expose.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="agentLink")
    def agent_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full link to referenced Agent.
        """
        return pulumi.get(self, "agent_link")

    @agent_link.setter
    def agent_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_link", value)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Fully qualified domain name.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @_builtins.property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of IP addresses.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ips", value)

    @_builtins.property
    @pulumi.getter(name="resolverIp")
    def resolver_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resolver IP.
        """
        return pulumi.get(self, "resolver_ip")

    @resolver_ip.setter
    def resolver_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolver_ip", value)


if not MYPY:
    class IdentityNgsAccessPolicyArgsDict(TypedDict):
        cloud_account_link: pulumi.Input[_builtins.str]
        """
        Full link to referenced cloud account.
        """
        data: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max number of bytes a connection can send. Default: -1
        """
        payload: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max message payload. Default: -1
        """
        pub: NotRequired[pulumi.Input['IdentityNgsAccessPolicyPubArgsDict']]
        """
        Pub Permission.
        """
        resp: NotRequired[pulumi.Input['IdentityNgsAccessPolicyRespArgsDict']]
        """
        Reponses.
        """
        sub: NotRequired[pulumi.Input['IdentityNgsAccessPolicySubArgsDict']]
        """
        Sub Permission.
        """
        subs: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max number of subscriptions per connection. Default: -1
        """
elif False:
    IdentityNgsAccessPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNgsAccessPolicyArgs:
    def __init__(__self__, *,
                 cloud_account_link: pulumi.Input[_builtins.str],
                 data: Optional[pulumi.Input[_builtins.int]] = None,
                 payload: Optional[pulumi.Input[_builtins.int]] = None,
                 pub: Optional[pulumi.Input['IdentityNgsAccessPolicyPubArgs']] = None,
                 resp: Optional[pulumi.Input['IdentityNgsAccessPolicyRespArgs']] = None,
                 sub: Optional[pulumi.Input['IdentityNgsAccessPolicySubArgs']] = None,
                 subs: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] cloud_account_link: Full link to referenced cloud account.
        :param pulumi.Input[_builtins.int] data: Max number of bytes a connection can send. Default: -1
        :param pulumi.Input[_builtins.int] payload: Max message payload. Default: -1
        :param pulumi.Input['IdentityNgsAccessPolicyPubArgs'] pub: Pub Permission.
        :param pulumi.Input['IdentityNgsAccessPolicyRespArgs'] resp: Reponses.
        :param pulumi.Input['IdentityNgsAccessPolicySubArgs'] sub: Sub Permission.
        :param pulumi.Input[_builtins.int] subs: Max number of subscriptions per connection. Default: -1
        """
        pulumi.set(__self__, "cloud_account_link", cloud_account_link)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if pub is not None:
            pulumi.set(__self__, "pub", pub)
        if resp is not None:
            pulumi.set(__self__, "resp", resp)
        if sub is not None:
            pulumi.set(__self__, "sub", sub)
        if subs is not None:
            pulumi.set(__self__, "subs", subs)

    @_builtins.property
    @pulumi.getter(name="cloudAccountLink")
    def cloud_account_link(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced cloud account.
        """
        return pulumi.get(self, "cloud_account_link")

    @cloud_account_link.setter
    def cloud_account_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_account_link", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max number of bytes a connection can send. Default: -1
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max message payload. Default: -1
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def pub(self) -> Optional[pulumi.Input['IdentityNgsAccessPolicyPubArgs']]:
        """
        Pub Permission.
        """
        return pulumi.get(self, "pub")

    @pub.setter
    def pub(self, value: Optional[pulumi.Input['IdentityNgsAccessPolicyPubArgs']]):
        pulumi.set(self, "pub", value)

    @_builtins.property
    @pulumi.getter
    def resp(self) -> Optional[pulumi.Input['IdentityNgsAccessPolicyRespArgs']]:
        """
        Reponses.
        """
        return pulumi.get(self, "resp")

    @resp.setter
    def resp(self, value: Optional[pulumi.Input['IdentityNgsAccessPolicyRespArgs']]):
        pulumi.set(self, "resp", value)

    @_builtins.property
    @pulumi.getter
    def sub(self) -> Optional[pulumi.Input['IdentityNgsAccessPolicySubArgs']]:
        """
        Sub Permission.
        """
        return pulumi.get(self, "sub")

    @sub.setter
    def sub(self, value: Optional[pulumi.Input['IdentityNgsAccessPolicySubArgs']]):
        pulumi.set(self, "sub", value)

    @_builtins.property
    @pulumi.getter
    def subs(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max number of subscriptions per connection. Default: -1
        """
        return pulumi.get(self, "subs")

    @subs.setter
    def subs(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "subs", value)


if not MYPY:
    class IdentityNgsAccessPolicyPubArgsDict(TypedDict):
        allows: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of allow subjects.
        """
        denies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of deny subjects.
        """
elif False:
    IdentityNgsAccessPolicyPubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNgsAccessPolicyPubArgs:
    def __init__(__self__, *,
                 allows: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 denies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allows: List of allow subjects.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] denies: List of deny subjects.
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @_builtins.property
    @pulumi.getter
    def allows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allow subjects.
        """
        return pulumi.get(self, "allows")

    @allows.setter
    def allows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allows", value)

    @_builtins.property
    @pulumi.getter
    def denies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of deny subjects.
        """
        return pulumi.get(self, "denies")

    @denies.setter
    def denies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "denies", value)


if not MYPY:
    class IdentityNgsAccessPolicyRespArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of responses allowed on the replyTo subject, -1 means no limit. Default: -1
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deadline to send replies on the replyTo subject [#ms(millis) | #s(econds) | m(inutes) | h(ours)]. -1 means no restriction.
        """
elif False:
    IdentityNgsAccessPolicyRespArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNgsAccessPolicyRespArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] max: Number of responses allowed on the replyTo subject, -1 means no limit. Default: -1
        :param pulumi.Input[_builtins.str] ttl: Deadline to send replies on the replyTo subject [#ms(millis) | #s(econds) | m(inutes) | h(ours)]. -1 means no restriction.
        """
        if max is not None:
            pulumi.set(__self__, "max", max)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of responses allowed on the replyTo subject, -1 means no limit. Default: -1
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deadline to send replies on the replyTo subject [#ms(millis) | #s(econds) | m(inutes) | h(ours)]. -1 means no restriction.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class IdentityNgsAccessPolicySubArgsDict(TypedDict):
        allows: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of allow subjects.
        """
        denies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of deny subjects.
        """
elif False:
    IdentityNgsAccessPolicySubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IdentityNgsAccessPolicySubArgs:
    def __init__(__self__, *,
                 allows: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 denies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allows: List of allow subjects.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] denies: List of deny subjects.
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @_builtins.property
    @pulumi.getter
    def allows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of allow subjects.
        """
        return pulumi.get(self, "allows")

    @allows.setter
    def allows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allows", value)

    @_builtins.property
    @pulumi.getter
    def denies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of deny subjects.
        """
        return pulumi.get(self, "denies")

    @denies.setter
    def denies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "denies", value)


if not MYPY:
    class IpSetLocationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The self link of a location.
        """
        retention_policy: pulumi.Input[_builtins.str]
elif False:
    IpSetLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSetLocationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 retention_policy: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The self link of a location.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "retention_policy", retention_policy)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The self link of a location.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="retentionPolicy")
    def retention_policy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "retention_policy")

    @retention_policy.setter
    def retention_policy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "retention_policy", value)


if not MYPY:
    class IpSetStatusArgsDict(TypedDict):
        error: NotRequired[pulumi.Input[_builtins.str]]
        ip_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['IpSetStatusIpAddressArgsDict']]]]
        warning: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IpSetStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSetStatusArgs:
    def __init__(__self__, *,
                 error: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_addresses: Optional[pulumi.Input[Sequence[pulumi.Input['IpSetStatusIpAddressArgs']]]] = None,
                 warning: Optional[pulumi.Input[_builtins.str]] = None):
        if error is not None:
            pulumi.set(__self__, "error", error)
        if ip_addresses is not None:
            pulumi.set(__self__, "ip_addresses", ip_addresses)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter(name="ipAddresses")
    def ip_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IpSetStatusIpAddressArgs']]]]:
        return pulumi.get(self, "ip_addresses")

    @ip_addresses.setter
    def ip_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IpSetStatusIpAddressArgs']]]]):
        pulumi.set(self, "ip_addresses", value)

    @_builtins.property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class IpSetStatusIpAddressArgsDict(TypedDict):
        created: NotRequired[pulumi.Input[_builtins.str]]
        id: NotRequired[pulumi.Input[_builtins.str]]
        ip: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
        state: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    IpSetStatusIpAddressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IpSetStatusIpAddressArgs:
    def __init__(__self__, *,
                 created: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        if created is not None:
            pulumi.set(__self__, "created", created)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def created(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "created")

    @created.setter
    def created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class LocationGeoArgsDict(TypedDict):
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        City of the location.
        """
        continent: NotRequired[pulumi.Input[_builtins.str]]
        """
        Continent of the location.
        """
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        Country of the location.
        """
        lat: NotRequired[pulumi.Input[_builtins.float]]
        """
        Latitude of the location.
        """
        lon: NotRequired[pulumi.Input[_builtins.float]]
        """
        Longitude of the location.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        State of the location.
        """
elif False:
    LocationGeoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocationGeoArgs:
    def __init__(__self__, *,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 continent: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 lat: Optional[pulumi.Input[_builtins.float]] = None,
                 lon: Optional[pulumi.Input[_builtins.float]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] city: City of the location.
        :param pulumi.Input[_builtins.str] continent: Continent of the location.
        :param pulumi.Input[_builtins.str] country: Country of the location.
        :param pulumi.Input[_builtins.float] lat: Latitude of the location.
        :param pulumi.Input[_builtins.float] lon: Longitude of the location.
        :param pulumi.Input[_builtins.str] state: State of the location.
        """
        if city is not None:
            pulumi.set(__self__, "city", city)
        if continent is not None:
            pulumi.set(__self__, "continent", continent)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if lat is not None:
            pulumi.set(__self__, "lat", lat)
        if lon is not None:
            pulumi.set(__self__, "lon", lon)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City of the location.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def continent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Continent of the location.
        """
        return pulumi.get(self, "continent")

    @continent.setter
    def continent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "continent", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Country of the location.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def lat(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Latitude of the location.
        """
        return pulumi.get(self, "lat")

    @lat.setter
    def lat(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lat", value)

    @_builtins.property
    @pulumi.getter
    def lon(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Longitude of the location.
        """
        return pulumi.get(self, "lon")

    @lon.setter
    def lon(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "lon", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State of the location.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class Mk8sAddOnsArgsDict(TypedDict):
        aws_ecr: NotRequired[pulumi.Input['Mk8sAddOnsAwsEcrArgsDict']]
        aws_efs: NotRequired[pulumi.Input['Mk8sAddOnsAwsEfsArgsDict']]
        aws_elb: NotRequired[pulumi.Input['Mk8sAddOnsAwsElbArgsDict']]
        aws_workload_identity: NotRequired[pulumi.Input[_builtins.bool]]
        azure_acr: NotRequired[pulumi.Input['Mk8sAddOnsAzureAcrArgsDict']]
        azure_workload_identity: NotRequired[pulumi.Input['Mk8sAddOnsAzureWorkloadIdentityArgsDict']]
        byok: NotRequired[pulumi.Input['Mk8sAddOnsByokArgsDict']]
        """
        Bring-your-own Kubernetes (BYOK) add-on settings.
        """
        dashboard: NotRequired[pulumi.Input[_builtins.bool]]
        local_path_storage: NotRequired[pulumi.Input[_builtins.bool]]
        logs: NotRequired[pulumi.Input['Mk8sAddOnsLogsArgsDict']]
        metrics: NotRequired[pulumi.Input['Mk8sAddOnsMetricsArgsDict']]
        """
        Scrape pods annotated with prometheus.io/scrape=true
        """
        nvidia: NotRequired[pulumi.Input['Mk8sAddOnsNvidiaArgsDict']]
        registry_mirror: NotRequired[pulumi.Input['Mk8sAddOnsRegistryMirrorArgsDict']]
        sysbox: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    Mk8sAddOnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsArgs:
    def __init__(__self__, *,
                 aws_ecr: Optional[pulumi.Input['Mk8sAddOnsAwsEcrArgs']] = None,
                 aws_efs: Optional[pulumi.Input['Mk8sAddOnsAwsEfsArgs']] = None,
                 aws_elb: Optional[pulumi.Input['Mk8sAddOnsAwsElbArgs']] = None,
                 aws_workload_identity: Optional[pulumi.Input[_builtins.bool]] = None,
                 azure_acr: Optional[pulumi.Input['Mk8sAddOnsAzureAcrArgs']] = None,
                 azure_workload_identity: Optional[pulumi.Input['Mk8sAddOnsAzureWorkloadIdentityArgs']] = None,
                 byok: Optional[pulumi.Input['Mk8sAddOnsByokArgs']] = None,
                 dashboard: Optional[pulumi.Input[_builtins.bool]] = None,
                 local_path_storage: Optional[pulumi.Input[_builtins.bool]] = None,
                 logs: Optional[pulumi.Input['Mk8sAddOnsLogsArgs']] = None,
                 metrics: Optional[pulumi.Input['Mk8sAddOnsMetricsArgs']] = None,
                 nvidia: Optional[pulumi.Input['Mk8sAddOnsNvidiaArgs']] = None,
                 registry_mirror: Optional[pulumi.Input['Mk8sAddOnsRegistryMirrorArgs']] = None,
                 sysbox: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['Mk8sAddOnsByokArgs'] byok: Bring-your-own Kubernetes (BYOK) add-on settings.
        :param pulumi.Input['Mk8sAddOnsMetricsArgs'] metrics: Scrape pods annotated with prometheus.io/scrape=true
        """
        if aws_ecr is not None:
            pulumi.set(__self__, "aws_ecr", aws_ecr)
        if aws_efs is not None:
            pulumi.set(__self__, "aws_efs", aws_efs)
        if aws_elb is not None:
            pulumi.set(__self__, "aws_elb", aws_elb)
        if aws_workload_identity is not None:
            pulumi.set(__self__, "aws_workload_identity", aws_workload_identity)
        if azure_acr is not None:
            pulumi.set(__self__, "azure_acr", azure_acr)
        if azure_workload_identity is not None:
            pulumi.set(__self__, "azure_workload_identity", azure_workload_identity)
        if byok is not None:
            pulumi.set(__self__, "byok", byok)
        if dashboard is not None:
            pulumi.set(__self__, "dashboard", dashboard)
        if local_path_storage is not None:
            pulumi.set(__self__, "local_path_storage", local_path_storage)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if nvidia is not None:
            pulumi.set(__self__, "nvidia", nvidia)
        if registry_mirror is not None:
            pulumi.set(__self__, "registry_mirror", registry_mirror)
        if sysbox is not None:
            pulumi.set(__self__, "sysbox", sysbox)

    @_builtins.property
    @pulumi.getter(name="awsEcr")
    def aws_ecr(self) -> Optional[pulumi.Input['Mk8sAddOnsAwsEcrArgs']]:
        return pulumi.get(self, "aws_ecr")

    @aws_ecr.setter
    def aws_ecr(self, value: Optional[pulumi.Input['Mk8sAddOnsAwsEcrArgs']]):
        pulumi.set(self, "aws_ecr", value)

    @_builtins.property
    @pulumi.getter(name="awsEfs")
    def aws_efs(self) -> Optional[pulumi.Input['Mk8sAddOnsAwsEfsArgs']]:
        return pulumi.get(self, "aws_efs")

    @aws_efs.setter
    def aws_efs(self, value: Optional[pulumi.Input['Mk8sAddOnsAwsEfsArgs']]):
        pulumi.set(self, "aws_efs", value)

    @_builtins.property
    @pulumi.getter(name="awsElb")
    def aws_elb(self) -> Optional[pulumi.Input['Mk8sAddOnsAwsElbArgs']]:
        return pulumi.get(self, "aws_elb")

    @aws_elb.setter
    def aws_elb(self, value: Optional[pulumi.Input['Mk8sAddOnsAwsElbArgs']]):
        pulumi.set(self, "aws_elb", value)

    @_builtins.property
    @pulumi.getter(name="awsWorkloadIdentity")
    def aws_workload_identity(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "aws_workload_identity")

    @aws_workload_identity.setter
    def aws_workload_identity(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "aws_workload_identity", value)

    @_builtins.property
    @pulumi.getter(name="azureAcr")
    def azure_acr(self) -> Optional[pulumi.Input['Mk8sAddOnsAzureAcrArgs']]:
        return pulumi.get(self, "azure_acr")

    @azure_acr.setter
    def azure_acr(self, value: Optional[pulumi.Input['Mk8sAddOnsAzureAcrArgs']]):
        pulumi.set(self, "azure_acr", value)

    @_builtins.property
    @pulumi.getter(name="azureWorkloadIdentity")
    def azure_workload_identity(self) -> Optional[pulumi.Input['Mk8sAddOnsAzureWorkloadIdentityArgs']]:
        return pulumi.get(self, "azure_workload_identity")

    @azure_workload_identity.setter
    def azure_workload_identity(self, value: Optional[pulumi.Input['Mk8sAddOnsAzureWorkloadIdentityArgs']]):
        pulumi.set(self, "azure_workload_identity", value)

    @_builtins.property
    @pulumi.getter
    def byok(self) -> Optional[pulumi.Input['Mk8sAddOnsByokArgs']]:
        """
        Bring-your-own Kubernetes (BYOK) add-on settings.
        """
        return pulumi.get(self, "byok")

    @byok.setter
    def byok(self, value: Optional[pulumi.Input['Mk8sAddOnsByokArgs']]):
        pulumi.set(self, "byok", value)

    @_builtins.property
    @pulumi.getter
    def dashboard(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "dashboard")

    @dashboard.setter
    def dashboard(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "dashboard", value)

    @_builtins.property
    @pulumi.getter(name="localPathStorage")
    def local_path_storage(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "local_path_storage")

    @local_path_storage.setter
    def local_path_storage(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "local_path_storage", value)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input['Mk8sAddOnsLogsArgs']]:
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input['Mk8sAddOnsLogsArgs']]):
        pulumi.set(self, "logs", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['Mk8sAddOnsMetricsArgs']]:
        """
        Scrape pods annotated with prometheus.io/scrape=true
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['Mk8sAddOnsMetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter
    def nvidia(self) -> Optional[pulumi.Input['Mk8sAddOnsNvidiaArgs']]:
        return pulumi.get(self, "nvidia")

    @nvidia.setter
    def nvidia(self, value: Optional[pulumi.Input['Mk8sAddOnsNvidiaArgs']]):
        pulumi.set(self, "nvidia", value)

    @_builtins.property
    @pulumi.getter(name="registryMirror")
    def registry_mirror(self) -> Optional[pulumi.Input['Mk8sAddOnsRegistryMirrorArgs']]:
        return pulumi.get(self, "registry_mirror")

    @registry_mirror.setter
    def registry_mirror(self, value: Optional[pulumi.Input['Mk8sAddOnsRegistryMirrorArgs']]):
        pulumi.set(self, "registry_mirror", value)

    @_builtins.property
    @pulumi.getter
    def sysbox(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "sysbox")

    @sysbox.setter
    def sysbox(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "sysbox", value)


if not MYPY:
    class Mk8sAddOnsAwsEcrArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role to use when authorizing ECR pulls. Optional on AWS, in which case it will use the instance role to pull.
        """
elif False:
    Mk8sAddOnsAwsEcrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsAwsEcrArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] role_arn: Role to use when authorizing ECR pulls. Optional on AWS, in which case it will use the instance role to pull.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role to use when authorizing ECR pulls. Optional on AWS, in which case it will use the instance role to pull.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class Mk8sAddOnsAwsEfsArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Use this role for EFS interaction.
        """
elif False:
    Mk8sAddOnsAwsEfsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsAwsEfsArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] role_arn: Use this role for EFS interaction.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Use this role for EFS interaction.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class Mk8sAddOnsAwsElbArgsDict(TypedDict):
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role to use when authorizing calls to EC2 ELB. Optional on AWS, when not provided it will create the recommended role.
        """
elif False:
    Mk8sAddOnsAwsElbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsAwsElbArgs:
    def __init__(__self__, *,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] role_arn: Role to use when authorizing calls to EC2 ELB. Optional on AWS, when not provided it will create the recommended role.
        """
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role to use when authorizing calls to EC2 ELB. Optional on AWS, when not provided it will create the recommended role.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class Mk8sAddOnsAzureAcrArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
elif False:
    Mk8sAddOnsAzureAcrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsAzureAcrArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "client_id", client_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)


if not MYPY:
    class Mk8sAddOnsAzureWorkloadIdentityArgsDict(TypedDict):
        tenant_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tenant ID to use for workload identity.
        """
elif False:
    Mk8sAddOnsAzureWorkloadIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsAzureWorkloadIdentityArgs:
    def __init__(__self__, *,
                 tenant_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tenant_id: Tenant ID to use for workload identity.
        """
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tenant ID to use for workload identity.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class Mk8sAddOnsByokArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        """
        The full link of a BYOK location.
        """
        config: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigArgsDict']]
        """
        Fine-grained configuration for the BYOK workloads.
        """
        ignore_updates: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable Control Plane managed upgrades for BYOK components.
        """
elif False:
    Mk8sAddOnsByokArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 config: Optional[pulumi.Input['Mk8sAddOnsByokConfigArgs']] = None,
                 ignore_updates: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The full link of a BYOK location.
        :param pulumi.Input['Mk8sAddOnsByokConfigArgs'] config: Fine-grained configuration for the BYOK workloads.
        :param pulumi.Input[_builtins.bool] ignore_updates: Disable Control Plane managed upgrades for BYOK components.
        """
        pulumi.set(__self__, "location", location)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if ignore_updates is not None:
            pulumi.set(__self__, "ignore_updates", ignore_updates)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        The full link of a BYOK location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigArgs']]:
        """
        Fine-grained configuration for the BYOK workloads.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigArgs']]):
        pulumi.set(self, "config", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUpdates")
    def ignore_updates(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable Control Plane managed upgrades for BYOK components.
        """
        return pulumi.get(self, "ignore_updates")

    @ignore_updates.setter
    def ignore_updates(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_updates", value)


if not MYPY:
    class Mk8sAddOnsByokConfigArgsDict(TypedDict):
        actuator: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigActuatorArgsDict']]
        """
        Resource tuning for the actuator component.
        """
        common: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigCommonArgsDict']]
        """
        Shared rollout settings for BYOK workloads.
        """
        ingress: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigIngressArgsDict']]
        """
        Ingress controller resource configuration.
        """
        internal_dns: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigInternalDnsArgsDict']]
        """
        Internal DNS deployment settings.
        """
        istio: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigIstioArgsDict']]
        """
        Istio service mesh configuration.
        """
        log_splitter: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigLogSplitterArgsDict']]
        """
        Log splitter deployment configuration.
        """
        longhorn: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigLonghornArgsDict']]
        """
        Longhorn persistent volume settings.
        """
        middlebox: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigMiddleboxArgsDict']]
        """
        Configuration for the optional middlebox traffic shaper.
        """
        monitoring: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigMonitoringArgsDict']]
        """
        Monitoring stack configuration.
        """
        redis: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigRedisArgsDict']]
        """
        Redis cache configuration.
        """
        redis_ha: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigRedisHaArgsDict']]
        """
        High-availability Redis configuration.
        """
        redis_sentinel: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigRedisSentinelArgsDict']]
        """
        Redis Sentinel configuration.
        """
        tempo_agent: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigTempoAgentArgsDict']]
        """
        Tempo agent resource configuration.
        """
elif False:
    Mk8sAddOnsByokConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigArgs:
    def __init__(__self__, *,
                 actuator: Optional[pulumi.Input['Mk8sAddOnsByokConfigActuatorArgs']] = None,
                 common: Optional[pulumi.Input['Mk8sAddOnsByokConfigCommonArgs']] = None,
                 ingress: Optional[pulumi.Input['Mk8sAddOnsByokConfigIngressArgs']] = None,
                 internal_dns: Optional[pulumi.Input['Mk8sAddOnsByokConfigInternalDnsArgs']] = None,
                 istio: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioArgs']] = None,
                 log_splitter: Optional[pulumi.Input['Mk8sAddOnsByokConfigLogSplitterArgs']] = None,
                 longhorn: Optional[pulumi.Input['Mk8sAddOnsByokConfigLonghornArgs']] = None,
                 middlebox: Optional[pulumi.Input['Mk8sAddOnsByokConfigMiddleboxArgs']] = None,
                 monitoring: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringArgs']] = None,
                 redis: Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisArgs']] = None,
                 redis_ha: Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisHaArgs']] = None,
                 redis_sentinel: Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisSentinelArgs']] = None,
                 tempo_agent: Optional[pulumi.Input['Mk8sAddOnsByokConfigTempoAgentArgs']] = None):
        """
        :param pulumi.Input['Mk8sAddOnsByokConfigActuatorArgs'] actuator: Resource tuning for the actuator component.
        :param pulumi.Input['Mk8sAddOnsByokConfigCommonArgs'] common: Shared rollout settings for BYOK workloads.
        :param pulumi.Input['Mk8sAddOnsByokConfigIngressArgs'] ingress: Ingress controller resource configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigInternalDnsArgs'] internal_dns: Internal DNS deployment settings.
        :param pulumi.Input['Mk8sAddOnsByokConfigIstioArgs'] istio: Istio service mesh configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigLogSplitterArgs'] log_splitter: Log splitter deployment configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigLonghornArgs'] longhorn: Longhorn persistent volume settings.
        :param pulumi.Input['Mk8sAddOnsByokConfigMiddleboxArgs'] middlebox: Configuration for the optional middlebox traffic shaper.
        :param pulumi.Input['Mk8sAddOnsByokConfigMonitoringArgs'] monitoring: Monitoring stack configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigRedisArgs'] redis: Redis cache configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigRedisHaArgs'] redis_ha: High-availability Redis configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigRedisSentinelArgs'] redis_sentinel: Redis Sentinel configuration.
        :param pulumi.Input['Mk8sAddOnsByokConfigTempoAgentArgs'] tempo_agent: Tempo agent resource configuration.
        """
        if actuator is not None:
            pulumi.set(__self__, "actuator", actuator)
        if common is not None:
            pulumi.set(__self__, "common", common)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if internal_dns is not None:
            pulumi.set(__self__, "internal_dns", internal_dns)
        if istio is not None:
            pulumi.set(__self__, "istio", istio)
        if log_splitter is not None:
            pulumi.set(__self__, "log_splitter", log_splitter)
        if longhorn is not None:
            pulumi.set(__self__, "longhorn", longhorn)
        if middlebox is not None:
            pulumi.set(__self__, "middlebox", middlebox)
        if monitoring is not None:
            pulumi.set(__self__, "monitoring", monitoring)
        if redis is not None:
            pulumi.set(__self__, "redis", redis)
        if redis_ha is not None:
            pulumi.set(__self__, "redis_ha", redis_ha)
        if redis_sentinel is not None:
            pulumi.set(__self__, "redis_sentinel", redis_sentinel)
        if tempo_agent is not None:
            pulumi.set(__self__, "tempo_agent", tempo_agent)

    @_builtins.property
    @pulumi.getter
    def actuator(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigActuatorArgs']]:
        """
        Resource tuning for the actuator component.
        """
        return pulumi.get(self, "actuator")

    @actuator.setter
    def actuator(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigActuatorArgs']]):
        pulumi.set(self, "actuator", value)

    @_builtins.property
    @pulumi.getter
    def common(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigCommonArgs']]:
        """
        Shared rollout settings for BYOK workloads.
        """
        return pulumi.get(self, "common")

    @common.setter
    def common(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigCommonArgs']]):
        pulumi.set(self, "common", value)

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigIngressArgs']]:
        """
        Ingress controller resource configuration.
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigIngressArgs']]):
        pulumi.set(self, "ingress", value)

    @_builtins.property
    @pulumi.getter(name="internalDns")
    def internal_dns(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigInternalDnsArgs']]:
        """
        Internal DNS deployment settings.
        """
        return pulumi.get(self, "internal_dns")

    @internal_dns.setter
    def internal_dns(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigInternalDnsArgs']]):
        pulumi.set(self, "internal_dns", value)

    @_builtins.property
    @pulumi.getter
    def istio(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioArgs']]:
        """
        Istio service mesh configuration.
        """
        return pulumi.get(self, "istio")

    @istio.setter
    def istio(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioArgs']]):
        pulumi.set(self, "istio", value)

    @_builtins.property
    @pulumi.getter(name="logSplitter")
    def log_splitter(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigLogSplitterArgs']]:
        """
        Log splitter deployment configuration.
        """
        return pulumi.get(self, "log_splitter")

    @log_splitter.setter
    def log_splitter(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigLogSplitterArgs']]):
        pulumi.set(self, "log_splitter", value)

    @_builtins.property
    @pulumi.getter
    def longhorn(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigLonghornArgs']]:
        """
        Longhorn persistent volume settings.
        """
        return pulumi.get(self, "longhorn")

    @longhorn.setter
    def longhorn(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigLonghornArgs']]):
        pulumi.set(self, "longhorn", value)

    @_builtins.property
    @pulumi.getter
    def middlebox(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigMiddleboxArgs']]:
        """
        Configuration for the optional middlebox traffic shaper.
        """
        return pulumi.get(self, "middlebox")

    @middlebox.setter
    def middlebox(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigMiddleboxArgs']]):
        pulumi.set(self, "middlebox", value)

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringArgs']]:
        """
        Monitoring stack configuration.
        """
        return pulumi.get(self, "monitoring")

    @monitoring.setter
    def monitoring(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringArgs']]):
        pulumi.set(self, "monitoring", value)

    @_builtins.property
    @pulumi.getter
    def redis(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisArgs']]:
        """
        Redis cache configuration.
        """
        return pulumi.get(self, "redis")

    @redis.setter
    def redis(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisArgs']]):
        pulumi.set(self, "redis", value)

    @_builtins.property
    @pulumi.getter(name="redisHa")
    def redis_ha(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisHaArgs']]:
        """
        High-availability Redis configuration.
        """
        return pulumi.get(self, "redis_ha")

    @redis_ha.setter
    def redis_ha(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisHaArgs']]):
        pulumi.set(self, "redis_ha", value)

    @_builtins.property
    @pulumi.getter(name="redisSentinel")
    def redis_sentinel(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisSentinelArgs']]:
        """
        Redis Sentinel configuration.
        """
        return pulumi.get(self, "redis_sentinel")

    @redis_sentinel.setter
    def redis_sentinel(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigRedisSentinelArgs']]):
        pulumi.set(self, "redis_sentinel", value)

    @_builtins.property
    @pulumi.getter(name="tempoAgent")
    def tempo_agent(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigTempoAgentArgs']]:
        """
        Tempo agent resource configuration.
        """
        return pulumi.get(self, "tempo_agent")

    @tempo_agent.setter
    def tempo_agent(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigTempoAgentArgs']]):
        pulumi.set(self, "tempo_agent", value)


if not MYPY:
    class Mk8sAddOnsByokConfigActuatorArgsDict(TypedDict):
        env: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional environment variables injected into actuator pods.
        """
        log_level: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log level override for actuator containers. Valid values are: trace, info, error.
        """
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to actuator pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to actuator pods.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum CPU request applied to actuator pods (e.g. "100m").
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum memory request applied to actuator pods (e.g. "128Mi").
        """
elif False:
    Mk8sAddOnsByokConfigActuatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigActuatorArgs:
    def __init__(__self__, *,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 log_level: Optional[pulumi.Input[_builtins.str]] = None,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] env: Additional environment variables injected into actuator pods.
        :param pulumi.Input[_builtins.str] log_level: Log level override for actuator containers. Valid values are: trace, info, error.
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to actuator pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to actuator pods.
        :param pulumi.Input[_builtins.str] min_cpu: Minimum CPU request applied to actuator pods (e.g. "100m").
        :param pulumi.Input[_builtins.str] min_memory: Minimum memory request applied to actuator pods (e.g. "128Mi").
        """
        if env is not None:
            pulumi.set(__self__, "env", env)
        if log_level is not None:
            pulumi.set(__self__, "log_level", log_level)
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional environment variables injected into actuator pods.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "env", value)

    @_builtins.property
    @pulumi.getter(name="logLevel")
    def log_level(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log level override for actuator containers. Valid values are: trace, info, error.
        """
        return pulumi.get(self, "log_level")

    @log_level.setter
    def log_level(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_level", value)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to actuator pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to actuator pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum CPU request applied to actuator pods (e.g. "100m").
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum memory request applied to actuator pods (e.g. "128Mi").
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)


if not MYPY:
    class Mk8sAddOnsByokConfigCommonArgsDict(TypedDict):
        deployment_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        Replica count shared by BYOK control plane deployments.
        """
        pdb: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigCommonPdbArgsDict']]
        """
        Pod disruption budget limits for BYOK workloads.
        """
elif False:
    Mk8sAddOnsByokConfigCommonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigCommonArgs:
    def __init__(__self__, *,
                 deployment_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 pdb: Optional[pulumi.Input['Mk8sAddOnsByokConfigCommonPdbArgs']] = None):
        """
        :param pulumi.Input[_builtins.int] deployment_replicas: Replica count shared by BYOK control plane deployments.
        :param pulumi.Input['Mk8sAddOnsByokConfigCommonPdbArgs'] pdb: Pod disruption budget limits for BYOK workloads.
        """
        if deployment_replicas is not None:
            pulumi.set(__self__, "deployment_replicas", deployment_replicas)
        if pdb is not None:
            pulumi.set(__self__, "pdb", pdb)

    @_builtins.property
    @pulumi.getter(name="deploymentReplicas")
    def deployment_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Replica count shared by BYOK control plane deployments.
        """
        return pulumi.get(self, "deployment_replicas")

    @deployment_replicas.setter
    def deployment_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "deployment_replicas", value)

    @_builtins.property
    @pulumi.getter
    def pdb(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigCommonPdbArgs']]:
        """
        Pod disruption budget limits for BYOK workloads.
        """
        return pulumi.get(self, "pdb")

    @pdb.setter
    def pdb(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigCommonPdbArgs']]):
        pulumi.set(self, "pdb", value)


if not MYPY:
    class Mk8sAddOnsByokConfigCommonPdbArgsDict(TypedDict):
        max_unavailable: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of pods that can be unavailable during disruptions.
        """
elif False:
    Mk8sAddOnsByokConfigCommonPdbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigCommonPdbArgs:
    def __init__(__self__, *,
                 max_unavailable: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] max_unavailable: Maximum number of pods that can be unavailable during disruptions.
        """
        if max_unavailable is not None:
            pulumi.set(__self__, "max_unavailable", max_unavailable)

    @_builtins.property
    @pulumi.getter(name="maxUnavailable")
    def max_unavailable(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of pods that can be unavailable during disruptions.
        """
        return pulumi.get(self, "max_unavailable")

    @max_unavailable.setter
    def max_unavailable(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_unavailable", value)


if not MYPY:
    class Mk8sAddOnsByokConfigIngressArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request/limit string applied to ingress pods.
        """
        memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request/limit string applied to ingress pods.
        """
        target_percent: NotRequired[pulumi.Input[_builtins.float]]
        """
        Target usage percentage that triggers ingress autoscaling.
        """
elif False:
    Mk8sAddOnsByokConfigIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigIngressArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 memory: Optional[pulumi.Input[_builtins.str]] = None,
                 target_percent: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] cpu: CPU request/limit string applied to ingress pods.
        :param pulumi.Input[_builtins.str] memory: Memory request/limit string applied to ingress pods.
        :param pulumi.Input[_builtins.float] target_percent: Target usage percentage that triggers ingress autoscaling.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if target_percent is not None:
            pulumi.set(__self__, "target_percent", target_percent)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request/limit string applied to ingress pods.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request/limit string applied to ingress pods.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter(name="targetPercent")
    def target_percent(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Target usage percentage that triggers ingress autoscaling.
        """
        return pulumi.get(self, "target_percent")

    @target_percent.setter
    def target_percent(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "target_percent", value)


if not MYPY:
    class Mk8sAddOnsByokConfigInternalDnsArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to internal DNS pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to internal DNS pods.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to internal DNS pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to internal DNS pods.
        """
elif False:
    Mk8sAddOnsByokConfigInternalDnsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigInternalDnsArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to internal DNS pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to internal DNS pods.
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to internal DNS pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to internal DNS pods.
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to internal DNS pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to internal DNS pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to internal DNS pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to internal DNS pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)


if not MYPY:
    class Mk8sAddOnsByokConfigIstioArgsDict(TypedDict):
        ingress_gateway: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigIstioIngressGatewayArgsDict']]
        """
        Istio ingress gateway deployment settings.
        """
        istiod: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigIstioIstiodArgsDict']]
        """
        Control plane deployment settings for istiod.
        """
        sidecar: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigIstioSidecarArgsDict']]
        """
        Default resource requests for Istio sidecar injection.
        """
elif False:
    Mk8sAddOnsByokConfigIstioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigIstioArgs:
    def __init__(__self__, *,
                 ingress_gateway: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioIngressGatewayArgs']] = None,
                 istiod: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioIstiodArgs']] = None,
                 sidecar: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioSidecarArgs']] = None):
        """
        :param pulumi.Input['Mk8sAddOnsByokConfigIstioIngressGatewayArgs'] ingress_gateway: Istio ingress gateway deployment settings.
        :param pulumi.Input['Mk8sAddOnsByokConfigIstioIstiodArgs'] istiod: Control plane deployment settings for istiod.
        :param pulumi.Input['Mk8sAddOnsByokConfigIstioSidecarArgs'] sidecar: Default resource requests for Istio sidecar injection.
        """
        if ingress_gateway is not None:
            pulumi.set(__self__, "ingress_gateway", ingress_gateway)
        if istiod is not None:
            pulumi.set(__self__, "istiod", istiod)
        if sidecar is not None:
            pulumi.set(__self__, "sidecar", sidecar)

    @_builtins.property
    @pulumi.getter(name="ingressGateway")
    def ingress_gateway(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioIngressGatewayArgs']]:
        """
        Istio ingress gateway deployment settings.
        """
        return pulumi.get(self, "ingress_gateway")

    @ingress_gateway.setter
    def ingress_gateway(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioIngressGatewayArgs']]):
        pulumi.set(self, "ingress_gateway", value)

    @_builtins.property
    @pulumi.getter
    def istiod(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioIstiodArgs']]:
        """
        Control plane deployment settings for istiod.
        """
        return pulumi.get(self, "istiod")

    @istiod.setter
    def istiod(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioIstiodArgs']]):
        pulumi.set(self, "istiod", value)

    @_builtins.property
    @pulumi.getter
    def sidecar(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioSidecarArgs']]:
        """
        Default resource requests for Istio sidecar injection.
        """
        return pulumi.get(self, "sidecar")

    @sidecar.setter
    def sidecar(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigIstioSidecarArgs']]):
        pulumi.set(self, "sidecar", value)


if not MYPY:
    class Mk8sAddOnsByokConfigIstioIngressGatewayArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to ingress gateway pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to ingress gateway pods.
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of ingress gateway replicas.
        """
elif False:
    Mk8sAddOnsByokConfigIstioIngressGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigIstioIngressGatewayArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to ingress gateway pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to ingress gateway pods.
        :param pulumi.Input[_builtins.int] replicas: Number of ingress gateway replicas.
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to ingress gateway pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to ingress gateway pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of ingress gateway replicas.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class Mk8sAddOnsByokConfigIstioIstiodArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to istiod pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to istiod pods.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to istiod pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to istiod pods.
        """
        pdb: NotRequired[pulumi.Input[_builtins.int]]
        """
        Pod disruption budget maxUnavailable for istiod.
        """
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of istiod replicas.
        """
elif False:
    Mk8sAddOnsByokConfigIstioIstiodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigIstioIstiodArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 pdb: Optional[pulumi.Input[_builtins.int]] = None,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to istiod pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to istiod pods.
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to istiod pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to istiod pods.
        :param pulumi.Input[_builtins.int] pdb: Pod disruption budget maxUnavailable for istiod.
        :param pulumi.Input[_builtins.int] replicas: Number of istiod replicas.
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if pdb is not None:
            pulumi.set(__self__, "pdb", pdb)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to istiod pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to istiod pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to istiod pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to istiod pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    def pdb(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Pod disruption budget maxUnavailable for istiod.
        """
        return pulumi.get(self, "pdb")

    @pdb.setter
    def pdb(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "pdb", value)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of istiod replicas.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class Mk8sAddOnsByokConfigIstioSidecarArgsDict(TypedDict):
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to injected sidecars.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to injected sidecars.
        """
elif False:
    Mk8sAddOnsByokConfigIstioSidecarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigIstioSidecarArgs:
    def __init__(__self__, *,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to injected sidecars.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to injected sidecars.
        """
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to injected sidecars.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to injected sidecars.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)


if not MYPY:
    class Mk8sAddOnsByokConfigLogSplitterArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to log splitter pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to log splitter pods.
        """
        mem_buffer_size: NotRequired[pulumi.Input[_builtins.str]]
        """
        In-memory buffer size consumed by each log splitter pod.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to log splitter pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to log splitter pods.
        """
        per_pod_rate: NotRequired[pulumi.Input[_builtins.int]]
        """
        Per-pod log processing rate limit.
        """
elif False:
    Mk8sAddOnsByokConfigLogSplitterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigLogSplitterArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 mem_buffer_size: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 per_pod_rate: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to log splitter pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to log splitter pods.
        :param pulumi.Input[_builtins.str] mem_buffer_size: In-memory buffer size consumed by each log splitter pod.
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to log splitter pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to log splitter pods.
        :param pulumi.Input[_builtins.int] per_pod_rate: Per-pod log processing rate limit.
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if mem_buffer_size is not None:
            pulumi.set(__self__, "mem_buffer_size", mem_buffer_size)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if per_pod_rate is not None:
            pulumi.set(__self__, "per_pod_rate", per_pod_rate)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to log splitter pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to log splitter pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="memBufferSize")
    def mem_buffer_size(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        In-memory buffer size consumed by each log splitter pod.
        """
        return pulumi.get(self, "mem_buffer_size")

    @mem_buffer_size.setter
    def mem_buffer_size(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mem_buffer_size", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to log splitter pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to log splitter pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter(name="perPodRate")
    def per_pod_rate(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Per-pod log processing rate limit.
        """
        return pulumi.get(self, "per_pod_rate")

    @per_pod_rate.setter
    def per_pod_rate(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "per_pod_rate", value)


if not MYPY:
    class Mk8sAddOnsByokConfigLonghornArgsDict(TypedDict):
        replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        Replica factor for Longhorn volumes. Minimum: 1.
        """
elif False:
    Mk8sAddOnsByokConfigLonghornArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigLonghornArgs:
    def __init__(__self__, *,
                 replicas: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] replicas: Replica factor for Longhorn volumes. Minimum: 1.
        """
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @_builtins.property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Replica factor for Longhorn volumes. Minimum: 1.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "replicas", value)


if not MYPY:
    class Mk8sAddOnsByokConfigMiddleboxArgsDict(TypedDict):
        bandwidth_alert_mbps: NotRequired[pulumi.Input[_builtins.int]]
        """
        Alert threshold, in Mbps, for middlebox bandwidth usage.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to deploy the middlebox component.
        """
elif False:
    Mk8sAddOnsByokConfigMiddleboxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigMiddleboxArgs:
    def __init__(__self__, *,
                 bandwidth_alert_mbps: Optional[pulumi.Input[_builtins.int]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] bandwidth_alert_mbps: Alert threshold, in Mbps, for middlebox bandwidth usage.
        :param pulumi.Input[_builtins.bool] enabled: Whether to deploy the middlebox component.
        """
        if bandwidth_alert_mbps is not None:
            pulumi.set(__self__, "bandwidth_alert_mbps", bandwidth_alert_mbps)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="bandwidthAlertMbps")
    def bandwidth_alert_mbps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Alert threshold, in Mbps, for middlebox bandwidth usage.
        """
        return pulumi.get(self, "bandwidth_alert_mbps")

    @bandwidth_alert_mbps.setter
    def bandwidth_alert_mbps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "bandwidth_alert_mbps", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to deploy the middlebox component.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class Mk8sAddOnsByokConfigMonitoringArgsDict(TypedDict):
        kube_state_metrics: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgsDict']]
        """
        Kube-state-metrics resource overrides.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Maximum memory limit for monitoring components.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum memory request for monitoring components.
        """
        prometheus: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusArgsDict']]
        """
        Prometheus deployment configuration.
        """
elif False:
    Mk8sAddOnsByokConfigMonitoringArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigMonitoringArgs:
    def __init__(__self__, *,
                 kube_state_metrics: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgs']] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 prometheus: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusArgs']] = None):
        """
        :param pulumi.Input['Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgs'] kube_state_metrics: Kube-state-metrics resource overrides.
        :param pulumi.Input[_builtins.str] max_memory: Maximum memory limit for monitoring components.
        :param pulumi.Input[_builtins.str] min_memory: Minimum memory request for monitoring components.
        :param pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusArgs'] prometheus: Prometheus deployment configuration.
        """
        if kube_state_metrics is not None:
            pulumi.set(__self__, "kube_state_metrics", kube_state_metrics)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)

    @_builtins.property
    @pulumi.getter(name="kubeStateMetrics")
    def kube_state_metrics(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgs']]:
        """
        Kube-state-metrics resource overrides.
        """
        return pulumi.get(self, "kube_state_metrics")

    @kube_state_metrics.setter
    def kube_state_metrics(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgs']]):
        pulumi.set(self, "kube_state_metrics", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Maximum memory limit for monitoring components.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum memory request for monitoring components.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    def prometheus(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusArgs']]:
        """
        Prometheus deployment configuration.
        """
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusArgs']]):
        pulumi.set(self, "prometheus", value)


if not MYPY:
    class Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgsDict(TypedDict):
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to kube-state-metrics pods.
        """
elif False:
    Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigMonitoringKubeStateMetricsArgs:
    def __init__(__self__, *,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to kube-state-metrics pods.
        """
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to kube-state-metrics pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)


if not MYPY:
    class Mk8sAddOnsByokConfigMonitoringPrometheusArgsDict(TypedDict):
        main: NotRequired[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusMainArgsDict']]
        """
        Primary Prometheus instance settings.
        """
elif False:
    Mk8sAddOnsByokConfigMonitoringPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigMonitoringPrometheusArgs:
    def __init__(__self__, *,
                 main: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusMainArgs']] = None):
        """
        :param pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusMainArgs'] main: Primary Prometheus instance settings.
        """
        if main is not None:
            pulumi.set(__self__, "main", main)

    @_builtins.property
    @pulumi.getter
    def main(self) -> Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusMainArgs']]:
        """
        Primary Prometheus instance settings.
        """
        return pulumi.get(self, "main")

    @main.setter
    def main(self, value: Optional[pulumi.Input['Mk8sAddOnsByokConfigMonitoringPrometheusMainArgs']]):
        pulumi.set(self, "main", value)


if not MYPY:
    class Mk8sAddOnsByokConfigMonitoringPrometheusMainArgsDict(TypedDict):
        storage: NotRequired[pulumi.Input[_builtins.str]]
        """
        Persistent volume size for Prometheus (for example, "50Gi").
        """
elif False:
    Mk8sAddOnsByokConfigMonitoringPrometheusMainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigMonitoringPrometheusMainArgs:
    def __init__(__self__, *,
                 storage: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] storage: Persistent volume size for Prometheus (for example, "50Gi").
        """
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Persistent volume size for Prometheus (for example, "50Gi").
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class Mk8sAddOnsByokConfigRedisArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to the Redis pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to the Redis pods.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to the Redis pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to the Redis pods.
        """
        storage: NotRequired[pulumi.Input[_builtins.str]]
        """
        Persistent storage size allocated to the Redis pods (for example, "8Gi").
        """
elif False:
    Mk8sAddOnsByokConfigRedisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigRedisArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 storage: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to the Redis pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to the Redis pods.
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to the Redis pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to the Redis pods.
        :param pulumi.Input[_builtins.str] storage: Persistent storage size allocated to the Redis pods (for example, "8Gi").
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to the Redis pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to the Redis pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to the Redis pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to the Redis pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Persistent storage size allocated to the Redis pods (for example, "8Gi").
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class Mk8sAddOnsByokConfigRedisHaArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to the Redis pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to the Redis pods.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to the Redis pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to the Redis pods.
        """
        storage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Persistent storage size allocated to the Redis pods, in GiB.
        """
elif False:
    Mk8sAddOnsByokConfigRedisHaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigRedisHaArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 storage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to the Redis pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to the Redis pods.
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to the Redis pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to the Redis pods.
        :param pulumi.Input[_builtins.int] storage: Persistent storage size allocated to the Redis pods, in GiB.
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to the Redis pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to the Redis pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to the Redis pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to the Redis pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Persistent storage size allocated to the Redis pods, in GiB.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class Mk8sAddOnsByokConfigRedisSentinelArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU limit applied to the Redis pods.
        """
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory limit applied to the Redis pods.
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to the Redis pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to the Redis pods.
        """
        storage: NotRequired[pulumi.Input[_builtins.int]]
        """
        Persistent storage size allocated to the Redis pods, in GiB.
        """
elif False:
    Mk8sAddOnsByokConfigRedisSentinelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigRedisSentinelArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 storage: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] max_cpu: CPU limit applied to the Redis pods.
        :param pulumi.Input[_builtins.str] max_memory: Memory limit applied to the Redis pods.
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to the Redis pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to the Redis pods.
        :param pulumi.Input[_builtins.int] storage: Persistent storage size allocated to the Redis pods, in GiB.
        """
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU limit applied to the Redis pods.
        """
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory limit applied to the Redis pods.
        """
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to the Redis pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to the Redis pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    def storage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Persistent storage size allocated to the Redis pods, in GiB.
        """
        return pulumi.get(self, "storage")

    @storage.setter
    def storage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "storage", value)


if not MYPY:
    class Mk8sAddOnsByokConfigTempoAgentArgsDict(TypedDict):
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        CPU request applied to tempo agent pods.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Memory request applied to tempo agent pods.
        """
elif False:
    Mk8sAddOnsByokConfigTempoAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsByokConfigTempoAgentArgs:
    def __init__(__self__, *,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] min_cpu: CPU request applied to tempo agent pods.
        :param pulumi.Input[_builtins.str] min_memory: Memory request applied to tempo agent pods.
        """
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CPU request applied to tempo agent pods.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Memory request applied to tempo agent pods.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)


if not MYPY:
    class Mk8sAddOnsLogsArgsDict(TypedDict):
        audit_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Collect k8s audit log as log events.
        """
        docker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Collect docker logs if docker is also running.
        """
        events: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Collect K8S events from all namespaces.
        """
        exclude_namespaces: NotRequired[pulumi.Input[_builtins.str]]
        include_namespaces: NotRequired[pulumi.Input[_builtins.str]]
        kernel: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Collect kernel logs.
        """
        kubelet: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Collect kubelet logs from journald.
        """
elif False:
    Mk8sAddOnsLogsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsLogsArgs:
    def __init__(__self__, *,
                 audit_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 docker: Optional[pulumi.Input[_builtins.bool]] = None,
                 events: Optional[pulumi.Input[_builtins.bool]] = None,
                 exclude_namespaces: Optional[pulumi.Input[_builtins.str]] = None,
                 include_namespaces: Optional[pulumi.Input[_builtins.str]] = None,
                 kernel: Optional[pulumi.Input[_builtins.bool]] = None,
                 kubelet: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] audit_enabled: Collect k8s audit log as log events.
        :param pulumi.Input[_builtins.bool] docker: Collect docker logs if docker is also running.
        :param pulumi.Input[_builtins.bool] events: Collect K8S events from all namespaces.
        :param pulumi.Input[_builtins.bool] kernel: Collect kernel logs.
        :param pulumi.Input[_builtins.bool] kubelet: Collect kubelet logs from journald.
        """
        if audit_enabled is not None:
            pulumi.set(__self__, "audit_enabled", audit_enabled)
        if docker is not None:
            pulumi.set(__self__, "docker", docker)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if exclude_namespaces is not None:
            pulumi.set(__self__, "exclude_namespaces", exclude_namespaces)
        if include_namespaces is not None:
            pulumi.set(__self__, "include_namespaces", include_namespaces)
        if kernel is not None:
            pulumi.set(__self__, "kernel", kernel)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)

    @_builtins.property
    @pulumi.getter(name="auditEnabled")
    def audit_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Collect k8s audit log as log events.
        """
        return pulumi.get(self, "audit_enabled")

    @audit_enabled.setter
    def audit_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "audit_enabled", value)

    @_builtins.property
    @pulumi.getter
    def docker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Collect docker logs if docker is also running.
        """
        return pulumi.get(self, "docker")

    @docker.setter
    def docker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "docker", value)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Collect K8S events from all namespaces.
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "events", value)

    @_builtins.property
    @pulumi.getter(name="excludeNamespaces")
    def exclude_namespaces(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "exclude_namespaces")

    @exclude_namespaces.setter
    def exclude_namespaces(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="includeNamespaces")
    def include_namespaces(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "include_namespaces")

    @include_namespaces.setter
    def include_namespaces(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_namespaces", value)

    @_builtins.property
    @pulumi.getter
    def kernel(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Collect kernel logs.
        """
        return pulumi.get(self, "kernel")

    @kernel.setter
    def kernel(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "kernel", value)

    @_builtins.property
    @pulumi.getter
    def kubelet(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Collect kubelet logs from journald.
        """
        return pulumi.get(self, "kubelet")

    @kubelet.setter
    def kubelet(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "kubelet", value)


if not MYPY:
    class Mk8sAddOnsMetricsArgsDict(TypedDict):
        api_server: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable scraping apiserver stats.
        """
        cadvisor: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable CNI-level container stats.
        """
        core_dns: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable scraping of core-dns service.
        """
        kube_state: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable kube-state metrics.
        """
        kubelet: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable scraping kubelet stats.
        """
        node_exporter: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable collecting node-level stats (disk, network, filesystem, etc).
        """
        scrape_annotated: NotRequired[pulumi.Input['Mk8sAddOnsMetricsScrapeAnnotatedArgsDict']]
elif False:
    Mk8sAddOnsMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsMetricsArgs:
    def __init__(__self__, *,
                 api_server: Optional[pulumi.Input[_builtins.bool]] = None,
                 cadvisor: Optional[pulumi.Input[_builtins.bool]] = None,
                 core_dns: Optional[pulumi.Input[_builtins.bool]] = None,
                 kube_state: Optional[pulumi.Input[_builtins.bool]] = None,
                 kubelet: Optional[pulumi.Input[_builtins.bool]] = None,
                 node_exporter: Optional[pulumi.Input[_builtins.bool]] = None,
                 scrape_annotated: Optional[pulumi.Input['Mk8sAddOnsMetricsScrapeAnnotatedArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] api_server: Enable scraping apiserver stats.
        :param pulumi.Input[_builtins.bool] cadvisor: Enable CNI-level container stats.
        :param pulumi.Input[_builtins.bool] core_dns: Enable scraping of core-dns service.
        :param pulumi.Input[_builtins.bool] kube_state: Enable kube-state metrics.
        :param pulumi.Input[_builtins.bool] kubelet: Enable scraping kubelet stats.
        :param pulumi.Input[_builtins.bool] node_exporter: Enable collecting node-level stats (disk, network, filesystem, etc).
        """
        if api_server is not None:
            pulumi.set(__self__, "api_server", api_server)
        if cadvisor is not None:
            pulumi.set(__self__, "cadvisor", cadvisor)
        if core_dns is not None:
            pulumi.set(__self__, "core_dns", core_dns)
        if kube_state is not None:
            pulumi.set(__self__, "kube_state", kube_state)
        if kubelet is not None:
            pulumi.set(__self__, "kubelet", kubelet)
        if node_exporter is not None:
            pulumi.set(__self__, "node_exporter", node_exporter)
        if scrape_annotated is not None:
            pulumi.set(__self__, "scrape_annotated", scrape_annotated)

    @_builtins.property
    @pulumi.getter(name="apiServer")
    def api_server(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable scraping apiserver stats.
        """
        return pulumi.get(self, "api_server")

    @api_server.setter
    def api_server(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "api_server", value)

    @_builtins.property
    @pulumi.getter
    def cadvisor(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable CNI-level container stats.
        """
        return pulumi.get(self, "cadvisor")

    @cadvisor.setter
    def cadvisor(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "cadvisor", value)

    @_builtins.property
    @pulumi.getter(name="coreDns")
    def core_dns(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable scraping of core-dns service.
        """
        return pulumi.get(self, "core_dns")

    @core_dns.setter
    def core_dns(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "core_dns", value)

    @_builtins.property
    @pulumi.getter(name="kubeState")
    def kube_state(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable kube-state metrics.
        """
        return pulumi.get(self, "kube_state")

    @kube_state.setter
    def kube_state(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "kube_state", value)

    @_builtins.property
    @pulumi.getter
    def kubelet(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable scraping kubelet stats.
        """
        return pulumi.get(self, "kubelet")

    @kubelet.setter
    def kubelet(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "kubelet", value)

    @_builtins.property
    @pulumi.getter(name="nodeExporter")
    def node_exporter(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable collecting node-level stats (disk, network, filesystem, etc).
        """
        return pulumi.get(self, "node_exporter")

    @node_exporter.setter
    def node_exporter(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "node_exporter", value)

    @_builtins.property
    @pulumi.getter(name="scrapeAnnotated")
    def scrape_annotated(self) -> Optional[pulumi.Input['Mk8sAddOnsMetricsScrapeAnnotatedArgs']]:
        return pulumi.get(self, "scrape_annotated")

    @scrape_annotated.setter
    def scrape_annotated(self, value: Optional[pulumi.Input['Mk8sAddOnsMetricsScrapeAnnotatedArgs']]):
        pulumi.set(self, "scrape_annotated", value)


if not MYPY:
    class Mk8sAddOnsMetricsScrapeAnnotatedArgsDict(TypedDict):
        exclude_namespaces: NotRequired[pulumi.Input[_builtins.str]]
        include_namespaces: NotRequired[pulumi.Input[_builtins.str]]
        interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        retain_labels: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sAddOnsMetricsScrapeAnnotatedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsMetricsScrapeAnnotatedArgs:
    def __init__(__self__, *,
                 exclude_namespaces: Optional[pulumi.Input[_builtins.str]] = None,
                 include_namespaces: Optional[pulumi.Input[_builtins.str]] = None,
                 interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 retain_labels: Optional[pulumi.Input[_builtins.str]] = None):
        if exclude_namespaces is not None:
            pulumi.set(__self__, "exclude_namespaces", exclude_namespaces)
        if include_namespaces is not None:
            pulumi.set(__self__, "include_namespaces", include_namespaces)
        if interval_seconds is not None:
            pulumi.set(__self__, "interval_seconds", interval_seconds)
        if retain_labels is not None:
            pulumi.set(__self__, "retain_labels", retain_labels)

    @_builtins.property
    @pulumi.getter(name="excludeNamespaces")
    def exclude_namespaces(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "exclude_namespaces")

    @exclude_namespaces.setter
    def exclude_namespaces(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exclude_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="includeNamespaces")
    def include_namespaces(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "include_namespaces")

    @include_namespaces.setter
    def include_namespaces(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "include_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="intervalSeconds")
    def interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "interval_seconds")

    @interval_seconds.setter
    def interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "interval_seconds", value)

    @_builtins.property
    @pulumi.getter(name="retainLabels")
    def retain_labels(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "retain_labels")

    @retain_labels.setter
    def retain_labels(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retain_labels", value)


if not MYPY:
    class Mk8sAddOnsNvidiaArgsDict(TypedDict):
        taint_gpu_nodes: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    Mk8sAddOnsNvidiaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsNvidiaArgs:
    def __init__(__self__, *,
                 taint_gpu_nodes: Optional[pulumi.Input[_builtins.bool]] = None):
        if taint_gpu_nodes is not None:
            pulumi.set(__self__, "taint_gpu_nodes", taint_gpu_nodes)

    @_builtins.property
    @pulumi.getter(name="taintGpuNodes")
    def taint_gpu_nodes(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "taint_gpu_nodes")

    @taint_gpu_nodes.setter
    def taint_gpu_nodes(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "taint_gpu_nodes", value)


if not MYPY:
    class Mk8sAddOnsRegistryMirrorArgsDict(TypedDict):
        mirrors: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sAddOnsRegistryMirrorMirrorArgsDict']]]]
elif False:
    Mk8sAddOnsRegistryMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsRegistryMirrorArgs:
    def __init__(__self__, *,
                 mirrors: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAddOnsRegistryMirrorMirrorArgs']]]] = None):
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAddOnsRegistryMirrorMirrorArgs']]]]:
        return pulumi.get(self, "mirrors")

    @mirrors.setter
    def mirrors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAddOnsRegistryMirrorMirrorArgs']]]]):
        pulumi.set(self, "mirrors", value)


if not MYPY:
    class Mk8sAddOnsRegistryMirrorMirrorArgsDict(TypedDict):
        registry: pulumi.Input[_builtins.str]
        mirrors: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    Mk8sAddOnsRegistryMirrorMirrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAddOnsRegistryMirrorMirrorArgs:
    def __init__(__self__, *,
                 registry: pulumi.Input[_builtins.str],
                 mirrors: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        pulumi.set(__self__, "registry", registry)
        if mirrors is not None:
            pulumi.set(__self__, "mirrors", mirrors)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry", value)

    @_builtins.property
    @pulumi.getter
    def mirrors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "mirrors")

    @mirrors.setter
    def mirrors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mirrors", value)


if not MYPY:
    class Mk8sAwsProviderArgsDict(TypedDict):
        deploy_role_arn: pulumi.Input[_builtins.str]
        """
        Control Plane will set up the cluster by assuming this role.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region where the cluster nodes will live.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        The vpc where nodes will be deployed. Supports SSM.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sAwsProviderAutoscalerArgsDict']]
        aws_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to all created objects.
        """
        deploy_role_chains: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderDeployRoleChainArgsDict']]]]
        disk_encryption_key_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        KMS key used to encrypt volumes. Supports SSM.
        """
        extra_node_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        image: NotRequired[pulumi.Input['Mk8sAwsProviderImageArgsDict']]
        """
        Default image for all nodes.
        """
        key_pair: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of keyPair. Supports SSM
        """
        networking: NotRequired[pulumi.Input['Mk8sAwsProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        """
        skip_create_roles: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, Control Plane will not create any roles.
        """
elif False:
    Mk8sAwsProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderArgs:
    def __init__(__self__, *,
                 deploy_role_arn: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sAwsProviderAutoscalerArgs']] = None,
                 aws_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 deploy_role_chains: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderDeployRoleChainArgs']]]] = None,
                 disk_encryption_key_arn: Optional[pulumi.Input[_builtins.str]] = None,
                 extra_node_policies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 image: Optional[pulumi.Input['Mk8sAwsProviderImageArgs']] = None,
                 key_pair: Optional[pulumi.Input[_builtins.str]] = None,
                 networking: Optional[pulumi.Input['Mk8sAwsProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 skip_create_roles: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] deploy_role_arn: Control Plane will set up the cluster by assuming this role.
        :param pulumi.Input[_builtins.str] region: Region where the cluster nodes will live.
        :param pulumi.Input[_builtins.str] vpc_id: The vpc where nodes will be deployed. Supports SSM.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] aws_tags: Extra tags to attach to all created objects.
        :param pulumi.Input[_builtins.str] disk_encryption_key_arn: KMS key used to encrypt volumes. Supports SSM.
        :param pulumi.Input['Mk8sAwsProviderImageArgs'] image: Default image for all nodes.
        :param pulumi.Input[_builtins.str] key_pair: Name of keyPair. Supports SSM
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolArgs']]] node_pools: List of node pools.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] security_group_ids: Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        :param pulumi.Input[_builtins.bool] skip_create_roles: If true, Control Plane will not create any roles.
        """
        pulumi.set(__self__, "deploy_role_arn", deploy_role_arn)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if aws_tags is not None:
            pulumi.set(__self__, "aws_tags", aws_tags)
        if deploy_role_chains is not None:
            pulumi.set(__self__, "deploy_role_chains", deploy_role_chains)
        if disk_encryption_key_arn is not None:
            pulumi.set(__self__, "disk_encryption_key_arn", disk_encryption_key_arn)
        if extra_node_policies is not None:
            pulumi.set(__self__, "extra_node_policies", extra_node_policies)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if key_pair is not None:
            pulumi.set(__self__, "key_pair", key_pair)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if security_group_ids is not None:
            pulumi.set(__self__, "security_group_ids", security_group_ids)
        if skip_create_roles is not None:
            pulumi.set(__self__, "skip_create_roles", skip_create_roles)

    @_builtins.property
    @pulumi.getter(name="deployRoleArn")
    def deploy_role_arn(self) -> pulumi.Input[_builtins.str]:
        """
        Control Plane will set up the cluster by assuming this role.
        """
        return pulumi.get(self, "deploy_role_arn")

    @deploy_role_arn.setter
    def deploy_role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "deploy_role_arn", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        The vpc where nodes will be deployed. Supports SSM.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sAwsProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sAwsProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="awsTags")
    def aws_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to all created objects.
        """
        return pulumi.get(self, "aws_tags")

    @aws_tags.setter
    def aws_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "aws_tags", value)

    @_builtins.property
    @pulumi.getter(name="deployRoleChains")
    def deploy_role_chains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderDeployRoleChainArgs']]]]:
        return pulumi.get(self, "deploy_role_chains")

    @deploy_role_chains.setter
    def deploy_role_chains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderDeployRoleChainArgs']]]]):
        pulumi.set(self, "deploy_role_chains", value)

    @_builtins.property
    @pulumi.getter(name="diskEncryptionKeyArn")
    def disk_encryption_key_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KMS key used to encrypt volumes. Supports SSM.
        """
        return pulumi.get(self, "disk_encryption_key_arn")

    @disk_encryption_key_arn.setter
    def disk_encryption_key_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "disk_encryption_key_arn", value)

    @_builtins.property
    @pulumi.getter(name="extraNodePolicies")
    def extra_node_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "extra_node_policies")

    @extra_node_policies.setter
    def extra_node_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extra_node_policies", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['Mk8sAwsProviderImageArgs']]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['Mk8sAwsProviderImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="keyPair")
    def key_pair(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of keyPair. Supports SSM
        """
        return pulumi.get(self, "key_pair")

    @key_pair.setter
    def key_pair(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_pair", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sAwsProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sAwsProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="securityGroupIds")
    def security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        """
        return pulumi.get(self, "security_group_ids")

    @security_group_ids.setter
    def security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "security_group_ids", value)

    @_builtins.property
    @pulumi.getter(name="skipCreateRoles")
    def skip_create_roles(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, Control Plane will not create any roles.
        """
        return pulumi.get(self, "skip_create_roles")

    @skip_create_roles.setter
    def skip_create_roles(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_create_roles", value)


if not MYPY:
    class Mk8sAwsProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sAwsProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sAwsProviderDeployRoleChainArgsDict(TypedDict):
        role_arn: pulumi.Input[_builtins.str]
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        session_name_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Control Plane will set up the cluster by assuming this role.
        """
elif False:
    Mk8sAwsProviderDeployRoleChainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderDeployRoleChainArgs:
    def __init__(__self__, *,
                 role_arn: pulumi.Input[_builtins.str],
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 session_name_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] session_name_prefix: Control Plane will set up the cluster by assuming this role.
        """
        pulumi.set(__self__, "role_arn", role_arn)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if session_name_prefix is not None:
            pulumi.set(__self__, "session_name_prefix", session_name_prefix)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="sessionNamePrefix")
    def session_name_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Control Plane will set up the cluster by assuming this role.
        """
        return pulumi.get(self, "session_name_prefix")

    @session_name_prefix.setter
    def session_name_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_name_prefix", value)


if not MYPY:
    class Mk8sAwsProviderImageArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        Support SSM.
        """
        recommended: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sAwsProviderImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderImageArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 recommended: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: Support SSM.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Support SSM.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def recommended(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recommended")

    @recommended.setter
    def recommended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommended", value)


if not MYPY:
    class Mk8sAwsProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sAwsProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sAwsProviderNodePoolArgsDict(TypedDict):
        instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        name: pulumi.Input[_builtins.str]
        subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        boot_disk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Size in GB.
        """
        extra_security_group_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        on_demand_base_capacity: NotRequired[pulumi.Input[_builtins.int]]
        on_demand_percentage_above_base_capacity: NotRequired[pulumi.Input[_builtins.int]]
        override_image: NotRequired[pulumi.Input['Mk8sAwsProviderNodePoolOverrideImageArgsDict']]
        """
        Default image for all nodes.
        """
        spot_allocation_strategy: NotRequired[pulumi.Input[_builtins.str]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sAwsProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderNodePoolArgs:
    def __init__(__self__, *,
                 instance_types: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 name: pulumi.Input[_builtins.str],
                 subnet_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 boot_disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 extra_security_group_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 on_demand_base_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 on_demand_percentage_above_base_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image: Optional[pulumi.Input['Mk8sAwsProviderNodePoolOverrideImageArgs']] = None,
                 spot_allocation_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] boot_disk_size: Size in GB.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] extra_security_group_ids: Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input['Mk8sAwsProviderNodePoolOverrideImageArgs'] override_image: Default image for all nodes.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "instance_types", instance_types)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet_ids", subnet_ids)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if extra_security_group_ids is not None:
            pulumi.set(__self__, "extra_security_group_ids", extra_security_group_ids)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if on_demand_base_capacity is not None:
            pulumi.set(__self__, "on_demand_base_capacity", on_demand_base_capacity)
        if on_demand_percentage_above_base_capacity is not None:
            pulumi.set(__self__, "on_demand_percentage_above_base_capacity", on_demand_percentage_above_base_capacity)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if spot_allocation_strategy is not None:
            pulumi.set(__self__, "spot_allocation_strategy", spot_allocation_strategy)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="instanceTypes")
    def instance_types(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "instance_types")

    @instance_types.setter
    def instance_types(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "instance_types", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="subnetIds")
    def subnet_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "subnet_ids")

    @subnet_ids.setter
    def subnet_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnet_ids", value)

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Size in GB.
        """
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "boot_disk_size", value)

    @_builtins.property
    @pulumi.getter(name="extraSecurityGroupIds")
    def extra_security_group_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Security groups to deploy nodes to. Security groups control if the cluster is multi-zone or single-zon.
        """
        return pulumi.get(self, "extra_security_group_ids")

    @extra_security_group_ids.setter
    def extra_security_group_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extra_security_group_ids", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="onDemandBaseCapacity")
    def on_demand_base_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "on_demand_base_capacity")

    @on_demand_base_capacity.setter
    def on_demand_base_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_base_capacity", value)

    @_builtins.property
    @pulumi.getter(name="onDemandPercentageAboveBaseCapacity")
    def on_demand_percentage_above_base_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "on_demand_percentage_above_base_capacity")

    @on_demand_percentage_above_base_capacity.setter
    def on_demand_percentage_above_base_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "on_demand_percentage_above_base_capacity", value)

    @_builtins.property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[pulumi.Input['Mk8sAwsProviderNodePoolOverrideImageArgs']]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "override_image")

    @override_image.setter
    def override_image(self, value: Optional[pulumi.Input['Mk8sAwsProviderNodePoolOverrideImageArgs']]):
        pulumi.set(self, "override_image", value)

    @_builtins.property
    @pulumi.getter(name="spotAllocationStrategy")
    def spot_allocation_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "spot_allocation_strategy")

    @spot_allocation_strategy.setter
    def spot_allocation_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "spot_allocation_strategy", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAwsProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sAwsProviderNodePoolOverrideImageArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        Support SSM.
        """
        recommended: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sAwsProviderNodePoolOverrideImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderNodePoolOverrideImageArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 recommended: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: Support SSM.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Support SSM.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def recommended(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recommended")

    @recommended.setter
    def recommended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommended", value)


if not MYPY:
    class Mk8sAwsProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sAwsProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAwsProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sAzureProviderArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        """
        Region where the cluster nodes will live.
        """
        network_id: pulumi.Input[_builtins.str]
        """
        The vpc where nodes will be deployed.
        """
        resource_group: pulumi.Input[_builtins.str]
        sdk_secret_link: pulumi.Input[_builtins.str]
        ssh_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        SSH keys to install for "azureuser" linux user
        """
        subscription_id: pulumi.Input[_builtins.str]
        autoscaler: NotRequired[pulumi.Input['Mk8sAzureProviderAutoscalerArgsDict']]
        image: NotRequired[pulumi.Input['Mk8sAzureProviderImageArgsDict']]
        """
        Default image for all nodes.
        """
        networking: NotRequired[pulumi.Input['Mk8sAzureProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolArgsDict']]]]
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to all created objects.
        """
elif False:
    Mk8sAzureProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 network_id: pulumi.Input[_builtins.str],
                 resource_group: pulumi.Input[_builtins.str],
                 sdk_secret_link: pulumi.Input[_builtins.str],
                 ssh_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 subscription_id: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sAzureProviderAutoscalerArgs']] = None,
                 image: Optional[pulumi.Input['Mk8sAzureProviderImageArgs']] = None,
                 networking: Optional[pulumi.Input['Mk8sAzureProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] location: Region where the cluster nodes will live.
        :param pulumi.Input[_builtins.str] network_id: The vpc where nodes will be deployed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ssh_keys: SSH keys to install for "azureuser" linux user
        :param pulumi.Input['Mk8sAzureProviderImageArgs'] image: Default image for all nodes.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Extra tags to attach to all created objects.
        """
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "resource_group", resource_group)
        pulumi.set(__self__, "sdk_secret_link", sdk_secret_link)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "subscription_id", subscription_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[_builtins.str]:
        """
        The vpc where nodes will be deployed.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource_group", value)

    @_builtins.property
    @pulumi.getter(name="sdkSecretLink")
    def sdk_secret_link(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sdk_secret_link")

    @sdk_secret_link.setter
    def sdk_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sdk_secret_link", value)

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        SSH keys to install for "azureuser" linux user
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ssh_keys", value)

    @_builtins.property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subscription_id", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sAzureProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sAzureProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['Mk8sAzureProviderImageArgs']]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['Mk8sAzureProviderImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sAzureProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sAzureProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolArgs']]]]:
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to all created objects.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class Mk8sAzureProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sAzureProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sAzureProviderImageArgsDict(TypedDict):
        recommended: NotRequired[pulumi.Input[_builtins.str]]
        reference: NotRequired[pulumi.Input['Mk8sAzureProviderImageReferenceArgsDict']]
elif False:
    Mk8sAzureProviderImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderImageArgs:
    def __init__(__self__, *,
                 recommended: Optional[pulumi.Input[_builtins.str]] = None,
                 reference: Optional[pulumi.Input['Mk8sAzureProviderImageReferenceArgs']] = None):
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)

    @_builtins.property
    @pulumi.getter
    def recommended(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recommended")

    @recommended.setter
    def recommended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommended", value)

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[pulumi.Input['Mk8sAzureProviderImageReferenceArgs']]:
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[pulumi.Input['Mk8sAzureProviderImageReferenceArgs']]):
        pulumi.set(self, "reference", value)


if not MYPY:
    class Mk8sAzureProviderImageReferenceArgsDict(TypedDict):
        offer: pulumi.Input[_builtins.str]
        publisher: pulumi.Input[_builtins.str]
        sku: pulumi.Input[_builtins.str]
        version: pulumi.Input[_builtins.str]
elif False:
    Mk8sAzureProviderImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[_builtins.str],
                 publisher: pulumi.Input[_builtins.str],
                 sku: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def offer(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "offer", value)

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "publisher", value)

    @_builtins.property
    @pulumi.getter
    def sku(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sku", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sAzureProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sAzureProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sAzureProviderNodePoolArgsDict(TypedDict):
        boot_disk_size: pulumi.Input[_builtins.int]
        name: pulumi.Input[_builtins.str]
        size: pulumi.Input[_builtins.str]
        subnet_id: pulumi.Input[_builtins.str]
        zones: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        override_image: NotRequired[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageArgsDict']]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sAzureProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderNodePoolArgs:
    def __init__(__self__, *,
                 boot_disk_size: pulumi.Input[_builtins.int],
                 name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str],
                 zones: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image: Optional[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageArgs']] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "subnet_id", subnet_id)
        pulumi.set(__self__, "zones", zones)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> pulumi.Input[_builtins.int]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "boot_disk_size", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def zones(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        return pulumi.get(self, "zones")

    @zones.setter
    def zones(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "zones", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageArgs']]:
        return pulumi.get(self, "override_image")

    @override_image.setter
    def override_image(self, value: Optional[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageArgs']]):
        pulumi.set(self, "override_image", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sAzureProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sAzureProviderNodePoolOverrideImageArgsDict(TypedDict):
        recommended: NotRequired[pulumi.Input[_builtins.str]]
        reference: NotRequired[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageReferenceArgsDict']]
elif False:
    Mk8sAzureProviderNodePoolOverrideImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderNodePoolOverrideImageArgs:
    def __init__(__self__, *,
                 recommended: Optional[pulumi.Input[_builtins.str]] = None,
                 reference: Optional[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageReferenceArgs']] = None):
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)
        if reference is not None:
            pulumi.set(__self__, "reference", reference)

    @_builtins.property
    @pulumi.getter
    def recommended(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "recommended")

    @recommended.setter
    def recommended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommended", value)

    @_builtins.property
    @pulumi.getter
    def reference(self) -> Optional[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageReferenceArgs']]:
        return pulumi.get(self, "reference")

    @reference.setter
    def reference(self, value: Optional[pulumi.Input['Mk8sAzureProviderNodePoolOverrideImageReferenceArgs']]):
        pulumi.set(self, "reference", value)


if not MYPY:
    class Mk8sAzureProviderNodePoolOverrideImageReferenceArgsDict(TypedDict):
        offer: pulumi.Input[_builtins.str]
        publisher: pulumi.Input[_builtins.str]
        sku: pulumi.Input[_builtins.str]
        version: pulumi.Input[_builtins.str]
elif False:
    Mk8sAzureProviderNodePoolOverrideImageReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderNodePoolOverrideImageReferenceArgs:
    def __init__(__self__, *,
                 offer: pulumi.Input[_builtins.str],
                 publisher: pulumi.Input[_builtins.str],
                 sku: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "offer", offer)
        pulumi.set(__self__, "publisher", publisher)
        pulumi.set(__self__, "sku", sku)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def offer(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "offer")

    @offer.setter
    def offer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "offer", value)

    @_builtins.property
    @pulumi.getter
    def publisher(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "publisher")

    @publisher.setter
    def publisher(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "publisher", value)

    @_builtins.property
    @pulumi.getter
    def sku(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "sku")

    @sku.setter
    def sku(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sku", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class Mk8sAzureProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sAzureProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sAzureProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sDigitalOceanProviderArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        Default image for all nodes.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region to deploy nodes to.
        """
        ssh_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        SSH key name for accessing deployed nodes.
        """
        token_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a secret holding personal access token.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        ID of the Hetzner network to deploy nodes to.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sDigitalOceanProviderAutoscalerArgsDict']]
        digital_ocean_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to droplets.
        """
        extra_ssh_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Extra SSH keys to provision for user root that are not registered in the DigitalOcean.
        """
        networking: NotRequired[pulumi.Input['Mk8sDigitalOceanProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolArgsDict']]]]
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        reserved_ips: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Optional set of IPs to assign as extra IPs for nodes of the cluster.
        """
elif False:
    Mk8sDigitalOceanProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sDigitalOceanProviderArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 ssh_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 token_secret_link: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sDigitalOceanProviderAutoscalerArgs']] = None,
                 digital_ocean_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 extra_ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 networking: Optional[pulumi.Input['Mk8sDigitalOceanProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 reserved_ips: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] image: Default image for all nodes.
        :param pulumi.Input[_builtins.str] region: Region to deploy nodes to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ssh_keys: SSH key name for accessing deployed nodes.
        :param pulumi.Input[_builtins.str] token_secret_link: Link to a secret holding personal access token.
        :param pulumi.Input[_builtins.str] vpc_id: ID of the Hetzner network to deploy nodes to.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] digital_ocean_tags: Extra tags to attach to droplets.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] extra_ssh_keys: Extra SSH keys to provision for user root that are not registered in the DigitalOcean.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] reserved_ips: Optional set of IPs to assign as extra IPs for nodes of the cluster.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if digital_ocean_tags is not None:
            pulumi.set(__self__, "digital_ocean_tags", digital_ocean_tags)
        if extra_ssh_keys is not None:
            pulumi.set(__self__, "extra_ssh_keys", extra_ssh_keys)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if reserved_ips is not None:
            pulumi.set(__self__, "reserved_ips", reserved_ips)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region to deploy nodes to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        SSH key name for accessing deployed nodes.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ssh_keys", value)

    @_builtins.property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret holding personal access token.
        """
        return pulumi.get(self, "token_secret_link")

    @token_secret_link.setter
    def token_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_secret_link", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the Hetzner network to deploy nodes to.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sDigitalOceanProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sDigitalOceanProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="digitalOceanTags")
    def digital_ocean_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to droplets.
        """
        return pulumi.get(self, "digital_ocean_tags")

    @digital_ocean_tags.setter
    def digital_ocean_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "digital_ocean_tags", value)

    @_builtins.property
    @pulumi.getter(name="extraSshKeys")
    def extra_ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Extra SSH keys to provision for user root that are not registered in the DigitalOcean.
        """
        return pulumi.get(self, "extra_ssh_keys")

    @extra_ssh_keys.setter
    def extra_ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extra_ssh_keys", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sDigitalOceanProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sDigitalOceanProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolArgs']]]]:
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="reservedIps")
    def reserved_ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Optional set of IPs to assign as extra IPs for nodes of the cluster.
        """
        return pulumi.get(self, "reserved_ips")

    @reserved_ips.setter
    def reserved_ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "reserved_ips", value)


if not MYPY:
    class Mk8sDigitalOceanProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sDigitalOceanProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sDigitalOceanProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sDigitalOceanProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sDigitalOceanProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sDigitalOceanProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sDigitalOceanProviderNodePoolArgsDict(TypedDict):
        droplet_size: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        override_image: NotRequired[pulumi.Input[_builtins.str]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sDigitalOceanProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sDigitalOceanProviderNodePoolArgs:
    def __init__(__self__, *,
                 droplet_size: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image: Optional[pulumi.Input[_builtins.str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "droplet_size", droplet_size)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="dropletSize")
    def droplet_size(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "droplet_size")

    @droplet_size.setter
    def droplet_size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "droplet_size", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "override_image")

    @override_image.setter
    def override_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_image", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sDigitalOceanProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sDigitalOceanProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sDigitalOceanProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sDigitalOceanProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sEphemeralProviderArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        """
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
elif False:
    Mk8sEphemeralProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sEphemeralProviderArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] location: Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolArgs']]] node_pools: List of node pools.
        """
        pulumi.set(__self__, "location", location)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)


if not MYPY:
    class Mk8sEphemeralProviderNodePoolArgsDict(TypedDict):
        arch: pulumi.Input[_builtins.str]
        """
        CPU architecture of the nodes.
        """
        count: pulumi.Input[_builtins.int]
        """
        Number of nodes to deploy.
        """
        cpu: pulumi.Input[_builtins.str]
        """
        Allocated CPU.
        """
        memory: pulumi.Input[_builtins.str]
        """
        Allocated memory.
        """
        name: pulumi.Input[_builtins.str]
        flavor: NotRequired[pulumi.Input[_builtins.str]]
        """
        Linux distro to use for ephemeral nodes.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sEphemeralProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sEphemeralProviderNodePoolArgs:
    def __init__(__self__, *,
                 arch: pulumi.Input[_builtins.str],
                 count: pulumi.Input[_builtins.int],
                 cpu: pulumi.Input[_builtins.str],
                 memory: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 flavor: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] arch: CPU architecture of the nodes.
        :param pulumi.Input[_builtins.int] count: Number of nodes to deploy.
        :param pulumi.Input[_builtins.str] cpu: Allocated CPU.
        :param pulumi.Input[_builtins.str] memory: Allocated memory.
        :param pulumi.Input[_builtins.str] flavor: Linux distro to use for ephemeral nodes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "arch", arch)
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "name", name)
        if flavor is not None:
            pulumi.set(__self__, "flavor", flavor)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def arch(self) -> pulumi.Input[_builtins.str]:
        """
        CPU architecture of the nodes.
        """
        return pulumi.get(self, "arch")

    @arch.setter
    def arch(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "arch", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> pulumi.Input[_builtins.int]:
        """
        Number of nodes to deploy.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> pulumi.Input[_builtins.str]:
        """
        Allocated CPU.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> pulumi.Input[_builtins.str]:
        """
        Allocated memory.
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Linux distro to use for ephemeral nodes.
        """
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sEphemeralProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sEphemeralProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sEphemeralProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sEphemeralProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sFirewallArgsDict(TypedDict):
        source_cidr: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sFirewallArgs:
    def __init__(__self__, *,
                 source_cidr: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "source_cidr", source_cidr)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="sourceCidr")
    def source_cidr(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "source_cidr")

    @source_cidr.setter
    def source_cidr(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source_cidr", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class Mk8sGcpProviderArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        VPC network used by the cluster.
        """
        project_id: pulumi.Input[_builtins.str]
        """
        GCP project ID that hosts the cluster infrastructure.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region where the cluster nodes will live.
        """
        sa_key_link: pulumi.Input[_builtins.str]
        """
        Link to a secret containing the service account JSON key.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sGcpProviderAutoscalerArgsDict']]
        image: NotRequired[pulumi.Input['Mk8sGcpProviderImageArgsDict']]
        """
        Default image for all nodes.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to all created objects.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        networking: NotRequired[pulumi.Input['Mk8sGcpProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolArgsDict']]]]
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    Mk8sGcpProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 sa_key_link: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sGcpProviderAutoscalerArgs']] = None,
                 image: Optional[pulumi.Input['Mk8sGcpProviderImageArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 networking: Optional[pulumi.Input['Mk8sGcpProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] network: VPC network used by the cluster.
        :param pulumi.Input[_builtins.str] project_id: GCP project ID that hosts the cluster infrastructure.
        :param pulumi.Input[_builtins.str] region: Region where the cluster nodes will live.
        :param pulumi.Input[_builtins.str] sa_key_link: Link to a secret containing the service account JSON key.
        :param pulumi.Input['Mk8sGcpProviderImageArgs'] image: Default image for all nodes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Extra tags to attach to all created objects.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "sa_key_link", sa_key_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        VPC network used by the cluster.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        GCP project ID that hosts the cluster infrastructure.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="saKeyLink")
    def sa_key_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret containing the service account JSON key.
        """
        return pulumi.get(self, "sa_key_link")

    @sa_key_link.setter
    def sa_key_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sa_key_link", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sGcpProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sGcpProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['Mk8sGcpProviderImageArgs']]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['Mk8sGcpProviderImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to all created objects.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sGcpProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sGcpProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolArgs']]]]:
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class Mk8sGcpProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sGcpProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sGcpProviderImageArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        family: NotRequired[pulumi.Input['Mk8sGcpProviderImageFamilyArgsDict']]
        recommended: NotRequired[pulumi.Input[_builtins.str]]
        """
        Recommended image alias. Valid values: `ubuntu/jammy-22.04`, `ubuntu/noble-24.04`, `debian/bookworm-12`, `debian/trixie-13`, `google/cos-stable`.
        """
elif False:
    Mk8sGcpProviderImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderImageArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 family: Optional[pulumi.Input['Mk8sGcpProviderImageFamilyArgs']] = None,
                 recommended: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] recommended: Recommended image alias. Valid values: `ubuntu/jammy-22.04`, `ubuntu/noble-24.04`, `debian/bookworm-12`, `debian/trixie-13`, `google/cos-stable`.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input['Mk8sGcpProviderImageFamilyArgs']]:
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input['Mk8sGcpProviderImageFamilyArgs']]):
        pulumi.set(self, "family", value)

    @_builtins.property
    @pulumi.getter
    def recommended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Recommended image alias. Valid values: `ubuntu/jammy-22.04`, `ubuntu/noble-24.04`, `debian/bookworm-12`, `debian/trixie-13`, `google/cos-stable`.
        """
        return pulumi.get(self, "recommended")

    @recommended.setter
    def recommended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommended", value)


if not MYPY:
    class Mk8sGcpProviderImageFamilyArgsDict(TypedDict):
        family: pulumi.Input[_builtins.str]
        project: pulumi.Input[_builtins.str]
elif False:
    Mk8sGcpProviderImageFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderImageFamilyArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[_builtins.str],
                 project: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def family(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "family", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)


if not MYPY:
    class Mk8sGcpProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sGcpProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sGcpProviderNodePoolArgsDict(TypedDict):
        boot_disk_size: pulumi.Input[_builtins.int]
        """
        Size in GB.
        """
        machine_type: pulumi.Input[_builtins.str]
        """
        GCE machine type for nodes in this pool.
        """
        name: pulumi.Input[_builtins.str]
        subnet: pulumi.Input[_builtins.str]
        """
        Subnet within the selected network.
        """
        zone: pulumi.Input[_builtins.str]
        """
        Zone where the pool nodes run.
        """
        assign_public_ip: NotRequired[pulumi.Input[_builtins.bool]]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        local_persistent_disks: NotRequired[pulumi.Input[_builtins.int]]
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        override_image: NotRequired[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageArgsDict']]
        preemptible: NotRequired[pulumi.Input[_builtins.bool]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sGcpProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderNodePoolArgs:
    def __init__(__self__, *,
                 boot_disk_size: pulumi.Input[_builtins.int],
                 machine_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 subnet: pulumi.Input[_builtins.str],
                 zone: pulumi.Input[_builtins.str],
                 assign_public_ip: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 local_persistent_disks: Optional[pulumi.Input[_builtins.int]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image: Optional[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageArgs']] = None,
                 preemptible: Optional[pulumi.Input[_builtins.bool]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.int] boot_disk_size: Size in GB.
        :param pulumi.Input[_builtins.str] machine_type: GCE machine type for nodes in this pool.
        :param pulumi.Input[_builtins.str] subnet: Subnet within the selected network.
        :param pulumi.Input[_builtins.str] zone: Zone where the pool nodes run.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "zone", zone)
        if assign_public_ip is not None:
            pulumi.set(__self__, "assign_public_ip", assign_public_ip)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if local_persistent_disks is not None:
            pulumi.set(__self__, "local_persistent_disks", local_persistent_disks)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if preemptible is not None:
            pulumi.set(__self__, "preemptible", preemptible)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> pulumi.Input[_builtins.int]:
        """
        Size in GB.
        """
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "boot_disk_size", value)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> pulumi.Input[_builtins.str]:
        """
        GCE machine type for nodes in this pool.
        """
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "machine_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[_builtins.str]:
        """
        Subnet within the selected network.
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> pulumi.Input[_builtins.str]:
        """
        Zone where the pool nodes run.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "zone", value)

    @_builtins.property
    @pulumi.getter(name="assignPublicIp")
    def assign_public_ip(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "assign_public_ip")

    @assign_public_ip.setter
    def assign_public_ip(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "assign_public_ip", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="localPersistentDisks")
    def local_persistent_disks(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "local_persistent_disks")

    @local_persistent_disks.setter
    def local_persistent_disks(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "local_persistent_disks", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageArgs']]:
        return pulumi.get(self, "override_image")

    @override_image.setter
    def override_image(self, value: Optional[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageArgs']]):
        pulumi.set(self, "override_image", value)

    @_builtins.property
    @pulumi.getter
    def preemptible(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "preemptible")

    @preemptible.setter
    def preemptible(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preemptible", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGcpProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sGcpProviderNodePoolOverrideImageArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        family: NotRequired[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageFamilyArgsDict']]
        recommended: NotRequired[pulumi.Input[_builtins.str]]
        """
        Recommended image alias. Valid values: `ubuntu/jammy-22.04`, `ubuntu/noble-24.04`, `debian/bookworm-12`, `debian/trixie-13`, `google/cos-stable`.
        """
elif False:
    Mk8sGcpProviderNodePoolOverrideImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderNodePoolOverrideImageArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 family: Optional[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageFamilyArgs']] = None,
                 recommended: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] recommended: Recommended image alias. Valid values: `ubuntu/jammy-22.04`, `ubuntu/noble-24.04`, `debian/bookworm-12`, `debian/trixie-13`, `google/cos-stable`.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if recommended is not None:
            pulumi.set(__self__, "recommended", recommended)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    def family(self) -> Optional[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageFamilyArgs']]:
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: Optional[pulumi.Input['Mk8sGcpProviderNodePoolOverrideImageFamilyArgs']]):
        pulumi.set(self, "family", value)

    @_builtins.property
    @pulumi.getter
    def recommended(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Recommended image alias. Valid values: `ubuntu/jammy-22.04`, `ubuntu/noble-24.04`, `debian/bookworm-12`, `debian/trixie-13`, `google/cos-stable`.
        """
        return pulumi.get(self, "recommended")

    @recommended.setter
    def recommended(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recommended", value)


if not MYPY:
    class Mk8sGcpProviderNodePoolOverrideImageFamilyArgsDict(TypedDict):
        family: pulumi.Input[_builtins.str]
        project: pulumi.Input[_builtins.str]
elif False:
    Mk8sGcpProviderNodePoolOverrideImageFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderNodePoolOverrideImageFamilyArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[_builtins.str],
                 project: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def family(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "family", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project", value)


if not MYPY:
    class Mk8sGcpProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sGcpProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGcpProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sGenericProviderArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        """
        networking: NotRequired[pulumi.Input['Mk8sGenericProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
elif False:
    Mk8sGenericProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGenericProviderArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 networking: Optional[pulumi.Input['Mk8sGenericProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] location: Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolArgs']]] node_pools: List of node pools.
        """
        pulumi.set(__self__, "location", location)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to where the nodes are running.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sGenericProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sGenericProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)


if not MYPY:
    class Mk8sGenericProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sGenericProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGenericProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sGenericProviderNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sGenericProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGenericProviderNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sGenericProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sGenericProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sGenericProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sGenericProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sHetznerProviderArgsDict(TypedDict):
        network_id: pulumi.Input[_builtins.str]
        """
        ID of the Hetzner network to deploy nodes to.
        """
        region: pulumi.Input[_builtins.str]
        """
        Hetzner region to deploy nodes to.
        """
        token_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a secret holding Hetzner access key.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sHetznerProviderAutoscalerArgsDict']]
        dedicated_server_node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolArgsDict']]]]
        """
        Node pools that can configure dedicated Hetzner servers.
        """
        firewall_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional firewall rule to attach to all nodes.
        """
        floating_ip_selector: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        If supplied, nodes will get assigned a random floating ip matching the selector.
        """
        hetzner_labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra labels to attach to servers.
        """
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default image for all nodes.
        """
        networking: NotRequired[pulumi.Input['Mk8sHetznerProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolArgsDict']]]]
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        ssh_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        SSH key name for accessing deployed nodes.
        """
elif False:
    Mk8sHetznerProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 token_secret_link: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sHetznerProviderAutoscalerArgs']] = None,
                 dedicated_server_node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolArgs']]]] = None,
                 firewall_id: Optional[pulumi.Input[_builtins.str]] = None,
                 floating_ip_selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 hetzner_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 networking: Optional[pulumi.Input['Mk8sHetznerProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 ssh_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] network_id: ID of the Hetzner network to deploy nodes to.
        :param pulumi.Input[_builtins.str] region: Hetzner region to deploy nodes to.
        :param pulumi.Input[_builtins.str] token_secret_link: Link to a secret holding Hetzner access key.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolArgs']]] dedicated_server_node_pools: Node pools that can configure dedicated Hetzner servers.
        :param pulumi.Input[_builtins.str] firewall_id: Optional firewall rule to attach to all nodes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] floating_ip_selector: If supplied, nodes will get assigned a random floating ip matching the selector.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] hetzner_labels: Extra labels to attach to servers.
        :param pulumi.Input[_builtins.str] image: Default image for all nodes.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param pulumi.Input[_builtins.str] ssh_key: SSH key name for accessing deployed nodes.
        """
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if dedicated_server_node_pools is not None:
            pulumi.set(__self__, "dedicated_server_node_pools", dedicated_server_node_pools)
        if firewall_id is not None:
            pulumi.set(__self__, "firewall_id", firewall_id)
        if floating_ip_selector is not None:
            pulumi.set(__self__, "floating_ip_selector", floating_ip_selector)
        if hetzner_labels is not None:
            pulumi.set(__self__, "hetzner_labels", hetzner_labels)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if ssh_key is not None:
            pulumi.set(__self__, "ssh_key", ssh_key)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the Hetzner network to deploy nodes to.
        """
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Hetzner region to deploy nodes to.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret holding Hetzner access key.
        """
        return pulumi.get(self, "token_secret_link")

    @token_secret_link.setter
    def token_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_secret_link", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sHetznerProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sHetznerProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="dedicatedServerNodePools")
    def dedicated_server_node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolArgs']]]]:
        """
        Node pools that can configure dedicated Hetzner servers.
        """
        return pulumi.get(self, "dedicated_server_node_pools")

    @dedicated_server_node_pools.setter
    def dedicated_server_node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolArgs']]]]):
        pulumi.set(self, "dedicated_server_node_pools", value)

    @_builtins.property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional firewall rule to attach to all nodes.
        """
        return pulumi.get(self, "firewall_id")

    @firewall_id.setter
    def firewall_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firewall_id", value)

    @_builtins.property
    @pulumi.getter(name="floatingIpSelector")
    def floating_ip_selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        If supplied, nodes will get assigned a random floating ip matching the selector.
        """
        return pulumi.get(self, "floating_ip_selector")

    @floating_ip_selector.setter
    def floating_ip_selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "floating_ip_selector", value)

    @_builtins.property
    @pulumi.getter(name="hetznerLabels")
    def hetzner_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra labels to attach to servers.
        """
        return pulumi.get(self, "hetzner_labels")

    @hetzner_labels.setter
    def hetzner_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "hetzner_labels", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sHetznerProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sHetznerProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolArgs']]]]:
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SSH key name for accessing deployed nodes.
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssh_key", value)


if not MYPY:
    class Mk8sHetznerProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sHetznerProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sHetznerProviderDedicatedServerNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sHetznerProviderDedicatedServerNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderDedicatedServerNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sHetznerProviderDedicatedServerNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sHetznerProviderDedicatedServerNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderDedicatedServerNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sHetznerProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sHetznerProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sHetznerProviderNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        server_type: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        override_image: NotRequired[pulumi.Input[_builtins.str]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sHetznerProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_type: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image: Optional[pulumi.Input[_builtins.str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_type", server_type)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverType")
    def server_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_type", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "override_image")

    @override_image.setter
    def override_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_image", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sHetznerProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sHetznerProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sHetznerProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sHetznerProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sLambdalabsProviderArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        Region where the cluster nodes will live.
        """
        ssh_key: pulumi.Input[_builtins.str]
        """
        SSH key name for accessing deployed nodes.
        """
        token_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a secret holding Lambdalabs access key.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sLambdalabsProviderAutoscalerArgsDict']]
        file_systems: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        unmanaged_node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolArgsDict']]]]
elif False:
    Mk8sLambdalabsProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLambdalabsProviderArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str],
                 ssh_key: pulumi.Input[_builtins.str],
                 token_secret_link: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sLambdalabsProviderAutoscalerArgs']] = None,
                 file_systems: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 unmanaged_node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] region: Region where the cluster nodes will live.
        :param pulumi.Input[_builtins.str] ssh_key: SSH key name for accessing deployed nodes.
        :param pulumi.Input[_builtins.str] token_secret_link: Link to a secret holding Lambdalabs access key.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolArgs']]] node_pools: List of node pools.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "ssh_key", ssh_key)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if file_systems is not None:
            pulumi.set(__self__, "file_systems", file_systems)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if unmanaged_node_pools is not None:
            pulumi.set(__self__, "unmanaged_node_pools", unmanaged_node_pools)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="sshKey")
    def ssh_key(self) -> pulumi.Input[_builtins.str]:
        """
        SSH key name for accessing deployed nodes.
        """
        return pulumi.get(self, "ssh_key")

    @ssh_key.setter
    def ssh_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssh_key", value)

    @_builtins.property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret holding Lambdalabs access key.
        """
        return pulumi.get(self, "token_secret_link")

    @token_secret_link.setter
    def token_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_secret_link", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sLambdalabsProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sLambdalabsProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="fileSystems")
    def file_systems(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "file_systems")

    @file_systems.setter
    def file_systems(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "file_systems", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolArgs']]]]:
        return pulumi.get(self, "unmanaged_node_pools")

    @unmanaged_node_pools.setter
    def unmanaged_node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolArgs']]]]):
        pulumi.set(self, "unmanaged_node_pools", value)


if not MYPY:
    class Mk8sLambdalabsProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sLambdalabsProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLambdalabsProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sLambdalabsProviderNodePoolArgsDict(TypedDict):
        instance_type: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sLambdalabsProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLambdalabsProviderNodePoolArgs:
    def __init__(__self__, *,
                 instance_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "instance_type", instance_type)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="instanceType")
    def instance_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "instance_type")

    @instance_type.setter
    def instance_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instance_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sLambdalabsProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sLambdalabsProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLambdalabsProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sLambdalabsProviderUnmanagedNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sLambdalabsProviderUnmanagedNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLambdalabsProviderUnmanagedNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLambdalabsProviderUnmanagedNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sLinodeProviderArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        Default image for all nodes.
        """
        region: pulumi.Input[_builtins.str]
        """
        Region where the cluster nodes will live.
        """
        token_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a secret holding Linode access key.
        """
        vpc_id: pulumi.Input[_builtins.str]
        """
        The vpc where nodes will be deployed. Supports SSM.
        """
        authorized_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        authorized_users: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        autoscaler: NotRequired[pulumi.Input['Mk8sLinodeProviderAutoscalerArgsDict']]
        firewall_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional firewall rule to attach to all nodes.
        """
        networking: NotRequired[pulumi.Input['Mk8sLinodeProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
elif False:
    Mk8sLinodeProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLinodeProviderArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 token_secret_link: pulumi.Input[_builtins.str],
                 vpc_id: pulumi.Input[_builtins.str],
                 authorized_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 authorized_users: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 autoscaler: Optional[pulumi.Input['Mk8sLinodeProviderAutoscalerArgs']] = None,
                 firewall_id: Optional[pulumi.Input[_builtins.str]] = None,
                 networking: Optional[pulumi.Input['Mk8sLinodeProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: Default image for all nodes.
        :param pulumi.Input[_builtins.str] region: Region where the cluster nodes will live.
        :param pulumi.Input[_builtins.str] token_secret_link: Link to a secret holding Linode access key.
        :param pulumi.Input[_builtins.str] vpc_id: The vpc where nodes will be deployed. Supports SSM.
        :param pulumi.Input[_builtins.str] firewall_id: Optional firewall rule to attach to all nodes.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolArgs']]] node_pools: List of node pools.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        pulumi.set(__self__, "vpc_id", vpc_id)
        if authorized_keys is not None:
            pulumi.set(__self__, "authorized_keys", authorized_keys)
        if authorized_users is not None:
            pulumi.set(__self__, "authorized_users", authorized_users)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if firewall_id is not None:
            pulumi.set(__self__, "firewall_id", firewall_id)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret holding Linode access key.
        """
        return pulumi.get(self, "token_secret_link")

    @token_secret_link.setter
    def token_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_secret_link", value)

    @_builtins.property
    @pulumi.getter(name="vpcId")
    def vpc_id(self) -> pulumi.Input[_builtins.str]:
        """
        The vpc where nodes will be deployed. Supports SSM.
        """
        return pulumi.get(self, "vpc_id")

    @vpc_id.setter
    def vpc_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_id", value)

    @_builtins.property
    @pulumi.getter(name="authorizedKeys")
    def authorized_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "authorized_keys")

    @authorized_keys.setter
    def authorized_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "authorized_keys", value)

    @_builtins.property
    @pulumi.getter(name="authorizedUsers")
    def authorized_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "authorized_users")

    @authorized_users.setter
    def authorized_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "authorized_users", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sLinodeProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sLinodeProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="firewallId")
    def firewall_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional firewall rule to attach to all nodes.
        """
        return pulumi.get(self, "firewall_id")

    @firewall_id.setter
    def firewall_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "firewall_id", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sLinodeProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sLinodeProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)


if not MYPY:
    class Mk8sLinodeProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sLinodeProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLinodeProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sLinodeProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sLinodeProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLinodeProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sLinodeProviderNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        server_type: pulumi.Input[_builtins.str]
        subnet_id: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        override_image: NotRequired[pulumi.Input[_builtins.str]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sLinodeProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLinodeProviderNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 server_type: pulumi.Input[_builtins.str],
                 subnet_id: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image: Optional[pulumi.Input[_builtins.str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "server_type", server_type)
        pulumi.set(__self__, "subnet_id", subnet_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image is not None:
            pulumi.set(__self__, "override_image", override_image)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="serverType")
    def server_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "server_type")

    @server_type.setter
    def server_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "server_type", value)

    @_builtins.property
    @pulumi.getter(name="subnetId")
    def subnet_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "subnet_id")

    @subnet_id.setter
    def subnet_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subnet_id", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="overrideImage")
    def override_image(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "override_image")

    @override_image.setter
    def override_image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_image", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sLinodeProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sLinodeProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sLinodeProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sLinodeProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sOblivusProviderArgsDict(TypedDict):
        datacenter: pulumi.Input[_builtins.str]
        token_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a secret holding Oblivus access key.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sOblivusProviderAutoscalerArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        ssh_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unmanaged_node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolArgsDict']]]]
elif False:
    Mk8sOblivusProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sOblivusProviderArgs:
    def __init__(__self__, *,
                 datacenter: pulumi.Input[_builtins.str],
                 token_secret_link: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sOblivusProviderAutoscalerArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unmanaged_node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] token_secret_link: Link to a secret holding Oblivus access key.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolArgs']]] node_pools: List of node pools.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "datacenter", datacenter)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)
        if unmanaged_node_pools is not None:
            pulumi.set(__self__, "unmanaged_node_pools", unmanaged_node_pools)

    @_builtins.property
    @pulumi.getter
    def datacenter(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "datacenter", value)

    @_builtins.property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret holding Oblivus access key.
        """
        return pulumi.get(self, "token_secret_link")

    @token_secret_link.setter
    def token_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_secret_link", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sOblivusProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sOblivusProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ssh_keys", value)

    @_builtins.property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolArgs']]]]:
        return pulumi.get(self, "unmanaged_node_pools")

    @unmanaged_node_pools.setter
    def unmanaged_node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolArgs']]]]):
        pulumi.set(self, "unmanaged_node_pools", value)


if not MYPY:
    class Mk8sOblivusProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sOblivusProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sOblivusProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sOblivusProviderNodePoolArgsDict(TypedDict):
        flavor: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sOblivusProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sOblivusProviderNodePoolArgs:
    def __init__(__self__, *,
                 flavor: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "flavor", flavor)
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def flavor(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "flavor")

    @flavor.setter
    def flavor(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flavor", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sOblivusProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sOblivusProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sOblivusProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sOblivusProviderUnmanagedNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sOblivusProviderUnmanagedNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sOblivusProviderUnmanagedNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sOblivusProviderUnmanagedNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sOblivusProviderUnmanagedNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sOblivusProviderUnmanagedNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sOblivusProviderUnmanagedNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sPaperspaceProviderArgsDict(TypedDict):
        network_id: pulumi.Input[_builtins.str]
        region: pulumi.Input[_builtins.str]
        """
        Region where the cluster nodes will live.
        """
        token_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a secret holding Paperspace access key.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sPaperspaceProviderAutoscalerArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        shared_drives: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unmanaged_node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolArgsDict']]]]
        user_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    Mk8sPaperspaceProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sPaperspaceProviderArgs:
    def __init__(__self__, *,
                 network_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 token_secret_link: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sPaperspaceProviderAutoscalerArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 shared_drives: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unmanaged_node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolArgs']]]] = None,
                 user_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] region: Region where the cluster nodes will live.
        :param pulumi.Input[_builtins.str] token_secret_link: Link to a secret holding Paperspace access key.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolArgs']]] node_pools: List of node pools.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        pulumi.set(__self__, "network_id", network_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "token_secret_link", token_secret_link)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if shared_drives is not None:
            pulumi.set(__self__, "shared_drives", shared_drives)
        if unmanaged_node_pools is not None:
            pulumi.set(__self__, "unmanaged_node_pools", unmanaged_node_pools)
        if user_ids is not None:
            pulumi.set(__self__, "user_ids", user_ids)

    @_builtins.property
    @pulumi.getter(name="networkId")
    def network_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "network_id")

    @network_id.setter
    def network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the cluster nodes will live.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="tokenSecretLink")
    def token_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a secret holding Paperspace access key.
        """
        return pulumi.get(self, "token_secret_link")

    @token_secret_link.setter
    def token_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_secret_link", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sPaperspaceProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sPaperspaceProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="sharedDrives")
    def shared_drives(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "shared_drives")

    @shared_drives.setter
    def shared_drives(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "shared_drives", value)

    @_builtins.property
    @pulumi.getter(name="unmanagedNodePools")
    def unmanaged_node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolArgs']]]]:
        return pulumi.get(self, "unmanaged_node_pools")

    @unmanaged_node_pools.setter
    def unmanaged_node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolArgs']]]]):
        pulumi.set(self, "unmanaged_node_pools", value)

    @_builtins.property
    @pulumi.getter(name="userIds")
    def user_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "user_ids")

    @user_ids.setter
    def user_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_ids", value)


if not MYPY:
    class Mk8sPaperspaceProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sPaperspaceProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sPaperspaceProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sPaperspaceProviderNodePoolArgsDict(TypedDict):
        machine_type: pulumi.Input[_builtins.str]
        name: pulumi.Input[_builtins.str]
        public_ip_type: pulumi.Input[_builtins.str]
        boot_disk_size: NotRequired[pulumi.Input[_builtins.int]]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sPaperspaceProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sPaperspaceProviderNodePoolArgs:
    def __init__(__self__, *,
                 machine_type: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 public_ip_type: pulumi.Input[_builtins.str],
                 boot_disk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "machine_type", machine_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_ip_type", public_ip_type)
        if boot_disk_size is not None:
            pulumi.set(__self__, "boot_disk_size", boot_disk_size)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="machineType")
    def machine_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "machine_type")

    @machine_type.setter
    def machine_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "machine_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="publicIpType")
    def public_ip_type(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "public_ip_type")

    @public_ip_type.setter
    def public_ip_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_ip_type", value)

    @_builtins.property
    @pulumi.getter(name="bootDiskSize")
    def boot_disk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "boot_disk_size")

    @boot_disk_size.setter
    def boot_disk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "boot_disk_size", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sPaperspaceProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sPaperspaceProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sPaperspaceProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sPaperspaceProviderUnmanagedNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
elif False:
    Mk8sPaperspaceProviderUnmanagedNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sPaperspaceProviderUnmanagedNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        """
        pulumi.set(__self__, "name", name)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sPaperspaceProviderUnmanagedNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class Mk8sStatusArgsDict(TypedDict):
        add_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnArgsDict']]]]
        home_location: NotRequired[pulumi.Input[_builtins.str]]
        oidc_provider_url: NotRequired[pulumi.Input[_builtins.str]]
        server_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusArgs:
    def __init__(__self__, *,
                 add_ons: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnArgs']]]] = None,
                 home_location: Optional[pulumi.Input[_builtins.str]] = None,
                 oidc_provider_url: Optional[pulumi.Input[_builtins.str]] = None,
                 server_url: Optional[pulumi.Input[_builtins.str]] = None):
        if add_ons is not None:
            pulumi.set(__self__, "add_ons", add_ons)
        if home_location is not None:
            pulumi.set(__self__, "home_location", home_location)
        if oidc_provider_url is not None:
            pulumi.set(__self__, "oidc_provider_url", oidc_provider_url)
        if server_url is not None:
            pulumi.set(__self__, "server_url", server_url)

    @_builtins.property
    @pulumi.getter(name="addOns")
    def add_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnArgs']]]]:
        return pulumi.get(self, "add_ons")

    @add_ons.setter
    def add_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnArgs']]]]):
        pulumi.set(self, "add_ons", value)

    @_builtins.property
    @pulumi.getter(name="homeLocation")
    def home_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "home_location")

    @home_location.setter
    def home_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "home_location", value)

    @_builtins.property
    @pulumi.getter(name="oidcProviderUrl")
    def oidc_provider_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "oidc_provider_url")

    @oidc_provider_url.setter
    def oidc_provider_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oidc_provider_url", value)

    @_builtins.property
    @pulumi.getter(name="serverUrl")
    def server_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "server_url")

    @server_url.setter
    def server_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "server_url", value)


if not MYPY:
    class Mk8sStatusAddOnArgsDict(TypedDict):
        aws_ecrs: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEcrArgsDict']]]]
        aws_efs: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEfArgsDict']]]]
        aws_elbs: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsElbArgsDict']]]]
        aws_workload_identities: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityArgsDict']]]]
        dashboards: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnDashboardArgsDict']]]]
        headlamps: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnHeadlampArgsDict']]]]
        logs: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnLogArgsDict']]]]
        metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnMetricArgsDict']]]]
elif False:
    Mk8sStatusAddOnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnArgs:
    def __init__(__self__, *,
                 aws_ecrs: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEcrArgs']]]] = None,
                 aws_efs: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEfArgs']]]] = None,
                 aws_elbs: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsElbArgs']]]] = None,
                 aws_workload_identities: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityArgs']]]] = None,
                 dashboards: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnDashboardArgs']]]] = None,
                 headlamps: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnHeadlampArgs']]]] = None,
                 logs: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnLogArgs']]]] = None,
                 metrics: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnMetricArgs']]]] = None):
        if aws_ecrs is not None:
            pulumi.set(__self__, "aws_ecrs", aws_ecrs)
        if aws_efs is not None:
            pulumi.set(__self__, "aws_efs", aws_efs)
        if aws_elbs is not None:
            pulumi.set(__self__, "aws_elbs", aws_elbs)
        if aws_workload_identities is not None:
            pulumi.set(__self__, "aws_workload_identities", aws_workload_identities)
        if dashboards is not None:
            pulumi.set(__self__, "dashboards", dashboards)
        if headlamps is not None:
            pulumi.set(__self__, "headlamps", headlamps)
        if logs is not None:
            pulumi.set(__self__, "logs", logs)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)

    @_builtins.property
    @pulumi.getter(name="awsEcrs")
    def aws_ecrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEcrArgs']]]]:
        return pulumi.get(self, "aws_ecrs")

    @aws_ecrs.setter
    def aws_ecrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEcrArgs']]]]):
        pulumi.set(self, "aws_ecrs", value)

    @_builtins.property
    @pulumi.getter(name="awsEfs")
    def aws_efs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEfArgs']]]]:
        return pulumi.get(self, "aws_efs")

    @aws_efs.setter
    def aws_efs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsEfArgs']]]]):
        pulumi.set(self, "aws_efs", value)

    @_builtins.property
    @pulumi.getter(name="awsElbs")
    def aws_elbs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsElbArgs']]]]:
        return pulumi.get(self, "aws_elbs")

    @aws_elbs.setter
    def aws_elbs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsElbArgs']]]]):
        pulumi.set(self, "aws_elbs", value)

    @_builtins.property
    @pulumi.getter(name="awsWorkloadIdentities")
    def aws_workload_identities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityArgs']]]]:
        return pulumi.get(self, "aws_workload_identities")

    @aws_workload_identities.setter
    def aws_workload_identities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityArgs']]]]):
        pulumi.set(self, "aws_workload_identities", value)

    @_builtins.property
    @pulumi.getter
    def dashboards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnDashboardArgs']]]]:
        return pulumi.get(self, "dashboards")

    @dashboards.setter
    def dashboards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnDashboardArgs']]]]):
        pulumi.set(self, "dashboards", value)

    @_builtins.property
    @pulumi.getter
    def headlamps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnHeadlampArgs']]]]:
        return pulumi.get(self, "headlamps")

    @headlamps.setter
    def headlamps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnHeadlampArgs']]]]):
        pulumi.set(self, "headlamps", value)

    @_builtins.property
    @pulumi.getter
    def logs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnLogArgs']]]]:
        return pulumi.get(self, "logs")

    @logs.setter
    def logs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnLogArgs']]]]):
        pulumi.set(self, "logs", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnMetricArgs']]]]:
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnMetricArgs']]]]):
        pulumi.set(self, "metrics", value)


if not MYPY:
    class Mk8sStatusAddOnAwsEcrArgsDict(TypedDict):
        trust_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusAddOnAwsEcrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnAwsEcrArgs:
    def __init__(__self__, *,
                 trust_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @_builtins.property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trust_policy")

    @trust_policy.setter
    def trust_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_policy", value)


if not MYPY:
    class Mk8sStatusAddOnAwsEfArgsDict(TypedDict):
        trust_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusAddOnAwsEfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnAwsEfArgs:
    def __init__(__self__, *,
                 trust_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @_builtins.property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trust_policy")

    @trust_policy.setter
    def trust_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_policy", value)


if not MYPY:
    class Mk8sStatusAddOnAwsElbArgsDict(TypedDict):
        trust_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusAddOnAwsElbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnAwsElbArgs:
    def __init__(__self__, *,
                 trust_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @_builtins.property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trust_policy")

    @trust_policy.setter
    def trust_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_policy", value)


if not MYPY:
    class Mk8sStatusAddOnAwsWorkloadIdentityArgsDict(TypedDict):
        oidc_provider_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgsDict']]]]
        trust_policy: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusAddOnAwsWorkloadIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnAwsWorkloadIdentityArgs:
    def __init__(__self__, *,
                 oidc_provider_configs: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgs']]]] = None,
                 trust_policy: Optional[pulumi.Input[_builtins.str]] = None):
        if oidc_provider_configs is not None:
            pulumi.set(__self__, "oidc_provider_configs", oidc_provider_configs)
        if trust_policy is not None:
            pulumi.set(__self__, "trust_policy", trust_policy)

    @_builtins.property
    @pulumi.getter(name="oidcProviderConfigs")
    def oidc_provider_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgs']]]]:
        return pulumi.get(self, "oidc_provider_configs")

    @oidc_provider_configs.setter
    def oidc_provider_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgs']]]]):
        pulumi.set(self, "oidc_provider_configs", value)

    @_builtins.property
    @pulumi.getter(name="trustPolicy")
    def trust_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "trust_policy")

    @trust_policy.setter
    def trust_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_policy", value)


if not MYPY:
    class Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgsDict(TypedDict):
        audience: NotRequired[pulumi.Input[_builtins.str]]
        provider_url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnAwsWorkloadIdentityOidcProviderConfigArgs:
    def __init__(__self__, *,
                 audience: Optional[pulumi.Input[_builtins.str]] = None,
                 provider_url: Optional[pulumi.Input[_builtins.str]] = None):
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if provider_url is not None:
            pulumi.set(__self__, "provider_url", provider_url)

    @_builtins.property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audience", value)

    @_builtins.property
    @pulumi.getter(name="providerUrl")
    def provider_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "provider_url")

    @provider_url.setter
    def provider_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider_url", value)


if not MYPY:
    class Mk8sStatusAddOnDashboardArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access to dashboard.
        """
elif False:
    Mk8sStatusAddOnDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnDashboardArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Access to dashboard.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access to dashboard.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class Mk8sStatusAddOnHeadlampArgsDict(TypedDict):
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Access to dashboard.
        """
elif False:
    Mk8sStatusAddOnHeadlampArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnHeadlampArgs:
    def __init__(__self__, *,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: Access to dashboard.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Access to dashboard.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class Mk8sStatusAddOnLogArgsDict(TypedDict):
        loki_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Loki endpoint to query logs from.
        """
elif False:
    Mk8sStatusAddOnLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnLogArgs:
    def __init__(__self__, *,
                 loki_address: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] loki_address: Loki endpoint to query logs from.
        """
        if loki_address is not None:
            pulumi.set(__self__, "loki_address", loki_address)

    @_builtins.property
    @pulumi.getter(name="lokiAddress")
    def loki_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Loki endpoint to query logs from.
        """
        return pulumi.get(self, "loki_address")

    @loki_address.setter
    def loki_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "loki_address", value)


if not MYPY:
    class Mk8sStatusAddOnMetricArgsDict(TypedDict):
        prometheus_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        remote_write_config: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sStatusAddOnMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sStatusAddOnMetricArgs:
    def __init__(__self__, *,
                 prometheus_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_write_config: Optional[pulumi.Input[_builtins.str]] = None):
        if prometheus_endpoint is not None:
            pulumi.set(__self__, "prometheus_endpoint", prometheus_endpoint)
        if remote_write_config is not None:
            pulumi.set(__self__, "remote_write_config", remote_write_config)

    @_builtins.property
    @pulumi.getter(name="prometheusEndpoint")
    def prometheus_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "prometheus_endpoint")

    @prometheus_endpoint.setter
    def prometheus_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prometheus_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="remoteWriteConfig")
    def remote_write_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "remote_write_config")

    @remote_write_config.setter
    def remote_write_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "remote_write_config", value)


if not MYPY:
    class Mk8sTritonProviderArgsDict(TypedDict):
        image_id: pulumi.Input[_builtins.str]
        """
        Default image for all nodes.
        """
        location: pulumi.Input[_builtins.str]
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to the Triton datacenter.
        """
        private_network_id: pulumi.Input[_builtins.str]
        """
        ID of the private Fabric/Network.
        """
        autoscaler: NotRequired[pulumi.Input['Mk8sTritonProviderAutoscalerArgsDict']]
        connection: NotRequired[pulumi.Input['Mk8sTritonProviderConnectionArgsDict']]
        firewall_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable firewall for the instances deployed.
        """
        load_balancer: NotRequired[pulumi.Input['Mk8sTritonProviderLoadBalancerArgsDict']]
        networking: NotRequired[pulumi.Input['Mk8sTritonProviderNetworkingArgsDict']]
        node_pools: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolArgsDict']]]]
        """
        List of node pools.
        """
        pre_install_script: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        ssh_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Extra SSH keys to provision for user root.
        """
elif False:
    Mk8sTritonProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderArgs:
    def __init__(__self__, *,
                 image_id: pulumi.Input[_builtins.str],
                 location: pulumi.Input[_builtins.str],
                 private_network_id: pulumi.Input[_builtins.str],
                 autoscaler: Optional[pulumi.Input['Mk8sTritonProviderAutoscalerArgs']] = None,
                 connection: Optional[pulumi.Input['Mk8sTritonProviderConnectionArgs']] = None,
                 firewall_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 load_balancer: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerArgs']] = None,
                 networking: Optional[pulumi.Input['Mk8sTritonProviderNetworkingArgs']] = None,
                 node_pools: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolArgs']]]] = None,
                 pre_install_script: Optional[pulumi.Input[_builtins.str]] = None,
                 ssh_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] image_id: Default image for all nodes.
        :param pulumi.Input[_builtins.str] location: Control Plane location that will host the K8s components. Prefer one that is closest to the Triton datacenter.
        :param pulumi.Input[_builtins.str] private_network_id: ID of the private Fabric/Network.
        :param pulumi.Input[_builtins.bool] firewall_enabled: Enable firewall for the instances deployed.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolArgs']]] node_pools: List of node pools.
        :param pulumi.Input[_builtins.str] pre_install_script: Optional shell script that will be run before K8s is installed. Supports SSM.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ssh_keys: Extra SSH keys to provision for user root.
        """
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "private_network_id", private_network_id)
        if autoscaler is not None:
            pulumi.set(__self__, "autoscaler", autoscaler)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if firewall_enabled is not None:
            pulumi.set(__self__, "firewall_enabled", firewall_enabled)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if networking is not None:
            pulumi.set(__self__, "networking", networking)
        if node_pools is not None:
            pulumi.set(__self__, "node_pools", node_pools)
        if pre_install_script is not None:
            pulumi.set(__self__, "pre_install_script", pre_install_script)
        if ssh_keys is not None:
            pulumi.set(__self__, "ssh_keys", ssh_keys)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> pulumi.Input[_builtins.str]:
        """
        Default image for all nodes.
        """
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        Control Plane location that will host the K8s components. Prefer one that is closest to the Triton datacenter.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter(name="privateNetworkId")
    def private_network_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the private Fabric/Network.
        """
        return pulumi.get(self, "private_network_id")

    @private_network_id.setter
    def private_network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_network_id", value)

    @_builtins.property
    @pulumi.getter
    def autoscaler(self) -> Optional[pulumi.Input['Mk8sTritonProviderAutoscalerArgs']]:
        return pulumi.get(self, "autoscaler")

    @autoscaler.setter
    def autoscaler(self, value: Optional[pulumi.Input['Mk8sTritonProviderAutoscalerArgs']]):
        pulumi.set(self, "autoscaler", value)

    @_builtins.property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input['Mk8sTritonProviderConnectionArgs']]:
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input['Mk8sTritonProviderConnectionArgs']]):
        pulumi.set(self, "connection", value)

    @_builtins.property
    @pulumi.getter(name="firewallEnabled")
    def firewall_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable firewall for the instances deployed.
        """
        return pulumi.get(self, "firewall_enabled")

    @firewall_enabled.setter
    def firewall_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "firewall_enabled", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerArgs']]:
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerArgs']]):
        pulumi.set(self, "load_balancer", value)

    @_builtins.property
    @pulumi.getter
    def networking(self) -> Optional[pulumi.Input['Mk8sTritonProviderNetworkingArgs']]:
        return pulumi.get(self, "networking")

    @networking.setter
    def networking(self, value: Optional[pulumi.Input['Mk8sTritonProviderNetworkingArgs']]):
        pulumi.set(self, "networking", value)

    @_builtins.property
    @pulumi.getter(name="nodePools")
    def node_pools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolArgs']]]]:
        """
        List of node pools.
        """
        return pulumi.get(self, "node_pools")

    @node_pools.setter
    def node_pools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolArgs']]]]):
        pulumi.set(self, "node_pools", value)

    @_builtins.property
    @pulumi.getter(name="preInstallScript")
    def pre_install_script(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional shell script that will be run before K8s is installed. Supports SSM.
        """
        return pulumi.get(self, "pre_install_script")

    @pre_install_script.setter
    def pre_install_script(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pre_install_script", value)

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Extra SSH keys to provision for user root.
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ssh_keys", value)


if not MYPY:
    class Mk8sTritonProviderAutoscalerArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        unready_time: NotRequired[pulumi.Input[_builtins.str]]
        utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
elif False:
    Mk8sTritonProviderAutoscalerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderAutoscalerArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 unready_time: Optional[pulumi.Input[_builtins.str]] = None,
                 utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if unneeded_time is not None:
            pulumi.set(__self__, "unneeded_time", unneeded_time)
        if unready_time is not None:
            pulumi.set(__self__, "unready_time", unready_time)
        if utilization_threshold is not None:
            pulumi.set(__self__, "utilization_threshold", utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="unneededTime")
    def unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unneeded_time")

    @unneeded_time.setter
    def unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="unreadyTime")
    def unready_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "unready_time")

    @unready_time.setter
    def unready_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "unready_time", value)

    @_builtins.property
    @pulumi.getter(name="utilizationThreshold")
    def utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        return pulumi.get(self, "utilization_threshold")

    @utilization_threshold.setter
    def utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "utilization_threshold", value)


if not MYPY:
    class Mk8sTritonProviderConnectionArgsDict(TypedDict):
        account: pulumi.Input[_builtins.str]
        private_key_secret_link: pulumi.Input[_builtins.str]
        """
        Link to a SSH or opaque secret.
        """
        url: pulumi.Input[_builtins.str]
        user: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sTritonProviderConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderConnectionArgs:
    def __init__(__self__, *,
                 account: pulumi.Input[_builtins.str],
                 private_key_secret_link: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str],
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_key_secret_link: Link to a SSH or opaque secret.
        """
        pulumi.set(__self__, "account", account)
        pulumi.set(__self__, "private_key_secret_link", private_key_secret_link)
        pulumi.set(__self__, "url", url)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def account(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "account")

    @account.setter
    def account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account", value)

    @_builtins.property
    @pulumi.getter(name="privateKeySecretLink")
    def private_key_secret_link(self) -> pulumi.Input[_builtins.str]:
        """
        Link to a SSH or opaque secret.
        """
        return pulumi.get(self, "private_key_secret_link")

    @private_key_secret_link.setter
    def private_key_secret_link(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key_secret_link", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class Mk8sTritonProviderLoadBalancerArgsDict(TypedDict):
        gateway: NotRequired[pulumi.Input['Mk8sTritonProviderLoadBalancerGatewayArgsDict']]
        manual: NotRequired[pulumi.Input['Mk8sTritonProviderLoadBalancerManualArgsDict']]
        none: NotRequired[pulumi.Input['Mk8sTritonProviderLoadBalancerNoneArgsDict']]
elif False:
    Mk8sTritonProviderLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderLoadBalancerArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerGatewayArgs']] = None,
                 manual: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerManualArgs']] = None,
                 none: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerNoneArgs']] = None):
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if manual is not None:
            pulumi.set(__self__, "manual", manual)
        if none is not None:
            pulumi.set(__self__, "none", none)

    @_builtins.property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerGatewayArgs']]:
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerGatewayArgs']]):
        pulumi.set(self, "gateway", value)

    @_builtins.property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerManualArgs']]:
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerManualArgs']]):
        pulumi.set(self, "manual", value)

    @_builtins.property
    @pulumi.getter
    def none(self) -> Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerNoneArgs']]:
        return pulumi.get(self, "none")

    @none.setter
    def none(self, value: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerNoneArgs']]):
        pulumi.set(self, "none", value)


if not MYPY:
    class Mk8sTritonProviderLoadBalancerGatewayArgsDict(TypedDict):
        pass
elif False:
    Mk8sTritonProviderLoadBalancerGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderLoadBalancerGatewayArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sTritonProviderLoadBalancerManualArgsDict(TypedDict):
        cns_internal_domain: pulumi.Input[_builtins.str]
        cns_public_domain: pulumi.Input[_builtins.str]
        image_id: pulumi.Input[_builtins.str]
        package_id: pulumi.Input[_builtins.str]
        private_network_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        If set, machine will also get a public IP.
        """
        public_network_id: pulumi.Input[_builtins.str]
        """
        If set, machine will also get a public IP.
        """
        count: NotRequired[pulumi.Input[_builtins.int]]
        logging: NotRequired[pulumi.Input['Mk8sTritonProviderLoadBalancerManualLoggingArgsDict']]
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to instances from a node pool.
        """
        tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to instances from a node pool.
        """
elif False:
    Mk8sTritonProviderLoadBalancerManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderLoadBalancerManualArgs:
    def __init__(__self__, *,
                 cns_internal_domain: pulumi.Input[_builtins.str],
                 cns_public_domain: pulumi.Input[_builtins.str],
                 image_id: pulumi.Input[_builtins.str],
                 package_id: pulumi.Input[_builtins.str],
                 private_network_ids: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 public_network_id: pulumi.Input[_builtins.str],
                 count: Optional[pulumi.Input[_builtins.int]] = None,
                 logging: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerManualLoggingArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_network_ids: If set, machine will also get a public IP.
        :param pulumi.Input[_builtins.str] public_network_id: If set, machine will also get a public IP.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: Extra tags to attach to instances from a node pool.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] tags: Extra tags to attach to instances from a node pool.
        """
        pulumi.set(__self__, "cns_internal_domain", cns_internal_domain)
        pulumi.set(__self__, "cns_public_domain", cns_public_domain)
        pulumi.set(__self__, "image_id", image_id)
        pulumi.set(__self__, "package_id", package_id)
        pulumi.set(__self__, "private_network_ids", private_network_ids)
        pulumi.set(__self__, "public_network_id", public_network_id)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if logging is not None:
            pulumi.set(__self__, "logging", logging)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter(name="cnsInternalDomain")
    def cns_internal_domain(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cns_internal_domain")

    @cns_internal_domain.setter
    def cns_internal_domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cns_internal_domain", value)

    @_builtins.property
    @pulumi.getter(name="cnsPublicDomain")
    def cns_public_domain(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "cns_public_domain")

    @cns_public_domain.setter
    def cns_public_domain(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cns_public_domain", value)

    @_builtins.property
    @pulumi.getter(name="imageId")
    def image_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "image_id")

    @image_id.setter
    def image_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image_id", value)

    @_builtins.property
    @pulumi.getter(name="packageId")
    def package_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "package_id")

    @package_id.setter
    def package_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "package_id", value)

    @_builtins.property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        If set, machine will also get a public IP.
        """
        return pulumi.get(self, "private_network_ids")

    @private_network_ids.setter
    def private_network_ids(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "private_network_ids", value)

    @_builtins.property
    @pulumi.getter(name="publicNetworkId")
    def public_network_id(self) -> pulumi.Input[_builtins.str]:
        """
        If set, machine will also get a public IP.
        """
        return pulumi.get(self, "public_network_id")

    @public_network_id.setter
    def public_network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_network_id", value)

    @_builtins.property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "count", value)

    @_builtins.property
    @pulumi.getter
    def logging(self) -> Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerManualLoggingArgs']]:
        return pulumi.get(self, "logging")

    @logging.setter
    def logging(self, value: Optional[pulumi.Input['Mk8sTritonProviderLoadBalancerManualLoggingArgs']]):
        pulumi.set(self, "logging", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to instances from a node pool.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to instances from a node pool.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class Mk8sTritonProviderLoadBalancerManualLoggingArgsDict(TypedDict):
        external_syslog: NotRequired[pulumi.Input[_builtins.str]]
        node_port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    Mk8sTritonProviderLoadBalancerManualLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderLoadBalancerManualLoggingArgs:
    def __init__(__self__, *,
                 external_syslog: Optional[pulumi.Input[_builtins.str]] = None,
                 node_port: Optional[pulumi.Input[_builtins.int]] = None):
        if external_syslog is not None:
            pulumi.set(__self__, "external_syslog", external_syslog)
        if node_port is not None:
            pulumi.set(__self__, "node_port", node_port)

    @_builtins.property
    @pulumi.getter(name="externalSyslog")
    def external_syslog(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "external_syslog")

    @external_syslog.setter
    def external_syslog(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_syslog", value)

    @_builtins.property
    @pulumi.getter(name="nodePort")
    def node_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "node_port")

    @node_port.setter
    def node_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_port", value)


if not MYPY:
    class Mk8sTritonProviderLoadBalancerNoneArgsDict(TypedDict):
        pass
elif False:
    Mk8sTritonProviderLoadBalancerNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderLoadBalancerNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class Mk8sTritonProviderNetworkingArgsDict(TypedDict):
        dns_forwarder: NotRequired[pulumi.Input[_builtins.str]]
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        pod_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the pod network.
        """
        service_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CIDR of the service network.
        """
elif False:
    Mk8sTritonProviderNetworkingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderNetworkingArgs:
    def __init__(__self__, *,
                 dns_forwarder: Optional[pulumi.Input[_builtins.str]] = None,
                 pod_network: Optional[pulumi.Input[_builtins.str]] = None,
                 service_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dns_forwarder: DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        :param pulumi.Input[_builtins.str] pod_network: The CIDR of the pod network.
        :param pulumi.Input[_builtins.str] service_network: The CIDR of the service network.
        """
        if dns_forwarder is not None:
            pulumi.set(__self__, "dns_forwarder", dns_forwarder)
        if pod_network is not None:
            pulumi.set(__self__, "pod_network", pod_network)
        if service_network is not None:
            pulumi.set(__self__, "service_network", service_network)

    @_builtins.property
    @pulumi.getter(name="dnsForwarder")
    def dns_forwarder(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        DNS forwarder used by the cluster. Can be a space-delimited list of dns servers. Default is /etc/resolv.conf when not specified.
        """
        return pulumi.get(self, "dns_forwarder")

    @dns_forwarder.setter
    def dns_forwarder(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dns_forwarder", value)

    @_builtins.property
    @pulumi.getter(name="podNetwork")
    def pod_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the pod network.
        """
        return pulumi.get(self, "pod_network")

    @pod_network.setter
    def pod_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "pod_network", value)

    @_builtins.property
    @pulumi.getter(name="serviceNetwork")
    def service_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CIDR of the service network.
        """
        return pulumi.get(self, "service_network")

    @service_network.setter
    def service_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_network", value)


if not MYPY:
    class Mk8sTritonProviderNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        package_id: pulumi.Input[_builtins.str]
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to attach to nodes of a node pool.
        """
        max_size: NotRequired[pulumi.Input[_builtins.int]]
        min_size: NotRequired[pulumi.Input[_builtins.int]]
        override_image_id: NotRequired[pulumi.Input[_builtins.str]]
        private_network_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        More private networks to join.
        """
        public_network_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        If set, machine will also get a public IP.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolTaintArgsDict']]]]
        """
        Taint for the nodes of a pool.
        """
        triton_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Extra tags to attach to instances from a node pool.
        """
elif False:
    Mk8sTritonProviderNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 package_id: pulumi.Input[_builtins.str],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_size: Optional[pulumi.Input[_builtins.int]] = None,
                 min_size: Optional[pulumi.Input[_builtins.int]] = None,
                 override_image_id: Optional[pulumi.Input[_builtins.str]] = None,
                 private_network_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 public_network_id: Optional[pulumi.Input[_builtins.str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolTaintArgs']]]] = None,
                 triton_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to attach to nodes of a node pool.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] private_network_ids: More private networks to join.
        :param pulumi.Input[_builtins.str] public_network_id: If set, machine will also get a public IP.
        :param pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolTaintArgs']]] taints: Taint for the nodes of a pool.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] triton_tags: Extra tags to attach to instances from a node pool.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "package_id", package_id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)
        if min_size is not None:
            pulumi.set(__self__, "min_size", min_size)
        if override_image_id is not None:
            pulumi.set(__self__, "override_image_id", override_image_id)
        if private_network_ids is not None:
            pulumi.set(__self__, "private_network_ids", private_network_ids)
        if public_network_id is not None:
            pulumi.set(__self__, "public_network_id", public_network_id)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if triton_tags is not None:
            pulumi.set(__self__, "triton_tags", triton_tags)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="packageId")
    def package_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "package_id")

    @package_id.setter
    def package_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "package_id", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to attach to nodes of a node pool.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_size", value)

    @_builtins.property
    @pulumi.getter(name="minSize")
    def min_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_size")

    @min_size.setter
    def min_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_size", value)

    @_builtins.property
    @pulumi.getter(name="overrideImageId")
    def override_image_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "override_image_id")

    @override_image_id.setter
    def override_image_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "override_image_id", value)

    @_builtins.property
    @pulumi.getter(name="privateNetworkIds")
    def private_network_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        More private networks to join.
        """
        return pulumi.get(self, "private_network_ids")

    @private_network_ids.setter
    def private_network_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "private_network_ids", value)

    @_builtins.property
    @pulumi.getter(name="publicNetworkId")
    def public_network_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If set, machine will also get a public IP.
        """
        return pulumi.get(self, "public_network_id")

    @public_network_id.setter
    def public_network_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_network_id", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolTaintArgs']]]]:
        """
        Taint for the nodes of a pool.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['Mk8sTritonProviderNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)

    @_builtins.property
    @pulumi.getter(name="tritonTags")
    def triton_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Extra tags to attach to instances from a node pool.
        """
        return pulumi.get(self, "triton_tags")

    @triton_tags.setter
    def triton_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "triton_tags", value)


if not MYPY:
    class Mk8sTritonProviderNodePoolTaintArgsDict(TypedDict):
        effect: NotRequired[pulumi.Input[_builtins.str]]
        key: NotRequired[pulumi.Input[_builtins.str]]
        value: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    Mk8sTritonProviderNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class Mk8sTritonProviderNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class OrgAuthConfigArgsDict(TypedDict):
        domain_auto_members: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of domains which will auto-provision users when authenticating using SAML.
        """
        saml_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enforce SAML only authentication.
        """
elif False:
    OrgAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgAuthConfigArgs:
    def __init__(__self__, *,
                 domain_auto_members: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 saml_only: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] domain_auto_members: List of domains which will auto-provision users when authenticating using SAML.
        :param pulumi.Input[_builtins.bool] saml_only: Enforce SAML only authentication.
        """
        pulumi.set(__self__, "domain_auto_members", domain_auto_members)
        if saml_only is not None:
            pulumi.set(__self__, "saml_only", saml_only)

    @_builtins.property
    @pulumi.getter(name="domainAutoMembers")
    def domain_auto_members(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of domains which will auto-provision users when authenticating using SAML.
        """
        return pulumi.get(self, "domain_auto_members")

    @domain_auto_members.setter
    def domain_auto_members(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "domain_auto_members", value)

    @_builtins.property
    @pulumi.getter(name="samlOnly")
    def saml_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enforce SAML only authentication.
        """
        return pulumi.get(self, "saml_only")

    @saml_only.setter
    def saml_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "saml_only", value)


if not MYPY:
    class OrgLoggingCloudWatchLoggingArgsDict(TypedDict):
        credentials: pulumi.Input[_builtins.str]
        """
        Full Link to a secret of type `opaque`.
        """
        group_name: pulumi.Input[_builtins.str]
        """
        A container for log streams with common settings like retention. Used to categorize logs by application or service type.
        """
        region: pulumi.Input[_builtins.str]
        """
        Valid AWS region.
        """
        stream_name: pulumi.Input[_builtins.str]
        """
        A sequence of log events from the same source within a log group. Typically represents individual instances of services or applications.
        """
        extract_fields: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Enable custom data extraction from log entries for enhanced querying and analysis.
        """
        retention_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Length, in days, for how log data is kept before it is automatically deleted.
        """
elif False:
    OrgLoggingCloudWatchLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingCloudWatchLoggingArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[_builtins.str],
                 group_name: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 stream_name: pulumi.Input[_builtins.str],
                 extract_fields: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 retention_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] credentials: Full Link to a secret of type `opaque`.
        :param pulumi.Input[_builtins.str] group_name: A container for log streams with common settings like retention. Used to categorize logs by application or service type.
        :param pulumi.Input[_builtins.str] region: Valid AWS region.
        :param pulumi.Input[_builtins.str] stream_name: A sequence of log events from the same source within a log group. Typically represents individual instances of services or applications.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extract_fields: Enable custom data extraction from log entries for enhanced querying and analysis.
        :param pulumi.Input[_builtins.int] retention_days: Length, in days, for how log data is kept before it is automatically deleted.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "group_name", group_name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "stream_name", stream_name)
        if extract_fields is not None:
            pulumi.set(__self__, "extract_fields", extract_fields)
        if retention_days is not None:
            pulumi.set(__self__, "retention_days", retention_days)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full Link to a secret of type `opaque`.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="groupName")
    def group_name(self) -> pulumi.Input[_builtins.str]:
        """
        A container for log streams with common settings like retention. Used to categorize logs by application or service type.
        """
        return pulumi.get(self, "group_name")

    @group_name.setter
    def group_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "group_name", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Valid AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="streamName")
    def stream_name(self) -> pulumi.Input[_builtins.str]:
        """
        A sequence of log events from the same source within a log group. Typically represents individual instances of services or applications.
        """
        return pulumi.get(self, "stream_name")

    @stream_name.setter
    def stream_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "stream_name", value)

    @_builtins.property
    @pulumi.getter(name="extractFields")
    def extract_fields(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Enable custom data extraction from log entries for enhanced querying and analysis.
        """
        return pulumi.get(self, "extract_fields")

    @extract_fields.setter
    def extract_fields(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extract_fields", value)

    @_builtins.property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Length, in days, for how log data is kept before it is automatically deleted.
        """
        return pulumi.get(self, "retention_days")

    @retention_days.setter
    def retention_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_days", value)


if not MYPY:
    class OrgLoggingCoralogixLoggingArgsDict(TypedDict):
        cluster: pulumi.Input[_builtins.str]
        """
        Coralogix cluster URI.
        """
        credentials: pulumi.Input[_builtins.str]
        """
        Full link to referenced Opaque Secret.
        """
        app: NotRequired[pulumi.Input[_builtins.str]]
        """
        App name to be displayed in Coralogix dashboard.
        """
        subsystem: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subsystem name to be displayed in Coralogix dashboard.
        """
elif False:
    OrgLoggingCoralogixLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingCoralogixLoggingArgs:
    def __init__(__self__, *,
                 cluster: pulumi.Input[_builtins.str],
                 credentials: pulumi.Input[_builtins.str],
                 app: Optional[pulumi.Input[_builtins.str]] = None,
                 subsystem: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster: Coralogix cluster URI.
        :param pulumi.Input[_builtins.str] credentials: Full link to referenced Opaque Secret.
        :param pulumi.Input[_builtins.str] app: App name to be displayed in Coralogix dashboard.
        :param pulumi.Input[_builtins.str] subsystem: Subsystem name to be displayed in Coralogix dashboard.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "credentials", credentials)
        if app is not None:
            pulumi.set(__self__, "app", app)
        if subsystem is not None:
            pulumi.set(__self__, "subsystem", subsystem)

    @_builtins.property
    @pulumi.getter
    def cluster(self) -> pulumi.Input[_builtins.str]:
        """
        Coralogix cluster URI.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cluster", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def app(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        App name to be displayed in Coralogix dashboard.
        """
        return pulumi.get(self, "app")

    @app.setter
    def app(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "app", value)

    @_builtins.property
    @pulumi.getter
    def subsystem(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subsystem name to be displayed in Coralogix dashboard.
        """
        return pulumi.get(self, "subsystem")

    @subsystem.setter
    def subsystem(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subsystem", value)


if not MYPY:
    class OrgLoggingDatadogLoggingArgsDict(TypedDict):
        credentials: pulumi.Input[_builtins.str]
        """
        Full link to referenced Opaque Secret.
        """
        host: pulumi.Input[_builtins.str]
        """
        Datadog host URI.
        """
elif False:
    OrgLoggingDatadogLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingDatadogLoggingArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] credentials: Full link to referenced Opaque Secret.
        :param pulumi.Input[_builtins.str] host: Datadog host URI.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog host URI.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)


if not MYPY:
    class OrgLoggingElasticLoggingArgsDict(TypedDict):
        aws: NotRequired[pulumi.Input['OrgLoggingElasticLoggingAwsArgsDict']]
        """
        For targeting Amazon Web Services (AWS) ElasticSearch.
        """
        elastic_cloud: NotRequired[pulumi.Input['OrgLoggingElasticLoggingElasticCloudArgsDict']]
        """
        For targeting Elastic Cloud.
        """
        generic: NotRequired[pulumi.Input['OrgLoggingElasticLoggingGenericArgsDict']]
        """
        For targeting generic Elastic Search providers.
        """
elif False:
    OrgLoggingElasticLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingElasticLoggingArgs:
    def __init__(__self__, *,
                 aws: Optional[pulumi.Input['OrgLoggingElasticLoggingAwsArgs']] = None,
                 elastic_cloud: Optional[pulumi.Input['OrgLoggingElasticLoggingElasticCloudArgs']] = None,
                 generic: Optional[pulumi.Input['OrgLoggingElasticLoggingGenericArgs']] = None):
        """
        :param pulumi.Input['OrgLoggingElasticLoggingAwsArgs'] aws: For targeting Amazon Web Services (AWS) ElasticSearch.
        :param pulumi.Input['OrgLoggingElasticLoggingElasticCloudArgs'] elastic_cloud: For targeting Elastic Cloud.
        :param pulumi.Input['OrgLoggingElasticLoggingGenericArgs'] generic: For targeting generic Elastic Search providers.
        """
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if elastic_cloud is not None:
            pulumi.set(__self__, "elastic_cloud", elastic_cloud)
        if generic is not None:
            pulumi.set(__self__, "generic", generic)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['OrgLoggingElasticLoggingAwsArgs']]:
        """
        For targeting Amazon Web Services (AWS) ElasticSearch.
        """
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['OrgLoggingElasticLoggingAwsArgs']]):
        pulumi.set(self, "aws", value)

    @_builtins.property
    @pulumi.getter(name="elasticCloud")
    def elastic_cloud(self) -> Optional[pulumi.Input['OrgLoggingElasticLoggingElasticCloudArgs']]:
        """
        For targeting Elastic Cloud.
        """
        return pulumi.get(self, "elastic_cloud")

    @elastic_cloud.setter
    def elastic_cloud(self, value: Optional[pulumi.Input['OrgLoggingElasticLoggingElasticCloudArgs']]):
        pulumi.set(self, "elastic_cloud", value)

    @_builtins.property
    @pulumi.getter
    def generic(self) -> Optional[pulumi.Input['OrgLoggingElasticLoggingGenericArgs']]:
        """
        For targeting generic Elastic Search providers.
        """
        return pulumi.get(self, "generic")

    @generic.setter
    def generic(self, value: Optional[pulumi.Input['OrgLoggingElasticLoggingGenericArgs']]):
        pulumi.set(self, "generic", value)


if not MYPY:
    class OrgLoggingElasticLoggingAwsArgsDict(TypedDict):
        credentials: pulumi.Input[_builtins.str]
        """
        Full Link to a secret of type `aws`.
        """
        host: pulumi.Input[_builtins.str]
        """
        A valid AWS ElasticSearch hostname (must end with es.amazonaws.com).
        """
        index: pulumi.Input[_builtins.str]
        """
        Logging Index.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port. Default: 443
        """
        region: pulumi.Input[_builtins.str]
        """
        Valid AWS region.
        """
        type: pulumi.Input[_builtins.str]
        """
        Logging Type.
        """
elif False:
    OrgLoggingElasticLoggingAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingElasticLoggingAwsArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 index: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 region: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] credentials: Full Link to a secret of type `aws`.
        :param pulumi.Input[_builtins.str] host: A valid AWS ElasticSearch hostname (must end with es.amazonaws.com).
        :param pulumi.Input[_builtins.str] index: Logging Index.
        :param pulumi.Input[_builtins.int] port: Port. Default: 443
        :param pulumi.Input[_builtins.str] region: Valid AWS region.
        :param pulumi.Input[_builtins.str] type: Logging Type.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full Link to a secret of type `aws`.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        A valid AWS ElasticSearch hostname (must end with es.amazonaws.com).
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        Logging Index.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port. Default: 443
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Valid AWS region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Logging Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OrgLoggingElasticLoggingElasticCloudArgsDict(TypedDict):
        cloud_id: pulumi.Input[_builtins.str]
        """
        [Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html)
        """
        credentials: pulumi.Input[_builtins.str]
        """
        Full Link to a secret of type `userpass`.
        """
        index: pulumi.Input[_builtins.str]
        """
        Logging Index.
        """
        type: pulumi.Input[_builtins.str]
        """
        Logging Type.
        """
elif False:
    OrgLoggingElasticLoggingElasticCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingElasticLoggingElasticCloudArgs:
    def __init__(__self__, *,
                 cloud_id: pulumi.Input[_builtins.str],
                 credentials: pulumi.Input[_builtins.str],
                 index: pulumi.Input[_builtins.str],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cloud_id: [Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html)
        :param pulumi.Input[_builtins.str] credentials: Full Link to a secret of type `userpass`.
        :param pulumi.Input[_builtins.str] index: Logging Index.
        :param pulumi.Input[_builtins.str] type: Logging Type.
        """
        pulumi.set(__self__, "cloud_id", cloud_id)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cloudId")
    def cloud_id(self) -> pulumi.Input[_builtins.str]:
        """
        [Cloud ID](https://www.elastic.co/guide/en/cloud/current/ec-cloud-id.html)
        """
        return pulumi.get(self, "cloud_id")

    @cloud_id.setter
    def cloud_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cloud_id", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full Link to a secret of type `userpass`.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        Logging Index.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Logging Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OrgLoggingElasticLoggingGenericArgsDict(TypedDict):
        credentials: pulumi.Input[_builtins.str]
        """
        Full Link to a secret of type `userpass`.
        """
        host: pulumi.Input[_builtins.str]
        """
        A valid Elastic Search provider hostname.
        """
        index: pulumi.Input[_builtins.str]
        """
        Logging Index.
        """
        path: pulumi.Input[_builtins.str]
        """
        Logging path.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port. Default: 443
        """
        type: pulumi.Input[_builtins.str]
        """
        Logging Type.
        """
elif False:
    OrgLoggingElasticLoggingGenericArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingElasticLoggingGenericArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 index: pulumi.Input[_builtins.str],
                 path: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] credentials: Full Link to a secret of type `userpass`.
        :param pulumi.Input[_builtins.str] host: A valid Elastic Search provider hostname.
        :param pulumi.Input[_builtins.str] index: Logging Index.
        :param pulumi.Input[_builtins.str] path: Logging path.
        :param pulumi.Input[_builtins.int] port: Port. Default: 443
        :param pulumi.Input[_builtins.str] type: Logging Type.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full Link to a secret of type `userpass`.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        A valid Elastic Search provider hostname.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        """
        Logging Index.
        """
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Logging path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port. Default: 443
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Logging Type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class OrgLoggingFluentdLoggingArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        The hostname or IP address of a remote log storage system.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        Port. Default: 24224
        """
elif False:
    OrgLoggingFluentdLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingFluentdLoggingArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The hostname or IP address of a remote log storage system.
        :param pulumi.Input[_builtins.int] port: Port. Default: 24224
        """
        pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname or IP address of a remote log storage system.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Port. Default: 24224
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class OrgLoggingLogzioLoggingArgsDict(TypedDict):
        credentials: pulumi.Input[_builtins.str]
        """
        Full link to referenced Opaque Secret.
        """
        listener_host: pulumi.Input[_builtins.str]
        """
        Logzio listener host URI.
        """
elif False:
    OrgLoggingLogzioLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingLogzioLoggingArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[_builtins.str],
                 listener_host: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] credentials: Full link to referenced Opaque Secret.
        :param pulumi.Input[_builtins.str] listener_host: Logzio listener host URI.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "listener_host", listener_host)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="listenerHost")
    def listener_host(self) -> pulumi.Input[_builtins.str]:
        """
        Logzio listener host URI.
        """
        return pulumi.get(self, "listener_host")

    @listener_host.setter
    def listener_host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "listener_host", value)


if not MYPY:
    class OrgLoggingS3LoggingArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Name of S3 bucket.
        """
        credentials: pulumi.Input[_builtins.str]
        """
        Full link to referenced AWS Secret.
        """
        region: pulumi.Input[_builtins.str]
        """
        AWS region where bucket is located.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Bucket path prefix. Default: "/".
        """
elif False:
    OrgLoggingS3LoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingS3LoggingArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 credentials: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Name of S3 bucket.
        :param pulumi.Input[_builtins.str] credentials: Full link to referenced AWS Secret.
        :param pulumi.Input[_builtins.str] region: AWS region where bucket is located.
        :param pulumi.Input[_builtins.str] prefix: Bucket path prefix. Default: "/".
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "region", region)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Name of S3 bucket.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full link to referenced AWS Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        AWS region where bucket is located.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Bucket path prefix. Default: "/".
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class OrgLoggingStackdriverLoggingArgsDict(TypedDict):
        credentials: pulumi.Input[_builtins.str]
        """
        Full Link to a secret of type `opaque`.
        """
        location: pulumi.Input[_builtins.str]
        """
        A Google Cloud Provider region.
        """
elif False:
    OrgLoggingStackdriverLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingStackdriverLoggingArgs:
    def __init__(__self__, *,
                 credentials: pulumi.Input[_builtins.str],
                 location: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] credentials: Full Link to a secret of type `opaque`.
        :param pulumi.Input[_builtins.str] location: A Google Cloud Provider region.
        """
        pulumi.set(__self__, "credentials", credentials)
        pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> pulumi.Input[_builtins.str]:
        """
        Full Link to a secret of type `opaque`.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        A Google Cloud Provider region.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)


if not MYPY:
    class OrgLoggingSyslogLoggingArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        Hostname of Syslog Endpoint.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port of Syslog Endpoint.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log Format. Valid values: RFC3164 or RFC5424.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Log Mode. Valid values: TCP, TLS, or UDP.
        """
        severity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Severity Level. See documentation for details. Valid values: 0 to 7.
        """
elif False:
    OrgLoggingSyslogLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgLoggingSyslogLoggingArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 severity: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] host: Hostname of Syslog Endpoint.
        :param pulumi.Input[_builtins.int] port: Port of Syslog Endpoint.
        :param pulumi.Input[_builtins.str] format: Log Format. Valid values: RFC3164 or RFC5424.
        :param pulumi.Input[_builtins.str] mode: Log Mode. Valid values: TCP, TLS, or UDP.
        :param pulumi.Input[_builtins.int] severity: Severity Level. See documentation for details. Valid values: 0 to 7.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        Hostname of Syslog Endpoint.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port of Syslog Endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log Format. Valid values: RFC3164 or RFC5424.
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Log Mode. Valid values: TCP, TLS, or UDP.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Severity Level. See documentation for details. Valid values: 0 to 7.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class OrgObservabilityArgsDict(TypedDict):
        default_alert_emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        These emails are configured as alert recipients in Grafana when the 'grafana-default-email' contact delivery type is 'Email'.
        """
        logs_retention_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Log retention days. Default: 30
        """
        metrics_retention_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Metrics retention days. Default: 30
        """
        traces_retention_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Traces retention days. Default: 30
        """
elif False:
    OrgObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgObservabilityArgs:
    def __init__(__self__, *,
                 default_alert_emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 logs_retention_days: Optional[pulumi.Input[_builtins.int]] = None,
                 metrics_retention_days: Optional[pulumi.Input[_builtins.int]] = None,
                 traces_retention_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] default_alert_emails: These emails are configured as alert recipients in Grafana when the 'grafana-default-email' contact delivery type is 'Email'.
        :param pulumi.Input[_builtins.int] logs_retention_days: Log retention days. Default: 30
        :param pulumi.Input[_builtins.int] metrics_retention_days: Metrics retention days. Default: 30
        :param pulumi.Input[_builtins.int] traces_retention_days: Traces retention days. Default: 30
        """
        if default_alert_emails is not None:
            pulumi.set(__self__, "default_alert_emails", default_alert_emails)
        if logs_retention_days is not None:
            pulumi.set(__self__, "logs_retention_days", logs_retention_days)
        if metrics_retention_days is not None:
            pulumi.set(__self__, "metrics_retention_days", metrics_retention_days)
        if traces_retention_days is not None:
            pulumi.set(__self__, "traces_retention_days", traces_retention_days)

    @_builtins.property
    @pulumi.getter(name="defaultAlertEmails")
    def default_alert_emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        These emails are configured as alert recipients in Grafana when the 'grafana-default-email' contact delivery type is 'Email'.
        """
        return pulumi.get(self, "default_alert_emails")

    @default_alert_emails.setter
    def default_alert_emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "default_alert_emails", value)

    @_builtins.property
    @pulumi.getter(name="logsRetentionDays")
    def logs_retention_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Log retention days. Default: 30
        """
        return pulumi.get(self, "logs_retention_days")

    @logs_retention_days.setter
    def logs_retention_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "logs_retention_days", value)

    @_builtins.property
    @pulumi.getter(name="metricsRetentionDays")
    def metrics_retention_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Metrics retention days. Default: 30
        """
        return pulumi.get(self, "metrics_retention_days")

    @metrics_retention_days.setter
    def metrics_retention_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "metrics_retention_days", value)

    @_builtins.property
    @pulumi.getter(name="tracesRetentionDays")
    def traces_retention_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Traces retention days. Default: 30
        """
        return pulumi.get(self, "traces_retention_days")

    @traces_retention_days.setter
    def traces_retention_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "traces_retention_days", value)


if not MYPY:
    class OrgSecurityArgsDict(TypedDict):
        threat_detection: NotRequired[pulumi.Input['OrgSecurityThreatDetectionArgsDict']]
elif False:
    OrgSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgSecurityArgs:
    def __init__(__self__, *,
                 threat_detection: Optional[pulumi.Input['OrgSecurityThreatDetectionArgs']] = None):
        if threat_detection is not None:
            pulumi.set(__self__, "threat_detection", threat_detection)

    @_builtins.property
    @pulumi.getter(name="threatDetection")
    def threat_detection(self) -> Optional[pulumi.Input['OrgSecurityThreatDetectionArgs']]:
        return pulumi.get(self, "threat_detection")

    @threat_detection.setter
    def threat_detection(self, value: Optional[pulumi.Input['OrgSecurityThreatDetectionArgs']]):
        pulumi.set(self, "threat_detection", value)


if not MYPY:
    class OrgSecurityThreatDetectionArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Indicates whether threat detection should be forwarded or not.
        """
        minimum_severity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        """
        syslog: NotRequired[pulumi.Input['OrgSecurityThreatDetectionSyslogArgsDict']]
        """
        Configuration for syslog forwarding.
        """
elif False:
    OrgSecurityThreatDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgSecurityThreatDetectionArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 minimum_severity: Optional[pulumi.Input[_builtins.str]] = None,
                 syslog: Optional[pulumi.Input['OrgSecurityThreatDetectionSyslogArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether threat detection should be forwarded or not.
        :param pulumi.Input[_builtins.str] minimum_severity: Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        :param pulumi.Input['OrgSecurityThreatDetectionSyslogArgs'] syslog: Configuration for syslog forwarding.
        """
        pulumi.set(__self__, "enabled", enabled)
        if minimum_severity is not None:
            pulumi.set(__self__, "minimum_severity", minimum_severity)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Indicates whether threat detection should be forwarded or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="minimumSeverity")
    def minimum_severity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        """
        return pulumi.get(self, "minimum_severity")

    @minimum_severity.setter
    def minimum_severity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "minimum_severity", value)

    @_builtins.property
    @pulumi.getter
    def syslog(self) -> Optional[pulumi.Input['OrgSecurityThreatDetectionSyslogArgs']]:
        """
        Configuration for syslog forwarding.
        """
        return pulumi.get(self, "syslog")

    @syslog.setter
    def syslog(self, value: Optional[pulumi.Input['OrgSecurityThreatDetectionSyslogArgs']]):
        pulumi.set(self, "syslog", value)


if not MYPY:
    class OrgSecurityThreatDetectionSyslogArgsDict(TypedDict):
        host: pulumi.Input[_builtins.str]
        """
        The hostname to send syslog messages to.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port to send syslog messages to.
        """
        transport: NotRequired[pulumi.Input[_builtins.str]]
        """
        The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
elif False:
    OrgSecurityThreatDetectionSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgSecurityThreatDetectionSyslogArgs:
    def __init__(__self__, *,
                 host: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 transport: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] host: The hostname to send syslog messages to.
        :param pulumi.Input[_builtins.int] port: The port to send syslog messages to.
        :param pulumi.Input[_builtins.str] transport: The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname to send syslog messages to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port to send syslog messages to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def transport(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
        return pulumi.get(self, "transport")

    @transport.setter
    def transport(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "transport", value)


if not MYPY:
    class OrgStatusArgsDict(TypedDict):
        account_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        The link of the account the org belongs to.
        """
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the org is active or not.
        """
        endpoint_prefix: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    OrgStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgStatusArgs:
    def __init__(__self__, *,
                 account_link: Optional[pulumi.Input[_builtins.str]] = None,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpoint_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] account_link: The link of the account the org belongs to.
        :param pulumi.Input[_builtins.bool] active: Indicates whether the org is active or not.
        """
        if account_link is not None:
            pulumi.set(__self__, "account_link", account_link)
        if active is not None:
            pulumi.set(__self__, "active", active)
        if endpoint_prefix is not None:
            pulumi.set(__self__, "endpoint_prefix", endpoint_prefix)

    @_builtins.property
    @pulumi.getter(name="accountLink")
    def account_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The link of the account the org belongs to.
        """
        return pulumi.get(self, "account_link")

    @account_link.setter
    def account_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "account_link", value)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the org is active or not.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter(name="endpointPrefix")
    def endpoint_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "endpoint_prefix")

    @endpoint_prefix.setter
    def endpoint_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint_prefix", value)


if not MYPY:
    class OrgTracingControlplaneTracingArgsDict(TypedDict):
        sampling: pulumi.Input[_builtins.float]
        """
        Determines what percentage of requests should be traced.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of custom tags.
        """
elif False:
    OrgTracingControlplaneTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgTracingControlplaneTracingArgs:
    def __init__(__self__, *,
                 sampling: pulumi.Input[_builtins.float],
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.float] sampling: Determines what percentage of requests should be traced.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> pulumi.Input[_builtins.float]:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class OrgTracingLightstepTracingArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        sampling: pulumi.Input[_builtins.float]
        """
        Determines what percentage of requests should be traced.
        """
        credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        Full link to referenced Opaque Secret.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of custom tags.
        """
elif False:
    OrgTracingLightstepTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgTracingLightstepTracingArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 sampling: pulumi.Input[_builtins.float],
                 credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param pulumi.Input[_builtins.float] sampling: Determines what percentage of requests should be traced.
        :param pulumi.Input[_builtins.str] credentials: Full link to referenced Opaque Secret.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> pulumi.Input[_builtins.float]:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class OrgTracingOtelTracingArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        sampling: pulumi.Input[_builtins.float]
        """
        Determines what percentage of requests should be traced.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of custom tags.
        """
elif False:
    OrgTracingOtelTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrgTracingOtelTracingArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str],
                 sampling: pulumi.Input[_builtins.float],
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param pulumi.Input[_builtins.float] sampling: Determines what percentage of requests should be traced.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> pulumi.Input[_builtins.float]:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class PolicyBindingArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of permissions to allow.
        """
        principal_links: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of the principals this binding will be applied to. Principal links format: `group/GROUP_NAME`, `user/USER_EMAIL`, `gvc/GVC_NAME/identity/IDENTITY_NAME`, `serviceaccount/SERVICE_ACCOUNT_NAME`.
        """
elif False:
    PolicyBindingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyBindingArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 principal_links: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] permissions: List of permissions to allow.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] principal_links: List of the principals this binding will be applied to. Principal links format: `group/GROUP_NAME`, `user/USER_EMAIL`, `gvc/GVC_NAME/identity/IDENTITY_NAME`, `serviceaccount/SERVICE_ACCOUNT_NAME`.
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "principal_links", principal_links)

    @_builtins.property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of permissions to allow.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "permissions", value)

    @_builtins.property
    @pulumi.getter(name="principalLinks")
    def principal_links(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of the principals this binding will be applied to. Principal links format: `group/GROUP_NAME`, `user/USER_EMAIL`, `gvc/GVC_NAME/identity/IDENTITY_NAME`, `serviceaccount/SERVICE_ACCOUNT_NAME`.
        """
        return pulumi.get(self, "principal_links")

    @principal_links.setter
    def principal_links(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "principal_links", value)


if not MYPY:
    class PolicyTargetQueryArgsDict(TypedDict):
        fetch: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        spec: NotRequired[pulumi.Input['PolicyTargetQuerySpecArgsDict']]
elif False:
    PolicyTargetQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyTargetQueryArgs:
    def __init__(__self__, *,
                 fetch: Optional[pulumi.Input[_builtins.str]] = None,
                 spec: Optional[pulumi.Input['PolicyTargetQuerySpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] fetch: Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        if fetch is not None:
            pulumi.set(__self__, "fetch", fetch)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def fetch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        return pulumi.get(self, "fetch")

    @fetch.setter
    def fetch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fetch", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['PolicyTargetQuerySpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['PolicyTargetQuerySpecArgs']]):
        pulumi.set(self, "spec", value)


if not MYPY:
    class PolicyTargetQuerySpecArgsDict(TypedDict):
        match: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        terms: NotRequired[pulumi.Input[Sequence[pulumi.Input['PolicyTargetQuerySpecTermArgsDict']]]]
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
elif False:
    PolicyTargetQuerySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyTargetQuerySpecArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[_builtins.str]] = None,
                 terms: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyTargetQuerySpecTermArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] match: Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        :param pulumi.Input[Sequence[pulumi.Input['PolicyTargetQuerySpecTermArgs']]] terms: Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def terms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PolicyTargetQuerySpecTermArgs']]]]:
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        return pulumi.get(self, "terms")

    @terms.setter
    def terms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PolicyTargetQuerySpecTermArgs']]]]):
        pulumi.set(self, "terms", value)


if not MYPY:
    class PolicyTargetQuerySpecTermArgsDict(TypedDict):
        op: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        property: NotRequired[pulumi.Input[_builtins.str]]
        """
        Property to use for query evaluation.
        """
        rel: NotRequired[pulumi.Input[_builtins.str]]
        """
        Relation to use for query evaluation.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        Tag key to use for query evaluation.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Testing value for query evaluation.
        """
elif False:
    PolicyTargetQuerySpecTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyTargetQuerySpecTermArgs:
    def __init__(__self__, *,
                 op: Optional[pulumi.Input[_builtins.str]] = None,
                 property: Optional[pulumi.Input[_builtins.str]] = None,
                 rel: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] op: Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        :param pulumi.Input[_builtins.str] property: Property to use for query evaluation.
        :param pulumi.Input[_builtins.str] rel: Relation to use for query evaluation.
        :param pulumi.Input[_builtins.str] tag: Tag key to use for query evaluation.
        :param pulumi.Input[_builtins.str] value: Testing value for query evaluation.
        """
        if op is not None:
            pulumi.set(__self__, "op", op)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Property to use for query evaluation.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Relation to use for query evaluation.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rel", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Tag key to use for query evaluation.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Testing value for query evaluation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecretAwsArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Access Key provided by AWS.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        Secret Key provided by AWS.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS IAM Role External ID.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role ARN provided by AWS.
        """
elif False:
    SecretAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretAwsArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 secret_key: pulumi.Input[_builtins.str],
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Access Key provided by AWS.
        :param pulumi.Input[_builtins.str] secret_key: Secret Key provided by AWS.
        :param pulumi.Input[_builtins.str] external_id: AWS IAM Role External ID.
        :param pulumi.Input[_builtins.str] role_arn: Role ARN provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS IAM Role External ID.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class SecretAzureConnectorArgsDict(TypedDict):
        code: pulumi.Input[_builtins.str]
        """
        Code/Key to authenticate to deployment URL.
        """
        url: pulumi.Input[_builtins.str]
        """
        Deployment URL.
        """
elif False:
    SecretAzureConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretAzureConnectorArgs:
    def __init__(__self__, *,
                 code: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] code: Code/Key to authenticate to deployment URL.
        :param pulumi.Input[_builtins.str] url: Deployment URL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def code(self) -> pulumi.Input[_builtins.str]:
        """
        Code/Key to authenticate to deployment URL.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        Deployment URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class SecretEcrArgsDict(TypedDict):
        access_key: pulumi.Input[_builtins.str]
        """
        Access Key provided by AWS.
        """
        repos: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of ECR repositories.
        """
        secret_key: pulumi.Input[_builtins.str]
        """
        Secret Key provided by AWS.
        """
        external_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role ARN provided by AWS.
        """
elif False:
    SecretEcrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretEcrArgs:
    def __init__(__self__, *,
                 access_key: pulumi.Input[_builtins.str],
                 repos: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 secret_key: pulumi.Input[_builtins.str],
                 external_id: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_key: Access Key provided by AWS.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] repos: List of ECR repositories.
        :param pulumi.Input[_builtins.str] secret_key: Secret Key provided by AWS.
        :param pulumi.Input[_builtins.str] external_id: AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        :param pulumi.Input[_builtins.str] role_arn: Role ARN provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "repos", repos)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> pulumi.Input[_builtins.str]:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def repos(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of ECR repositories.
        """
        return pulumi.get(self, "repos")

    @repos.setter
    def repos(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "repos", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class SecretKeypairArgsDict(TypedDict):
        secret_key: pulumi.Input[_builtins.str]
        """
        Secret/Private Key.
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Passphrase for private key.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Public Key.
        """
elif False:
    SecretKeypairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretKeypairArgs:
    def __init__(__self__, *,
                 secret_key: pulumi.Input[_builtins.str],
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_key: Secret/Private Key.
        :param pulumi.Input[_builtins.str] passphrase: Passphrase for private key.
        :param pulumi.Input[_builtins.str] public_key: Public Key.
        """
        pulumi.set(__self__, "secret_key", secret_key)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> pulumi.Input[_builtins.str]:
        """
        Secret/Private Key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Passphrase for private key.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)


if not MYPY:
    class SecretNatsAccountArgsDict(TypedDict):
        account_id: pulumi.Input[_builtins.str]
        """
        Account ID.
        """
        private_key: pulumi.Input[_builtins.str]
        """
        Private Key.
        """
elif False:
    SecretNatsAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretNatsAccountArgs:
    def __init__(__self__, *,
                 account_id: pulumi.Input[_builtins.str],
                 private_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account_id: Account ID.
        :param pulumi.Input[_builtins.str] private_key: Private Key.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "private_key", private_key)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> pulumi.Input[_builtins.str]:
        """
        Account ID.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        Private Key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class SecretOpaqueArgsDict(TypedDict):
        payload: pulumi.Input[_builtins.str]
        """
        Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
        encoding: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
elif False:
    SecretOpaqueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretOpaqueArgs:
    def __init__(__self__, *,
                 payload: pulumi.Input[_builtins.str],
                 encoding: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] payload: Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        :param pulumi.Input[_builtins.str] encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        """
        pulumi.set(__self__, "payload", payload)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> pulumi.Input[_builtins.str]:
        """
        Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encoding", value)


if not MYPY:
    class SecretTlsArgsDict(TypedDict):
        cert: pulumi.Input[_builtins.str]
        """
        Public Certificate.
        """
        key: pulumi.Input[_builtins.str]
        """
        Private Certificate.
        """
        chain: NotRequired[pulumi.Input[_builtins.str]]
        """
        Chain Certificate.
        """
elif False:
    SecretTlsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretTlsArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 chain: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert: Public Certificate.
        :param pulumi.Input[_builtins.str] key: Private Certificate.
        :param pulumi.Input[_builtins.str] chain: Chain Certificate.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)
        if chain is not None:
            pulumi.set(__self__, "chain", chain)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> pulumi.Input[_builtins.str]:
        """
        Public Certificate.
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Private Certificate.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def chain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Chain Certificate.
        """
        return pulumi.get(self, "chain")

    @chain.setter
    def chain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "chain", value)


if not MYPY:
    class SecretUserpassArgsDict(TypedDict):
        password: pulumi.Input[_builtins.str]
        """
        Password.
        """
        username: pulumi.Input[_builtins.str]
        """
        Username.
        """
        encoding: NotRequired[pulumi.Input[_builtins.str]]
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
elif False:
    SecretUserpassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecretUserpassArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[_builtins.str],
                 username: pulumi.Input[_builtins.str],
                 encoding: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password.
        :param pulumi.Input[_builtins.str] username: Username.
        :param pulumi.Input[_builtins.str] encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encoding", value)


if not MYPY:
    class VolumeSetAutoscalingArgsDict(TypedDict):
        max_capacity: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum size in GB for a volume in this set. A volume cannot grow to be bigger than this value. Minimum value: `10`.
        """
        min_free_percentage: NotRequired[pulumi.Input[_builtins.int]]
        """
        The guaranteed free space on the volume as a percentage of the volume's total size. Control Plane will try to maintain at least that many percent free by scaling up the total size. Minimum percentage: `1`. Maximum Percentage: `100`.
        """
        scaling_factor: NotRequired[pulumi.Input[_builtins.float]]
        """
        When scaling is necessary, then `new_capacity = current_capacity * storageScalingFactor`. Minimum value: `1.1`.
        """
elif False:
    VolumeSetAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetAutoscalingArgs:
    def __init__(__self__, *,
                 max_capacity: Optional[pulumi.Input[_builtins.int]] = None,
                 min_free_percentage: Optional[pulumi.Input[_builtins.int]] = None,
                 scaling_factor: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_capacity: The maximum size in GB for a volume in this set. A volume cannot grow to be bigger than this value. Minimum value: `10`.
        :param pulumi.Input[_builtins.int] min_free_percentage: The guaranteed free space on the volume as a percentage of the volume's total size. Control Plane will try to maintain at least that many percent free by scaling up the total size. Minimum percentage: `1`. Maximum Percentage: `100`.
        :param pulumi.Input[_builtins.float] scaling_factor: When scaling is necessary, then `new_capacity = current_capacity * storageScalingFactor`. Minimum value: `1.1`.
        """
        if max_capacity is not None:
            pulumi.set(__self__, "max_capacity", max_capacity)
        if min_free_percentage is not None:
            pulumi.set(__self__, "min_free_percentage", min_free_percentage)
        if scaling_factor is not None:
            pulumi.set(__self__, "scaling_factor", scaling_factor)

    @_builtins.property
    @pulumi.getter(name="maxCapacity")
    def max_capacity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum size in GB for a volume in this set. A volume cannot grow to be bigger than this value. Minimum value: `10`.
        """
        return pulumi.get(self, "max_capacity")

    @max_capacity.setter
    def max_capacity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_capacity", value)

    @_builtins.property
    @pulumi.getter(name="minFreePercentage")
    def min_free_percentage(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The guaranteed free space on the volume as a percentage of the volume's total size. Control Plane will try to maintain at least that many percent free by scaling up the total size. Minimum percentage: `1`. Maximum Percentage: `100`.
        """
        return pulumi.get(self, "min_free_percentage")

    @min_free_percentage.setter
    def min_free_percentage(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_free_percentage", value)

    @_builtins.property
    @pulumi.getter(name="scalingFactor")
    def scaling_factor(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        When scaling is necessary, then `new_capacity = current_capacity * storageScalingFactor`. Minimum value: `1.1`.
        """
        return pulumi.get(self, "scaling_factor")

    @scaling_factor.setter
    def scaling_factor(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scaling_factor", value)


if not MYPY:
    class VolumeSetCustomEncryptionArgsDict(TypedDict):
        regions: pulumi.Input[Mapping[str, pulumi.Input['VolumeSetCustomEncryptionRegionsArgsDict']]]
        """
        Map of region identifiers to encryption key configuration.
        """
elif False:
    VolumeSetCustomEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetCustomEncryptionArgs:
    def __init__(__self__, *,
                 regions: pulumi.Input[Mapping[str, pulumi.Input['VolumeSetCustomEncryptionRegionsArgs']]]):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input['VolumeSetCustomEncryptionRegionsArgs']]] regions: Map of region identifiers to encryption key configuration.
        """
        pulumi.set(__self__, "regions", regions)

    @_builtins.property
    @pulumi.getter
    def regions(self) -> pulumi.Input[Mapping[str, pulumi.Input['VolumeSetCustomEncryptionRegionsArgs']]]:
        """
        Map of region identifiers to encryption key configuration.
        """
        return pulumi.get(self, "regions")

    @regions.setter
    def regions(self, value: pulumi.Input[Mapping[str, pulumi.Input['VolumeSetCustomEncryptionRegionsArgs']]]):
        pulumi.set(self, "regions", value)


if not MYPY:
    class VolumeSetCustomEncryptionRegionsArgsDict(TypedDict):
        key_id: pulumi.Input[_builtins.str]
elif False:
    VolumeSetCustomEncryptionRegionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetCustomEncryptionRegionsArgs:
    def __init__(__self__, *,
                 key_id: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "key_id", key_id)

    @_builtins.property
    @pulumi.getter(name="keyId")
    def key_id(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "key_id")

    @key_id.setter
    def key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_id", value)


if not MYPY:
    class VolumeSetMountOptionsArgsDict(TypedDict):
        resources: NotRequired[pulumi.Input['VolumeSetMountOptionsResourcesArgsDict']]
        """
        For volume sets using the shared file system, this object specifies the CPU and memory resources allotted to each mount point.
        """
elif False:
    VolumeSetMountOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetMountOptionsArgs:
    def __init__(__self__, *,
                 resources: Optional[pulumi.Input['VolumeSetMountOptionsResourcesArgs']] = None):
        """
        :param pulumi.Input['VolumeSetMountOptionsResourcesArgs'] resources: For volume sets using the shared file system, this object specifies the CPU and memory resources allotted to each mount point.
        """
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input['VolumeSetMountOptionsResourcesArgs']]:
        """
        For volume sets using the shared file system, this object specifies the CPU and memory resources allotted to each mount point.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input['VolumeSetMountOptionsResourcesArgs']]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class VolumeSetMountOptionsResourcesArgsDict(TypedDict):
        max_cpu: NotRequired[pulumi.Input[_builtins.str]]
        max_memory: NotRequired[pulumi.Input[_builtins.str]]
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VolumeSetMountOptionsResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetMountOptionsResourcesArgs:
    def __init__(__self__, *,
                 max_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 max_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None):
        if max_cpu is not None:
            pulumi.set(__self__, "max_cpu", max_cpu)
        if max_memory is not None:
            pulumi.set(__self__, "max_memory", max_memory)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)

    @_builtins.property
    @pulumi.getter(name="maxCpu")
    def max_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "max_cpu")

    @max_cpu.setter
    def max_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_cpu", value)

    @_builtins.property
    @pulumi.getter(name="maxMemory")
    def max_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "max_memory")

    @max_memory.setter
    def max_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)


if not MYPY:
    class VolumeSetSnapshotsArgsDict(TypedDict):
        create_final_snapshot: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, a volume snapshot will be created immediately before deletion of any volume in this set. Default: `true`
        """
        retention_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default retention period for volume snapshots. This string should contain a floating point number followed by either d, h, or m. For example, "10d" would retain snapshots for 10 days.
        """
        schedule: NotRequired[pulumi.Input[_builtins.str]]
        """
        A standard cron schedule expression used to determine when a snapshot will be taken. (i.e., `0 * * * *` Every hour). Note: snapshots cannot be scheduled more often than once per hour.
        """
elif False:
    VolumeSetSnapshotsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetSnapshotsArgs:
    def __init__(__self__, *,
                 create_final_snapshot: Optional[pulumi.Input[_builtins.bool]] = None,
                 retention_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] create_final_snapshot: If true, a volume snapshot will be created immediately before deletion of any volume in this set. Default: `true`
        :param pulumi.Input[_builtins.str] retention_duration: The default retention period for volume snapshots. This string should contain a floating point number followed by either d, h, or m. For example, "10d" would retain snapshots for 10 days.
        :param pulumi.Input[_builtins.str] schedule: A standard cron schedule expression used to determine when a snapshot will be taken. (i.e., `0 * * * *` Every hour). Note: snapshots cannot be scheduled more often than once per hour.
        """
        if create_final_snapshot is not None:
            pulumi.set(__self__, "create_final_snapshot", create_final_snapshot)
        if retention_duration is not None:
            pulumi.set(__self__, "retention_duration", retention_duration)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter(name="createFinalSnapshot")
    def create_final_snapshot(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, a volume snapshot will be created immediately before deletion of any volume in this set. Default: `true`
        """
        return pulumi.get(self, "create_final_snapshot")

    @create_final_snapshot.setter
    def create_final_snapshot(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create_final_snapshot", value)

    @_builtins.property
    @pulumi.getter(name="retentionDuration")
    def retention_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default retention period for volume snapshots. This string should contain a floating point number followed by either d, h, or m. For example, "10d" would retain snapshots for 10 days.
        """
        return pulumi.get(self, "retention_duration")

    @retention_duration.setter
    def retention_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retention_duration", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A standard cron schedule expression used to determine when a snapshot will be taken. (i.e., `0 * * * *` Every hour). Note: snapshots cannot be scheduled more often than once per hour.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class VolumeSetStatusArgsDict(TypedDict):
        binding_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Uniquely identifies the connection between the volume set and its workload. Every time a new connection is made, a new id is generated (e.g., If a workload is updated to remove the volume set, then updated again to reattach it, the volume set will have a new binding id).
        """
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Contains a list of actual volumes grouped by location.
        """
        parent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The GVC ID.
        """
        used_by_workload: NotRequired[pulumi.Input[_builtins.str]]
        """
        The url of the workload currently using this volume set (if any).
        """
        workload_links: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Contains a list of workload links that are using this volume set.
        """
elif False:
    VolumeSetStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VolumeSetStatusArgs:
    def __init__(__self__, *,
                 binding_id: Optional[pulumi.Input[_builtins.str]] = None,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 parent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 used_by_workload: Optional[pulumi.Input[_builtins.str]] = None,
                 workload_links: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] binding_id: Uniquely identifies the connection between the volume set and its workload. Every time a new connection is made, a new id is generated (e.g., If a workload is updated to remove the volume set, then updated again to reattach it, the volume set will have a new binding id).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: Contains a list of actual volumes grouped by location.
        :param pulumi.Input[_builtins.str] parent_id: The GVC ID.
        :param pulumi.Input[_builtins.str] used_by_workload: The url of the workload currently using this volume set (if any).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] workload_links: Contains a list of workload links that are using this volume set.
        """
        if binding_id is not None:
            pulumi.set(__self__, "binding_id", binding_id)
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)
        if used_by_workload is not None:
            pulumi.set(__self__, "used_by_workload", used_by_workload)
        if workload_links is not None:
            pulumi.set(__self__, "workload_links", workload_links)

    @_builtins.property
    @pulumi.getter(name="bindingId")
    def binding_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Uniquely identifies the connection between the volume set and its workload. Every time a new connection is made, a new id is generated (e.g., If a workload is updated to remove the volume set, then updated again to reattach it, the volume set will have a new binding id).
        """
        return pulumi.get(self, "binding_id")

    @binding_id.setter
    def binding_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "binding_id", value)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Contains a list of actual volumes grouped by location.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The GVC ID.
        """
        return pulumi.get(self, "parent_id")

    @parent_id.setter
    def parent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_id", value)

    @_builtins.property
    @pulumi.getter(name="usedByWorkload")
    def used_by_workload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The url of the workload currently using this volume set (if any).
        """
        return pulumi.get(self, "used_by_workload")

    @used_by_workload.setter
    def used_by_workload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "used_by_workload", value)

    @_builtins.property
    @pulumi.getter(name="workloadLinks")
    def workload_links(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Contains a list of workload links that are using this volume set.
        """
        return pulumi.get(self, "workload_links")

    @workload_links.setter
    def workload_links(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "workload_links", value)


if not MYPY:
    class WorkloadContainerArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        The full image and tag path.
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the container.
        """
        args: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Command line arguments passed to the container at runtime. Replaces the CMD arguments of the running container. It is an ordered list.
        """
        command: NotRequired[pulumi.Input[_builtins.str]]
        """
        Override the entry point.
        """
        cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        """
        env: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Name-Value list of environment variables.
        """
        gpu_custom: NotRequired[pulumi.Input['WorkloadContainerGpuCustomArgsDict']]
        gpu_nvidia: NotRequired[pulumi.Input['WorkloadContainerGpuNvidiaArgsDict']]
        """
        GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        """
        inherit_env: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        """
        lifecycle: NotRequired[pulumi.Input['WorkloadContainerLifecycleArgsDict']]
        """
        Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        """
        liveness_probe: NotRequired[pulumi.Input['WorkloadContainerLivenessProbeArgsDict']]
        """
        Liveness Probe
        """
        memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        """
        metrics: NotRequired[pulumi.Input['WorkloadContainerMetricsArgsDict']]
        """
        [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        """
        min_cpu: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum CPU when capacity AI is enabled.
        """
        min_memory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Minimum memory when capacity AI is enabled.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        """
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerPortArgsDict']]]]
        """
        Communication endpoints used by the workload to send and receive network traffic.
        """
        readiness_probe: NotRequired[pulumi.Input['WorkloadContainerReadinessProbeArgsDict']]
        """
        Readiness Probe
        """
        volumes: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerVolumeArgsDict']]]]
        """
        Mount Object Store (S3, GCS, AzureBlob) buckets as file system.
        """
        working_directory: NotRequired[pulumi.Input[_builtins.str]]
        """
        Override the working directory. Must be an absolute path.
        """
elif False:
    WorkloadContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 args: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 command: Optional[pulumi.Input[_builtins.str]] = None,
                 cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 env: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 gpu_custom: Optional[pulumi.Input['WorkloadContainerGpuCustomArgs']] = None,
                 gpu_nvidia: Optional[pulumi.Input['WorkloadContainerGpuNvidiaArgs']] = None,
                 inherit_env: Optional[pulumi.Input[_builtins.bool]] = None,
                 lifecycle: Optional[pulumi.Input['WorkloadContainerLifecycleArgs']] = None,
                 liveness_probe: Optional[pulumi.Input['WorkloadContainerLivenessProbeArgs']] = None,
                 memory: Optional[pulumi.Input[_builtins.str]] = None,
                 metrics: Optional[pulumi.Input['WorkloadContainerMetricsArgs']] = None,
                 min_cpu: Optional[pulumi.Input[_builtins.str]] = None,
                 min_memory: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerPortArgs']]]] = None,
                 readiness_probe: Optional[pulumi.Input['WorkloadContainerReadinessProbeArgs']] = None,
                 volumes: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerVolumeArgs']]]] = None,
                 working_directory: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] image: The full image and tag path.
        :param pulumi.Input[_builtins.str] name: Name of the container.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] args: Command line arguments passed to the container at runtime. Replaces the CMD arguments of the running container. It is an ordered list.
        :param pulumi.Input[_builtins.str] command: Override the entry point.
        :param pulumi.Input[_builtins.str] cpu: Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] env: Name-Value list of environment variables.
        :param pulumi.Input['WorkloadContainerGpuNvidiaArgs'] gpu_nvidia: GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        :param pulumi.Input[_builtins.bool] inherit_env: Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        :param pulumi.Input['WorkloadContainerLifecycleArgs'] lifecycle: Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        :param pulumi.Input['WorkloadContainerLivenessProbeArgs'] liveness_probe: Liveness Probe
        :param pulumi.Input[_builtins.str] memory: Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        :param pulumi.Input['WorkloadContainerMetricsArgs'] metrics: [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        :param pulumi.Input[_builtins.str] min_cpu: Minimum CPU when capacity AI is enabled.
        :param pulumi.Input[_builtins.str] min_memory: Minimum memory when capacity AI is enabled.
        :param pulumi.Input[_builtins.int] port: The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadContainerPortArgs']]] ports: Communication endpoints used by the workload to send and receive network traffic.
        :param pulumi.Input['WorkloadContainerReadinessProbeArgs'] readiness_probe: Readiness Probe
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadContainerVolumeArgs']]] volumes: Mount Object Store (S3, GCS, AzureBlob) buckets as file system.
        :param pulumi.Input[_builtins.str] working_directory: Override the working directory. Must be an absolute path.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "name", name)
        if args is not None:
            pulumi.set(__self__, "args", args)
        if command is not None:
            pulumi.set(__self__, "command", command)
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if gpu_custom is not None:
            pulumi.set(__self__, "gpu_custom", gpu_custom)
        if gpu_nvidia is not None:
            pulumi.set(__self__, "gpu_nvidia", gpu_nvidia)
        if inherit_env is not None:
            pulumi.set(__self__, "inherit_env", inherit_env)
        if lifecycle is not None:
            pulumi.set(__self__, "lifecycle", lifecycle)
        if liveness_probe is not None:
            pulumi.set(__self__, "liveness_probe", liveness_probe)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if min_cpu is not None:
            pulumi.set(__self__, "min_cpu", min_cpu)
        if min_memory is not None:
            pulumi.set(__self__, "min_memory", min_memory)
        if port is not None:
            warnings.warn("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""", DeprecationWarning)
            pulumi.log.warn("""port is deprecated: The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probe is not None:
            pulumi.set(__self__, "readiness_probe", readiness_probe)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)
        if working_directory is not None:
            pulumi.set(__self__, "working_directory", working_directory)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        The full image and tag path.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Command line arguments passed to the container at runtime. Replaces the CMD arguments of the running container. It is an ordered list.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Override the entry point.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def env(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Name-Value list of environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "env", value)

    @_builtins.property
    @pulumi.getter(name="gpuCustom")
    def gpu_custom(self) -> Optional[pulumi.Input['WorkloadContainerGpuCustomArgs']]:
        return pulumi.get(self, "gpu_custom")

    @gpu_custom.setter
    def gpu_custom(self, value: Optional[pulumi.Input['WorkloadContainerGpuCustomArgs']]):
        pulumi.set(self, "gpu_custom", value)

    @_builtins.property
    @pulumi.getter(name="gpuNvidia")
    def gpu_nvidia(self) -> Optional[pulumi.Input['WorkloadContainerGpuNvidiaArgs']]:
        """
        GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        """
        return pulumi.get(self, "gpu_nvidia")

    @gpu_nvidia.setter
    def gpu_nvidia(self, value: Optional[pulumi.Input['WorkloadContainerGpuNvidiaArgs']]):
        pulumi.set(self, "gpu_nvidia", value)

    @_builtins.property
    @pulumi.getter(name="inheritEnv")
    def inherit_env(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        """
        return pulumi.get(self, "inherit_env")

    @inherit_env.setter
    def inherit_env(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "inherit_env", value)

    @_builtins.property
    @pulumi.getter
    def lifecycle(self) -> Optional[pulumi.Input['WorkloadContainerLifecycleArgs']]:
        """
        Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        """
        return pulumi.get(self, "lifecycle")

    @lifecycle.setter
    def lifecycle(self, value: Optional[pulumi.Input['WorkloadContainerLifecycleArgs']]):
        pulumi.set(self, "lifecycle", value)

    @_builtins.property
    @pulumi.getter(name="livenessProbe")
    def liveness_probe(self) -> Optional[pulumi.Input['WorkloadContainerLivenessProbeArgs']]:
        """
        Liveness Probe
        """
        return pulumi.get(self, "liveness_probe")

    @liveness_probe.setter
    def liveness_probe(self, value: Optional[pulumi.Input['WorkloadContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probe", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[pulumi.Input['WorkloadContainerMetricsArgs']]:
        """
        [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[pulumi.Input['WorkloadContainerMetricsArgs']]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum CPU when capacity AI is enabled.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Minimum memory when capacity AI is enabled.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerPortArgs']]]]:
        """
        Communication endpoints used by the workload to send and receive network traffic.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerPortArgs']]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbe")
    def readiness_probe(self) -> Optional[pulumi.Input['WorkloadContainerReadinessProbeArgs']]:
        """
        Readiness Probe
        """
        return pulumi.get(self, "readiness_probe")

    @readiness_probe.setter
    def readiness_probe(self, value: Optional[pulumi.Input['WorkloadContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probe", value)

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerVolumeArgs']]]]:
        """
        Mount Object Store (S3, GCS, AzureBlob) buckets as file system.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadContainerVolumeArgs']]]]):
        pulumi.set(self, "volumes", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Override the working directory. Must be an absolute path.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "working_directory", value)


if not MYPY:
    class WorkloadContainerGpuCustomArgsDict(TypedDict):
        quantity: pulumi.Input[_builtins.int]
        """
        Number of GPUs.
        """
        resource: pulumi.Input[_builtins.str]
        runtime_class: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkloadContainerGpuCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerGpuCustomArgs:
    def __init__(__self__, *,
                 quantity: pulumi.Input[_builtins.int],
                 resource: pulumi.Input[_builtins.str],
                 runtime_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] quantity: Number of GPUs.
        """
        pulumi.set(__self__, "quantity", quantity)
        pulumi.set(__self__, "resource", resource)
        if runtime_class is not None:
            pulumi.set(__self__, "runtime_class", runtime_class)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> pulumi.Input[_builtins.int]:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "quantity", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter(name="runtimeClass")
    def runtime_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "runtime_class")

    @runtime_class.setter
    def runtime_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_class", value)


if not MYPY:
    class WorkloadContainerGpuNvidiaArgsDict(TypedDict):
        model: pulumi.Input[_builtins.str]
        """
        GPU Model (i.e.: t4)
        """
        quantity: pulumi.Input[_builtins.int]
        """
        Number of GPUs.
        """
elif False:
    WorkloadContainerGpuNvidiaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerGpuNvidiaArgs:
    def __init__(__self__, *,
                 model: pulumi.Input[_builtins.str],
                 quantity: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] model: GPU Model (i.e.: t4)
        :param pulumi.Input[_builtins.int] quantity: Number of GPUs.
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def model(self) -> pulumi.Input[_builtins.str]:
        """
        GPU Model (i.e.: t4)
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> pulumi.Input[_builtins.int]:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "quantity", value)


if not MYPY:
    class WorkloadContainerLifecycleArgsDict(TypedDict):
        post_start: NotRequired[pulumi.Input['WorkloadContainerLifecyclePostStartArgsDict']]
        pre_stop: NotRequired[pulumi.Input['WorkloadContainerLifecyclePreStopArgsDict']]
elif False:
    WorkloadContainerLifecycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLifecycleArgs:
    def __init__(__self__, *,
                 post_start: Optional[pulumi.Input['WorkloadContainerLifecyclePostStartArgs']] = None,
                 pre_stop: Optional[pulumi.Input['WorkloadContainerLifecyclePreStopArgs']] = None):
        if post_start is not None:
            pulumi.set(__self__, "post_start", post_start)
        if pre_stop is not None:
            pulumi.set(__self__, "pre_stop", pre_stop)

    @_builtins.property
    @pulumi.getter(name="postStart")
    def post_start(self) -> Optional[pulumi.Input['WorkloadContainerLifecyclePostStartArgs']]:
        return pulumi.get(self, "post_start")

    @post_start.setter
    def post_start(self, value: Optional[pulumi.Input['WorkloadContainerLifecyclePostStartArgs']]):
        pulumi.set(self, "post_start", value)

    @_builtins.property
    @pulumi.getter(name="preStop")
    def pre_stop(self) -> Optional[pulumi.Input['WorkloadContainerLifecyclePreStopArgs']]:
        return pulumi.get(self, "pre_stop")

    @pre_stop.setter
    def pre_stop(self, value: Optional[pulumi.Input['WorkloadContainerLifecyclePreStopArgs']]):
        pulumi.set(self, "pre_stop", value)


if not MYPY:
    class WorkloadContainerLifecyclePostStartArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['WorkloadContainerLifecyclePostStartExecArgsDict']]
elif False:
    WorkloadContainerLifecyclePostStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLifecyclePostStartArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['WorkloadContainerLifecyclePostStartExecArgs']] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['WorkloadContainerLifecyclePostStartExecArgs']]:
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['WorkloadContainerLifecyclePostStartExecArgs']]):
        pulumi.set(self, "exec_", value)


if not MYPY:
    class WorkloadContainerLifecyclePostStartExecArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Command and arguments executed immediately after the container is created.
        """
elif False:
    WorkloadContainerLifecyclePostStartExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLifecyclePostStartExecArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Command and arguments executed immediately after the container is created.
        """
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Command and arguments executed immediately after the container is created.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class WorkloadContainerLifecyclePreStopArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['WorkloadContainerLifecyclePreStopExecArgsDict']]
elif False:
    WorkloadContainerLifecyclePreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLifecyclePreStopArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['WorkloadContainerLifecyclePreStopExecArgs']] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['WorkloadContainerLifecyclePreStopExecArgs']]:
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['WorkloadContainerLifecyclePreStopExecArgs']]):
        pulumi.set(self, "exec_", value)


if not MYPY:
    class WorkloadContainerLifecyclePreStopExecArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Command and arguments executed immediately before the container is stopped.
        """
elif False:
    WorkloadContainerLifecyclePreStopExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLifecyclePreStopExecArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] commands: Command and arguments executed immediately before the container is stopped.
        """
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Command and arguments executed immediately before the container is stopped.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class WorkloadContainerLivenessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['WorkloadContainerLivenessProbeExecArgsDict']]
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        grpc: NotRequired[pulumi.Input['WorkloadContainerLivenessProbeGrpcArgsDict']]
        http_get: NotRequired[pulumi.Input['WorkloadContainerLivenessProbeHttpGetArgsDict']]
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        tcp_socket: NotRequired[pulumi.Input['WorkloadContainerLivenessProbeTcpSocketArgsDict']]
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WorkloadContainerLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['WorkloadContainerLivenessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 grpc: Optional[pulumi.Input['WorkloadContainerLivenessProbeGrpcArgs']] = None,
                 http_get: Optional[pulumi.Input['WorkloadContainerLivenessProbeHttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 tcp_socket: Optional[pulumi.Input['WorkloadContainerLivenessProbeTcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['WorkloadContainerLivenessProbeExecArgs']]:
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['WorkloadContainerLivenessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter
    def grpc(self) -> Optional[pulumi.Input['WorkloadContainerLivenessProbeGrpcArgs']]:
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: Optional[pulumi.Input['WorkloadContainerLivenessProbeGrpcArgs']]):
        pulumi.set(self, "grpc", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['WorkloadContainerLivenessProbeHttpGetArgs']]:
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['WorkloadContainerLivenessProbeHttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['WorkloadContainerLivenessProbeTcpSocketArgs']]:
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['WorkloadContainerLivenessProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadContainerLivenessProbeExecArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WorkloadContainerLivenessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLivenessProbeExecArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class WorkloadContainerLivenessProbeGrpcArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WorkloadContainerLivenessProbeGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLivenessProbeGrpcArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WorkloadContainerLivenessProbeHttpGetArgsDict(TypedDict):
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        path: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
        scheme: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkloadContainerLivenessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class WorkloadContainerLivenessProbeTcpSocketArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WorkloadContainerLivenessProbeTcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerLivenessProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WorkloadContainerMetricsArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Path from container emitting custom metrics.
        """
        port: pulumi.Input[_builtins.int]
        """
        Port from container emitting custom metrics.
        """
        drop_metrics: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Drop metrics that match given patterns.
        """
elif False:
    WorkloadContainerMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerMetricsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 drop_metrics: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] path: Path from container emitting custom metrics.
        :param pulumi.Input[_builtins.int] port: Port from container emitting custom metrics.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] drop_metrics: Drop metrics that match given patterns.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        if drop_metrics is not None:
            pulumi.set(__self__, "drop_metrics", drop_metrics)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Path from container emitting custom metrics.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        Port from container emitting custom metrics.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="dropMetrics")
    def drop_metrics(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Drop metrics that match given patterns.
        """
        return pulumi.get(self, "drop_metrics")

    @drop_metrics.setter
    def drop_metrics(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "drop_metrics", value)


if not MYPY:
    class WorkloadContainerPortArgsDict(TypedDict):
        number: pulumi.Input[_builtins.int]
        """
        Port to expose.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
elif False:
    WorkloadContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerPortArgs:
    def __init__(__self__, *,
                 number: pulumi.Input[_builtins.int],
                 protocol: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] number: Port to expose.
        :param pulumi.Input[_builtins.str] protocol: Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
        pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.int]:
        """
        Port to expose.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class WorkloadContainerReadinessProbeArgsDict(TypedDict):
        exec_: NotRequired[pulumi.Input['WorkloadContainerReadinessProbeExecArgsDict']]
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        grpc: NotRequired[pulumi.Input['WorkloadContainerReadinessProbeGrpcArgsDict']]
        http_get: NotRequired[pulumi.Input['WorkloadContainerReadinessProbeHttpGetArgsDict']]
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        tcp_socket: NotRequired[pulumi.Input['WorkloadContainerReadinessProbeTcpSocketArgsDict']]
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WorkloadContainerReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 exec_: Optional[pulumi.Input['WorkloadContainerReadinessProbeExecArgs']] = None,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 grpc: Optional[pulumi.Input['WorkloadContainerReadinessProbeGrpcArgs']] = None,
                 http_get: Optional[pulumi.Input['WorkloadContainerReadinessProbeHttpGetArgs']] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 tcp_socket: Optional[pulumi.Input['WorkloadContainerReadinessProbeTcpSocketArgs']] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        if exec_ is not None:
            pulumi.set(__self__, "exec_", exec_)
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if grpc is not None:
            pulumi.set(__self__, "grpc", grpc)
        if http_get is not None:
            pulumi.set(__self__, "http_get", http_get)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if tcp_socket is not None:
            pulumi.set(__self__, "tcp_socket", tcp_socket)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="exec")
    def exec_(self) -> Optional[pulumi.Input['WorkloadContainerReadinessProbeExecArgs']]:
        return pulumi.get(self, "exec_")

    @exec_.setter
    def exec_(self, value: Optional[pulumi.Input['WorkloadContainerReadinessProbeExecArgs']]):
        pulumi.set(self, "exec_", value)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter
    def grpc(self) -> Optional[pulumi.Input['WorkloadContainerReadinessProbeGrpcArgs']]:
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: Optional[pulumi.Input['WorkloadContainerReadinessProbeGrpcArgs']]):
        pulumi.set(self, "grpc", value)

    @_builtins.property
    @pulumi.getter(name="httpGet")
    def http_get(self) -> Optional[pulumi.Input['WorkloadContainerReadinessProbeHttpGetArgs']]:
        return pulumi.get(self, "http_get")

    @http_get.setter
    def http_get(self, value: Optional[pulumi.Input['WorkloadContainerReadinessProbeHttpGetArgs']]):
        pulumi.set(self, "http_get", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="tcpSocket")
    def tcp_socket(self) -> Optional[pulumi.Input['WorkloadContainerReadinessProbeTcpSocketArgs']]:
        return pulumi.get(self, "tcp_socket")

    @tcp_socket.setter
    def tcp_socket(self, value: Optional[pulumi.Input['WorkloadContainerReadinessProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_socket", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadContainerReadinessProbeExecArgsDict(TypedDict):
        commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
elif False:
    WorkloadContainerReadinessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerReadinessProbeExecArgs:
    def __init__(__self__, *,
                 commands: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class WorkloadContainerReadinessProbeGrpcArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WorkloadContainerReadinessProbeGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerReadinessProbeGrpcArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WorkloadContainerReadinessProbeHttpGetArgsDict(TypedDict):
        http_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        path: NotRequired[pulumi.Input[_builtins.str]]
        port: NotRequired[pulumi.Input[_builtins.int]]
        scheme: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkloadContainerReadinessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 http_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        if http_headers is not None:
            pulumi.set(__self__, "http_headers", http_headers)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class WorkloadContainerReadinessProbeTcpSocketArgsDict(TypedDict):
        port: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    WorkloadContainerReadinessProbeTcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerReadinessProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: Optional[pulumi.Input[_builtins.int]] = None):
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class WorkloadContainerVolumeArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        File path added to workload pointing to the volume.
        """
        uri: pulumi.Input[_builtins.str]
        """
        URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        """
        recovery_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
elif False:
    WorkloadContainerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadContainerVolumeArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 uri: pulumi.Input[_builtins.str],
                 recovery_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] path: File path added to workload pointing to the volume.
        :param pulumi.Input[_builtins.str] uri: URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        :param pulumi.Input[_builtins.str] recovery_policy: Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "uri", uri)
        if recovery_policy is not None:
            pulumi.set(__self__, "recovery_policy", recovery_policy)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        File path added to workload pointing to the volume.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="recoveryPolicy")
    def recovery_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
        return pulumi.get(self, "recovery_policy")

    @recovery_policy.setter
    def recovery_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "recovery_policy", value)


if not MYPY:
    class WorkloadFirewallSpecArgsDict(TypedDict):
        external: NotRequired[pulumi.Input['WorkloadFirewallSpecExternalArgsDict']]
        """
        The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        """
        internal: NotRequired[pulumi.Input['WorkloadFirewallSpecInternalArgsDict']]
        """
        The internal firewall is used to control access between workloads.
        """
elif False:
    WorkloadFirewallSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadFirewallSpecArgs:
    def __init__(__self__, *,
                 external: Optional[pulumi.Input['WorkloadFirewallSpecExternalArgs']] = None,
                 internal: Optional[pulumi.Input['WorkloadFirewallSpecInternalArgs']] = None):
        """
        :param pulumi.Input['WorkloadFirewallSpecExternalArgs'] external: The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        :param pulumi.Input['WorkloadFirewallSpecInternalArgs'] internal: The internal firewall is used to control access between workloads.
        """
        if external is not None:
            pulumi.set(__self__, "external", external)
        if internal is not None:
            pulumi.set(__self__, "internal", internal)

    @_builtins.property
    @pulumi.getter
    def external(self) -> Optional[pulumi.Input['WorkloadFirewallSpecExternalArgs']]:
        """
        The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        """
        return pulumi.get(self, "external")

    @external.setter
    def external(self, value: Optional[pulumi.Input['WorkloadFirewallSpecExternalArgs']]):
        pulumi.set(self, "external", value)

    @_builtins.property
    @pulumi.getter
    def internal(self) -> Optional[pulumi.Input['WorkloadFirewallSpecInternalArgs']]:
        """
        The internal firewall is used to control access between workloads.
        """
        return pulumi.get(self, "internal")

    @internal.setter
    def internal(self, value: Optional[pulumi.Input['WorkloadFirewallSpecInternalArgs']]):
        pulumi.set(self, "internal", value)


if not MYPY:
    class WorkloadFirewallSpecExternalArgsDict(TypedDict):
        http: NotRequired[pulumi.Input['WorkloadFirewallSpecExternalHttpArgsDict']]
        """
        Firewall options for HTTP workloads.
        """
        inbound_allow_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        """
        inbound_blocked_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are NOT allowed to access this workload. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        outbound_allow_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        """
        outbound_allow_hostnames: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        """
        outbound_allow_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalOutboundAllowPortArgsDict']]]]
        """
        Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
        outbound_blocked_cidrs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is NOT allowed to reach. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
elif False:
    WorkloadFirewallSpecExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadFirewallSpecExternalArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['WorkloadFirewallSpecExternalHttpArgs']] = None,
                 inbound_allow_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 inbound_blocked_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 outbound_allow_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 outbound_allow_hostnames: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 outbound_allow_ports: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalOutboundAllowPortArgs']]]] = None,
                 outbound_blocked_cidrs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input['WorkloadFirewallSpecExternalHttpArgs'] http: Firewall options for HTTP workloads.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inbound_allow_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inbound_blocked_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that are NOT allowed to access this workload. Addresses in the allow list will only be allowed if they do not exist in this list.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] outbound_allow_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] outbound_allow_hostnames: The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalOutboundAllowPortArgs']]] outbound_allow_ports: Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] outbound_blocked_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that this workload is NOT allowed to reach. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if inbound_allow_cidrs is not None:
            pulumi.set(__self__, "inbound_allow_cidrs", inbound_allow_cidrs)
        if inbound_blocked_cidrs is not None:
            pulumi.set(__self__, "inbound_blocked_cidrs", inbound_blocked_cidrs)
        if outbound_allow_cidrs is not None:
            pulumi.set(__self__, "outbound_allow_cidrs", outbound_allow_cidrs)
        if outbound_allow_hostnames is not None:
            pulumi.set(__self__, "outbound_allow_hostnames", outbound_allow_hostnames)
        if outbound_allow_ports is not None:
            pulumi.set(__self__, "outbound_allow_ports", outbound_allow_ports)
        if outbound_blocked_cidrs is not None:
            pulumi.set(__self__, "outbound_blocked_cidrs", outbound_blocked_cidrs)

    @_builtins.property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['WorkloadFirewallSpecExternalHttpArgs']]:
        """
        Firewall options for HTTP workloads.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['WorkloadFirewallSpecExternalHttpArgs']]):
        pulumi.set(self, "http", value)

    @_builtins.property
    @pulumi.getter(name="inboundAllowCidrs")
    def inbound_allow_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        """
        return pulumi.get(self, "inbound_allow_cidrs")

    @inbound_allow_cidrs.setter
    def inbound_allow_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inbound_allow_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="inboundBlockedCidrs")
    def inbound_blocked_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are NOT allowed to access this workload. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        return pulumi.get(self, "inbound_blocked_cidrs")

    @inbound_blocked_cidrs.setter
    def inbound_blocked_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inbound_blocked_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="outboundAllowCidrs")
    def outbound_allow_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        """
        return pulumi.get(self, "outbound_allow_cidrs")

    @outbound_allow_cidrs.setter
    def outbound_allow_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "outbound_allow_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="outboundAllowHostnames")
    def outbound_allow_hostnames(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        """
        return pulumi.get(self, "outbound_allow_hostnames")

    @outbound_allow_hostnames.setter
    def outbound_allow_hostnames(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "outbound_allow_hostnames", value)

    @_builtins.property
    @pulumi.getter(name="outboundAllowPorts")
    def outbound_allow_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalOutboundAllowPortArgs']]]]:
        """
        Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
        return pulumi.get(self, "outbound_allow_ports")

    @outbound_allow_ports.setter
    def outbound_allow_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalOutboundAllowPortArgs']]]]):
        pulumi.set(self, "outbound_allow_ports", value)

    @_builtins.property
    @pulumi.getter(name="outboundBlockedCidrs")
    def outbound_blocked_cidrs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is NOT allowed to reach. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        return pulumi.get(self, "outbound_blocked_cidrs")

    @outbound_blocked_cidrs.setter
    def outbound_blocked_cidrs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "outbound_blocked_cidrs", value)


if not MYPY:
    class WorkloadFirewallSpecExternalHttpArgsDict(TypedDict):
        inbound_header_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict']]]]
        """
        A list of header filters for HTTP workloads.
        """
elif False:
    WorkloadFirewallSpecExternalHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadFirewallSpecExternalHttpArgs:
    def __init__(__self__, *,
                 inbound_header_filters: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']]] inbound_header_filters: A list of header filters for HTTP workloads.
        """
        if inbound_header_filters is not None:
            pulumi.set(__self__, "inbound_header_filters", inbound_header_filters)

    @_builtins.property
    @pulumi.getter(name="inboundHeaderFilters")
    def inbound_header_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']]]]:
        """
        A list of header filters for HTTP workloads.
        """
        return pulumi.get(self, "inbound_header_filters")

    @inbound_header_filters.setter
    def inbound_header_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']]]]):
        pulumi.set(self, "inbound_header_filters", value)


if not MYPY:
    class WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The header to match for.
        """
        allowed_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of regular expressions to match for allowed header values. Headers that do not match ANY of these values will be filtered and will not reach the workload.
        """
        blocked_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of regular expressions to match for blocked header values. Headers that match ANY of these values will be filtered and will not reach the workload.
        """
elif False:
    WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 allowed_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 blocked_values: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The header to match for.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_values: A list of regular expressions to match for allowed header values. Headers that do not match ANY of these values will be filtered and will not reach the workload.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] blocked_values: A list of regular expressions to match for blocked header values. Headers that match ANY of these values will be filtered and will not reach the workload.
        """
        pulumi.set(__self__, "key", key)
        if allowed_values is not None:
            pulumi.set(__self__, "allowed_values", allowed_values)
        if blocked_values is not None:
            pulumi.set(__self__, "blocked_values", blocked_values)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The header to match for.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of regular expressions to match for allowed header values. Headers that do not match ANY of these values will be filtered and will not reach the workload.
        """
        return pulumi.get(self, "allowed_values")

    @allowed_values.setter
    def allowed_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_values", value)

    @_builtins.property
    @pulumi.getter(name="blockedValues")
    def blocked_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of regular expressions to match for blocked header values. Headers that match ANY of these values will be filtered and will not reach the workload.
        """
        return pulumi.get(self, "blocked_values")

    @blocked_values.setter
    def blocked_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "blocked_values", value)


if not MYPY:
    class WorkloadFirewallSpecExternalOutboundAllowPortArgsDict(TypedDict):
        number: pulumi.Input[_builtins.int]
        """
        Port number. Max: 65000
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Either `http`, `https` or `tcp`.
        """
elif False:
    WorkloadFirewallSpecExternalOutboundAllowPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadFirewallSpecExternalOutboundAllowPortArgs:
    def __init__(__self__, *,
                 number: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] number: Port number. Max: 65000
        :param pulumi.Input[_builtins.str] protocol: Either `http`, `https` or `tcp`.
        """
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def number(self) -> pulumi.Input[_builtins.int]:
        """
        Port number. Max: 65000
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Either `http`, `https` or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class WorkloadFirewallSpecInternalArgsDict(TypedDict):
        inbound_allow_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        """
        inbound_allow_workloads: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
elif False:
    WorkloadFirewallSpecInternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadFirewallSpecInternalArgs:
    def __init__(__self__, *,
                 inbound_allow_type: Optional[pulumi.Input[_builtins.str]] = None,
                 inbound_allow_workloads: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] inbound_allow_type: Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] inbound_allow_workloads: A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
        if inbound_allow_type is not None:
            pulumi.set(__self__, "inbound_allow_type", inbound_allow_type)
        if inbound_allow_workloads is not None:
            pulumi.set(__self__, "inbound_allow_workloads", inbound_allow_workloads)

    @_builtins.property
    @pulumi.getter(name="inboundAllowType")
    def inbound_allow_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        """
        return pulumi.get(self, "inbound_allow_type")

    @inbound_allow_type.setter
    def inbound_allow_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inbound_allow_type", value)

    @_builtins.property
    @pulumi.getter(name="inboundAllowWorkloads")
    def inbound_allow_workloads(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
        return pulumi.get(self, "inbound_allow_workloads")

    @inbound_allow_workloads.setter
    def inbound_allow_workloads(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "inbound_allow_workloads", value)


if not MYPY:
    class WorkloadJobArgsDict(TypedDict):
        schedule: pulumi.Input[_builtins.str]
        """
        A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        """
        active_deadline_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        """
        concurrency_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`.
        """
        history_limit: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`.
        """
        restart_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`.
        """
elif False:
    WorkloadJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadJobArgs:
    def __init__(__self__, *,
                 schedule: pulumi.Input[_builtins.str],
                 active_deadline_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 concurrency_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 history_limit: Optional[pulumi.Input[_builtins.int]] = None,
                 restart_policy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] schedule: A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        :param pulumi.Input[_builtins.int] active_deadline_seconds: The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        :param pulumi.Input[_builtins.str] concurrency_policy: Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`.
        :param pulumi.Input[_builtins.int] history_limit: The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`.
        :param pulumi.Input[_builtins.str] restart_policy: Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`.
        """
        pulumi.set(__self__, "schedule", schedule)
        if active_deadline_seconds is not None:
            pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        if concurrency_policy is not None:
            pulumi.set(__self__, "concurrency_policy", concurrency_policy)
        if history_limit is not None:
            pulumi.set(__self__, "history_limit", history_limit)
        if restart_policy is not None:
            pulumi.set(__self__, "restart_policy", restart_policy)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> pulumi.Input[_builtins.str]:
        """
        A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "schedule", value)

    @_builtins.property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @active_deadline_seconds.setter
    def active_deadline_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "active_deadline_seconds", value)

    @_builtins.property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`.
        """
        return pulumi.get(self, "concurrency_policy")

    @concurrency_policy.setter
    def concurrency_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "concurrency_policy", value)

    @_builtins.property
    @pulumi.getter(name="historyLimit")
    def history_limit(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`.
        """
        return pulumi.get(self, "history_limit")

    @history_limit.setter
    def history_limit(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "history_limit", value)

    @_builtins.property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`.
        """
        return pulumi.get(self, "restart_policy")

    @restart_policy.setter
    def restart_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "restart_policy", value)


if not MYPY:
    class WorkloadLoadBalancerArgsDict(TypedDict):
        direct: NotRequired[pulumi.Input['WorkloadLoadBalancerDirectArgsDict']]
        """
        Direct load balancers are created in each location that a workload is running in and are configured for the standard endpoints of the workload. Customers are responsible for configuring the workload with certificates if TLS is required.
        """
        geo_location: NotRequired[pulumi.Input['WorkloadLoadBalancerGeoLocationArgsDict']]
        replica_direct: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, individual replicas of the workload can be reached directly using the subdomain prefix replica-<index>. For example, replica-0.my-workload.my-gvc.cpln.local or replica-0.my-workload-<gvc-alias>.cpln.app - Can only be used with stateful workloads.
        """
elif False:
    WorkloadLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLoadBalancerArgs:
    def __init__(__self__, *,
                 direct: Optional[pulumi.Input['WorkloadLoadBalancerDirectArgs']] = None,
                 geo_location: Optional[pulumi.Input['WorkloadLoadBalancerGeoLocationArgs']] = None,
                 replica_direct: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['WorkloadLoadBalancerDirectArgs'] direct: Direct load balancers are created in each location that a workload is running in and are configured for the standard endpoints of the workload. Customers are responsible for configuring the workload with certificates if TLS is required.
        :param pulumi.Input[_builtins.bool] replica_direct: When enabled, individual replicas of the workload can be reached directly using the subdomain prefix replica-<index>. For example, replica-0.my-workload.my-gvc.cpln.local or replica-0.my-workload-<gvc-alias>.cpln.app - Can only be used with stateful workloads.
        """
        if direct is not None:
            pulumi.set(__self__, "direct", direct)
        if geo_location is not None:
            pulumi.set(__self__, "geo_location", geo_location)
        if replica_direct is not None:
            pulumi.set(__self__, "replica_direct", replica_direct)

    @_builtins.property
    @pulumi.getter
    def direct(self) -> Optional[pulumi.Input['WorkloadLoadBalancerDirectArgs']]:
        """
        Direct load balancers are created in each location that a workload is running in and are configured for the standard endpoints of the workload. Customers are responsible for configuring the workload with certificates if TLS is required.
        """
        return pulumi.get(self, "direct")

    @direct.setter
    def direct(self, value: Optional[pulumi.Input['WorkloadLoadBalancerDirectArgs']]):
        pulumi.set(self, "direct", value)

    @_builtins.property
    @pulumi.getter(name="geoLocation")
    def geo_location(self) -> Optional[pulumi.Input['WorkloadLoadBalancerGeoLocationArgs']]:
        return pulumi.get(self, "geo_location")

    @geo_location.setter
    def geo_location(self, value: Optional[pulumi.Input['WorkloadLoadBalancerGeoLocationArgs']]):
        pulumi.set(self, "geo_location", value)

    @_builtins.property
    @pulumi.getter(name="replicaDirect")
    def replica_direct(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, individual replicas of the workload can be reached directly using the subdomain prefix replica-<index>. For example, replica-0.my-workload.my-gvc.cpln.local or replica-0.my-workload-<gvc-alias>.cpln.app - Can only be used with stateful workloads.
        """
        return pulumi.get(self, "replica_direct")

    @replica_direct.setter
    def replica_direct(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "replica_direct", value)


if not MYPY:
    class WorkloadLoadBalancerDirectArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        When disabled, this load balancer will be stopped.
        """
        ipset: NotRequired[pulumi.Input[_builtins.str]]
        ports: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadLoadBalancerDirectPortArgsDict']]]]
        """
        List of ports that will be exposed by this load balancer.
        """
elif False:
    WorkloadLoadBalancerDirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLoadBalancerDirectArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 ipset: Optional[pulumi.Input[_builtins.str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLoadBalancerDirectPortArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When disabled, this load balancer will be stopped.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadLoadBalancerDirectPortArgs']]] ports: List of ports that will be exposed by this load balancer.
        """
        pulumi.set(__self__, "enabled", enabled)
        if ipset is not None:
            pulumi.set(__self__, "ipset", ipset)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        When disabled, this load balancer will be stopped.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def ipset(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "ipset")

    @ipset.setter
    def ipset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipset", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLoadBalancerDirectPortArgs']]]]:
        """
        List of ports that will be exposed by this load balancer.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLoadBalancerDirectPortArgs']]]]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class WorkloadLoadBalancerDirectPortArgsDict(TypedDict):
        external_port: pulumi.Input[_builtins.int]
        """
        The port that is available publicly.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The protocol that is exposed publicly.
        """
        container_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port on the container tha will receive this traffic.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        Overrides the default `https` url scheme that will be used for links in the UI and status.
        """
elif False:
    WorkloadLoadBalancerDirectPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLoadBalancerDirectPortArgs:
    def __init__(__self__, *,
                 external_port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 container_port: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] external_port: The port that is available publicly.
        :param pulumi.Input[_builtins.str] protocol: The protocol that is exposed publicly.
        :param pulumi.Input[_builtins.int] container_port: The port on the container tha will receive this traffic.
        :param pulumi.Input[_builtins.str] scheme: Overrides the default `https` url scheme that will be used for links in the UI and status.
        """
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "protocol", protocol)
        if container_port is not None:
            pulumi.set(__self__, "container_port", container_port)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> pulumi.Input[_builtins.int]:
        """
        The port that is available publicly.
        """
        return pulumi.get(self, "external_port")

    @external_port.setter
    def external_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "external_port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol that is exposed publicly.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port on the container tha will receive this traffic.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Overrides the default `https` url scheme that will be used for links in the UI and status.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class WorkloadLoadBalancerGeoLocationArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        headers: NotRequired[pulumi.Input['WorkloadLoadBalancerGeoLocationHeadersArgsDict']]
elif False:
    WorkloadLoadBalancerGeoLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLoadBalancerGeoLocationArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 headers: Optional[pulumi.Input['WorkloadLoadBalancerGeoLocationHeadersArgs']] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['WorkloadLoadBalancerGeoLocationHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['WorkloadLoadBalancerGeoLocationHeadersArgs']]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class WorkloadLoadBalancerGeoLocationHeadersArgsDict(TypedDict):
        asn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The geo asn header.
        """
        city: NotRequired[pulumi.Input[_builtins.str]]
        """
        The geo city header.
        """
        country: NotRequired[pulumi.Input[_builtins.str]]
        """
        The geo country header.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The geo region header.
        """
elif False:
    WorkloadLoadBalancerGeoLocationHeadersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLoadBalancerGeoLocationHeadersArgs:
    def __init__(__self__, *,
                 asn: Optional[pulumi.Input[_builtins.str]] = None,
                 city: Optional[pulumi.Input[_builtins.str]] = None,
                 country: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] asn: The geo asn header.
        :param pulumi.Input[_builtins.str] city: The geo city header.
        :param pulumi.Input[_builtins.str] country: The geo country header.
        :param pulumi.Input[_builtins.str] region: The geo region header.
        """
        if asn is not None:
            pulumi.set(__self__, "asn", asn)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The geo asn header.
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The geo city header.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The geo country header.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The geo region header.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class WorkloadLocalOptionArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        """
        Valid only for `local_options`. Override options for a specific location.
        """
        autoscaling: NotRequired[pulumi.Input['WorkloadLocalOptionAutoscalingArgsDict']]
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        capacity_ai: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Capacity AI. Default: `true`.
        """
        capacity_ai_update_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        debug: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Debug mode. Default: `false`.
        """
        multi_zone: NotRequired[pulumi.Input['WorkloadLocalOptionMultiZoneArgsDict']]
        suspend: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Workload suspend. Default: `false`.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in seconds. Default: `5`.
        """
elif False:
    WorkloadLocalOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str],
                 autoscaling: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingArgs']] = None,
                 capacity_ai: Optional[pulumi.Input[_builtins.bool]] = None,
                 capacity_ai_update_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 debug: Optional[pulumi.Input[_builtins.bool]] = None,
                 multi_zone: Optional[pulumi.Input['WorkloadLocalOptionMultiZoneArgs']] = None,
                 suspend: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] location: Valid only for `local_options`. Override options for a specific location.
        :param pulumi.Input['WorkloadLocalOptionAutoscalingArgs'] autoscaling: Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        :param pulumi.Input[_builtins.bool] capacity_ai: Capacity AI. Default: `true`.
        :param pulumi.Input[_builtins.int] capacity_ai_update_minutes: The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        :param pulumi.Input[_builtins.bool] debug: Debug mode. Default: `false`.
        :param pulumi.Input[_builtins.bool] suspend: Workload suspend. Default: `false`.
        :param pulumi.Input[_builtins.int] timeout_seconds: Timeout in seconds. Default: `5`.
        """
        pulumi.set(__self__, "location", location)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if capacity_ai is not None:
            pulumi.set(__self__, "capacity_ai", capacity_ai)
        if capacity_ai_update_minutes is not None:
            pulumi.set(__self__, "capacity_ai_update_minutes", capacity_ai_update_minutes)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if multi_zone is not None:
            pulumi.set(__self__, "multi_zone", multi_zone)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        Valid only for `local_options`. Override options for a specific location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['WorkloadLocalOptionAutoscalingArgs']]:
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @_builtins.property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Capacity AI. Default: `true`.
        """
        return pulumi.get(self, "capacity_ai")

    @capacity_ai.setter
    def capacity_ai(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "capacity_ai", value)

    @_builtins.property
    @pulumi.getter(name="capacityAiUpdateMinutes")
    def capacity_ai_update_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        return pulumi.get(self, "capacity_ai_update_minutes")

    @capacity_ai_update_minutes.setter
    def capacity_ai_update_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "capacity_ai_update_minutes", value)

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Debug mode. Default: `false`.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "debug", value)

    @_builtins.property
    @pulumi.getter(name="multiZone")
    def multi_zone(self) -> Optional[pulumi.Input['WorkloadLocalOptionMultiZoneArgs']]:
        return pulumi.get(self, "multi_zone")

    @multi_zone.setter
    def multi_zone(self, value: Optional[pulumi.Input['WorkloadLocalOptionMultiZoneArgs']]):
        pulumi.set(self, "multi_zone", value)

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Workload suspend. Default: `false`.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suspend", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in seconds. Default: `5`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingArgsDict(TypedDict):
        keda: NotRequired[pulumi.Input['WorkloadLocalOptionAutoscalingKedaArgsDict']]
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        max_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        max_scale: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        metric_percentile: NotRequired[pulumi.Input[_builtins.str]]
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        min_scale: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        multis: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingMultiArgsDict']]]]
        scale_to_zero_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        target: NotRequired[pulumi.Input[_builtins.int]]
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
elif False:
    WorkloadLocalOptionAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingArgs:
    def __init__(__self__, *,
                 keda: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaArgs']] = None,
                 max_concurrency: Optional[pulumi.Input[_builtins.int]] = None,
                 max_scale: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_percentile: Optional[pulumi.Input[_builtins.str]] = None,
                 min_scale: Optional[pulumi.Input[_builtins.int]] = None,
                 multis: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingMultiArgs']]]] = None,
                 scale_to_zero_delay: Optional[pulumi.Input[_builtins.int]] = None,
                 target: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['WorkloadLocalOptionAutoscalingKedaArgs'] keda: KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        :param pulumi.Input[_builtins.int] max_concurrency: A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        :param pulumi.Input[_builtins.int] max_scale: The maximum allowed number of replicas. Min: `0`. Default `5`.
        :param pulumi.Input[_builtins.str] metric: Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        :param pulumi.Input[_builtins.str] metric_percentile: For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        :param pulumi.Input[_builtins.int] min_scale: The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        :param pulumi.Input[_builtins.int] scale_to_zero_delay: The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        :param pulumi.Input[_builtins.int] target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        if keda is not None:
            pulumi.set(__self__, "keda", keda)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_scale is not None:
            pulumi.set(__self__, "max_scale", max_scale)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_percentile is not None:
            pulumi.set(__self__, "metric_percentile", metric_percentile)
        if min_scale is not None:
            pulumi.set(__self__, "min_scale", min_scale)
        if multis is not None:
            pulumi.set(__self__, "multis", multis)
        if scale_to_zero_delay is not None:
            pulumi.set(__self__, "scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def keda(self) -> Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaArgs']]:
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        return pulumi.get(self, "keda")

    @keda.setter
    def keda(self, value: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaArgs']]):
        pulumi.set(self, "keda", value)

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_concurrency", value)

    @_builtins.property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        return pulumi.get(self, "max_scale")

    @max_scale.setter
    def max_scale(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_scale", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        return pulumi.get(self, "metric_percentile")

    @metric_percentile.setter
    def metric_percentile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_percentile", value)

    @_builtins.property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        return pulumi.get(self, "min_scale")

    @min_scale.setter
    def min_scale(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_scale", value)

    @_builtins.property
    @pulumi.getter
    def multis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingMultiArgs']]]]:
        return pulumi.get(self, "multis")

    @multis.setter
    def multis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingMultiArgs']]]]):
        pulumi.set(self, "multis", value)

    @_builtins.property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        return pulumi.get(self, "scale_to_zero_delay")

    @scale_to_zero_delay.setter
    def scale_to_zero_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "scale_to_zero_delay", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingKedaArgsDict(TypedDict):
        advanced: NotRequired[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedArgsDict']]
        """
        Advanced configuration options for KEDA.
        """
        cooldown_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        initial_cooldown_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        polling_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        triggers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerArgsDict']]]]
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
elif False:
    WorkloadLocalOptionAutoscalingKedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingKedaArgs:
    def __init__(__self__, *,
                 advanced: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedArgs']] = None,
                 cooldown_period: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_cooldown_period: Optional[pulumi.Input[_builtins.int]] = None,
                 polling_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 triggers: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerArgs']]]] = None):
        """
        :param pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedArgs'] advanced: Advanced configuration options for KEDA.
        :param pulumi.Input[_builtins.int] cooldown_period: The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param pulumi.Input[_builtins.int] initial_cooldown_period: The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param pulumi.Input[_builtins.int] polling_interval: The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerArgs']]] triggers: An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if initial_cooldown_period is not None:
            pulumi.set(__self__, "initial_cooldown_period", initial_cooldown_period)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter
    def advanced(self) -> Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedArgs']]:
        """
        Advanced configuration options for KEDA.
        """
        return pulumi.get(self, "advanced")

    @advanced.setter
    def advanced(self, value: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedArgs']]):
        pulumi.set(self, "advanced", value)

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="initialCooldownPeriod")
    def initial_cooldown_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "initial_cooldown_period")

    @initial_cooldown_period.setter
    def initial_cooldown_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "polling_interval", value)

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerArgs']]]]:
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerArgs']]]]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingKedaAdvancedArgsDict(TypedDict):
        scaling_modifiers: NotRequired[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgsDict']]
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
elif False:
    WorkloadLocalOptionAutoscalingKedaAdvancedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingKedaAdvancedArgs:
    def __init__(__self__, *,
                 scaling_modifiers: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgs']] = None):
        """
        :param pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgs'] scaling_modifiers: Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        if scaling_modifiers is not None:
            pulumi.set(__self__, "scaling_modifiers", scaling_modifiers)

    @_builtins.property
    @pulumi.getter(name="scalingModifiers")
    def scaling_modifiers(self) -> Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgs']]:
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        return pulumi.get(self, "scaling_modifiers")

    @scaling_modifiers.setter
    def scaling_modifiers(self, value: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgs']]):
        pulumi.set(self, "scaling_modifiers", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgsDict(TypedDict):
        activation_target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        formula: NotRequired[pulumi.Input[_builtins.str]]
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines metric type used for this new composite-metric.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines new target value to scale on for the composed metric.
        """
elif False:
    WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingKedaAdvancedScalingModifiersArgs:
    def __init__(__self__, *,
                 activation_target: Optional[pulumi.Input[_builtins.str]] = None,
                 formula: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] activation_target: Defines the new activation target value to scale on for the composed metric.
        :param pulumi.Input[_builtins.str] formula: Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        :param pulumi.Input[_builtins.str] metric_type: Defines metric type used for this new composite-metric.
        :param pulumi.Input[_builtins.str] target: Defines new target value to scale on for the composed metric.
        """
        if activation_target is not None:
            pulumi.set(__self__, "activation_target", activation_target)
        if formula is not None:
            pulumi.set(__self__, "formula", formula)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="activationTarget")
    def activation_target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        return pulumi.get(self, "activation_target")

    @activation_target.setter
    def activation_target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "activation_target", value)

    @_builtins.property
    @pulumi.getter
    def formula(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "formula", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines metric type used for this new composite-metric.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines new target value to scale on for the composed metric.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingKedaTriggerArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        authentication_ref: NotRequired[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict']]
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The configuration parameters that the trigger requires.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of metric to be used for scaling.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        use_cached_metrics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables caching of metric values during polling interval.
        """
elif False:
    WorkloadLocalOptionAutoscalingKedaTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingKedaTriggerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 authentication_ref: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 use_cached_metrics: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        :param pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs'] authentication_ref: Reference to a KEDA authentication object for secure access to external systems.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: The configuration parameters that the trigger requires.
        :param pulumi.Input[_builtins.str] metric_type: The type of metric to be used for scaling.
        :param pulumi.Input[_builtins.str] name: An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        :param pulumi.Input[_builtins.bool] use_cached_metrics: Enables caching of metric values during polling interval.
        """
        pulumi.set(__self__, "type", type)
        if authentication_ref is not None:
            pulumi.set(__self__, "authentication_ref", authentication_ref)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if use_cached_metrics is not None:
            pulumi.set(__self__, "use_cached_metrics", use_cached_metrics)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="authenticationRef")
    def authentication_ref(self) -> Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs']]:
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
        return pulumi.get(self, "authentication_ref")

    @authentication_ref.setter
    def authentication_ref(self, value: Optional[pulumi.Input['WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs']]):
        pulumi.set(self, "authentication_ref", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The configuration parameters that the trigger requires.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of metric to be used for scaling.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="useCachedMetrics")
    def use_cached_metrics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables caching of metric values during polling interval.
        """
        return pulumi.get(self, "use_cached_metrics")

    @use_cached_metrics.setter
    def use_cached_metrics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cached_metrics", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
elif False:
    WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of secret listed in the GVC spec.keda.secrets.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkloadLocalOptionAutoscalingMultiArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        Valid values: `cpu` or `memory`.
        """
        target: NotRequired[pulumi.Input[_builtins.int]]
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
elif False:
    WorkloadLocalOptionAutoscalingMultiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionAutoscalingMultiArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] metric: Valid values: `cpu` or `memory`.
        :param pulumi.Input[_builtins.int] target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Valid values: `cpu` or `memory`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WorkloadLocalOptionMultiZoneArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    WorkloadLocalOptionMultiZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadLocalOptionMultiZoneArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WorkloadOptionsArgsDict(TypedDict):
        autoscaling: NotRequired[pulumi.Input['WorkloadOptionsAutoscalingArgsDict']]
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        capacity_ai: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Capacity AI. Default: `true`.
        """
        capacity_ai_update_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        debug: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Debug mode. Default: `false`.
        """
        multi_zone: NotRequired[pulumi.Input['WorkloadOptionsMultiZoneArgsDict']]
        suspend: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Workload suspend. Default: `false`.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Timeout in seconds. Default: `5`.
        """
elif False:
    WorkloadOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsArgs:
    def __init__(__self__, *,
                 autoscaling: Optional[pulumi.Input['WorkloadOptionsAutoscalingArgs']] = None,
                 capacity_ai: Optional[pulumi.Input[_builtins.bool]] = None,
                 capacity_ai_update_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 debug: Optional[pulumi.Input[_builtins.bool]] = None,
                 multi_zone: Optional[pulumi.Input['WorkloadOptionsMultiZoneArgs']] = None,
                 suspend: Optional[pulumi.Input[_builtins.bool]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['WorkloadOptionsAutoscalingArgs'] autoscaling: Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        :param pulumi.Input[_builtins.bool] capacity_ai: Capacity AI. Default: `true`.
        :param pulumi.Input[_builtins.int] capacity_ai_update_minutes: The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        :param pulumi.Input[_builtins.bool] debug: Debug mode. Default: `false`.
        :param pulumi.Input[_builtins.bool] suspend: Workload suspend. Default: `false`.
        :param pulumi.Input[_builtins.int] timeout_seconds: Timeout in seconds. Default: `5`.
        """
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if capacity_ai is not None:
            pulumi.set(__self__, "capacity_ai", capacity_ai)
        if capacity_ai_update_minutes is not None:
            pulumi.set(__self__, "capacity_ai_update_minutes", capacity_ai_update_minutes)
        if debug is not None:
            pulumi.set(__self__, "debug", debug)
        if multi_zone is not None:
            pulumi.set(__self__, "multi_zone", multi_zone)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['WorkloadOptionsAutoscalingArgs']]:
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['WorkloadOptionsAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @_builtins.property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Capacity AI. Default: `true`.
        """
        return pulumi.get(self, "capacity_ai")

    @capacity_ai.setter
    def capacity_ai(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "capacity_ai", value)

    @_builtins.property
    @pulumi.getter(name="capacityAiUpdateMinutes")
    def capacity_ai_update_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        return pulumi.get(self, "capacity_ai_update_minutes")

    @capacity_ai_update_minutes.setter
    def capacity_ai_update_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "capacity_ai_update_minutes", value)

    @_builtins.property
    @pulumi.getter
    def debug(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Debug mode. Default: `false`.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "debug", value)

    @_builtins.property
    @pulumi.getter(name="multiZone")
    def multi_zone(self) -> Optional[pulumi.Input['WorkloadOptionsMultiZoneArgs']]:
        return pulumi.get(self, "multi_zone")

    @multi_zone.setter
    def multi_zone(self, value: Optional[pulumi.Input['WorkloadOptionsMultiZoneArgs']]):
        pulumi.set(self, "multi_zone", value)

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Workload suspend. Default: `false`.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "suspend", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Timeout in seconds. Default: `5`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class WorkloadOptionsAutoscalingArgsDict(TypedDict):
        keda: NotRequired[pulumi.Input['WorkloadOptionsAutoscalingKedaArgsDict']]
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        max_concurrency: NotRequired[pulumi.Input[_builtins.int]]
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        max_scale: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        metric_percentile: NotRequired[pulumi.Input[_builtins.str]]
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        min_scale: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        multis: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingMultiArgsDict']]]]
        scale_to_zero_delay: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        target: NotRequired[pulumi.Input[_builtins.int]]
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
elif False:
    WorkloadOptionsAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingArgs:
    def __init__(__self__, *,
                 keda: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaArgs']] = None,
                 max_concurrency: Optional[pulumi.Input[_builtins.int]] = None,
                 max_scale: Optional[pulumi.Input[_builtins.int]] = None,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_percentile: Optional[pulumi.Input[_builtins.str]] = None,
                 min_scale: Optional[pulumi.Input[_builtins.int]] = None,
                 multis: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingMultiArgs']]]] = None,
                 scale_to_zero_delay: Optional[pulumi.Input[_builtins.int]] = None,
                 target: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input['WorkloadOptionsAutoscalingKedaArgs'] keda: KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        :param pulumi.Input[_builtins.int] max_concurrency: A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        :param pulumi.Input[_builtins.int] max_scale: The maximum allowed number of replicas. Min: `0`. Default `5`.
        :param pulumi.Input[_builtins.str] metric: Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        :param pulumi.Input[_builtins.str] metric_percentile: For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        :param pulumi.Input[_builtins.int] min_scale: The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        :param pulumi.Input[_builtins.int] scale_to_zero_delay: The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        :param pulumi.Input[_builtins.int] target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        if keda is not None:
            pulumi.set(__self__, "keda", keda)
        if max_concurrency is not None:
            pulumi.set(__self__, "max_concurrency", max_concurrency)
        if max_scale is not None:
            pulumi.set(__self__, "max_scale", max_scale)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metric_percentile is not None:
            pulumi.set(__self__, "metric_percentile", metric_percentile)
        if min_scale is not None:
            pulumi.set(__self__, "min_scale", min_scale)
        if multis is not None:
            pulumi.set(__self__, "multis", multis)
        if scale_to_zero_delay is not None:
            pulumi.set(__self__, "scale_to_zero_delay", scale_to_zero_delay)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def keda(self) -> Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaArgs']]:
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        return pulumi.get(self, "keda")

    @keda.setter
    def keda(self, value: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaArgs']]):
        pulumi.set(self, "keda", value)

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_concurrency", value)

    @_builtins.property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        return pulumi.get(self, "max_scale")

    @max_scale.setter
    def max_scale(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_scale", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        return pulumi.get(self, "metric_percentile")

    @metric_percentile.setter
    def metric_percentile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_percentile", value)

    @_builtins.property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        return pulumi.get(self, "min_scale")

    @min_scale.setter
    def min_scale(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_scale", value)

    @_builtins.property
    @pulumi.getter
    def multis(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingMultiArgs']]]]:
        return pulumi.get(self, "multis")

    @multis.setter
    def multis(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingMultiArgs']]]]):
        pulumi.set(self, "multis", value)

    @_builtins.property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        return pulumi.get(self, "scale_to_zero_delay")

    @scale_to_zero_delay.setter
    def scale_to_zero_delay(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "scale_to_zero_delay", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WorkloadOptionsAutoscalingKedaArgsDict(TypedDict):
        advanced: NotRequired[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedArgsDict']]
        """
        Advanced configuration options for KEDA.
        """
        cooldown_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        initial_cooldown_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        polling_interval: NotRequired[pulumi.Input[_builtins.int]]
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        triggers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerArgsDict']]]]
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
elif False:
    WorkloadOptionsAutoscalingKedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingKedaArgs:
    def __init__(__self__, *,
                 advanced: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedArgs']] = None,
                 cooldown_period: Optional[pulumi.Input[_builtins.int]] = None,
                 initial_cooldown_period: Optional[pulumi.Input[_builtins.int]] = None,
                 polling_interval: Optional[pulumi.Input[_builtins.int]] = None,
                 triggers: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerArgs']]]] = None):
        """
        :param pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedArgs'] advanced: Advanced configuration options for KEDA.
        :param pulumi.Input[_builtins.int] cooldown_period: The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param pulumi.Input[_builtins.int] initial_cooldown_period: The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param pulumi.Input[_builtins.int] polling_interval: The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerArgs']]] triggers: An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        if advanced is not None:
            pulumi.set(__self__, "advanced", advanced)
        if cooldown_period is not None:
            pulumi.set(__self__, "cooldown_period", cooldown_period)
        if initial_cooldown_period is not None:
            pulumi.set(__self__, "initial_cooldown_period", initial_cooldown_period)
        if polling_interval is not None:
            pulumi.set(__self__, "polling_interval", polling_interval)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter
    def advanced(self) -> Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedArgs']]:
        """
        Advanced configuration options for KEDA.
        """
        return pulumi.get(self, "advanced")

    @advanced.setter
    def advanced(self, value: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedArgs']]):
        pulumi.set(self, "advanced", value)

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="initialCooldownPeriod")
    def initial_cooldown_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "initial_cooldown_period")

    @initial_cooldown_period.setter
    def initial_cooldown_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "polling_interval", value)

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerArgs']]]]:
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerArgs']]]]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class WorkloadOptionsAutoscalingKedaAdvancedArgsDict(TypedDict):
        scaling_modifiers: NotRequired[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgsDict']]
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
elif False:
    WorkloadOptionsAutoscalingKedaAdvancedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingKedaAdvancedArgs:
    def __init__(__self__, *,
                 scaling_modifiers: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgs']] = None):
        """
        :param pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgs'] scaling_modifiers: Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        if scaling_modifiers is not None:
            pulumi.set(__self__, "scaling_modifiers", scaling_modifiers)

    @_builtins.property
    @pulumi.getter(name="scalingModifiers")
    def scaling_modifiers(self) -> Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgs']]:
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        return pulumi.get(self, "scaling_modifiers")

    @scaling_modifiers.setter
    def scaling_modifiers(self, value: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgs']]):
        pulumi.set(self, "scaling_modifiers", value)


if not MYPY:
    class WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgsDict(TypedDict):
        activation_target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        formula: NotRequired[pulumi.Input[_builtins.str]]
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines metric type used for this new composite-metric.
        """
        target: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines new target value to scale on for the composed metric.
        """
elif False:
    WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingKedaAdvancedScalingModifiersArgs:
    def __init__(__self__, *,
                 activation_target: Optional[pulumi.Input[_builtins.str]] = None,
                 formula: Optional[pulumi.Input[_builtins.str]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] activation_target: Defines the new activation target value to scale on for the composed metric.
        :param pulumi.Input[_builtins.str] formula: Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        :param pulumi.Input[_builtins.str] metric_type: Defines metric type used for this new composite-metric.
        :param pulumi.Input[_builtins.str] target: Defines new target value to scale on for the composed metric.
        """
        if activation_target is not None:
            pulumi.set(__self__, "activation_target", activation_target)
        if formula is not None:
            pulumi.set(__self__, "formula", formula)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="activationTarget")
    def activation_target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        return pulumi.get(self, "activation_target")

    @activation_target.setter
    def activation_target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "activation_target", value)

    @_builtins.property
    @pulumi.getter
    def formula(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "formula", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines metric type used for this new composite-metric.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines new target value to scale on for the composed metric.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WorkloadOptionsAutoscalingKedaTriggerArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        authentication_ref: NotRequired[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgsDict']]
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The configuration parameters that the trigger requires.
        """
        metric_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of metric to be used for scaling.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        use_cached_metrics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables caching of metric values during polling interval.
        """
elif False:
    WorkloadOptionsAutoscalingKedaTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingKedaTriggerArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 authentication_ref: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgs']] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 metric_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 use_cached_metrics: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        :param pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgs'] authentication_ref: Reference to a KEDA authentication object for secure access to external systems.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: The configuration parameters that the trigger requires.
        :param pulumi.Input[_builtins.str] metric_type: The type of metric to be used for scaling.
        :param pulumi.Input[_builtins.str] name: An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        :param pulumi.Input[_builtins.bool] use_cached_metrics: Enables caching of metric values during polling interval.
        """
        pulumi.set(__self__, "type", type)
        if authentication_ref is not None:
            pulumi.set(__self__, "authentication_ref", authentication_ref)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if metric_type is not None:
            pulumi.set(__self__, "metric_type", metric_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if use_cached_metrics is not None:
            pulumi.set(__self__, "use_cached_metrics", use_cached_metrics)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="authenticationRef")
    def authentication_ref(self) -> Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgs']]:
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
        return pulumi.get(self, "authentication_ref")

    @authentication_ref.setter
    def authentication_ref(self, value: Optional[pulumi.Input['WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgs']]):
        pulumi.set(self, "authentication_ref", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The configuration parameters that the trigger requires.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of metric to be used for scaling.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="useCachedMetrics")
    def use_cached_metrics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables caching of metric values during polling interval.
        """
        return pulumi.get(self, "use_cached_metrics")

    @use_cached_metrics.setter
    def use_cached_metrics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_cached_metrics", value)


if not MYPY:
    class WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
elif False:
    WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingKedaTriggerAuthenticationRefArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] name: The name of secret listed in the GVC spec.keda.secrets.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class WorkloadOptionsAutoscalingMultiArgsDict(TypedDict):
        metric: NotRequired[pulumi.Input[_builtins.str]]
        """
        Valid values: `cpu` or `memory`.
        """
        target: NotRequired[pulumi.Input[_builtins.int]]
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
elif False:
    WorkloadOptionsAutoscalingMultiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsAutoscalingMultiArgs:
    def __init__(__self__, *,
                 metric: Optional[pulumi.Input[_builtins.str]] = None,
                 target: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] metric: Valid values: `cpu` or `memory`.
        :param pulumi.Input[_builtins.int] target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Valid values: `cpu` or `memory`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target", value)


if not MYPY:
    class WorkloadOptionsMultiZoneArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    WorkloadOptionsMultiZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadOptionsMultiZoneArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class WorkloadRequestRetryPolicyArgsDict(TypedDict):
        attempts: NotRequired[pulumi.Input[_builtins.int]]
        retry_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
elif False:
    WorkloadRequestRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadRequestRetryPolicyArgs:
    def __init__(__self__, *,
                 attempts: Optional[pulumi.Input[_builtins.int]] = None,
                 retry_ons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)
        if retry_ons is not None:
            pulumi.set(__self__, "retry_ons", retry_ons)

    @_builtins.property
    @pulumi.getter
    def attempts(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "attempts", value)

    @_builtins.property
    @pulumi.getter(name="retryOns")
    def retry_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "retry_ons")

    @retry_ons.setter
    def retry_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "retry_ons", value)


if not MYPY:
    class WorkloadRolloutOptionArgsDict(TypedDict):
        max_surge_replicas: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of replicas that can be created above the desired amount of replicas during an update.
        """
        max_unavailable_replicas: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of replicas that can be unavailable during the update process.
        """
        min_ready_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of seconds a container must run without crashing to be considered available.
        """
        scaling_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        """
        termination_grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of time in seconds a workload has to gracefully terminate before forcefully terminating it. This includes the time it takes for the preStop hook to run.
        """
elif False:
    WorkloadRolloutOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadRolloutOptionArgs:
    def __init__(__self__, *,
                 max_surge_replicas: Optional[pulumi.Input[_builtins.str]] = None,
                 max_unavailable_replicas: Optional[pulumi.Input[_builtins.str]] = None,
                 min_ready_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 scaling_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 termination_grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] max_surge_replicas: The number of replicas that can be created above the desired amount of replicas during an update.
        :param pulumi.Input[_builtins.str] max_unavailable_replicas: The number of replicas that can be unavailable during the update process.
        :param pulumi.Input[_builtins.int] min_ready_seconds: The minimum number of seconds a container must run without crashing to be considered available.
        :param pulumi.Input[_builtins.str] scaling_policy: The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        :param pulumi.Input[_builtins.int] termination_grace_period_seconds: The amount of time in seconds a workload has to gracefully terminate before forcefully terminating it. This includes the time it takes for the preStop hook to run.
        """
        if max_surge_replicas is not None:
            pulumi.set(__self__, "max_surge_replicas", max_surge_replicas)
        if max_unavailable_replicas is not None:
            pulumi.set(__self__, "max_unavailable_replicas", max_unavailable_replicas)
        if min_ready_seconds is not None:
            pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        if scaling_policy is not None:
            pulumi.set(__self__, "scaling_policy", scaling_policy)
        if termination_grace_period_seconds is not None:
            pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="maxSurgeReplicas")
    def max_surge_replicas(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of replicas that can be created above the desired amount of replicas during an update.
        """
        return pulumi.get(self, "max_surge_replicas")

    @max_surge_replicas.setter
    def max_surge_replicas(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_surge_replicas", value)

    @_builtins.property
    @pulumi.getter(name="maxUnavailableReplicas")
    def max_unavailable_replicas(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of replicas that can be unavailable during the update process.
        """
        return pulumi.get(self, "max_unavailable_replicas")

    @max_unavailable_replicas.setter
    def max_unavailable_replicas(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_unavailable_replicas", value)

    @_builtins.property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of seconds a container must run without crashing to be considered available.
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_ready_seconds", value)

    @_builtins.property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        """
        return pulumi.get(self, "scaling_policy")

    @scaling_policy.setter
    def scaling_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scaling_policy", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of time in seconds a workload has to gracefully terminate before forcefully terminating it. This includes the time it takes for the preStop hook to run.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class WorkloadSecurityOptionsArgsDict(TypedDict):
        file_system_group_id: NotRequired[pulumi.Input[_builtins.int]]
        """
        The group id assigned to any mounted volume.
        """
elif False:
    WorkloadSecurityOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadSecurityOptionsArgs:
    def __init__(__self__, *,
                 file_system_group_id: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] file_system_group_id: The group id assigned to any mounted volume.
        """
        if file_system_group_id is not None:
            pulumi.set(__self__, "file_system_group_id", file_system_group_id)

    @_builtins.property
    @pulumi.getter(name="fileSystemGroupId")
    def file_system_group_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The group id assigned to any mounted volume.
        """
        return pulumi.get(self, "file_system_group_id")

    @file_system_group_id.setter
    def file_system_group_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "file_system_group_id", value)


if not MYPY:
    class WorkloadSidecarArgsDict(TypedDict):
        envoy: pulumi.Input[_builtins.str]
elif False:
    WorkloadSidecarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadSidecarArgs:
    def __init__(__self__, *,
                 envoy: pulumi.Input[_builtins.str]):
        pulumi.set(__self__, "envoy", envoy)

    @_builtins.property
    @pulumi.getter
    def envoy(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "envoy")

    @envoy.setter
    def envoy(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "envoy", value)


if not MYPY:
    class WorkloadStatusArgsDict(TypedDict):
        canonical_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Canonical endpoint for the workload.
        """
        current_replica_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Current amount of replicas deployed.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint for the workload.
        """
        health_checks: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusHealthCheckArgsDict']]]]
        """
        Current health status.
        """
        internal_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Internal hostname for the workload. Used for service-to-service requests.
        """
        load_balancers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusLoadBalancerArgsDict']]]]
        parent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the parent object.
        """
        replica_internal_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        resolved_images: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageArgsDict']]]]
        """
        Resolved images for workloads with dynamic tags enabled.
        """
elif False:
    WorkloadStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStatusArgs:
    def __init__(__self__, *,
                 canonical_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 current_replica_count: Optional[pulumi.Input[_builtins.int]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 health_checks: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusHealthCheckArgs']]]] = None,
                 internal_name: Optional[pulumi.Input[_builtins.str]] = None,
                 load_balancers: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusLoadBalancerArgs']]]] = None,
                 parent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 replica_internal_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resolved_images: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] canonical_endpoint: Canonical endpoint for the workload.
        :param pulumi.Input[_builtins.int] current_replica_count: Current amount of replicas deployed.
        :param pulumi.Input[_builtins.str] endpoint: Endpoint for the workload.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadStatusHealthCheckArgs']]] health_checks: Current health status.
        :param pulumi.Input[_builtins.str] internal_name: Internal hostname for the workload. Used for service-to-service requests.
        :param pulumi.Input[_builtins.str] parent_id: ID of the parent object.
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageArgs']]] resolved_images: Resolved images for workloads with dynamic tags enabled.
        """
        if canonical_endpoint is not None:
            pulumi.set(__self__, "canonical_endpoint", canonical_endpoint)
        if current_replica_count is not None:
            pulumi.set(__self__, "current_replica_count", current_replica_count)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if health_checks is not None:
            pulumi.set(__self__, "health_checks", health_checks)
        if internal_name is not None:
            pulumi.set(__self__, "internal_name", internal_name)
        if load_balancers is not None:
            pulumi.set(__self__, "load_balancers", load_balancers)
        if parent_id is not None:
            pulumi.set(__self__, "parent_id", parent_id)
        if replica_internal_names is not None:
            pulumi.set(__self__, "replica_internal_names", replica_internal_names)
        if resolved_images is not None:
            pulumi.set(__self__, "resolved_images", resolved_images)

    @_builtins.property
    @pulumi.getter(name="canonicalEndpoint")
    def canonical_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Canonical endpoint for the workload.
        """
        return pulumi.get(self, "canonical_endpoint")

    @canonical_endpoint.setter
    def canonical_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "canonical_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="currentReplicaCount")
    def current_replica_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Current amount of replicas deployed.
        """
        return pulumi.get(self, "current_replica_count")

    @current_replica_count.setter
    def current_replica_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "current_replica_count", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint for the workload.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="healthChecks")
    def health_checks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusHealthCheckArgs']]]]:
        """
        Current health status.
        """
        return pulumi.get(self, "health_checks")

    @health_checks.setter
    def health_checks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusHealthCheckArgs']]]]):
        pulumi.set(self, "health_checks", value)

    @_builtins.property
    @pulumi.getter(name="internalName")
    def internal_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Internal hostname for the workload. Used for service-to-service requests.
        """
        return pulumi.get(self, "internal_name")

    @internal_name.setter
    def internal_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "internal_name", value)

    @_builtins.property
    @pulumi.getter(name="loadBalancers")
    def load_balancers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusLoadBalancerArgs']]]]:
        return pulumi.get(self, "load_balancers")

    @load_balancers.setter
    def load_balancers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusLoadBalancerArgs']]]]):
        pulumi.set(self, "load_balancers", value)

    @_builtins.property
    @pulumi.getter(name="parentId")
    def parent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the parent object.
        """
        return pulumi.get(self, "parent_id")

    @parent_id.setter
    def parent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_id", value)

    @_builtins.property
    @pulumi.getter(name="replicaInternalNames")
    def replica_internal_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "replica_internal_names")

    @replica_internal_names.setter
    def replica_internal_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "replica_internal_names", value)

    @_builtins.property
    @pulumi.getter(name="resolvedImages")
    def resolved_images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageArgs']]]]:
        """
        Resolved images for workloads with dynamic tags enabled.
        """
        return pulumi.get(self, "resolved_images")

    @resolved_images.setter
    def resolved_images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageArgs']]]]):
        pulumi.set(self, "resolved_images", value)


if not MYPY:
    class WorkloadStatusHealthCheckArgsDict(TypedDict):
        active: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Active boolean for the associated workload.
        """
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        Current output code for the associated workload.
        """
        failures: NotRequired[pulumi.Input[_builtins.int]]
        """
        Failure integer for the associated workload.
        """
        last_checked: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp in UTC of the last health check.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Current health status for the associated workload.
        """
        success: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Success boolean for the associated workload.
        """
        successes: NotRequired[pulumi.Input[_builtins.int]]
        """
        Success integer for the associated workload.
        """
elif False:
    WorkloadStatusHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStatusHealthCheckArgs:
    def __init__(__self__, *,
                 active: Optional[pulumi.Input[_builtins.bool]] = None,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 failures: Optional[pulumi.Input[_builtins.int]] = None,
                 last_checked: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 success: Optional[pulumi.Input[_builtins.bool]] = None,
                 successes: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] active: Active boolean for the associated workload.
        :param pulumi.Input[_builtins.int] code: Current output code for the associated workload.
        :param pulumi.Input[_builtins.int] failures: Failure integer for the associated workload.
        :param pulumi.Input[_builtins.str] last_checked: Timestamp in UTC of the last health check.
        :param pulumi.Input[_builtins.str] message: Current health status for the associated workload.
        :param pulumi.Input[_builtins.bool] success: Success boolean for the associated workload.
        :param pulumi.Input[_builtins.int] successes: Success integer for the associated workload.
        """
        if active is not None:
            pulumi.set(__self__, "active", active)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if failures is not None:
            pulumi.set(__self__, "failures", failures)
        if last_checked is not None:
            pulumi.set(__self__, "last_checked", last_checked)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if success is not None:
            pulumi.set(__self__, "success", success)
        if successes is not None:
            pulumi.set(__self__, "successes", successes)

    @_builtins.property
    @pulumi.getter
    def active(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Active boolean for the associated workload.
        """
        return pulumi.get(self, "active")

    @active.setter
    def active(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "active", value)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Current output code for the associated workload.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def failures(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Failure integer for the associated workload.
        """
        return pulumi.get(self, "failures")

    @failures.setter
    def failures(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failures", value)

    @_builtins.property
    @pulumi.getter(name="lastChecked")
    def last_checked(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp in UTC of the last health check.
        """
        return pulumi.get(self, "last_checked")

    @last_checked.setter
    def last_checked(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_checked", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Current health status for the associated workload.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter
    def success(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Success boolean for the associated workload.
        """
        return pulumi.get(self, "success")

    @success.setter
    def success(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "success", value)

    @_builtins.property
    @pulumi.getter
    def successes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Success integer for the associated workload.
        """
        return pulumi.get(self, "successes")

    @successes.setter
    def successes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "successes", value)


if not MYPY:
    class WorkloadStatusLoadBalancerArgsDict(TypedDict):
        origin: NotRequired[pulumi.Input[_builtins.str]]
        url: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    WorkloadStatusLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStatusLoadBalancerArgs:
    def __init__(__self__, *,
                 origin: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        if origin is not None:
            pulumi.set(__self__, "origin", origin)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def origin(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "origin")

    @origin.setter
    def origin(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "origin", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class WorkloadStatusResolvedImageArgsDict(TypedDict):
        error_messages: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        images: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageArgsDict']]]]
        """
        A list of images that were resolved.
        """
        next_retry_at: NotRequired[pulumi.Input[_builtins.str]]
        resolved_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        UTC Time when the images were resolved.
        """
        resolved_for_version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Workload version the images were resolved for.
        """
elif False:
    WorkloadStatusResolvedImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStatusResolvedImageArgs:
    def __init__(__self__, *,
                 error_messages: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 images: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageArgs']]]] = None,
                 next_retry_at: Optional[pulumi.Input[_builtins.str]] = None,
                 resolved_at: Optional[pulumi.Input[_builtins.str]] = None,
                 resolved_for_version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageArgs']]] images: A list of images that were resolved.
        :param pulumi.Input[_builtins.str] resolved_at: UTC Time when the images were resolved.
        :param pulumi.Input[_builtins.int] resolved_for_version: Workload version the images were resolved for.
        """
        if error_messages is not None:
            pulumi.set(__self__, "error_messages", error_messages)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if next_retry_at is not None:
            pulumi.set(__self__, "next_retry_at", next_retry_at)
        if resolved_at is not None:
            pulumi.set(__self__, "resolved_at", resolved_at)
        if resolved_for_version is not None:
            pulumi.set(__self__, "resolved_for_version", resolved_for_version)

    @_builtins.property
    @pulumi.getter(name="errorMessages")
    def error_messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "error_messages")

    @error_messages.setter
    def error_messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "error_messages", value)

    @_builtins.property
    @pulumi.getter
    def images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageArgs']]]]:
        """
        A list of images that were resolved.
        """
        return pulumi.get(self, "images")

    @images.setter
    def images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageArgs']]]]):
        pulumi.set(self, "images", value)

    @_builtins.property
    @pulumi.getter(name="nextRetryAt")
    def next_retry_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "next_retry_at")

    @next_retry_at.setter
    def next_retry_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "next_retry_at", value)

    @_builtins.property
    @pulumi.getter(name="resolvedAt")
    def resolved_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UTC Time when the images were resolved.
        """
        return pulumi.get(self, "resolved_at")

    @resolved_at.setter
    def resolved_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resolved_at", value)

    @_builtins.property
    @pulumi.getter(name="resolvedForVersion")
    def resolved_for_version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Workload version the images were resolved for.
        """
        return pulumi.get(self, "resolved_for_version")

    @resolved_for_version.setter
    def resolved_for_version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "resolved_for_version", value)


if not MYPY:
    class WorkloadStatusResolvedImageImageArgsDict(TypedDict):
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique SHA256 hash value that identifies a specific image content. This digest serves as a fingerprint of the image's content, ensuring the image you pull or run is exactly what you expect, without any modifications or corruptions.
        """
        manifests: NotRequired[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageManifestArgsDict']]]]
elif False:
    WorkloadStatusResolvedImageImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStatusResolvedImageImageArgs:
    def __init__(__self__, *,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 manifests: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageManifestArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] digest: A unique SHA256 hash value that identifies a specific image content. This digest serves as a fingerprint of the image's content, ensuring the image you pull or run is exactly what you expect, without any modifications or corruptions.
        """
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if manifests is not None:
            pulumi.set(__self__, "manifests", manifests)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique SHA256 hash value that identifies a specific image content. This digest serves as a fingerprint of the image's content, ensuring the image you pull or run is exactly what you expect, without any modifications or corruptions.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter
    def manifests(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageManifestArgs']]]]:
        return pulumi.get(self, "manifests")

    @manifests.setter
    def manifests(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WorkloadStatusResolvedImageImageManifestArgs']]]]):
        pulumi.set(self, "manifests", value)


if not MYPY:
    class WorkloadStatusResolvedImageImageManifestArgsDict(TypedDict):
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        A SHA256 hash that uniquely identifies the specific image manifest.
        """
        image: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name and tag of the resolved image.
        """
        media_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The MIME type used in the Docker Registry HTTP API to specify the format of the data being sent or received. Docker uses media types to distinguish between different kinds of JSON objects and binary data formats within the registry protocol, enabling the Docker client and registry to understand and process different components of Docker images correctly.
        """
        platform: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Key-value map of strings. The combination of the operating system and architecture for which the image is built.
        """
elif False:
    WorkloadStatusResolvedImageImageManifestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WorkloadStatusResolvedImageImageManifestArgs:
    def __init__(__self__, *,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 image: Optional[pulumi.Input[_builtins.str]] = None,
                 media_type: Optional[pulumi.Input[_builtins.str]] = None,
                 platform: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] digest: A SHA256 hash that uniquely identifies the specific image manifest.
        :param pulumi.Input[_builtins.str] image: The name and tag of the resolved image.
        :param pulumi.Input[_builtins.str] media_type: The MIME type used in the Docker Registry HTTP API to specify the format of the data being sent or received. Docker uses media types to distinguish between different kinds of JSON objects and binary data formats within the registry protocol, enabling the Docker client and registry to understand and process different components of Docker images correctly.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] platform: Key-value map of strings. The combination of the operating system and architecture for which the image is built.
        """
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if media_type is not None:
            pulumi.set(__self__, "media_type", media_type)
        if platform is not None:
            pulumi.set(__self__, "platform", platform)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A SHA256 hash that uniquely identifies the specific image manifest.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name and tag of the resolved image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The MIME type used in the Docker Registry HTTP API to specify the format of the data being sent or received. Docker uses media types to distinguish between different kinds of JSON objects and binary data formats within the registry protocol, enabling the Docker client and registry to understand and process different components of Docker images correctly.
        """
        return pulumi.get(self, "media_type")

    @media_type.setter
    def media_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "media_type", value)

    @_builtins.property
    @pulumi.getter
    def platform(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Key-value map of strings. The combination of the operating system and architecture for which the image is built.
        """
        return pulumi.get(self, "platform")

    @platform.setter
    def platform(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "platform", value)


if not MYPY:
    class GetGvcControlplaneTracingArgsDict(TypedDict):
        sampling: _builtins.float
        """
        Determines what percentage of requests should be traced.
        """
        custom_tags: NotRequired[Mapping[str, _builtins.str]]
        """
        Key-value map of custom tags.
        """
elif False:
    GetGvcControlplaneTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcControlplaneTracingArgs:
    def __init__(__self__, *,
                 sampling: _builtins.float,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, _builtins.str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> _builtins.float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: _builtins.float):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GetGvcKedaArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Enable KEDA for this GVC. KEDA is a Kubernetes-based event-driven autoscaler that allows you to scale workloads based on external events. When enabled, a keda operator will be deployed in the GVC and workloads in the GVC can use KEDA to scale based on external metrics.
        """
        identity_link: NotRequired[_builtins.str]
        """
        A link to an Identity resource that will be used for KEDA. This will allow the keda operator to access cloud and network resources.
        """
        secrets: NotRequired[Sequence[_builtins.str]]
        """
        A list of secrets to be used as TriggerAuthentication objects. The TriggerAuthentication object will be named after the secret and can be used by triggers on workloads in this GVC.
        """
elif False:
    GetGvcKedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcKedaArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 identity_link: Optional[_builtins.str] = None,
                 secrets: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enabled: Enable KEDA for this GVC. KEDA is a Kubernetes-based event-driven autoscaler that allows you to scale workloads based on external events. When enabled, a keda operator will be deployed in the GVC and workloads in the GVC can use KEDA to scale based on external metrics.
        :param _builtins.str identity_link: A link to an Identity resource that will be used for KEDA. This will allow the keda operator to access cloud and network resources.
        :param Sequence[_builtins.str] secrets: A list of secrets to be used as TriggerAuthentication objects. The TriggerAuthentication object will be named after the secret and can be used by triggers on workloads in this GVC.
        """
        pulumi.set(__self__, "enabled", enabled)
        if identity_link is not None:
            pulumi.set(__self__, "identity_link", identity_link)
        if secrets is not None:
            pulumi.set(__self__, "secrets", secrets)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Enable KEDA for this GVC. KEDA is a Kubernetes-based event-driven autoscaler that allows you to scale workloads based on external events. When enabled, a keda operator will be deployed in the GVC and workloads in the GVC can use KEDA to scale based on external metrics.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="identityLink")
    def identity_link(self) -> Optional[_builtins.str]:
        """
        A link to an Identity resource that will be used for KEDA. This will allow the keda operator to access cloud and network resources.
        """
        return pulumi.get(self, "identity_link")

    @identity_link.setter
    def identity_link(self, value: Optional[_builtins.str]):
        pulumi.set(self, "identity_link", value)

    @_builtins.property
    @pulumi.getter
    def secrets(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of secrets to be used as TriggerAuthentication objects. The TriggerAuthentication object will be named after the secret and can be used by triggers on workloads in this GVC.
        """
        return pulumi.get(self, "secrets")

    @secrets.setter
    def secrets(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "secrets", value)


if not MYPY:
    class GetGvcLightstepTracingArgsDict(TypedDict):
        endpoint: _builtins.str
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        sampling: _builtins.float
        """
        Determines what percentage of requests should be traced.
        """
        credentials: NotRequired[_builtins.str]
        """
        Full link to referenced Opaque Secret.
        """
        custom_tags: NotRequired[Mapping[str, _builtins.str]]
        """
        Key-value map of custom tags.
        """
elif False:
    GetGvcLightstepTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcLightstepTracingArgs:
    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 sampling: _builtins.float,
                 credentials: Optional[_builtins.str] = None,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param _builtins.float sampling: Determines what percentage of requests should be traced.
        :param _builtins.str credentials: Full link to referenced Opaque Secret.
        :param Mapping[str, _builtins.str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if credentials is not None:
            pulumi.set(__self__, "credentials", credentials)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: _builtins.str):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> _builtins.float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: _builtins.float):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter
    def credentials(self) -> Optional[_builtins.str]:
        """
        Full link to referenced Opaque Secret.
        """
        return pulumi.get(self, "credentials")

    @credentials.setter
    def credentials(self, value: Optional[_builtins.str]):
        pulumi.set(self, "credentials", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GetGvcLoadBalancerArgsDict(TypedDict):
        trusted_proxies: _builtins.int
        """
        Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        dedicated: NotRequired[_builtins.bool]
        """
        Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        """
        ipset: NotRequired[_builtins.str]
        """
        The link or the name of the IP Set that will be used for this load balancer.
        """
        multi_zone: NotRequired['GetGvcLoadBalancerMultiZoneArgsDict']
        redirect: NotRequired['GetGvcLoadBalancerRedirectArgsDict']
        """
        Specify the url to be redirected to for different http status codes.
        """
elif False:
    GetGvcLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcLoadBalancerArgs:
    def __init__(__self__, *,
                 trusted_proxies: _builtins.int,
                 dedicated: Optional[_builtins.bool] = None,
                 ipset: Optional[_builtins.str] = None,
                 multi_zone: Optional['GetGvcLoadBalancerMultiZoneArgs'] = None,
                 redirect: Optional['GetGvcLoadBalancerRedirectArgs'] = None):
        """
        :param _builtins.int trusted_proxies: Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        :param _builtins.bool dedicated: Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        :param _builtins.str ipset: The link or the name of the IP Set that will be used for this load balancer.
        :param 'GetGvcLoadBalancerRedirectArgs' redirect: Specify the url to be redirected to for different http status codes.
        """
        pulumi.set(__self__, "trusted_proxies", trusted_proxies)
        if dedicated is not None:
            pulumi.set(__self__, "dedicated", dedicated)
        if ipset is not None:
            pulumi.set(__self__, "ipset", ipset)
        if multi_zone is not None:
            pulumi.set(__self__, "multi_zone", multi_zone)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter(name="trustedProxies")
    def trusted_proxies(self) -> _builtins.int:
        """
        Controls the address used for request logging and for setting the X-Envoy-External-Address header. If set to 1, then the last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If set to 2, then the second to last address in an existing X-Forwarded-For header will be used in place of the source client IP address. If the XFF header does not have at least two addresses or does not exist then the source client IP address will be used instead.
        """
        return pulumi.get(self, "trusted_proxies")

    @trusted_proxies.setter
    def trusted_proxies(self, value: _builtins.int):
        pulumi.set(self, "trusted_proxies", value)

    @_builtins.property
    @pulumi.getter
    def dedicated(self) -> Optional[_builtins.bool]:
        """
        Creates a dedicated load balancer in each location and enables additional Domain features: custom ports, protocols and wildcard hostnames. Charges apply for each location.
        """
        return pulumi.get(self, "dedicated")

    @dedicated.setter
    def dedicated(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "dedicated", value)

    @_builtins.property
    @pulumi.getter
    def ipset(self) -> Optional[_builtins.str]:
        """
        The link or the name of the IP Set that will be used for this load balancer.
        """
        return pulumi.get(self, "ipset")

    @ipset.setter
    def ipset(self, value: Optional[_builtins.str]):
        pulumi.set(self, "ipset", value)

    @_builtins.property
    @pulumi.getter(name="multiZone")
    def multi_zone(self) -> Optional['GetGvcLoadBalancerMultiZoneArgs']:
        return pulumi.get(self, "multi_zone")

    @multi_zone.setter
    def multi_zone(self, value: Optional['GetGvcLoadBalancerMultiZoneArgs']):
        pulumi.set(self, "multi_zone", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional['GetGvcLoadBalancerRedirectArgs']:
        """
        Specify the url to be redirected to for different http status codes.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional['GetGvcLoadBalancerRedirectArgs']):
        pulumi.set(self, "redirect", value)


if not MYPY:
    class GetGvcLoadBalancerMultiZoneArgsDict(TypedDict):
        enabled: _builtins.bool
elif False:
    GetGvcLoadBalancerMultiZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcLoadBalancerMultiZoneArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetGvcLoadBalancerRedirectArgsDict(TypedDict):
        class_: NotRequired['GetGvcLoadBalancerRedirectClassArgsDict']
        """
        Specify the redirect url for all status codes in a class.
        """
elif False:
    GetGvcLoadBalancerRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcLoadBalancerRedirectArgs:
    def __init__(__self__, *,
                 class_: Optional['GetGvcLoadBalancerRedirectClassArgs'] = None):
        """
        :param 'GetGvcLoadBalancerRedirectClassArgs' class_: Specify the redirect url for all status codes in a class.
        """
        if class_ is not None:
            pulumi.set(__self__, "class_", class_)

    @_builtins.property
    @pulumi.getter(name="class")
    def class_(self) -> Optional['GetGvcLoadBalancerRedirectClassArgs']:
        """
        Specify the redirect url for all status codes in a class.
        """
        return pulumi.get(self, "class_")

    @class_.setter
    def class_(self, value: Optional['GetGvcLoadBalancerRedirectClassArgs']):
        pulumi.set(self, "class_", value)


if not MYPY:
    class GetGvcLoadBalancerRedirectClassArgsDict(TypedDict):
        status401: NotRequired[_builtins.str]
        """
        An optional url redirect for 401 responses. Supports envoy format strings to include request information. E.g. https://your-oauth-server/oauth2/authorize?return_to=%REQ(:path)%&client_id=your-client-id
        """
        status5xx: NotRequired[_builtins.str]
        """
        Specify the redirect url for any 500 level status code.
        """
elif False:
    GetGvcLoadBalancerRedirectClassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcLoadBalancerRedirectClassArgs:
    def __init__(__self__, *,
                 status401: Optional[_builtins.str] = None,
                 status5xx: Optional[_builtins.str] = None):
        """
        :param _builtins.str status401: An optional url redirect for 401 responses. Supports envoy format strings to include request information. E.g. https://your-oauth-server/oauth2/authorize?return_to=%REQ(:path)%&client_id=your-client-id
        :param _builtins.str status5xx: Specify the redirect url for any 500 level status code.
        """
        if status401 is not None:
            pulumi.set(__self__, "status401", status401)
        if status5xx is not None:
            pulumi.set(__self__, "status5xx", status5xx)

    @_builtins.property
    @pulumi.getter
    def status401(self) -> Optional[_builtins.str]:
        """
        An optional url redirect for 401 responses. Supports envoy format strings to include request information. E.g. https://your-oauth-server/oauth2/authorize?return_to=%REQ(:path)%&client_id=your-client-id
        """
        return pulumi.get(self, "status401")

    @status401.setter
    def status401(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status401", value)

    @_builtins.property
    @pulumi.getter
    def status5xx(self) -> Optional[_builtins.str]:
        """
        Specify the redirect url for any 500 level status code.
        """
        return pulumi.get(self, "status5xx")

    @status5xx.setter
    def status5xx(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status5xx", value)


if not MYPY:
    class GetGvcOtelTracingArgsDict(TypedDict):
        endpoint: _builtins.str
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        sampling: _builtins.float
        """
        Determines what percentage of requests should be traced.
        """
        custom_tags: NotRequired[Mapping[str, _builtins.str]]
        """
        Key-value map of custom tags.
        """
elif False:
    GetGvcOtelTracingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcOtelTracingArgs:
    def __init__(__self__, *,
                 endpoint: _builtins.str,
                 sampling: _builtins.float,
                 custom_tags: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str endpoint: Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        :param _builtins.float sampling: Determines what percentage of requests should be traced.
        :param Mapping[str, _builtins.str] custom_tags: Key-value map of custom tags.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "sampling", sampling)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Tracing Endpoint Workload. Either the canonical endpoint or internal endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: _builtins.str):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def sampling(self) -> _builtins.float:
        """
        Determines what percentage of requests should be traced.
        """
        return pulumi.get(self, "sampling")

    @sampling.setter
    def sampling(self, value: _builtins.float):
        pulumi.set(self, "sampling", value)

    @_builtins.property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Key-value map of custom tags.
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[Mapping[str, _builtins.str]]):
        pulumi.set(self, "custom_tags", value)


if not MYPY:
    class GetGvcSidecarArgsDict(TypedDict):
        envoy: _builtins.str
elif False:
    GetGvcSidecarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGvcSidecarArgs:
    def __init__(__self__, *,
                 envoy: _builtins.str):
        pulumi.set(__self__, "envoy", envoy)

    @_builtins.property
    @pulumi.getter
    def envoy(self) -> _builtins.str:
        return pulumi.get(self, "envoy")

    @envoy.setter
    def envoy(self, value: _builtins.str):
        pulumi.set(self, "envoy", value)


if not MYPY:
    class GetImagesQueryArgsDict(TypedDict):
        fetch: _builtins.str
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        spec: NotRequired['GetImagesQuerySpecArgsDict']
        """
        The specification of the query.
        """
elif False:
    GetImagesQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesQueryArgs:
    def __init__(__self__, *,
                 fetch: _builtins.str,
                 spec: Optional['GetImagesQuerySpecArgs'] = None):
        """
        :param _builtins.str fetch: Type of fetch. Specify either: `links` or `items`. Default: `items`.
        :param 'GetImagesQuerySpecArgs' spec: The specification of the query.
        """
        pulumi.set(__self__, "fetch", fetch)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)

    @_builtins.property
    @pulumi.getter
    def fetch(self) -> _builtins.str:
        """
        Type of fetch. Specify either: `links` or `items`. Default: `items`.
        """
        return pulumi.get(self, "fetch")

    @fetch.setter
    def fetch(self, value: _builtins.str):
        pulumi.set(self, "fetch", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['GetImagesQuerySpecArgs']:
        """
        The specification of the query.
        """
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional['GetImagesQuerySpecArgs']):
        pulumi.set(self, "spec", value)


if not MYPY:
    class GetImagesQuerySpecArgsDict(TypedDict):
        match: _builtins.str
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        terms: NotRequired[Sequence['GetImagesQuerySpecTermArgsDict']]
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
elif False:
    GetImagesQuerySpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesQuerySpecArgs:
    def __init__(__self__, *,
                 match: _builtins.str,
                 terms: Optional[Sequence['GetImagesQuerySpecTermArgs']] = None):
        """
        :param _builtins.str match: Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        :param Sequence['GetImagesQuerySpecTermArgs'] terms: Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        pulumi.set(__self__, "match", match)
        if terms is not None:
            pulumi.set(__self__, "terms", terms)

    @_builtins.property
    @pulumi.getter
    def match(self) -> _builtins.str:
        """
        Type of match. Available values: `all`, `any`, `none`. Default: `all`.
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: _builtins.str):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def terms(self) -> Optional[Sequence['GetImagesQuerySpecTermArgs']]:
        """
        Terms can only contain one of the following attributes: `property`, `rel`, `tag`.
        """
        return pulumi.get(self, "terms")

    @terms.setter
    def terms(self, value: Optional[Sequence['GetImagesQuerySpecTermArgs']]):
        pulumi.set(self, "terms", value)


if not MYPY:
    class GetImagesQuerySpecTermArgsDict(TypedDict):
        op: _builtins.str
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        property: NotRequired[_builtins.str]
        """
        Property to use for query evaluation.
        """
        rel: NotRequired[_builtins.str]
        """
        Relation to use for query evaluation.
        """
        tag: NotRequired[_builtins.str]
        """
        Tag key to use for query evaluation.
        """
        value: NotRequired[_builtins.str]
        """
        Testing value for query evaluation.
        """
elif False:
    GetImagesQuerySpecTermArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesQuerySpecTermArgs:
    def __init__(__self__, *,
                 op: _builtins.str,
                 property: Optional[_builtins.str] = None,
                 rel: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str op: Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        :param _builtins.str property: Property to use for query evaluation.
        :param _builtins.str rel: Relation to use for query evaluation.
        :param _builtins.str tag: Tag key to use for query evaluation.
        :param _builtins.str value: Testing value for query evaluation.
        """
        pulumi.set(__self__, "op", op)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if rel is not None:
            pulumi.set(__self__, "rel", rel)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def op(self) -> _builtins.str:
        """
        Type of query operation. Available values: `=`, `>`, `>=`, `<`, `<=`, `!=`, `exists`, `!exists`. Default: `=`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: _builtins.str):
        pulumi.set(self, "op", value)

    @_builtins.property
    @pulumi.getter
    def property(self) -> Optional[_builtins.str]:
        """
        Property to use for query evaluation.
        """
        return pulumi.get(self, "property")

    @property.setter
    def property(self, value: Optional[_builtins.str]):
        pulumi.set(self, "property", value)

    @_builtins.property
    @pulumi.getter
    def rel(self) -> Optional[_builtins.str]:
        """
        Relation to use for query evaluation.
        """
        return pulumi.get(self, "rel")

    @rel.setter
    def rel(self, value: Optional[_builtins.str]):
        pulumi.set(self, "rel", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        Tag key to use for query evaluation.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[_builtins.str]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Testing value for query evaluation.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class GetOrgAuthConfigArgsDict(TypedDict):
        domain_auto_members: Sequence[_builtins.str]
        """
        List of domains which will auto-provision users when authenticating using SAML.
        """
        saml_only: _builtins.bool
        """
        Enforce SAML only authentication.
        """
elif False:
    GetOrgAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrgAuthConfigArgs:
    def __init__(__self__, *,
                 domain_auto_members: Sequence[_builtins.str],
                 saml_only: _builtins.bool):
        """
        :param Sequence[_builtins.str] domain_auto_members: List of domains which will auto-provision users when authenticating using SAML.
        :param _builtins.bool saml_only: Enforce SAML only authentication.
        """
        pulumi.set(__self__, "domain_auto_members", domain_auto_members)
        pulumi.set(__self__, "saml_only", saml_only)

    @_builtins.property
    @pulumi.getter(name="domainAutoMembers")
    def domain_auto_members(self) -> Sequence[_builtins.str]:
        """
        List of domains which will auto-provision users when authenticating using SAML.
        """
        return pulumi.get(self, "domain_auto_members")

    @domain_auto_members.setter
    def domain_auto_members(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "domain_auto_members", value)

    @_builtins.property
    @pulumi.getter(name="samlOnly")
    def saml_only(self) -> _builtins.bool:
        """
        Enforce SAML only authentication.
        """
        return pulumi.get(self, "saml_only")

    @saml_only.setter
    def saml_only(self, value: _builtins.bool):
        pulumi.set(self, "saml_only", value)


if not MYPY:
    class GetOrgObservabilityArgsDict(TypedDict):
        default_alert_emails: Sequence[_builtins.str]
        """
        These emails are configured as alert recipients in Grafana when the 'grafana-default-email' contact delivery type is 'Email'.
        """
        logs_retention_days: _builtins.int
        """
        Log retention days. Default: 30
        """
        metrics_retention_days: _builtins.int
        """
        Metrics retention days. Default: 30
        """
        traces_retention_days: _builtins.int
        """
        Traces retention days. Default: 30
        """
elif False:
    GetOrgObservabilityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrgObservabilityArgs:
    def __init__(__self__, *,
                 default_alert_emails: Sequence[_builtins.str],
                 logs_retention_days: _builtins.int,
                 metrics_retention_days: _builtins.int,
                 traces_retention_days: _builtins.int):
        """
        :param Sequence[_builtins.str] default_alert_emails: These emails are configured as alert recipients in Grafana when the 'grafana-default-email' contact delivery type is 'Email'.
        :param _builtins.int logs_retention_days: Log retention days. Default: 30
        :param _builtins.int metrics_retention_days: Metrics retention days. Default: 30
        :param _builtins.int traces_retention_days: Traces retention days. Default: 30
        """
        pulumi.set(__self__, "default_alert_emails", default_alert_emails)
        pulumi.set(__self__, "logs_retention_days", logs_retention_days)
        pulumi.set(__self__, "metrics_retention_days", metrics_retention_days)
        pulumi.set(__self__, "traces_retention_days", traces_retention_days)

    @_builtins.property
    @pulumi.getter(name="defaultAlertEmails")
    def default_alert_emails(self) -> Sequence[_builtins.str]:
        """
        These emails are configured as alert recipients in Grafana when the 'grafana-default-email' contact delivery type is 'Email'.
        """
        return pulumi.get(self, "default_alert_emails")

    @default_alert_emails.setter
    def default_alert_emails(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "default_alert_emails", value)

    @_builtins.property
    @pulumi.getter(name="logsRetentionDays")
    def logs_retention_days(self) -> _builtins.int:
        """
        Log retention days. Default: 30
        """
        return pulumi.get(self, "logs_retention_days")

    @logs_retention_days.setter
    def logs_retention_days(self, value: _builtins.int):
        pulumi.set(self, "logs_retention_days", value)

    @_builtins.property
    @pulumi.getter(name="metricsRetentionDays")
    def metrics_retention_days(self) -> _builtins.int:
        """
        Metrics retention days. Default: 30
        """
        return pulumi.get(self, "metrics_retention_days")

    @metrics_retention_days.setter
    def metrics_retention_days(self, value: _builtins.int):
        pulumi.set(self, "metrics_retention_days", value)

    @_builtins.property
    @pulumi.getter(name="tracesRetentionDays")
    def traces_retention_days(self) -> _builtins.int:
        """
        Traces retention days. Default: 30
        """
        return pulumi.get(self, "traces_retention_days")

    @traces_retention_days.setter
    def traces_retention_days(self, value: _builtins.int):
        pulumi.set(self, "traces_retention_days", value)


if not MYPY:
    class GetOrgSecurityArgsDict(TypedDict):
        threat_detection: NotRequired['GetOrgSecurityThreatDetectionArgsDict']
elif False:
    GetOrgSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrgSecurityArgs:
    def __init__(__self__, *,
                 threat_detection: Optional['GetOrgSecurityThreatDetectionArgs'] = None):
        if threat_detection is not None:
            pulumi.set(__self__, "threat_detection", threat_detection)

    @_builtins.property
    @pulumi.getter(name="threatDetection")
    def threat_detection(self) -> Optional['GetOrgSecurityThreatDetectionArgs']:
        return pulumi.get(self, "threat_detection")

    @threat_detection.setter
    def threat_detection(self, value: Optional['GetOrgSecurityThreatDetectionArgs']):
        pulumi.set(self, "threat_detection", value)


if not MYPY:
    class GetOrgSecurityThreatDetectionArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        Indicates whether threat detection should be forwarded or not.
        """
        minimum_severity: NotRequired[_builtins.str]
        """
        Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        """
        syslog: NotRequired['GetOrgSecurityThreatDetectionSyslogArgsDict']
        """
        Configuration for syslog forwarding.
        """
elif False:
    GetOrgSecurityThreatDetectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrgSecurityThreatDetectionArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 minimum_severity: Optional[_builtins.str] = None,
                 syslog: Optional['GetOrgSecurityThreatDetectionSyslogArgs'] = None):
        """
        :param _builtins.bool enabled: Indicates whether threat detection should be forwarded or not.
        :param _builtins.str minimum_severity: Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        :param 'GetOrgSecurityThreatDetectionSyslogArgs' syslog: Configuration for syslog forwarding.
        """
        pulumi.set(__self__, "enabled", enabled)
        if minimum_severity is not None:
            pulumi.set(__self__, "minimum_severity", minimum_severity)
        if syslog is not None:
            pulumi.set(__self__, "syslog", syslog)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Indicates whether threat detection should be forwarded or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="minimumSeverity")
    def minimum_severity(self) -> Optional[_builtins.str]:
        """
        Any threats with this severity and more severe will be sent. Others will be ignored. Valid values: `warning`, `error`, or `critical`.
        """
        return pulumi.get(self, "minimum_severity")

    @minimum_severity.setter
    def minimum_severity(self, value: Optional[_builtins.str]):
        pulumi.set(self, "minimum_severity", value)

    @_builtins.property
    @pulumi.getter
    def syslog(self) -> Optional['GetOrgSecurityThreatDetectionSyslogArgs']:
        """
        Configuration for syslog forwarding.
        """
        return pulumi.get(self, "syslog")

    @syslog.setter
    def syslog(self, value: Optional['GetOrgSecurityThreatDetectionSyslogArgs']):
        pulumi.set(self, "syslog", value)


if not MYPY:
    class GetOrgSecurityThreatDetectionSyslogArgsDict(TypedDict):
        host: _builtins.str
        """
        The hostname to send syslog messages to.
        """
        port: _builtins.int
        """
        The port to send syslog messages to.
        """
        transport: _builtins.str
        """
        The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
elif False:
    GetOrgSecurityThreatDetectionSyslogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetOrgSecurityThreatDetectionSyslogArgs:
    def __init__(__self__, *,
                 host: _builtins.str,
                 port: _builtins.int,
                 transport: _builtins.str):
        """
        :param _builtins.str host: The hostname to send syslog messages to.
        :param _builtins.int port: The port to send syslog messages to.
        :param _builtins.str transport: The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "transport", transport)

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The hostname to send syslog messages to.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: _builtins.str):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port to send syslog messages to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def transport(self) -> _builtins.str:
        """
        The transport-layer protocol to send the syslog messages over. If TCP is chosen, messages will be sent with TLS. Default: `tcp`.
        """
        return pulumi.get(self, "transport")

    @transport.setter
    def transport(self, value: _builtins.str):
        pulumi.set(self, "transport", value)


if not MYPY:
    class GetSecretAwArgsDict(TypedDict):
        access_key: _builtins.str
        """
        Access Key provided by AWS.
        """
        external_id: _builtins.str
        """
        AWS IAM Role External ID.
        """
        role_arn: _builtins.str
        """
        Role ARN provided by AWS.
        """
        secret_key: _builtins.str
        """
        Secret Key provided by AWS.
        """
elif False:
    GetSecretAwArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretAwArgs:
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 external_id: _builtins.str,
                 role_arn: _builtins.str,
                 secret_key: _builtins.str):
        """
        :param _builtins.str access_key: Access Key provided by AWS.
        :param _builtins.str external_id: AWS IAM Role External ID.
        :param _builtins.str role_arn: Role ARN provided by AWS.
        :param _builtins.str secret_key: Secret Key provided by AWS.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "external_id", external_id)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: _builtins.str):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> _builtins.str:
        """
        AWS IAM Role External ID.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: _builtins.str):
        pulumi.set(self, "external_id", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: _builtins.str):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: _builtins.str):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class GetSecretAzureConnectorArgsDict(TypedDict):
        code: _builtins.str
        """
        Code/Key to authenticate to deployment URL.
        """
        url: _builtins.str
        """
        Deployment URL.
        """
elif False:
    GetSecretAzureConnectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretAzureConnectorArgs:
    def __init__(__self__, *,
                 code: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str code: Code/Key to authenticate to deployment URL.
        :param _builtins.str url: Deployment URL.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Code/Key to authenticate to deployment URL.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: _builtins.str):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        Deployment URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: _builtins.str):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetSecretEcrArgsDict(TypedDict):
        access_key: _builtins.str
        """
        Access Key provided by AWS.
        """
        repos: Sequence[_builtins.str]
        """
        List of ECR repositories.
        """
        role_arn: _builtins.str
        """
        Role ARN provided by AWS.
        """
        secret_key: _builtins.str
        """
        Secret Key provided by AWS.
        """
        external_id: NotRequired[_builtins.str]
        """
        AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
elif False:
    GetSecretEcrArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretEcrArgs:
    def __init__(__self__, *,
                 access_key: _builtins.str,
                 repos: Sequence[_builtins.str],
                 role_arn: _builtins.str,
                 secret_key: _builtins.str,
                 external_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str access_key: Access Key provided by AWS.
        :param Sequence[_builtins.str] repos: List of ECR repositories.
        :param _builtins.str role_arn: Role ARN provided by AWS.
        :param _builtins.str secret_key: Secret Key provided by AWS.
        :param _builtins.str external_id: AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
        pulumi.set(__self__, "access_key", access_key)
        pulumi.set(__self__, "repos", repos)
        pulumi.set(__self__, "role_arn", role_arn)
        pulumi.set(__self__, "secret_key", secret_key)
        if external_id is not None:
            pulumi.set(__self__, "external_id", external_id)

    @_builtins.property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> _builtins.str:
        """
        Access Key provided by AWS.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: _builtins.str):
        pulumi.set(self, "access_key", value)

    @_builtins.property
    @pulumi.getter
    def repos(self) -> Sequence[_builtins.str]:
        """
        List of ECR repositories.
        """
        return pulumi.get(self, "repos")

    @repos.setter
    def repos(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "repos", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> _builtins.str:
        """
        Role ARN provided by AWS.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: _builtins.str):
        pulumi.set(self, "role_arn", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        Secret Key provided by AWS.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: _builtins.str):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter(name="externalId")
    def external_id(self) -> Optional[_builtins.str]:
        """
        AWS IAM Role External ID. Used when setting up cross-account access to your ECR repositories.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "external_id", value)


if not MYPY:
    class GetSecretKeypairArgsDict(TypedDict):
        passphrase: _builtins.str
        """
        Passphrase for private key.
        """
        public_key: _builtins.str
        """
        Public Key.
        """
        secret_key: _builtins.str
        """
        Secret/Private Key.
        """
elif False:
    GetSecretKeypairArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretKeypairArgs:
    def __init__(__self__, *,
                 passphrase: _builtins.str,
                 public_key: _builtins.str,
                 secret_key: _builtins.str):
        """
        :param _builtins.str passphrase: Passphrase for private key.
        :param _builtins.str public_key: Public Key.
        :param _builtins.str secret_key: Secret/Private Key.
        """
        pulumi.set(__self__, "passphrase", passphrase)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "secret_key", secret_key)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> _builtins.str:
        """
        Passphrase for private key.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: _builtins.str):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        """
        Public Key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: _builtins.str):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> _builtins.str:
        """
        Secret/Private Key.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: _builtins.str):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class GetSecretNatsAccountArgsDict(TypedDict):
        account_id: _builtins.str
        """
        Account ID.
        """
        private_key: _builtins.str
        """
        Private Key.
        """
elif False:
    GetSecretNatsAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretNatsAccountArgs:
    def __init__(__self__, *,
                 account_id: _builtins.str,
                 private_key: _builtins.str):
        """
        :param _builtins.str account_id: Account ID.
        :param _builtins.str private_key: Private Key.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "private_key", private_key)

    @_builtins.property
    @pulumi.getter(name="accountId")
    def account_id(self) -> _builtins.str:
        """
        Account ID.
        """
        return pulumi.get(self, "account_id")

    @account_id.setter
    def account_id(self, value: _builtins.str):
        pulumi.set(self, "account_id", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        """
        Private Key.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: _builtins.str):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class GetSecretOpaqueArgsDict(TypedDict):
        encoding: _builtins.str
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        payload: _builtins.str
        """
        Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
elif False:
    GetSecretOpaqueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretOpaqueArgs:
    def __init__(__self__, *,
                 encoding: _builtins.str,
                 payload: _builtins.str):
        """
        :param _builtins.str encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        :param _builtins.str payload: Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
        pulumi.set(__self__, "encoding", encoding)
        pulumi.set(__self__, "payload", payload)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> _builtins.str:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: _builtins.str):
        pulumi.set(self, "encoding", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> _builtins.str:
        """
        Plain text or base64 encoded string. Use `encoding` attribute to specify encoding.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: _builtins.str):
        pulumi.set(self, "payload", value)


if not MYPY:
    class GetSecretTlArgsDict(TypedDict):
        cert: _builtins.str
        """
        Public Certificate.
        """
        chain: _builtins.str
        """
        Chain Certificate.
        """
        key: _builtins.str
        """
        Private Certificate.
        """
elif False:
    GetSecretTlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretTlArgs:
    def __init__(__self__, *,
                 cert: _builtins.str,
                 chain: _builtins.str,
                 key: _builtins.str):
        """
        :param _builtins.str cert: Public Certificate.
        :param _builtins.str chain: Chain Certificate.
        :param _builtins.str key: Private Certificate.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "chain", chain)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        """
        Public Certificate.
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: _builtins.str):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter
    def chain(self) -> _builtins.str:
        """
        Chain Certificate.
        """
        return pulumi.get(self, "chain")

    @chain.setter
    def chain(self, value: _builtins.str):
        pulumi.set(self, "chain", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Private Certificate.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)


if not MYPY:
    class GetSecretUserpassArgsDict(TypedDict):
        encoding: _builtins.str
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        password: _builtins.str
        """
        Password.
        """
        username: _builtins.str
        """
        Username.
        """
elif False:
    GetSecretUserpassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSecretUserpassArgs:
    def __init__(__self__, *,
                 encoding: _builtins.str,
                 password: _builtins.str,
                 username: _builtins.str):
        """
        :param _builtins.str encoding: Available encodings: `plain`, `base64`. Default: `plain`.
        :param _builtins.str password: Password.
        :param _builtins.str username: Username.
        """
        pulumi.set(__self__, "encoding", encoding)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> _builtins.str:
        """
        Available encodings: `plain`, `base64`. Default: `plain`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: _builtins.str):
        pulumi.set(self, "encoding", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        Password.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: _builtins.str):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: _builtins.str):
        pulumi.set(self, "username", value)


if not MYPY:
    class GetWorkloadContainerArgsDict(TypedDict):
        args: Sequence[_builtins.str]
        """
        Command line arguments passed to the container at runtime. Replaces the CMD arguments of the running container. It is an ordered list.
        """
        command: _builtins.str
        """
        Override the entry point.
        """
        cpu: _builtins.str
        """
        Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        """
        env: Mapping[str, _builtins.str]
        """
        Name-Value list of environment variables.
        """
        image: _builtins.str
        """
        The full image and tag path.
        """
        inherit_env: _builtins.bool
        """
        Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        """
        memory: _builtins.str
        """
        Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        """
        min_cpu: _builtins.str
        """
        Minimum CPU when capacity AI is enabled.
        """
        min_memory: _builtins.str
        """
        Minimum memory when capacity AI is enabled.
        """
        name: _builtins.str
        """
        Name of the container.
        """
        port: _builtins.int
        """
        The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        """
        working_directory: _builtins.str
        """
        Override the working directory. Must be an absolute path.
        """
        gpu_customs: NotRequired[Sequence['GetWorkloadContainerGpuCustomArgsDict']]
        gpu_nvidias: NotRequired[Sequence['GetWorkloadContainerGpuNvidiaArgsDict']]
        """
        GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        """
        lifecycles: NotRequired[Sequence['GetWorkloadContainerLifecycleArgsDict']]
        """
        Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        """
        liveness_probes: NotRequired[Sequence['GetWorkloadContainerLivenessProbeArgsDict']]
        """
        Liveness Probe
        """
        metrics: NotRequired[Sequence['GetWorkloadContainerMetricArgsDict']]
        """
        [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        """
        ports: NotRequired[Sequence['GetWorkloadContainerPortArgsDict']]
        """
        Communication endpoints used by the workload to send and receive network traffic.
        """
        readiness_probes: NotRequired[Sequence['GetWorkloadContainerReadinessProbeArgsDict']]
        """
        Readiness Probe
        """
        volumes: NotRequired[Sequence['GetWorkloadContainerVolumeArgsDict']]
        """
        Mount Object Store (S3, GCS, AzureBlob) buckets as file system.
        """
elif False:
    GetWorkloadContainerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerArgs:
    def __init__(__self__, *,
                 args: Sequence[_builtins.str],
                 command: _builtins.str,
                 cpu: _builtins.str,
                 env: Mapping[str, _builtins.str],
                 image: _builtins.str,
                 inherit_env: _builtins.bool,
                 memory: _builtins.str,
                 min_cpu: _builtins.str,
                 min_memory: _builtins.str,
                 name: _builtins.str,
                 port: _builtins.int,
                 working_directory: _builtins.str,
                 gpu_customs: Optional[Sequence['GetWorkloadContainerGpuCustomArgs']] = None,
                 gpu_nvidias: Optional[Sequence['GetWorkloadContainerGpuNvidiaArgs']] = None,
                 lifecycles: Optional[Sequence['GetWorkloadContainerLifecycleArgs']] = None,
                 liveness_probes: Optional[Sequence['GetWorkloadContainerLivenessProbeArgs']] = None,
                 metrics: Optional[Sequence['GetWorkloadContainerMetricArgs']] = None,
                 ports: Optional[Sequence['GetWorkloadContainerPortArgs']] = None,
                 readiness_probes: Optional[Sequence['GetWorkloadContainerReadinessProbeArgs']] = None,
                 volumes: Optional[Sequence['GetWorkloadContainerVolumeArgs']] = None):
        """
        :param Sequence[_builtins.str] args: Command line arguments passed to the container at runtime. Replaces the CMD arguments of the running container. It is an ordered list.
        :param _builtins.str command: Override the entry point.
        :param _builtins.str cpu: Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        :param Mapping[str, _builtins.str] env: Name-Value list of environment variables.
        :param _builtins.str image: The full image and tag path.
        :param _builtins.bool inherit_env: Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        :param _builtins.str memory: Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        :param _builtins.str min_cpu: Minimum CPU when capacity AI is enabled.
        :param _builtins.str min_memory: Minimum memory when capacity AI is enabled.
        :param _builtins.str name: Name of the container.
        :param _builtins.int port: The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        :param _builtins.str working_directory: Override the working directory. Must be an absolute path.
        :param Sequence['GetWorkloadContainerGpuNvidiaArgs'] gpu_nvidias: GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        :param Sequence['GetWorkloadContainerLifecycleArgs'] lifecycles: Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        :param Sequence['GetWorkloadContainerLivenessProbeArgs'] liveness_probes: Liveness Probe
        :param Sequence['GetWorkloadContainerMetricArgs'] metrics: [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        :param Sequence['GetWorkloadContainerPortArgs'] ports: Communication endpoints used by the workload to send and receive network traffic.
        :param Sequence['GetWorkloadContainerReadinessProbeArgs'] readiness_probes: Readiness Probe
        :param Sequence['GetWorkloadContainerVolumeArgs'] volumes: Mount Object Store (S3, GCS, AzureBlob) buckets as file system.
        """
        pulumi.set(__self__, "args", args)
        pulumi.set(__self__, "command", command)
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "inherit_env", inherit_env)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "min_cpu", min_cpu)
        pulumi.set(__self__, "min_memory", min_memory)
        pulumi.set(__self__, "name", name)
        if port is not None:
            warnings.warn("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""", DeprecationWarning)
            pulumi.log.warn("""port is deprecated: The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "working_directory", working_directory)
        if gpu_customs is not None:
            pulumi.set(__self__, "gpu_customs", gpu_customs)
        if gpu_nvidias is not None:
            pulumi.set(__self__, "gpu_nvidias", gpu_nvidias)
        if lifecycles is not None:
            pulumi.set(__self__, "lifecycles", lifecycles)
        if liveness_probes is not None:
            pulumi.set(__self__, "liveness_probes", liveness_probes)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if readiness_probes is not None:
            pulumi.set(__self__, "readiness_probes", readiness_probes)
        if volumes is not None:
            pulumi.set(__self__, "volumes", volumes)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Sequence[_builtins.str]:
        """
        Command line arguments passed to the container at runtime. Replaces the CMD arguments of the running container. It is an ordered list.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter
    def command(self) -> _builtins.str:
        """
        Override the entry point.
        """
        return pulumi.get(self, "command")

    @command.setter
    def command(self, value: _builtins.str):
        pulumi.set(self, "command", value)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.str:
        """
        Reserved CPU of the workload when capacityAI is disabled. Maximum CPU when CapacityAI is enabled. Default: "50m".
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: _builtins.str):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def env(self) -> Mapping[str, _builtins.str]:
        """
        Name-Value list of environment variables.
        """
        return pulumi.get(self, "env")

    @env.setter
    def env(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "env", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The full image and tag path.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: _builtins.str):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="inheritEnv")
    def inherit_env(self) -> _builtins.bool:
        """
        Enables inheritance of GVC environment variables. A variable in spec.env will override a GVC variable with the same name.
        """
        return pulumi.get(self, "inherit_env")

    @inherit_env.setter
    def inherit_env(self, value: _builtins.bool):
        pulumi.set(self, "inherit_env", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.str:
        """
        Reserved memory of the workload when capacityAI is disabled. Maximum memory when CapacityAI is enabled. Default: "128Mi".
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: _builtins.str):
        pulumi.set(self, "memory", value)

    @_builtins.property
    @pulumi.getter(name="minCpu")
    def min_cpu(self) -> _builtins.str:
        """
        Minimum CPU when capacity AI is enabled.
        """
        return pulumi.get(self, "min_cpu")

    @min_cpu.setter
    def min_cpu(self, value: _builtins.str):
        pulumi.set(self, "min_cpu", value)

    @_builtins.property
    @pulumi.getter(name="minMemory")
    def min_memory(self) -> _builtins.str:
        """
        Minimum memory when capacity AI is enabled.
        """
        return pulumi.get(self, "min_memory")

    @min_memory.setter
    def min_memory(self, value: _builtins.str):
        pulumi.set(self, "min_memory", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the container.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""The 'port' attribute will be deprecated in the next major version. Use the 'ports' attribute instead.""")
    def port(self) -> _builtins.int:
        """
        The port the container exposes. Only one container is allowed to specify a port. Min: `80`. Max: `65535`. Used by `serverless` Workload type. **DEPRECATED - Use `ports`.**
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="workingDirectory")
    def working_directory(self) -> _builtins.str:
        """
        Override the working directory. Must be an absolute path.
        """
        return pulumi.get(self, "working_directory")

    @working_directory.setter
    def working_directory(self, value: _builtins.str):
        pulumi.set(self, "working_directory", value)

    @_builtins.property
    @pulumi.getter(name="gpuCustoms")
    def gpu_customs(self) -> Optional[Sequence['GetWorkloadContainerGpuCustomArgs']]:
        return pulumi.get(self, "gpu_customs")

    @gpu_customs.setter
    def gpu_customs(self, value: Optional[Sequence['GetWorkloadContainerGpuCustomArgs']]):
        pulumi.set(self, "gpu_customs", value)

    @_builtins.property
    @pulumi.getter(name="gpuNvidias")
    def gpu_nvidias(self) -> Optional[Sequence['GetWorkloadContainerGpuNvidiaArgs']]:
        """
        GPUs manufactured by NVIDIA, which are specialized hardware accelerators used to offload and accelerate computationally intensive tasks within the workload.
        """
        return pulumi.get(self, "gpu_nvidias")

    @gpu_nvidias.setter
    def gpu_nvidias(self, value: Optional[Sequence['GetWorkloadContainerGpuNvidiaArgs']]):
        pulumi.set(self, "gpu_nvidias", value)

    @_builtins.property
    @pulumi.getter
    def lifecycles(self) -> Optional[Sequence['GetWorkloadContainerLifecycleArgs']]:
        """
        Lifecycle [Reference Page](https://docs.controlplane.com/reference/workload#lifecycle).
        """
        return pulumi.get(self, "lifecycles")

    @lifecycles.setter
    def lifecycles(self, value: Optional[Sequence['GetWorkloadContainerLifecycleArgs']]):
        pulumi.set(self, "lifecycles", value)

    @_builtins.property
    @pulumi.getter(name="livenessProbes")
    def liveness_probes(self) -> Optional[Sequence['GetWorkloadContainerLivenessProbeArgs']]:
        """
        Liveness Probe
        """
        return pulumi.get(self, "liveness_probes")

    @liveness_probes.setter
    def liveness_probes(self, value: Optional[Sequence['GetWorkloadContainerLivenessProbeArgs']]):
        pulumi.set(self, "liveness_probes", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence['GetWorkloadContainerMetricArgs']]:
        """
        [Reference Page](https://docs.controlplane.com/reference/workload#metrics).
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: Optional[Sequence['GetWorkloadContainerMetricArgs']]):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['GetWorkloadContainerPortArgs']]:
        """
        Communication endpoints used by the workload to send and receive network traffic.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[Sequence['GetWorkloadContainerPortArgs']]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="readinessProbes")
    def readiness_probes(self) -> Optional[Sequence['GetWorkloadContainerReadinessProbeArgs']]:
        """
        Readiness Probe
        """
        return pulumi.get(self, "readiness_probes")

    @readiness_probes.setter
    def readiness_probes(self, value: Optional[Sequence['GetWorkloadContainerReadinessProbeArgs']]):
        pulumi.set(self, "readiness_probes", value)

    @_builtins.property
    @pulumi.getter
    def volumes(self) -> Optional[Sequence['GetWorkloadContainerVolumeArgs']]:
        """
        Mount Object Store (S3, GCS, AzureBlob) buckets as file system.
        """
        return pulumi.get(self, "volumes")

    @volumes.setter
    def volumes(self, value: Optional[Sequence['GetWorkloadContainerVolumeArgs']]):
        pulumi.set(self, "volumes", value)


if not MYPY:
    class GetWorkloadContainerGpuCustomArgsDict(TypedDict):
        quantity: _builtins.int
        """
        Number of GPUs.
        """
        resource: _builtins.str
        runtime_class: _builtins.str
elif False:
    GetWorkloadContainerGpuCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerGpuCustomArgs:
    def __init__(__self__, *,
                 quantity: _builtins.int,
                 resource: _builtins.str,
                 runtime_class: _builtins.str):
        """
        :param _builtins.int quantity: Number of GPUs.
        """
        pulumi.set(__self__, "quantity", quantity)
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "runtime_class", runtime_class)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> _builtins.int:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: _builtins.int):
        pulumi.set(self, "quantity", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: _builtins.str):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter(name="runtimeClass")
    def runtime_class(self) -> _builtins.str:
        return pulumi.get(self, "runtime_class")

    @runtime_class.setter
    def runtime_class(self, value: _builtins.str):
        pulumi.set(self, "runtime_class", value)


if not MYPY:
    class GetWorkloadContainerGpuNvidiaArgsDict(TypedDict):
        model: _builtins.str
        """
        GPU Model (i.e.: t4)
        """
        quantity: _builtins.int
        """
        Number of GPUs.
        """
elif False:
    GetWorkloadContainerGpuNvidiaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerGpuNvidiaArgs:
    def __init__(__self__, *,
                 model: _builtins.str,
                 quantity: _builtins.int):
        """
        :param _builtins.str model: GPU Model (i.e.: t4)
        :param _builtins.int quantity: Number of GPUs.
        """
        pulumi.set(__self__, "model", model)
        pulumi.set(__self__, "quantity", quantity)

    @_builtins.property
    @pulumi.getter
    def model(self) -> _builtins.str:
        """
        GPU Model (i.e.: t4)
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: _builtins.str):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def quantity(self) -> _builtins.int:
        """
        Number of GPUs.
        """
        return pulumi.get(self, "quantity")

    @quantity.setter
    def quantity(self, value: _builtins.int):
        pulumi.set(self, "quantity", value)


if not MYPY:
    class GetWorkloadContainerLifecycleArgsDict(TypedDict):
        post_starts: NotRequired[Sequence['GetWorkloadContainerLifecyclePostStartArgsDict']]
        pre_stops: NotRequired[Sequence['GetWorkloadContainerLifecyclePreStopArgsDict']]
elif False:
    GetWorkloadContainerLifecycleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLifecycleArgs:
    def __init__(__self__, *,
                 post_starts: Optional[Sequence['GetWorkloadContainerLifecyclePostStartArgs']] = None,
                 pre_stops: Optional[Sequence['GetWorkloadContainerLifecyclePreStopArgs']] = None):
        if post_starts is not None:
            pulumi.set(__self__, "post_starts", post_starts)
        if pre_stops is not None:
            pulumi.set(__self__, "pre_stops", pre_stops)

    @_builtins.property
    @pulumi.getter(name="postStarts")
    def post_starts(self) -> Optional[Sequence['GetWorkloadContainerLifecyclePostStartArgs']]:
        return pulumi.get(self, "post_starts")

    @post_starts.setter
    def post_starts(self, value: Optional[Sequence['GetWorkloadContainerLifecyclePostStartArgs']]):
        pulumi.set(self, "post_starts", value)

    @_builtins.property
    @pulumi.getter(name="preStops")
    def pre_stops(self) -> Optional[Sequence['GetWorkloadContainerLifecyclePreStopArgs']]:
        return pulumi.get(self, "pre_stops")

    @pre_stops.setter
    def pre_stops(self, value: Optional[Sequence['GetWorkloadContainerLifecyclePreStopArgs']]):
        pulumi.set(self, "pre_stops", value)


if not MYPY:
    class GetWorkloadContainerLifecyclePostStartArgsDict(TypedDict):
        execs: NotRequired[Sequence['GetWorkloadContainerLifecyclePostStartExecArgsDict']]
elif False:
    GetWorkloadContainerLifecyclePostStartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLifecyclePostStartArgs:
    def __init__(__self__, *,
                 execs: Optional[Sequence['GetWorkloadContainerLifecyclePostStartExecArgs']] = None):
        if execs is not None:
            pulumi.set(__self__, "execs", execs)

    @_builtins.property
    @pulumi.getter
    def execs(self) -> Optional[Sequence['GetWorkloadContainerLifecyclePostStartExecArgs']]:
        return pulumi.get(self, "execs")

    @execs.setter
    def execs(self, value: Optional[Sequence['GetWorkloadContainerLifecyclePostStartExecArgs']]):
        pulumi.set(self, "execs", value)


if not MYPY:
    class GetWorkloadContainerLifecyclePostStartExecArgsDict(TypedDict):
        commands: Sequence[_builtins.str]
        """
        Command and arguments executed immediately after the container is created.
        """
elif False:
    GetWorkloadContainerLifecyclePostStartExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLifecyclePostStartExecArgs:
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] commands: Command and arguments executed immediately after the container is created.
        """
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        """
        Command and arguments executed immediately after the container is created.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class GetWorkloadContainerLifecyclePreStopArgsDict(TypedDict):
        execs: NotRequired[Sequence['GetWorkloadContainerLifecyclePreStopExecArgsDict']]
elif False:
    GetWorkloadContainerLifecyclePreStopArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLifecyclePreStopArgs:
    def __init__(__self__, *,
                 execs: Optional[Sequence['GetWorkloadContainerLifecyclePreStopExecArgs']] = None):
        if execs is not None:
            pulumi.set(__self__, "execs", execs)

    @_builtins.property
    @pulumi.getter
    def execs(self) -> Optional[Sequence['GetWorkloadContainerLifecyclePreStopExecArgs']]:
        return pulumi.get(self, "execs")

    @execs.setter
    def execs(self, value: Optional[Sequence['GetWorkloadContainerLifecyclePreStopExecArgs']]):
        pulumi.set(self, "execs", value)


if not MYPY:
    class GetWorkloadContainerLifecyclePreStopExecArgsDict(TypedDict):
        commands: Sequence[_builtins.str]
        """
        Command and arguments executed immediately before the container is stopped.
        """
elif False:
    GetWorkloadContainerLifecyclePreStopExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLifecyclePreStopExecArgs:
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] commands: Command and arguments executed immediately before the container is stopped.
        """
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        """
        Command and arguments executed immediately before the container is stopped.
        """
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class GetWorkloadContainerLivenessProbeArgsDict(TypedDict):
        failure_threshold: _builtins.int
        initial_delay_seconds: _builtins.int
        period_seconds: _builtins.int
        success_threshold: _builtins.int
        timeout_seconds: _builtins.int
        execs: NotRequired[Sequence['GetWorkloadContainerLivenessProbeExecArgsDict']]
        grpcs: NotRequired[Sequence['GetWorkloadContainerLivenessProbeGrpcArgsDict']]
        http_gets: NotRequired[Sequence['GetWorkloadContainerLivenessProbeHttpGetArgsDict']]
        tcp_sockets: NotRequired[Sequence['GetWorkloadContainerLivenessProbeTcpSocketArgsDict']]
elif False:
    GetWorkloadContainerLivenessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLivenessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: _builtins.int,
                 initial_delay_seconds: _builtins.int,
                 period_seconds: _builtins.int,
                 success_threshold: _builtins.int,
                 timeout_seconds: _builtins.int,
                 execs: Optional[Sequence['GetWorkloadContainerLivenessProbeExecArgs']] = None,
                 grpcs: Optional[Sequence['GetWorkloadContainerLivenessProbeGrpcArgs']] = None,
                 http_gets: Optional[Sequence['GetWorkloadContainerLivenessProbeHttpGetArgs']] = None,
                 tcp_sockets: Optional[Sequence['GetWorkloadContainerLivenessProbeTcpSocketArgs']] = None):
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "success_threshold", success_threshold)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> _builtins.int:
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: _builtins.int):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> _builtins.int:
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: _builtins.int):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> _builtins.int:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: _builtins.int):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> _builtins.int:
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: _builtins.int):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: _builtins.int):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def execs(self) -> Optional[Sequence['GetWorkloadContainerLivenessProbeExecArgs']]:
        return pulumi.get(self, "execs")

    @execs.setter
    def execs(self, value: Optional[Sequence['GetWorkloadContainerLivenessProbeExecArgs']]):
        pulumi.set(self, "execs", value)

    @_builtins.property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['GetWorkloadContainerLivenessProbeGrpcArgs']]:
        return pulumi.get(self, "grpcs")

    @grpcs.setter
    def grpcs(self, value: Optional[Sequence['GetWorkloadContainerLivenessProbeGrpcArgs']]):
        pulumi.set(self, "grpcs", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[Sequence['GetWorkloadContainerLivenessProbeHttpGetArgs']]:
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[Sequence['GetWorkloadContainerLivenessProbeHttpGetArgs']]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['GetWorkloadContainerLivenessProbeTcpSocketArgs']]:
        return pulumi.get(self, "tcp_sockets")

    @tcp_sockets.setter
    def tcp_sockets(self, value: Optional[Sequence['GetWorkloadContainerLivenessProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_sockets", value)


if not MYPY:
    class GetWorkloadContainerLivenessProbeExecArgsDict(TypedDict):
        commands: Sequence[_builtins.str]
elif False:
    GetWorkloadContainerLivenessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLivenessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str]):
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class GetWorkloadContainerLivenessProbeGrpcArgsDict(TypedDict):
        port: _builtins.int
elif False:
    GetWorkloadContainerLivenessProbeGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLivenessProbeGrpcArgs:
    def __init__(__self__, *,
                 port: _builtins.int):
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetWorkloadContainerLivenessProbeHttpGetArgsDict(TypedDict):
        http_headers: Mapping[str, _builtins.str]
        path: _builtins.str
        port: _builtins.int
        scheme: _builtins.str
elif False:
    GetWorkloadContainerLivenessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLivenessProbeHttpGetArgs:
    def __init__(__self__, *,
                 http_headers: Mapping[str, _builtins.str],
                 path: _builtins.str,
                 port: _builtins.int,
                 scheme: _builtins.str):
        pulumi.set(__self__, "http_headers", http_headers)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> _builtins.str:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: _builtins.str):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class GetWorkloadContainerLivenessProbeTcpSocketArgsDict(TypedDict):
        port: _builtins.int
elif False:
    GetWorkloadContainerLivenessProbeTcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerLivenessProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: _builtins.int):
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetWorkloadContainerMetricArgsDict(TypedDict):
        drop_metrics: Sequence[_builtins.str]
        """
        Drop metrics that match given patterns.
        """
        path: _builtins.str
        """
        Path from container emitting custom metrics.
        """
        port: _builtins.int
        """
        Port from container emitting custom metrics.
        """
elif False:
    GetWorkloadContainerMetricArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerMetricArgs:
    def __init__(__self__, *,
                 drop_metrics: Sequence[_builtins.str],
                 path: _builtins.str,
                 port: _builtins.int):
        """
        :param Sequence[_builtins.str] drop_metrics: Drop metrics that match given patterns.
        :param _builtins.str path: Path from container emitting custom metrics.
        :param _builtins.int port: Port from container emitting custom metrics.
        """
        pulumi.set(__self__, "drop_metrics", drop_metrics)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter(name="dropMetrics")
    def drop_metrics(self) -> Sequence[_builtins.str]:
        """
        Drop metrics that match given patterns.
        """
        return pulumi.get(self, "drop_metrics")

    @drop_metrics.setter
    def drop_metrics(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "drop_metrics", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path from container emitting custom metrics.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        Port from container emitting custom metrics.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetWorkloadContainerPortArgsDict(TypedDict):
        number: _builtins.int
        """
        Port to expose.
        """
        protocol: _builtins.str
        """
        Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
elif False:
    GetWorkloadContainerPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerPortArgs:
    def __init__(__self__, *,
                 number: _builtins.int,
                 protocol: _builtins.str):
        """
        :param _builtins.int number: Port to expose.
        :param _builtins.str protocol: Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        Port to expose.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: _builtins.int):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Protocol. Choice of: `http`, `http2`, `tcp`, or `grpc`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class GetWorkloadContainerReadinessProbeArgsDict(TypedDict):
        failure_threshold: _builtins.int
        initial_delay_seconds: _builtins.int
        period_seconds: _builtins.int
        success_threshold: _builtins.int
        timeout_seconds: _builtins.int
        execs: NotRequired[Sequence['GetWorkloadContainerReadinessProbeExecArgsDict']]
        grpcs: NotRequired[Sequence['GetWorkloadContainerReadinessProbeGrpcArgsDict']]
        http_gets: NotRequired[Sequence['GetWorkloadContainerReadinessProbeHttpGetArgsDict']]
        tcp_sockets: NotRequired[Sequence['GetWorkloadContainerReadinessProbeTcpSocketArgsDict']]
elif False:
    GetWorkloadContainerReadinessProbeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerReadinessProbeArgs:
    def __init__(__self__, *,
                 failure_threshold: _builtins.int,
                 initial_delay_seconds: _builtins.int,
                 period_seconds: _builtins.int,
                 success_threshold: _builtins.int,
                 timeout_seconds: _builtins.int,
                 execs: Optional[Sequence['GetWorkloadContainerReadinessProbeExecArgs']] = None,
                 grpcs: Optional[Sequence['GetWorkloadContainerReadinessProbeGrpcArgs']] = None,
                 http_gets: Optional[Sequence['GetWorkloadContainerReadinessProbeHttpGetArgs']] = None,
                 tcp_sockets: Optional[Sequence['GetWorkloadContainerReadinessProbeTcpSocketArgs']] = None):
        pulumi.set(__self__, "failure_threshold", failure_threshold)
        pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        pulumi.set(__self__, "period_seconds", period_seconds)
        pulumi.set(__self__, "success_threshold", success_threshold)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if execs is not None:
            pulumi.set(__self__, "execs", execs)
        if grpcs is not None:
            pulumi.set(__self__, "grpcs", grpcs)
        if http_gets is not None:
            pulumi.set(__self__, "http_gets", http_gets)
        if tcp_sockets is not None:
            pulumi.set(__self__, "tcp_sockets", tcp_sockets)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> _builtins.int:
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: _builtins.int):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> _builtins.int:
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: _builtins.int):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> _builtins.int:
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: _builtins.int):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> _builtins.int:
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: _builtins.int):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: _builtins.int):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def execs(self) -> Optional[Sequence['GetWorkloadContainerReadinessProbeExecArgs']]:
        return pulumi.get(self, "execs")

    @execs.setter
    def execs(self, value: Optional[Sequence['GetWorkloadContainerReadinessProbeExecArgs']]):
        pulumi.set(self, "execs", value)

    @_builtins.property
    @pulumi.getter
    def grpcs(self) -> Optional[Sequence['GetWorkloadContainerReadinessProbeGrpcArgs']]:
        return pulumi.get(self, "grpcs")

    @grpcs.setter
    def grpcs(self, value: Optional[Sequence['GetWorkloadContainerReadinessProbeGrpcArgs']]):
        pulumi.set(self, "grpcs", value)

    @_builtins.property
    @pulumi.getter(name="httpGets")
    def http_gets(self) -> Optional[Sequence['GetWorkloadContainerReadinessProbeHttpGetArgs']]:
        return pulumi.get(self, "http_gets")

    @http_gets.setter
    def http_gets(self, value: Optional[Sequence['GetWorkloadContainerReadinessProbeHttpGetArgs']]):
        pulumi.set(self, "http_gets", value)

    @_builtins.property
    @pulumi.getter(name="tcpSockets")
    def tcp_sockets(self) -> Optional[Sequence['GetWorkloadContainerReadinessProbeTcpSocketArgs']]:
        return pulumi.get(self, "tcp_sockets")

    @tcp_sockets.setter
    def tcp_sockets(self, value: Optional[Sequence['GetWorkloadContainerReadinessProbeTcpSocketArgs']]):
        pulumi.set(self, "tcp_sockets", value)


if not MYPY:
    class GetWorkloadContainerReadinessProbeExecArgsDict(TypedDict):
        commands: Sequence[_builtins.str]
elif False:
    GetWorkloadContainerReadinessProbeExecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerReadinessProbeExecArgs:
    def __init__(__self__, *,
                 commands: Sequence[_builtins.str]):
        pulumi.set(__self__, "commands", commands)

    @_builtins.property
    @pulumi.getter
    def commands(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "commands")

    @commands.setter
    def commands(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "commands", value)


if not MYPY:
    class GetWorkloadContainerReadinessProbeGrpcArgsDict(TypedDict):
        port: _builtins.int
elif False:
    GetWorkloadContainerReadinessProbeGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerReadinessProbeGrpcArgs:
    def __init__(__self__, *,
                 port: _builtins.int):
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetWorkloadContainerReadinessProbeHttpGetArgsDict(TypedDict):
        http_headers: Mapping[str, _builtins.str]
        path: _builtins.str
        port: _builtins.int
        scheme: _builtins.str
elif False:
    GetWorkloadContainerReadinessProbeHttpGetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerReadinessProbeHttpGetArgs:
    def __init__(__self__, *,
                 http_headers: Mapping[str, _builtins.str],
                 path: _builtins.str,
                 port: _builtins.int,
                 scheme: _builtins.str):
        pulumi.set(__self__, "http_headers", http_headers)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="httpHeaders")
    def http_headers(self) -> Mapping[str, _builtins.str]:
        return pulumi.get(self, "http_headers")

    @http_headers.setter
    def http_headers(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "http_headers", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> _builtins.str:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: _builtins.str):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class GetWorkloadContainerReadinessProbeTcpSocketArgsDict(TypedDict):
        port: _builtins.int
elif False:
    GetWorkloadContainerReadinessProbeTcpSocketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerReadinessProbeTcpSocketArgs:
    def __init__(__self__, *,
                 port: _builtins.int):
        pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: _builtins.int):
        pulumi.set(self, "port", value)


if not MYPY:
    class GetWorkloadContainerVolumeArgsDict(TypedDict):
        path: _builtins.str
        """
        File path added to workload pointing to the volume.
        """
        recovery_policy: _builtins.str
        """
        Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
        uri: _builtins.str
        """
        URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        """
elif False:
    GetWorkloadContainerVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadContainerVolumeArgs:
    def __init__(__self__, *,
                 path: _builtins.str,
                 recovery_policy: _builtins.str,
                 uri: _builtins.str):
        """
        :param _builtins.str path: File path added to workload pointing to the volume.
        :param _builtins.str recovery_policy: Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        :param _builtins.str uri: URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "recovery_policy", recovery_policy)
        pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        File path added to workload pointing to the volume.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: _builtins.str):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="recoveryPolicy")
    def recovery_policy(self) -> _builtins.str:
        """
        Only applicable to persistent volumes, this determines what Control Plane will do when creating a new workload replica if a corresponding volume exists. Available Values: `retain`, `recycle`. Default: `retain`. **DEPRECATED - No longer being used.**
        """
        return pulumi.get(self, "recovery_policy")

    @recovery_policy.setter
    def recovery_policy(self, value: _builtins.str):
        pulumi.set(self, "recovery_policy", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> _builtins.str:
        """
        URI of a volume hosted at Control Plane (Volume Set) or at a cloud provider (AWS, Azure, GCP).
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: _builtins.str):
        pulumi.set(self, "uri", value)


if not MYPY:
    class GetWorkloadFirewallSpecArgsDict(TypedDict):
        externals: NotRequired[Sequence['GetWorkloadFirewallSpecExternalArgsDict']]
        """
        The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        """
        internals: NotRequired[Sequence['GetWorkloadFirewallSpecInternalArgsDict']]
        """
        The internal firewall is used to control access between workloads.
        """
elif False:
    GetWorkloadFirewallSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadFirewallSpecArgs:
    def __init__(__self__, *,
                 externals: Optional[Sequence['GetWorkloadFirewallSpecExternalArgs']] = None,
                 internals: Optional[Sequence['GetWorkloadFirewallSpecInternalArgs']] = None):
        """
        :param Sequence['GetWorkloadFirewallSpecExternalArgs'] externals: The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        :param Sequence['GetWorkloadFirewallSpecInternalArgs'] internals: The internal firewall is used to control access between workloads.
        """
        if externals is not None:
            pulumi.set(__self__, "externals", externals)
        if internals is not None:
            pulumi.set(__self__, "internals", internals)

    @_builtins.property
    @pulumi.getter
    def externals(self) -> Optional[Sequence['GetWorkloadFirewallSpecExternalArgs']]:
        """
        The external firewall is used to control inbound and outbound access to the workload for public-facing traffic.
        """
        return pulumi.get(self, "externals")

    @externals.setter
    def externals(self, value: Optional[Sequence['GetWorkloadFirewallSpecExternalArgs']]):
        pulumi.set(self, "externals", value)

    @_builtins.property
    @pulumi.getter
    def internals(self) -> Optional[Sequence['GetWorkloadFirewallSpecInternalArgs']]:
        """
        The internal firewall is used to control access between workloads.
        """
        return pulumi.get(self, "internals")

    @internals.setter
    def internals(self, value: Optional[Sequence['GetWorkloadFirewallSpecInternalArgs']]):
        pulumi.set(self, "internals", value)


if not MYPY:
    class GetWorkloadFirewallSpecExternalArgsDict(TypedDict):
        inbound_allow_cidrs: Sequence[_builtins.str]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        """
        inbound_blocked_cidrs: Sequence[_builtins.str]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are NOT allowed to access this workload. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        outbound_allow_cidrs: Sequence[_builtins.str]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        """
        outbound_allow_hostnames: Sequence[_builtins.str]
        """
        The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        """
        outbound_blocked_cidrs: Sequence[_builtins.str]
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is NOT allowed to reach. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        https: NotRequired[Sequence['GetWorkloadFirewallSpecExternalHttpArgsDict']]
        """
        Firewall options for HTTP workloads.
        """
        outbound_allow_ports: NotRequired[Sequence['GetWorkloadFirewallSpecExternalOutboundAllowPortArgsDict']]
        """
        Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
elif False:
    GetWorkloadFirewallSpecExternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadFirewallSpecExternalArgs:
    def __init__(__self__, *,
                 inbound_allow_cidrs: Sequence[_builtins.str],
                 inbound_blocked_cidrs: Sequence[_builtins.str],
                 outbound_allow_cidrs: Sequence[_builtins.str],
                 outbound_allow_hostnames: Sequence[_builtins.str],
                 outbound_blocked_cidrs: Sequence[_builtins.str],
                 https: Optional[Sequence['GetWorkloadFirewallSpecExternalHttpArgs']] = None,
                 outbound_allow_ports: Optional[Sequence['GetWorkloadFirewallSpecExternalOutboundAllowPortArgs']] = None):
        """
        :param Sequence[_builtins.str] inbound_allow_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        :param Sequence[_builtins.str] inbound_blocked_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that are NOT allowed to access this workload. Addresses in the allow list will only be allowed if they do not exist in this list.
        :param Sequence[_builtins.str] outbound_allow_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        :param Sequence[_builtins.str] outbound_allow_hostnames: The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        :param Sequence[_builtins.str] outbound_blocked_cidrs: The list of ipv4/ipv6 addresses or cidr blocks that this workload is NOT allowed to reach. Addresses in the allow list will only be allowed if they do not exist in this list.
        :param Sequence['GetWorkloadFirewallSpecExternalHttpArgs'] https: Firewall options for HTTP workloads.
        :param Sequence['GetWorkloadFirewallSpecExternalOutboundAllowPortArgs'] outbound_allow_ports: Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
        pulumi.set(__self__, "inbound_allow_cidrs", inbound_allow_cidrs)
        pulumi.set(__self__, "inbound_blocked_cidrs", inbound_blocked_cidrs)
        pulumi.set(__self__, "outbound_allow_cidrs", outbound_allow_cidrs)
        pulumi.set(__self__, "outbound_allow_hostnames", outbound_allow_hostnames)
        pulumi.set(__self__, "outbound_blocked_cidrs", outbound_blocked_cidrs)
        if https is not None:
            pulumi.set(__self__, "https", https)
        if outbound_allow_ports is not None:
            pulumi.set(__self__, "outbound_allow_ports", outbound_allow_ports)

    @_builtins.property
    @pulumi.getter(name="inboundAllowCidrs")
    def inbound_allow_cidrs(self) -> Sequence[_builtins.str]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are allowed to access this workload. No external access is allowed by default. Specify '0.0.0.0/0' to allow access to the public internet.
        """
        return pulumi.get(self, "inbound_allow_cidrs")

    @inbound_allow_cidrs.setter
    def inbound_allow_cidrs(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "inbound_allow_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="inboundBlockedCidrs")
    def inbound_blocked_cidrs(self) -> Sequence[_builtins.str]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that are NOT allowed to access this workload. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        return pulumi.get(self, "inbound_blocked_cidrs")

    @inbound_blocked_cidrs.setter
    def inbound_blocked_cidrs(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "inbound_blocked_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="outboundAllowCidrs")
    def outbound_allow_cidrs(self) -> Sequence[_builtins.str]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is allowed reach. No outbound access is allowed by default. Specify '0.0.0.0/0' to allow outbound access to the public internet.
        """
        return pulumi.get(self, "outbound_allow_cidrs")

    @outbound_allow_cidrs.setter
    def outbound_allow_cidrs(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "outbound_allow_cidrs", value)

    @_builtins.property
    @pulumi.getter(name="outboundAllowHostnames")
    def outbound_allow_hostnames(self) -> Sequence[_builtins.str]:
        """
        The list of public hostnames that this workload is allowed to reach. No outbound access is allowed by default. A wildcard `*` is allowed on the prefix of the hostname only, ex: `*.amazonaws.com`. Use `outboundAllowCIDR` to allow access to all external websites.
        """
        return pulumi.get(self, "outbound_allow_hostnames")

    @outbound_allow_hostnames.setter
    def outbound_allow_hostnames(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "outbound_allow_hostnames", value)

    @_builtins.property
    @pulumi.getter(name="outboundBlockedCidrs")
    def outbound_blocked_cidrs(self) -> Sequence[_builtins.str]:
        """
        The list of ipv4/ipv6 addresses or cidr blocks that this workload is NOT allowed to reach. Addresses in the allow list will only be allowed if they do not exist in this list.
        """
        return pulumi.get(self, "outbound_blocked_cidrs")

    @outbound_blocked_cidrs.setter
    def outbound_blocked_cidrs(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "outbound_blocked_cidrs", value)

    @_builtins.property
    @pulumi.getter
    def https(self) -> Optional[Sequence['GetWorkloadFirewallSpecExternalHttpArgs']]:
        """
        Firewall options for HTTP workloads.
        """
        return pulumi.get(self, "https")

    @https.setter
    def https(self, value: Optional[Sequence['GetWorkloadFirewallSpecExternalHttpArgs']]):
        pulumi.set(self, "https", value)

    @_builtins.property
    @pulumi.getter(name="outboundAllowPorts")
    def outbound_allow_ports(self) -> Optional[Sequence['GetWorkloadFirewallSpecExternalOutboundAllowPortArgs']]:
        """
        Allow outbound access to specific ports and protocols. When not specified, communication to address ranges in outboundAllowCIDR is allowed on all ports and communication to names in outboundAllowHostname is allowed on ports 80/443.
        """
        return pulumi.get(self, "outbound_allow_ports")

    @outbound_allow_ports.setter
    def outbound_allow_ports(self, value: Optional[Sequence['GetWorkloadFirewallSpecExternalOutboundAllowPortArgs']]):
        pulumi.set(self, "outbound_allow_ports", value)


if not MYPY:
    class GetWorkloadFirewallSpecExternalHttpArgsDict(TypedDict):
        inbound_header_filters: NotRequired[Sequence['GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict']]
        """
        A list of header filters for HTTP workloads.
        """
elif False:
    GetWorkloadFirewallSpecExternalHttpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadFirewallSpecExternalHttpArgs:
    def __init__(__self__, *,
                 inbound_header_filters: Optional[Sequence['GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']] = None):
        """
        :param Sequence['GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs'] inbound_header_filters: A list of header filters for HTTP workloads.
        """
        if inbound_header_filters is not None:
            pulumi.set(__self__, "inbound_header_filters", inbound_header_filters)

    @_builtins.property
    @pulumi.getter(name="inboundHeaderFilters")
    def inbound_header_filters(self) -> Optional[Sequence['GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']]:
        """
        A list of header filters for HTTP workloads.
        """
        return pulumi.get(self, "inbound_header_filters")

    @inbound_header_filters.setter
    def inbound_header_filters(self, value: Optional[Sequence['GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs']]):
        pulumi.set(self, "inbound_header_filters", value)


if not MYPY:
    class GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict(TypedDict):
        allowed_values: Sequence[_builtins.str]
        """
        A list of regular expressions to match for allowed header values. Headers that do not match ANY of these values will be filtered and will not reach the workload.
        """
        blocked_values: Sequence[_builtins.str]
        """
        A list of regular expressions to match for blocked header values. Headers that match ANY of these values will be filtered and will not reach the workload.
        """
        key: _builtins.str
        """
        The header to match for.
        """
elif False:
    GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadFirewallSpecExternalHttpInboundHeaderFilterArgs:
    def __init__(__self__, *,
                 allowed_values: Sequence[_builtins.str],
                 blocked_values: Sequence[_builtins.str],
                 key: _builtins.str):
        """
        :param Sequence[_builtins.str] allowed_values: A list of regular expressions to match for allowed header values. Headers that do not match ANY of these values will be filtered and will not reach the workload.
        :param Sequence[_builtins.str] blocked_values: A list of regular expressions to match for blocked header values. Headers that match ANY of these values will be filtered and will not reach the workload.
        :param _builtins.str key: The header to match for.
        """
        pulumi.set(__self__, "allowed_values", allowed_values)
        pulumi.set(__self__, "blocked_values", blocked_values)
        pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="allowedValues")
    def allowed_values(self) -> Sequence[_builtins.str]:
        """
        A list of regular expressions to match for allowed header values. Headers that do not match ANY of these values will be filtered and will not reach the workload.
        """
        return pulumi.get(self, "allowed_values")

    @allowed_values.setter
    def allowed_values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "allowed_values", value)

    @_builtins.property
    @pulumi.getter(name="blockedValues")
    def blocked_values(self) -> Sequence[_builtins.str]:
        """
        A list of regular expressions to match for blocked header values. Headers that match ANY of these values will be filtered and will not reach the workload.
        """
        return pulumi.get(self, "blocked_values")

    @blocked_values.setter
    def blocked_values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "blocked_values", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The header to match for.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)


if not MYPY:
    class GetWorkloadFirewallSpecExternalOutboundAllowPortArgsDict(TypedDict):
        number: _builtins.int
        """
        Port number. Max: 65000
        """
        protocol: _builtins.str
        """
        Either `http`, `https` or `tcp`.
        """
elif False:
    GetWorkloadFirewallSpecExternalOutboundAllowPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadFirewallSpecExternalOutboundAllowPortArgs:
    def __init__(__self__, *,
                 number: _builtins.int,
                 protocol: _builtins.str):
        """
        :param _builtins.int number: Port number. Max: 65000
        :param _builtins.str protocol: Either `http`, `https` or `tcp`.
        """
        pulumi.set(__self__, "number", number)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def number(self) -> _builtins.int:
        """
        Port number. Max: 65000
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: _builtins.int):
        pulumi.set(self, "number", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        Either `http`, `https` or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class GetWorkloadFirewallSpecInternalArgsDict(TypedDict):
        inbound_allow_type: _builtins.str
        """
        Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        """
        inbound_allow_workloads: Sequence[_builtins.str]
        """
        A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
elif False:
    GetWorkloadFirewallSpecInternalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadFirewallSpecInternalArgs:
    def __init__(__self__, *,
                 inbound_allow_type: _builtins.str,
                 inbound_allow_workloads: Sequence[_builtins.str]):
        """
        :param _builtins.str inbound_allow_type: Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        :param Sequence[_builtins.str] inbound_allow_workloads: A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
        pulumi.set(__self__, "inbound_allow_type", inbound_allow_type)
        pulumi.set(__self__, "inbound_allow_workloads", inbound_allow_workloads)

    @_builtins.property
    @pulumi.getter(name="inboundAllowType")
    def inbound_allow_type(self) -> _builtins.str:
        """
        Used to control the internal firewall configuration and mutual tls. Allowed Values: "none", "same-gvc", "same-org", "workload-list".
        """
        return pulumi.get(self, "inbound_allow_type")

    @inbound_allow_type.setter
    def inbound_allow_type(self, value: _builtins.str):
        pulumi.set(self, "inbound_allow_type", value)

    @_builtins.property
    @pulumi.getter(name="inboundAllowWorkloads")
    def inbound_allow_workloads(self) -> Sequence[_builtins.str]:
        """
        A list of specific workloads which are allowed to access this workload internally. This list is only used if the 'inboundAllowType' is set to 'workload-list'.
        """
        return pulumi.get(self, "inbound_allow_workloads")

    @inbound_allow_workloads.setter
    def inbound_allow_workloads(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "inbound_allow_workloads", value)


if not MYPY:
    class GetWorkloadJobArgsDict(TypedDict):
        active_deadline_seconds: _builtins.int
        """
        The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        """
        concurrency_policy: _builtins.str
        """
        Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`.
        """
        history_limit: _builtins.int
        """
        The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`.
        """
        restart_policy: _builtins.str
        """
        Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`.
        """
        schedule: _builtins.str
        """
        A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        """
elif False:
    GetWorkloadJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadJobArgs:
    def __init__(__self__, *,
                 active_deadline_seconds: _builtins.int,
                 concurrency_policy: _builtins.str,
                 history_limit: _builtins.int,
                 restart_policy: _builtins.str,
                 schedule: _builtins.str):
        """
        :param _builtins.int active_deadline_seconds: The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        :param _builtins.str concurrency_policy: Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`.
        :param _builtins.int history_limit: The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`.
        :param _builtins.str restart_policy: Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`.
        :param _builtins.str schedule: A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        """
        pulumi.set(__self__, "active_deadline_seconds", active_deadline_seconds)
        pulumi.set(__self__, "concurrency_policy", concurrency_policy)
        pulumi.set(__self__, "history_limit", history_limit)
        pulumi.set(__self__, "restart_policy", restart_policy)
        pulumi.set(__self__, "schedule", schedule)

    @_builtins.property
    @pulumi.getter(name="activeDeadlineSeconds")
    def active_deadline_seconds(self) -> _builtins.int:
        """
        The maximum number of seconds Control Plane will wait for the job to complete. If a job does not succeed or fail in the allotted time, Control Plane will stop the job, moving it into the Removed status.
        """
        return pulumi.get(self, "active_deadline_seconds")

    @active_deadline_seconds.setter
    def active_deadline_seconds(self, value: _builtins.int):
        pulumi.set(self, "active_deadline_seconds", value)

    @_builtins.property
    @pulumi.getter(name="concurrencyPolicy")
    def concurrency_policy(self) -> _builtins.str:
        """
        Either 'Forbid' or 'Replace'. This determines what Control Plane will do when the schedule requires a job to start, while a prior instance of the job is still running. Enum: [ Forbid, Replace ] Default: `Forbid`.
        """
        return pulumi.get(self, "concurrency_policy")

    @concurrency_policy.setter
    def concurrency_policy(self, value: _builtins.str):
        pulumi.set(self, "concurrency_policy", value)

    @_builtins.property
    @pulumi.getter(name="historyLimit")
    def history_limit(self) -> _builtins.int:
        """
        The maximum number of completed job instances to display. This should be an integer between 1 and 10. Default: `5`.
        """
        return pulumi.get(self, "history_limit")

    @history_limit.setter
    def history_limit(self, value: _builtins.int):
        pulumi.set(self, "history_limit", value)

    @_builtins.property
    @pulumi.getter(name="restartPolicy")
    def restart_policy(self) -> _builtins.str:
        """
        Either 'OnFailure' or 'Never'. This determines what Control Plane will do when a job instance fails. Enum: [ OnFailure, Never ] Default: `Never`.
        """
        return pulumi.get(self, "restart_policy")

    @restart_policy.setter
    def restart_policy(self, value: _builtins.str):
        pulumi.set(self, "restart_policy", value)

    @_builtins.property
    @pulumi.getter
    def schedule(self) -> _builtins.str:
        """
        A standard cron [schedule expression](https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/#schedule-syntax) used to determine when your job should execute.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: _builtins.str):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class GetWorkloadLoadBalancerArgsDict(TypedDict):
        replica_direct: _builtins.bool
        """
        When enabled, individual replicas of the workload can be reached directly using the subdomain prefix replica-<index>. For example, replica-0.my-workload.my-gvc.cpln.local or replica-0.my-workload-<gvc-alias>.cpln.app - Can only be used with stateful workloads.
        """
        directs: NotRequired[Sequence['GetWorkloadLoadBalancerDirectArgsDict']]
        """
        Direct load balancers are created in each location that a workload is running in and are configured for the standard endpoints of the workload. Customers are responsible for configuring the workload with certificates if TLS is required.
        """
        geo_locations: NotRequired[Sequence['GetWorkloadLoadBalancerGeoLocationArgsDict']]
elif False:
    GetWorkloadLoadBalancerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLoadBalancerArgs:
    def __init__(__self__, *,
                 replica_direct: _builtins.bool,
                 directs: Optional[Sequence['GetWorkloadLoadBalancerDirectArgs']] = None,
                 geo_locations: Optional[Sequence['GetWorkloadLoadBalancerGeoLocationArgs']] = None):
        """
        :param _builtins.bool replica_direct: When enabled, individual replicas of the workload can be reached directly using the subdomain prefix replica-<index>. For example, replica-0.my-workload.my-gvc.cpln.local or replica-0.my-workload-<gvc-alias>.cpln.app - Can only be used with stateful workloads.
        :param Sequence['GetWorkloadLoadBalancerDirectArgs'] directs: Direct load balancers are created in each location that a workload is running in and are configured for the standard endpoints of the workload. Customers are responsible for configuring the workload with certificates if TLS is required.
        """
        pulumi.set(__self__, "replica_direct", replica_direct)
        if directs is not None:
            pulumi.set(__self__, "directs", directs)
        if geo_locations is not None:
            pulumi.set(__self__, "geo_locations", geo_locations)

    @_builtins.property
    @pulumi.getter(name="replicaDirect")
    def replica_direct(self) -> _builtins.bool:
        """
        When enabled, individual replicas of the workload can be reached directly using the subdomain prefix replica-<index>. For example, replica-0.my-workload.my-gvc.cpln.local or replica-0.my-workload-<gvc-alias>.cpln.app - Can only be used with stateful workloads.
        """
        return pulumi.get(self, "replica_direct")

    @replica_direct.setter
    def replica_direct(self, value: _builtins.bool):
        pulumi.set(self, "replica_direct", value)

    @_builtins.property
    @pulumi.getter
    def directs(self) -> Optional[Sequence['GetWorkloadLoadBalancerDirectArgs']]:
        """
        Direct load balancers are created in each location that a workload is running in and are configured for the standard endpoints of the workload. Customers are responsible for configuring the workload with certificates if TLS is required.
        """
        return pulumi.get(self, "directs")

    @directs.setter
    def directs(self, value: Optional[Sequence['GetWorkloadLoadBalancerDirectArgs']]):
        pulumi.set(self, "directs", value)

    @_builtins.property
    @pulumi.getter(name="geoLocations")
    def geo_locations(self) -> Optional[Sequence['GetWorkloadLoadBalancerGeoLocationArgs']]:
        return pulumi.get(self, "geo_locations")

    @geo_locations.setter
    def geo_locations(self, value: Optional[Sequence['GetWorkloadLoadBalancerGeoLocationArgs']]):
        pulumi.set(self, "geo_locations", value)


if not MYPY:
    class GetWorkloadLoadBalancerDirectArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        When disabled, this load balancer will be stopped.
        """
        ipset: _builtins.str
        ports: NotRequired[Sequence['GetWorkloadLoadBalancerDirectPortArgsDict']]
        """
        List of ports that will be exposed by this load balancer.
        """
elif False:
    GetWorkloadLoadBalancerDirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLoadBalancerDirectArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 ipset: _builtins.str,
                 ports: Optional[Sequence['GetWorkloadLoadBalancerDirectPortArgs']] = None):
        """
        :param _builtins.bool enabled: When disabled, this load balancer will be stopped.
        :param Sequence['GetWorkloadLoadBalancerDirectPortArgs'] ports: List of ports that will be exposed by this load balancer.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "ipset", ipset)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        When disabled, this load balancer will be stopped.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def ipset(self) -> _builtins.str:
        return pulumi.get(self, "ipset")

    @ipset.setter
    def ipset(self, value: _builtins.str):
        pulumi.set(self, "ipset", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['GetWorkloadLoadBalancerDirectPortArgs']]:
        """
        List of ports that will be exposed by this load balancer.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[Sequence['GetWorkloadLoadBalancerDirectPortArgs']]):
        pulumi.set(self, "ports", value)


if not MYPY:
    class GetWorkloadLoadBalancerDirectPortArgsDict(TypedDict):
        container_port: _builtins.int
        """
        The port on the container tha will receive this traffic.
        """
        external_port: _builtins.int
        """
        The port that is available publicly.
        """
        protocol: _builtins.str
        """
        The protocol that is exposed publicly.
        """
        scheme: _builtins.str
        """
        Overrides the default `https` url scheme that will be used for links in the UI and status.
        """
elif False:
    GetWorkloadLoadBalancerDirectPortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLoadBalancerDirectPortArgs:
    def __init__(__self__, *,
                 container_port: _builtins.int,
                 external_port: _builtins.int,
                 protocol: _builtins.str,
                 scheme: _builtins.str):
        """
        :param _builtins.int container_port: The port on the container tha will receive this traffic.
        :param _builtins.int external_port: The port that is available publicly.
        :param _builtins.str protocol: The protocol that is exposed publicly.
        :param _builtins.str scheme: Overrides the default `https` url scheme that will be used for links in the UI and status.
        """
        pulumi.set(__self__, "container_port", container_port)
        pulumi.set(__self__, "external_port", external_port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "scheme", scheme)

    @_builtins.property
    @pulumi.getter(name="containerPort")
    def container_port(self) -> _builtins.int:
        """
        The port on the container tha will receive this traffic.
        """
        return pulumi.get(self, "container_port")

    @container_port.setter
    def container_port(self, value: _builtins.int):
        pulumi.set(self, "container_port", value)

    @_builtins.property
    @pulumi.getter(name="externalPort")
    def external_port(self) -> _builtins.int:
        """
        The port that is available publicly.
        """
        return pulumi.get(self, "external_port")

    @external_port.setter
    def external_port(self, value: _builtins.int):
        pulumi.set(self, "external_port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol that is exposed publicly.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> _builtins.str:
        """
        Overrides the default `https` url scheme that will be used for links in the UI and status.
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: _builtins.str):
        pulumi.set(self, "scheme", value)


if not MYPY:
    class GetWorkloadLoadBalancerGeoLocationArgsDict(TypedDict):
        enabled: _builtins.bool
        """
        When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        headers: NotRequired[Sequence['GetWorkloadLoadBalancerGeoLocationHeaderArgsDict']]
elif False:
    GetWorkloadLoadBalancerGeoLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLoadBalancerGeoLocationArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 headers: Optional[Sequence['GetWorkloadLoadBalancerGeoLocationHeaderArgs']] = None):
        """
        :param _builtins.bool enabled: When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        pulumi.set(__self__, "enabled", enabled)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        When enabled, geo location headers will be included on inbound http requests. Existing headers will be replaced.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['GetWorkloadLoadBalancerGeoLocationHeaderArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[Sequence['GetWorkloadLoadBalancerGeoLocationHeaderArgs']]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class GetWorkloadLoadBalancerGeoLocationHeaderArgsDict(TypedDict):
        asn: _builtins.str
        """
        The geo asn header.
        """
        city: _builtins.str
        """
        The geo city header.
        """
        country: _builtins.str
        """
        The geo country header.
        """
        region: _builtins.str
        """
        The geo region header.
        """
elif False:
    GetWorkloadLoadBalancerGeoLocationHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLoadBalancerGeoLocationHeaderArgs:
    def __init__(__self__, *,
                 asn: _builtins.str,
                 city: _builtins.str,
                 country: _builtins.str,
                 region: _builtins.str):
        """
        :param _builtins.str asn: The geo asn header.
        :param _builtins.str city: The geo city header.
        :param _builtins.str country: The geo country header.
        :param _builtins.str region: The geo region header.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "city", city)
        pulumi.set(__self__, "country", country)
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def asn(self) -> _builtins.str:
        """
        The geo asn header.
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: _builtins.str):
        pulumi.set(self, "asn", value)

    @_builtins.property
    @pulumi.getter
    def city(self) -> _builtins.str:
        """
        The geo city header.
        """
        return pulumi.get(self, "city")

    @city.setter
    def city(self, value: _builtins.str):
        pulumi.set(self, "city", value)

    @_builtins.property
    @pulumi.getter
    def country(self) -> _builtins.str:
        """
        The geo country header.
        """
        return pulumi.get(self, "country")

    @country.setter
    def country(self, value: _builtins.str):
        pulumi.set(self, "country", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The geo region header.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: _builtins.str):
        pulumi.set(self, "region", value)


if not MYPY:
    class GetWorkloadLocalOptionArgsDict(TypedDict):
        capacity_ai: _builtins.bool
        """
        Capacity AI. Default: `true`.
        """
        capacity_ai_update_minutes: _builtins.int
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        debug: _builtins.bool
        """
        Debug mode. Default: `false`.
        """
        location: _builtins.str
        """
        Valid only for `local_options`. Override options for a specific location.
        """
        suspend: _builtins.bool
        """
        Workload suspend. Default: `false`.
        """
        timeout_seconds: _builtins.int
        """
        Timeout in seconds. Default: `5`.
        """
        autoscalings: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingArgsDict']]
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        multi_zones: NotRequired[Sequence['GetWorkloadLocalOptionMultiZoneArgsDict']]
elif False:
    GetWorkloadLocalOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionArgs:
    def __init__(__self__, *,
                 capacity_ai: _builtins.bool,
                 capacity_ai_update_minutes: _builtins.int,
                 debug: _builtins.bool,
                 location: _builtins.str,
                 suspend: _builtins.bool,
                 timeout_seconds: _builtins.int,
                 autoscalings: Optional[Sequence['GetWorkloadLocalOptionAutoscalingArgs']] = None,
                 multi_zones: Optional[Sequence['GetWorkloadLocalOptionMultiZoneArgs']] = None):
        """
        :param _builtins.bool capacity_ai: Capacity AI. Default: `true`.
        :param _builtins.int capacity_ai_update_minutes: The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        :param _builtins.bool debug: Debug mode. Default: `false`.
        :param _builtins.str location: Valid only for `local_options`. Override options for a specific location.
        :param _builtins.bool suspend: Workload suspend. Default: `false`.
        :param _builtins.int timeout_seconds: Timeout in seconds. Default: `5`.
        :param Sequence['GetWorkloadLocalOptionAutoscalingArgs'] autoscalings: Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        pulumi.set(__self__, "capacity_ai", capacity_ai)
        pulumi.set(__self__, "capacity_ai_update_minutes", capacity_ai_update_minutes)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "location", location)
        pulumi.set(__self__, "suspend", suspend)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if autoscalings is not None:
            pulumi.set(__self__, "autoscalings", autoscalings)
        if multi_zones is not None:
            pulumi.set(__self__, "multi_zones", multi_zones)

    @_builtins.property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> _builtins.bool:
        """
        Capacity AI. Default: `true`.
        """
        return pulumi.get(self, "capacity_ai")

    @capacity_ai.setter
    def capacity_ai(self, value: _builtins.bool):
        pulumi.set(self, "capacity_ai", value)

    @_builtins.property
    @pulumi.getter(name="capacityAiUpdateMinutes")
    def capacity_ai_update_minutes(self) -> _builtins.int:
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        return pulumi.get(self, "capacity_ai_update_minutes")

    @capacity_ai_update_minutes.setter
    def capacity_ai_update_minutes(self, value: _builtins.int):
        pulumi.set(self, "capacity_ai_update_minutes", value)

    @_builtins.property
    @pulumi.getter
    def debug(self) -> _builtins.bool:
        """
        Debug mode. Default: `false`.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: _builtins.bool):
        pulumi.set(self, "debug", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        Valid only for `local_options`. Override options for a specific location.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: _builtins.str):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> _builtins.bool:
        """
        Workload suspend. Default: `false`.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: _builtins.bool):
        pulumi.set(self, "suspend", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        """
        Timeout in seconds. Default: `5`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: _builtins.int):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def autoscalings(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingArgs']]:
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        return pulumi.get(self, "autoscalings")

    @autoscalings.setter
    def autoscalings(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingArgs']]):
        pulumi.set(self, "autoscalings", value)

    @_builtins.property
    @pulumi.getter(name="multiZones")
    def multi_zones(self) -> Optional[Sequence['GetWorkloadLocalOptionMultiZoneArgs']]:
        return pulumi.get(self, "multi_zones")

    @multi_zones.setter
    def multi_zones(self, value: Optional[Sequence['GetWorkloadLocalOptionMultiZoneArgs']]):
        pulumi.set(self, "multi_zones", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingArgsDict(TypedDict):
        max_concurrency: _builtins.int
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        max_scale: _builtins.int
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        metric: _builtins.str
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        metric_percentile: _builtins.str
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        min_scale: _builtins.int
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        scale_to_zero_delay: _builtins.int
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        target: _builtins.int
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        kedas: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingKedaArgsDict']]
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        multis: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingMultiArgsDict']]
elif False:
    GetWorkloadLocalOptionAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingArgs:
    def __init__(__self__, *,
                 max_concurrency: _builtins.int,
                 max_scale: _builtins.int,
                 metric: _builtins.str,
                 metric_percentile: _builtins.str,
                 min_scale: _builtins.int,
                 scale_to_zero_delay: _builtins.int,
                 target: _builtins.int,
                 kedas: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaArgs']] = None,
                 multis: Optional[Sequence['GetWorkloadLocalOptionAutoscalingMultiArgs']] = None):
        """
        :param _builtins.int max_concurrency: A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        :param _builtins.int max_scale: The maximum allowed number of replicas. Min: `0`. Default `5`.
        :param _builtins.str metric: Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        :param _builtins.str metric_percentile: For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        :param _builtins.int min_scale: The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        :param _builtins.int scale_to_zero_delay: The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        :param _builtins.int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        :param Sequence['GetWorkloadLocalOptionAutoscalingKedaArgs'] kedas: KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "max_scale", max_scale)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "metric_percentile", metric_percentile)
        pulumi.set(__self__, "min_scale", min_scale)
        pulumi.set(__self__, "scale_to_zero_delay", scale_to_zero_delay)
        pulumi.set(__self__, "target", target)
        if kedas is not None:
            pulumi.set(__self__, "kedas", kedas)
        if multis is not None:
            pulumi.set(__self__, "multis", multis)

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> _builtins.int:
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: _builtins.int):
        pulumi.set(self, "max_concurrency", value)

    @_builtins.property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> _builtins.int:
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        return pulumi.get(self, "max_scale")

    @max_scale.setter
    def max_scale(self, value: _builtins.int):
        pulumi.set(self, "max_scale", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: _builtins.str):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> _builtins.str:
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        return pulumi.get(self, "metric_percentile")

    @metric_percentile.setter
    def metric_percentile(self, value: _builtins.str):
        pulumi.set(self, "metric_percentile", value)

    @_builtins.property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> _builtins.int:
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        return pulumi.get(self, "min_scale")

    @min_scale.setter
    def min_scale(self, value: _builtins.int):
        pulumi.set(self, "min_scale", value)

    @_builtins.property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> _builtins.int:
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        return pulumi.get(self, "scale_to_zero_delay")

    @scale_to_zero_delay.setter
    def scale_to_zero_delay(self, value: _builtins.int):
        pulumi.set(self, "scale_to_zero_delay", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.int:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.int):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def kedas(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaArgs']]:
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        return pulumi.get(self, "kedas")

    @kedas.setter
    def kedas(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaArgs']]):
        pulumi.set(self, "kedas", value)

    @_builtins.property
    @pulumi.getter
    def multis(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingMultiArgs']]:
        return pulumi.get(self, "multis")

    @multis.setter
    def multis(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingMultiArgs']]):
        pulumi.set(self, "multis", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingKedaArgsDict(TypedDict):
        cooldown_period: _builtins.int
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        initial_cooldown_period: _builtins.int
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        polling_interval: _builtins.int
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        advanceds: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedArgsDict']]
        """
        Advanced configuration options for KEDA.
        """
        triggers: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerArgsDict']]
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
elif False:
    GetWorkloadLocalOptionAutoscalingKedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingKedaArgs:
    def __init__(__self__, *,
                 cooldown_period: _builtins.int,
                 initial_cooldown_period: _builtins.int,
                 polling_interval: _builtins.int,
                 advanceds: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedArgs']] = None,
                 triggers: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerArgs']] = None):
        """
        :param _builtins.int cooldown_period: The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param _builtins.int initial_cooldown_period: The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param _builtins.int polling_interval: The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        :param Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedArgs'] advanceds: Advanced configuration options for KEDA.
        :param Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerArgs'] triggers: An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        pulumi.set(__self__, "cooldown_period", cooldown_period)
        pulumi.set(__self__, "initial_cooldown_period", initial_cooldown_period)
        pulumi.set(__self__, "polling_interval", polling_interval)
        if advanceds is not None:
            pulumi.set(__self__, "advanceds", advanceds)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> _builtins.int:
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: _builtins.int):
        pulumi.set(self, "cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="initialCooldownPeriod")
    def initial_cooldown_period(self) -> _builtins.int:
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "initial_cooldown_period")

    @initial_cooldown_period.setter
    def initial_cooldown_period(self, value: _builtins.int):
        pulumi.set(self, "initial_cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> _builtins.int:
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: _builtins.int):
        pulumi.set(self, "polling_interval", value)

    @_builtins.property
    @pulumi.getter
    def advanceds(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedArgs']]:
        """
        Advanced configuration options for KEDA.
        """
        return pulumi.get(self, "advanceds")

    @advanceds.setter
    def advanceds(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedArgs']]):
        pulumi.set(self, "advanceds", value)

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerArgs']]:
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerArgs']]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingKedaAdvancedArgsDict(TypedDict):
        scaling_modifiers: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgsDict']]
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
elif False:
    GetWorkloadLocalOptionAutoscalingKedaAdvancedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingKedaAdvancedArgs:
    def __init__(__self__, *,
                 scaling_modifiers: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgs']] = None):
        """
        :param Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgs'] scaling_modifiers: Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        if scaling_modifiers is not None:
            pulumi.set(__self__, "scaling_modifiers", scaling_modifiers)

    @_builtins.property
    @pulumi.getter(name="scalingModifiers")
    def scaling_modifiers(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgs']]:
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        return pulumi.get(self, "scaling_modifiers")

    @scaling_modifiers.setter
    def scaling_modifiers(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgs']]):
        pulumi.set(self, "scaling_modifiers", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgsDict(TypedDict):
        activation_target: _builtins.str
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        formula: _builtins.str
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        metric_type: _builtins.str
        """
        Defines metric type used for this new composite-metric.
        """
        target: _builtins.str
        """
        Defines new target value to scale on for the composed metric.
        """
elif False:
    GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingKedaAdvancedScalingModifierArgs:
    def __init__(__self__, *,
                 activation_target: _builtins.str,
                 formula: _builtins.str,
                 metric_type: _builtins.str,
                 target: _builtins.str):
        """
        :param _builtins.str activation_target: Defines the new activation target value to scale on for the composed metric.
        :param _builtins.str formula: Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        :param _builtins.str metric_type: Defines metric type used for this new composite-metric.
        :param _builtins.str target: Defines new target value to scale on for the composed metric.
        """
        pulumi.set(__self__, "activation_target", activation_target)
        pulumi.set(__self__, "formula", formula)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="activationTarget")
    def activation_target(self) -> _builtins.str:
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        return pulumi.get(self, "activation_target")

    @activation_target.setter
    def activation_target(self, value: _builtins.str):
        pulumi.set(self, "activation_target", value)

    @_builtins.property
    @pulumi.getter
    def formula(self) -> _builtins.str:
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: _builtins.str):
        pulumi.set(self, "formula", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Defines metric type used for this new composite-metric.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: _builtins.str):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Defines new target value to scale on for the composed metric.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.str):
        pulumi.set(self, "target", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingKedaTriggerArgsDict(TypedDict):
        metadata: Mapping[str, _builtins.str]
        """
        The configuration parameters that the trigger requires.
        """
        metric_type: _builtins.str
        """
        The type of metric to be used for scaling.
        """
        name: _builtins.str
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        type: _builtins.str
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        use_cached_metrics: _builtins.bool
        """
        Enables caching of metric values during polling interval.
        """
        authentication_reves: NotRequired[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict']]
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
elif False:
    GetWorkloadLocalOptionAutoscalingKedaTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingKedaTriggerArgs:
    def __init__(__self__, *,
                 metadata: Mapping[str, _builtins.str],
                 metric_type: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 use_cached_metrics: _builtins.bool,
                 authentication_reves: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs']] = None):
        """
        :param Mapping[str, _builtins.str] metadata: The configuration parameters that the trigger requires.
        :param _builtins.str metric_type: The type of metric to be used for scaling.
        :param _builtins.str name: An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        :param _builtins.str type: The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        :param _builtins.bool use_cached_metrics: Enables caching of metric values during polling interval.
        :param Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs'] authentication_reves: Reference to a KEDA authentication object for secure access to external systems.
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_cached_metrics", use_cached_metrics)
        if authentication_reves is not None:
            pulumi.set(__self__, "authentication_reves", authentication_reves)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The configuration parameters that the trigger requires.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        The type of metric to be used for scaling.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: _builtins.str):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="useCachedMetrics")
    def use_cached_metrics(self) -> _builtins.bool:
        """
        Enables caching of metric values during polling interval.
        """
        return pulumi.get(self, "use_cached_metrics")

    @use_cached_metrics.setter
    def use_cached_metrics(self, value: _builtins.bool):
        pulumi.set(self, "use_cached_metrics", value)

    @_builtins.property
    @pulumi.getter(name="authenticationReves")
    def authentication_reves(self) -> Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs']]:
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
        return pulumi.get(self, "authentication_reves")

    @authentication_reves.setter
    def authentication_reves(self, value: Optional[Sequence['GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs']]):
        pulumi.set(self, "authentication_reves", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
elif False:
    GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingKedaTriggerAuthenticationRefArgs:
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of secret listed in the GVC spec.keda.secrets.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetWorkloadLocalOptionAutoscalingMultiArgsDict(TypedDict):
        metric: _builtins.str
        """
        Valid values: `cpu` or `memory`.
        """
        target: _builtins.int
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
elif False:
    GetWorkloadLocalOptionAutoscalingMultiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionAutoscalingMultiArgs:
    def __init__(__self__, *,
                 metric: _builtins.str,
                 target: _builtins.int):
        """
        :param _builtins.str metric: Valid values: `cpu` or `memory`.
        :param _builtins.int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        Valid values: `cpu` or `memory`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: _builtins.str):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.int:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.int):
        pulumi.set(self, "target", value)


if not MYPY:
    class GetWorkloadLocalOptionMultiZoneArgsDict(TypedDict):
        enabled: _builtins.bool
elif False:
    GetWorkloadLocalOptionMultiZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadLocalOptionMultiZoneArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetWorkloadOptionArgsDict(TypedDict):
        capacity_ai: _builtins.bool
        """
        Capacity AI. Default: `true`.
        """
        capacity_ai_update_minutes: _builtins.int
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        debug: _builtins.bool
        """
        Debug mode. Default: `false`.
        """
        suspend: _builtins.bool
        """
        Workload suspend. Default: `false`.
        """
        timeout_seconds: _builtins.int
        """
        Timeout in seconds. Default: `5`.
        """
        autoscalings: NotRequired[Sequence['GetWorkloadOptionAutoscalingArgsDict']]
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        multi_zones: NotRequired[Sequence['GetWorkloadOptionMultiZoneArgsDict']]
elif False:
    GetWorkloadOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionArgs:
    def __init__(__self__, *,
                 capacity_ai: _builtins.bool,
                 capacity_ai_update_minutes: _builtins.int,
                 debug: _builtins.bool,
                 suspend: _builtins.bool,
                 timeout_seconds: _builtins.int,
                 autoscalings: Optional[Sequence['GetWorkloadOptionAutoscalingArgs']] = None,
                 multi_zones: Optional[Sequence['GetWorkloadOptionMultiZoneArgs']] = None):
        """
        :param _builtins.bool capacity_ai: Capacity AI. Default: `true`.
        :param _builtins.int capacity_ai_update_minutes: The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        :param _builtins.bool debug: Debug mode. Default: `false`.
        :param _builtins.bool suspend: Workload suspend. Default: `false`.
        :param _builtins.int timeout_seconds: Timeout in seconds. Default: `5`.
        :param Sequence['GetWorkloadOptionAutoscalingArgs'] autoscalings: Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        pulumi.set(__self__, "capacity_ai", capacity_ai)
        pulumi.set(__self__, "capacity_ai_update_minutes", capacity_ai_update_minutes)
        pulumi.set(__self__, "debug", debug)
        pulumi.set(__self__, "suspend", suspend)
        pulumi.set(__self__, "timeout_seconds", timeout_seconds)
        if autoscalings is not None:
            pulumi.set(__self__, "autoscalings", autoscalings)
        if multi_zones is not None:
            pulumi.set(__self__, "multi_zones", multi_zones)

    @_builtins.property
    @pulumi.getter(name="capacityAi")
    def capacity_ai(self) -> _builtins.bool:
        """
        Capacity AI. Default: `true`.
        """
        return pulumi.get(self, "capacity_ai")

    @capacity_ai.setter
    def capacity_ai(self, value: _builtins.bool):
        pulumi.set(self, "capacity_ai", value)

    @_builtins.property
    @pulumi.getter(name="capacityAiUpdateMinutes")
    def capacity_ai_update_minutes(self) -> _builtins.int:
        """
        The highest frequency capacity AI is allowed to update resource reservations when CapacityAI is enabled.
        """
        return pulumi.get(self, "capacity_ai_update_minutes")

    @capacity_ai_update_minutes.setter
    def capacity_ai_update_minutes(self, value: _builtins.int):
        pulumi.set(self, "capacity_ai_update_minutes", value)

    @_builtins.property
    @pulumi.getter
    def debug(self) -> _builtins.bool:
        """
        Debug mode. Default: `false`.
        """
        return pulumi.get(self, "debug")

    @debug.setter
    def debug(self, value: _builtins.bool):
        pulumi.set(self, "debug", value)

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> _builtins.bool:
        """
        Workload suspend. Default: `false`.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: _builtins.bool):
        pulumi.set(self, "suspend", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> _builtins.int:
        """
        Timeout in seconds. Default: `5`.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: _builtins.int):
        pulumi.set(self, "timeout_seconds", value)

    @_builtins.property
    @pulumi.getter
    def autoscalings(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingArgs']]:
        """
        Auto-scaling adjusts horizontal scaling based on a set strategy, target value, and possibly a metric percentile.
        """
        return pulumi.get(self, "autoscalings")

    @autoscalings.setter
    def autoscalings(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingArgs']]):
        pulumi.set(self, "autoscalings", value)

    @_builtins.property
    @pulumi.getter(name="multiZones")
    def multi_zones(self) -> Optional[Sequence['GetWorkloadOptionMultiZoneArgs']]:
        return pulumi.get(self, "multi_zones")

    @multi_zones.setter
    def multi_zones(self, value: Optional[Sequence['GetWorkloadOptionMultiZoneArgs']]):
        pulumi.set(self, "multi_zones", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingArgsDict(TypedDict):
        max_concurrency: _builtins.int
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        max_scale: _builtins.int
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        metric: _builtins.str
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        metric_percentile: _builtins.str
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        min_scale: _builtins.int
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        scale_to_zero_delay: _builtins.int
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        target: _builtins.int
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        kedas: NotRequired[Sequence['GetWorkloadOptionAutoscalingKedaArgsDict']]
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        multis: NotRequired[Sequence['GetWorkloadOptionAutoscalingMultiArgsDict']]
elif False:
    GetWorkloadOptionAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingArgs:
    def __init__(__self__, *,
                 max_concurrency: _builtins.int,
                 max_scale: _builtins.int,
                 metric: _builtins.str,
                 metric_percentile: _builtins.str,
                 min_scale: _builtins.int,
                 scale_to_zero_delay: _builtins.int,
                 target: _builtins.int,
                 kedas: Optional[Sequence['GetWorkloadOptionAutoscalingKedaArgs']] = None,
                 multis: Optional[Sequence['GetWorkloadOptionAutoscalingMultiArgs']] = None):
        """
        :param _builtins.int max_concurrency: A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        :param _builtins.int max_scale: The maximum allowed number of replicas. Min: `0`. Default `5`.
        :param _builtins.str metric: Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        :param _builtins.str metric_percentile: For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        :param _builtins.int min_scale: The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        :param _builtins.int scale_to_zero_delay: The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        :param _builtins.int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        :param Sequence['GetWorkloadOptionAutoscalingKedaArgs'] kedas: KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        pulumi.set(__self__, "max_concurrency", max_concurrency)
        pulumi.set(__self__, "max_scale", max_scale)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "metric_percentile", metric_percentile)
        pulumi.set(__self__, "min_scale", min_scale)
        pulumi.set(__self__, "scale_to_zero_delay", scale_to_zero_delay)
        pulumi.set(__self__, "target", target)
        if kedas is not None:
            pulumi.set(__self__, "kedas", kedas)
        if multis is not None:
            pulumi.set(__self__, "multis", multis)

    @_builtins.property
    @pulumi.getter(name="maxConcurrency")
    def max_concurrency(self) -> _builtins.int:
        """
        A hard maximum for the number of concurrent requests allowed to a replica. If no replicas are available to fulfill the request then it will be queued until a replica with capacity is available and delivered as soon as one is available again. Capacity can be available from requests completing or when a new replica is available from scale out.Min: `0`. Max: `1000`. Default `0`.
        """
        return pulumi.get(self, "max_concurrency")

    @max_concurrency.setter
    def max_concurrency(self, value: _builtins.int):
        pulumi.set(self, "max_concurrency", value)

    @_builtins.property
    @pulumi.getter(name="maxScale")
    def max_scale(self) -> _builtins.int:
        """
        The maximum allowed number of replicas. Min: `0`. Default `5`.
        """
        return pulumi.get(self, "max_scale")

    @max_scale.setter
    def max_scale(self, value: _builtins.int):
        pulumi.set(self, "max_scale", value)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        Valid values: `concurrency`, `cpu`, `memory`, `rps`, `latency`, `keda` or `disabled`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: _builtins.str):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter(name="metricPercentile")
    def metric_percentile(self) -> _builtins.str:
        """
        For metrics represented as a distribution (e.g. latency) a percentile within the distribution must be chosen as the target.
        """
        return pulumi.get(self, "metric_percentile")

    @metric_percentile.setter
    def metric_percentile(self, value: _builtins.str):
        pulumi.set(self, "metric_percentile", value)

    @_builtins.property
    @pulumi.getter(name="minScale")
    def min_scale(self) -> _builtins.int:
        """
        The minimum allowed number of replicas. Control Plane can scale the workload down to 0 when there is no traffic and scale up immediately to fulfill new requests. Min: `0`. Max: `max_scale`. Default `1`.
        """
        return pulumi.get(self, "min_scale")

    @min_scale.setter
    def min_scale(self, value: _builtins.int):
        pulumi.set(self, "min_scale", value)

    @_builtins.property
    @pulumi.getter(name="scaleToZeroDelay")
    def scale_to_zero_delay(self) -> _builtins.int:
        """
        The amount of time (in seconds) with no requests received before a workload is scaled to 0. Min: `30`. Max: `3600`. Default: `300`.
        """
        return pulumi.get(self, "scale_to_zero_delay")

    @scale_to_zero_delay.setter
    def scale_to_zero_delay(self, value: _builtins.int):
        pulumi.set(self, "scale_to_zero_delay", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.int:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`. Default: `95`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.int):
        pulumi.set(self, "target", value)

    @_builtins.property
    @pulumi.getter
    def kedas(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingKedaArgs']]:
        """
        KEDA (Kubernetes-based Event Driven Autoscaling) allows for advanced autoscaling based on external metrics and triggers.
        """
        return pulumi.get(self, "kedas")

    @kedas.setter
    def kedas(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingKedaArgs']]):
        pulumi.set(self, "kedas", value)

    @_builtins.property
    @pulumi.getter
    def multis(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingMultiArgs']]:
        return pulumi.get(self, "multis")

    @multis.setter
    def multis(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingMultiArgs']]):
        pulumi.set(self, "multis", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingKedaArgsDict(TypedDict):
        cooldown_period: _builtins.int
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        initial_cooldown_period: _builtins.int
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        polling_interval: _builtins.int
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        advanceds: NotRequired[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedArgsDict']]
        """
        Advanced configuration options for KEDA.
        """
        triggers: NotRequired[Sequence['GetWorkloadOptionAutoscalingKedaTriggerArgsDict']]
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
elif False:
    GetWorkloadOptionAutoscalingKedaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingKedaArgs:
    def __init__(__self__, *,
                 cooldown_period: _builtins.int,
                 initial_cooldown_period: _builtins.int,
                 polling_interval: _builtins.int,
                 advanceds: Optional[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedArgs']] = None,
                 triggers: Optional[Sequence['GetWorkloadOptionAutoscalingKedaTriggerArgs']] = None):
        """
        :param _builtins.int cooldown_period: The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param _builtins.int initial_cooldown_period: The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        :param _builtins.int polling_interval: The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        :param Sequence['GetWorkloadOptionAutoscalingKedaAdvancedArgs'] advanceds: Advanced configuration options for KEDA.
        :param Sequence['GetWorkloadOptionAutoscalingKedaTriggerArgs'] triggers: An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        pulumi.set(__self__, "cooldown_period", cooldown_period)
        pulumi.set(__self__, "initial_cooldown_period", initial_cooldown_period)
        pulumi.set(__self__, "polling_interval", polling_interval)
        if advanceds is not None:
            pulumi.set(__self__, "advanceds", advanceds)
        if triggers is not None:
            pulumi.set(__self__, "triggers", triggers)

    @_builtins.property
    @pulumi.getter(name="cooldownPeriod")
    def cooldown_period(self) -> _builtins.int:
        """
        The cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "cooldown_period")

    @cooldown_period.setter
    def cooldown_period(self, value: _builtins.int):
        pulumi.set(self, "cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="initialCooldownPeriod")
    def initial_cooldown_period(self) -> _builtins.int:
        """
        The initial cooldown period in seconds after scaling down to 0 replicas before KEDA will allow scaling up again.
        """
        return pulumi.get(self, "initial_cooldown_period")

    @initial_cooldown_period.setter
    def initial_cooldown_period(self, value: _builtins.int):
        pulumi.set(self, "initial_cooldown_period", value)

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> _builtins.int:
        """
        The interval in seconds at which KEDA will poll the external metrics to determine if scaling is required.
        """
        return pulumi.get(self, "polling_interval")

    @polling_interval.setter
    def polling_interval(self, value: _builtins.int):
        pulumi.set(self, "polling_interval", value)

    @_builtins.property
    @pulumi.getter
    def advanceds(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedArgs']]:
        """
        Advanced configuration options for KEDA.
        """
        return pulumi.get(self, "advanceds")

    @advanceds.setter
    def advanceds(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedArgs']]):
        pulumi.set(self, "advanceds", value)

    @_builtins.property
    @pulumi.getter
    def triggers(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingKedaTriggerArgs']]:
        """
        An array of KEDA triggers to be used for scaling workloads in this GVC. This is used to define how KEDA will scale workloads in the GVC based on external metrics or events. Each trigger type may have its own specific configuration options.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingKedaTriggerArgs']]):
        pulumi.set(self, "triggers", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingKedaAdvancedArgsDict(TypedDict):
        scaling_modifiers: NotRequired[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgsDict']]
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
elif False:
    GetWorkloadOptionAutoscalingKedaAdvancedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingKedaAdvancedArgs:
    def __init__(__self__, *,
                 scaling_modifiers: Optional[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgs']] = None):
        """
        :param Sequence['GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgs'] scaling_modifiers: Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        if scaling_modifiers is not None:
            pulumi.set(__self__, "scaling_modifiers", scaling_modifiers)

    @_builtins.property
    @pulumi.getter(name="scalingModifiers")
    def scaling_modifiers(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgs']]:
        """
        Scaling modifiers allow for fine-tuning the scaling behavior of KEDA.
        """
        return pulumi.get(self, "scaling_modifiers")

    @scaling_modifiers.setter
    def scaling_modifiers(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgs']]):
        pulumi.set(self, "scaling_modifiers", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgsDict(TypedDict):
        activation_target: _builtins.str
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        formula: _builtins.str
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        metric_type: _builtins.str
        """
        Defines metric type used for this new composite-metric.
        """
        target: _builtins.str
        """
        Defines new target value to scale on for the composed metric.
        """
elif False:
    GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingKedaAdvancedScalingModifierArgs:
    def __init__(__self__, *,
                 activation_target: _builtins.str,
                 formula: _builtins.str,
                 metric_type: _builtins.str,
                 target: _builtins.str):
        """
        :param _builtins.str activation_target: Defines the new activation target value to scale on for the composed metric.
        :param _builtins.str formula: Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        :param _builtins.str metric_type: Defines metric type used for this new composite-metric.
        :param _builtins.str target: Defines new target value to scale on for the composed metric.
        """
        pulumi.set(__self__, "activation_target", activation_target)
        pulumi.set(__self__, "formula", formula)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter(name="activationTarget")
    def activation_target(self) -> _builtins.str:
        """
        Defines the new activation target value to scale on for the composed metric.
        """
        return pulumi.get(self, "activation_target")

    @activation_target.setter
    def activation_target(self, value: _builtins.str):
        pulumi.set(self, "activation_target", value)

    @_builtins.property
    @pulumi.getter
    def formula(self) -> _builtins.str:
        """
        Composes metrics together and allows them to be modified/manipulated. It accepts mathematical/conditional statements.
        """
        return pulumi.get(self, "formula")

    @formula.setter
    def formula(self, value: _builtins.str):
        pulumi.set(self, "formula", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        Defines metric type used for this new composite-metric.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: _builtins.str):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        Defines new target value to scale on for the composed metric.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.str):
        pulumi.set(self, "target", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingKedaTriggerArgsDict(TypedDict):
        metadata: Mapping[str, _builtins.str]
        """
        The configuration parameters that the trigger requires.
        """
        metric_type: _builtins.str
        """
        The type of metric to be used for scaling.
        """
        name: _builtins.str
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        type: _builtins.str
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        use_cached_metrics: _builtins.bool
        """
        Enables caching of metric values during polling interval.
        """
        authentication_reves: NotRequired[Sequence['GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgsDict']]
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
elif False:
    GetWorkloadOptionAutoscalingKedaTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingKedaTriggerArgs:
    def __init__(__self__, *,
                 metadata: Mapping[str, _builtins.str],
                 metric_type: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 use_cached_metrics: _builtins.bool,
                 authentication_reves: Optional[Sequence['GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgs']] = None):
        """
        :param Mapping[str, _builtins.str] metadata: The configuration parameters that the trigger requires.
        :param _builtins.str metric_type: The type of metric to be used for scaling.
        :param _builtins.str name: An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        :param _builtins.str type: The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        :param _builtins.bool use_cached_metrics: Enables caching of metric values during polling interval.
        :param Sequence['GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgs'] authentication_reves: Reference to a KEDA authentication object for secure access to external systems.
        """
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "metric_type", metric_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "use_cached_metrics", use_cached_metrics)
        if authentication_reves is not None:
            pulumi.set(__self__, "authentication_reves", authentication_reves)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        The configuration parameters that the trigger requires.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Mapping[str, _builtins.str]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="metricType")
    def metric_type(self) -> _builtins.str:
        """
        The type of metric to be used for scaling.
        """
        return pulumi.get(self, "metric_type")

    @metric_type.setter
    def metric_type(self, value: _builtins.str):
        pulumi.set(self, "metric_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        An optional name for the trigger. If not provided, a default name will be generated based on the trigger type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of KEDA trigger, e.g "prometheus", "aws-sqs", etc.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: _builtins.str):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="useCachedMetrics")
    def use_cached_metrics(self) -> _builtins.bool:
        """
        Enables caching of metric values during polling interval.
        """
        return pulumi.get(self, "use_cached_metrics")

    @use_cached_metrics.setter
    def use_cached_metrics(self, value: _builtins.bool):
        pulumi.set(self, "use_cached_metrics", value)

    @_builtins.property
    @pulumi.getter(name="authenticationReves")
    def authentication_reves(self) -> Optional[Sequence['GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgs']]:
        """
        Reference to a KEDA authentication object for secure access to external systems.
        """
        return pulumi.get(self, "authentication_reves")

    @authentication_reves.setter
    def authentication_reves(self, value: Optional[Sequence['GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgs']]):
        pulumi.set(self, "authentication_reves", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgsDict(TypedDict):
        name: _builtins.str
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
elif False:
    GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingKedaTriggerAuthenticationRefArgs:
    def __init__(__self__, *,
                 name: _builtins.str):
        """
        :param _builtins.str name: The name of secret listed in the GVC spec.keda.secrets.
        """
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of secret listed in the GVC spec.keda.secrets.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: _builtins.str):
        pulumi.set(self, "name", value)


if not MYPY:
    class GetWorkloadOptionAutoscalingMultiArgsDict(TypedDict):
        metric: _builtins.str
        """
        Valid values: `cpu` or `memory`.
        """
        target: _builtins.int
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
elif False:
    GetWorkloadOptionAutoscalingMultiArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionAutoscalingMultiArgs:
    def __init__(__self__, *,
                 metric: _builtins.str,
                 target: _builtins.int):
        """
        :param _builtins.str metric: Valid values: `cpu` or `memory`.
        :param _builtins.int target: Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def metric(self) -> _builtins.str:
        """
        Valid values: `cpu` or `memory`.
        """
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: _builtins.str):
        pulumi.set(self, "metric", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.int:
        """
        Control Plane will scale the number of replicas for this deployment up/down in order to be as close as possible to the target metric across all replicas of a deployment. Min: `1`. Max: `20000`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: _builtins.int):
        pulumi.set(self, "target", value)


if not MYPY:
    class GetWorkloadOptionMultiZoneArgsDict(TypedDict):
        enabled: _builtins.bool
elif False:
    GetWorkloadOptionMultiZoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadOptionMultiZoneArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetWorkloadRequestRetryPolicyArgsDict(TypedDict):
        attempts: _builtins.int
        retry_ons: Sequence[_builtins.str]
elif False:
    GetWorkloadRequestRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadRequestRetryPolicyArgs:
    def __init__(__self__, *,
                 attempts: _builtins.int,
                 retry_ons: Sequence[_builtins.str]):
        pulumi.set(__self__, "attempts", attempts)
        pulumi.set(__self__, "retry_ons", retry_ons)

    @_builtins.property
    @pulumi.getter
    def attempts(self) -> _builtins.int:
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: _builtins.int):
        pulumi.set(self, "attempts", value)

    @_builtins.property
    @pulumi.getter(name="retryOns")
    def retry_ons(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "retry_ons")

    @retry_ons.setter
    def retry_ons(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "retry_ons", value)


if not MYPY:
    class GetWorkloadRolloutOptionArgsDict(TypedDict):
        max_surge_replicas: _builtins.str
        """
        The number of replicas that can be created above the desired amount of replicas during an update.
        """
        max_unavailable_replicas: _builtins.str
        """
        The number of replicas that can be unavailable during the update process.
        """
        min_ready_seconds: _builtins.int
        """
        The minimum number of seconds a container must run without crashing to be considered available.
        """
        scaling_policy: _builtins.str
        """
        The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        """
        termination_grace_period_seconds: _builtins.int
        """
        The amount of time in seconds a workload has to gracefully terminate before forcefully terminating it. This includes the time it takes for the preStop hook to run.
        """
elif False:
    GetWorkloadRolloutOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadRolloutOptionArgs:
    def __init__(__self__, *,
                 max_surge_replicas: _builtins.str,
                 max_unavailable_replicas: _builtins.str,
                 min_ready_seconds: _builtins.int,
                 scaling_policy: _builtins.str,
                 termination_grace_period_seconds: _builtins.int):
        """
        :param _builtins.str max_surge_replicas: The number of replicas that can be created above the desired amount of replicas during an update.
        :param _builtins.str max_unavailable_replicas: The number of replicas that can be unavailable during the update process.
        :param _builtins.int min_ready_seconds: The minimum number of seconds a container must run without crashing to be considered available.
        :param _builtins.str scaling_policy: The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        :param _builtins.int termination_grace_period_seconds: The amount of time in seconds a workload has to gracefully terminate before forcefully terminating it. This includes the time it takes for the preStop hook to run.
        """
        pulumi.set(__self__, "max_surge_replicas", max_surge_replicas)
        pulumi.set(__self__, "max_unavailable_replicas", max_unavailable_replicas)
        pulumi.set(__self__, "min_ready_seconds", min_ready_seconds)
        pulumi.set(__self__, "scaling_policy", scaling_policy)
        pulumi.set(__self__, "termination_grace_period_seconds", termination_grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="maxSurgeReplicas")
    def max_surge_replicas(self) -> _builtins.str:
        """
        The number of replicas that can be created above the desired amount of replicas during an update.
        """
        return pulumi.get(self, "max_surge_replicas")

    @max_surge_replicas.setter
    def max_surge_replicas(self, value: _builtins.str):
        pulumi.set(self, "max_surge_replicas", value)

    @_builtins.property
    @pulumi.getter(name="maxUnavailableReplicas")
    def max_unavailable_replicas(self) -> _builtins.str:
        """
        The number of replicas that can be unavailable during the update process.
        """
        return pulumi.get(self, "max_unavailable_replicas")

    @max_unavailable_replicas.setter
    def max_unavailable_replicas(self, value: _builtins.str):
        pulumi.set(self, "max_unavailable_replicas", value)

    @_builtins.property
    @pulumi.getter(name="minReadySeconds")
    def min_ready_seconds(self) -> _builtins.int:
        """
        The minimum number of seconds a container must run without crashing to be considered available.
        """
        return pulumi.get(self, "min_ready_seconds")

    @min_ready_seconds.setter
    def min_ready_seconds(self, value: _builtins.int):
        pulumi.set(self, "min_ready_seconds", value)

    @_builtins.property
    @pulumi.getter(name="scalingPolicy")
    def scaling_policy(self) -> _builtins.str:
        """
        The strategies used to update applications and services deployed. Valid values: `OrderedReady` (Updates workloads in a rolling fashion, taking down old ones and bringing up new ones incrementally, ensuring that the service remains available during the update.), `Parallel` (Causes all pods affected by a scaling operation to be created or destroyed simultaneously. This does not affect update operations.). Default: `OrderedReady`.
        """
        return pulumi.get(self, "scaling_policy")

    @scaling_policy.setter
    def scaling_policy(self, value: _builtins.str):
        pulumi.set(self, "scaling_policy", value)

    @_builtins.property
    @pulumi.getter(name="terminationGracePeriodSeconds")
    def termination_grace_period_seconds(self) -> _builtins.int:
        """
        The amount of time in seconds a workload has to gracefully terminate before forcefully terminating it. This includes the time it takes for the preStop hook to run.
        """
        return pulumi.get(self, "termination_grace_period_seconds")

    @termination_grace_period_seconds.setter
    def termination_grace_period_seconds(self, value: _builtins.int):
        pulumi.set(self, "termination_grace_period_seconds", value)


if not MYPY:
    class GetWorkloadSecurityOptionArgsDict(TypedDict):
        file_system_group_id: _builtins.int
        """
        The group id assigned to any mounted volume.
        """
elif False:
    GetWorkloadSecurityOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadSecurityOptionArgs:
    def __init__(__self__, *,
                 file_system_group_id: _builtins.int):
        """
        :param _builtins.int file_system_group_id: The group id assigned to any mounted volume.
        """
        pulumi.set(__self__, "file_system_group_id", file_system_group_id)

    @_builtins.property
    @pulumi.getter(name="fileSystemGroupId")
    def file_system_group_id(self) -> _builtins.int:
        """
        The group id assigned to any mounted volume.
        """
        return pulumi.get(self, "file_system_group_id")

    @file_system_group_id.setter
    def file_system_group_id(self, value: _builtins.int):
        pulumi.set(self, "file_system_group_id", value)


if not MYPY:
    class GetWorkloadSidecarArgsDict(TypedDict):
        envoy: _builtins.str
elif False:
    GetWorkloadSidecarArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetWorkloadSidecarArgs:
    def __init__(__self__, *,
                 envoy: _builtins.str):
        pulumi.set(__self__, "envoy", envoy)

    @_builtins.property
    @pulumi.getter
    def envoy(self) -> _builtins.str:
        return pulumi.get(self, "envoy")

    @envoy.setter
    def envoy(self, value: _builtins.str):
        pulumi.set(self, "envoy", value)


