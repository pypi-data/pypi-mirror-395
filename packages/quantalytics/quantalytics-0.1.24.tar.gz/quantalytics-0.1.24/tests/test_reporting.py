import math
import uuid
from pathlib import Path

import pandas as pd
import pytest

from quantalytics.reports import html
from quantalytics.reports.metric_registry import (
    SUMMARY_METRIC_REGISTRY,
    resolve_summary_specs,
)
from quantalytics.reports.metrics import monthly_returns
from quantalytics.reports.tearsheet import (
    CustomPanel,
    _format_date_iso,
    _format_date_readable,
    _format_summary_metric,
    _package_version,
    _period_return,
    _scalar_value,
)
from quantalytics.reports.tearsheet import (
    _resolve_summary_specs as _resolve_summary_specs_tearsheet,
)

DATA_PATH = Path(__file__).with_name("daily_returns.csv")
BENCHMARK_PATH = Path(__file__).with_name("benchmark_returns.csv")


def sample_returns() -> pd.Series:
    """Returns the deterministic series used for reporting tests."""

    df = pd.read_csv(DATA_PATH, parse_dates=["Date"]).set_index("Date")
    return df["Return"]


def sample_benchmark_returns() -> pd.Series:
    """Benchmark series aligned with sample_returns dates."""

    df = pd.read_csv(BENCHMARK_PATH, parse_dates=["Date"]).set_index("Date")
    return df["Return"]


def test_html_render_basic_tearsheet():
    returns = sample_returns()
    report = html(returns, title="Custom Tearsheet")
    assert isinstance(report.html, str)
    assert "Custom Tearsheet" in report.html
    assert report.html.strip().startswith("<!DOCTYPE html>")
    assert "4 Nov 2020 â†’ 12 Nov 2025" in report.html
    assert "Generated by Quantalytics (v" in report.html
    assert "Client identity" not in report.html
    assert "Strategy Parameters" not in report.html
    assert "Sharpe Ratio" in report.html


def test_html_accepts_summary_stats_list():
    returns = sample_returns()
    report = html(
        returns, summary_stats=["sharpe", "max_drawdown", "sortino", "romad", "cagr"]
    )
    assert "Sharpe Ratio" in report.html
    assert "Win Rate" in report.html
    assert "CAGR" in report.html


def test_html_handles_empty_returns_branch():
    empty_returns = pd.Series(dtype=float)
    report = html(empty_returns, title="Empty Case")
    assert "Empty Case" in report.html
    assert "Data coverage unavailable" in report.html


def test_package_version_falls_back_for_missing_package():
    missing = f"quantalytics_missing_{uuid.uuid4().hex}"
    assert _package_version(missing) == "0.0.0"


def test_scalar_value_handles_empty_series():
    result = _scalar_value(pd.Series(dtype=float))
    assert math.isnan(result)


def test_format_date_helpers_return_original_string_on_error():
    invalid_date = "not a date"
    assert _format_date_iso(invalid_date) == invalid_date
    assert _format_date_readable(invalid_date) == invalid_date


def test_format_summary_metric_handles_invalid_inputs():
    assert _format_summary_metric(None, scale=1, decimals=2, suffix="%") == "N/A"
    assert _format_summary_metric("bad", scale=1, decimals=2, suffix="%") == "N/A"
    assert (
        _format_summary_metric(pd.Series(dtype=float), scale=1, decimals=2, suffix="%")
        == "N/A"
    )


def test_period_return_falls_back_when_window_is_empty():
    series = pd.Series([0.01, 0.02], index=pd.date_range("2024-01-01", periods=2))
    distant_future = pd.Timestamp("2030-01-01")
    assert _period_return(series, distant_future) == 0.0


def test_html_handles_date_parsing_errors(monkeypatch):
    returns = sample_returns()

    original_to_datetime = pd.to_datetime

    def _fake_to_datetime(value, *args, **kwargs):
        if value is returns.index:
            raise ValueError("boom")
        return original_to_datetime(value, *args, **kwargs)

    monkeypatch.setattr(pd, "to_datetime", _fake_to_datetime)
    report = html(returns, title="Date Error")
    assert "Data coverage unavailable" in report.html


def test_html_supports_log_scale_mode():
    returns = sample_returns()
    report = html(returns, log_scale=True, title="Log Scale")
    assert "Log Scale" in report.html


def test_html_short_series_skips_rolling_metrics():
    dates = pd.date_range("2030-01-01", periods=2)
    series = pd.Series([0.01, 0.02], index=dates)
    report = html(series, title="Short Series")
    assert "Short Series" in report.html


def test_html_includes_header_logo():
    returns = sample_returns()
    logo_url = "https://example.com/logo.png"
    report = html(returns, title="Logo Report", header_logo=logo_url)
    assert f'src="{logo_url}"' in report.html
    assert "Client identity" in report.html


def test_html_with_benchmark_adds_comparison_columns():
    returns = sample_returns()
    benchmark = sample_benchmark_returns().rename("AAPL")
    report = html(returns, benchmark=benchmark)
    assert "Return (AAPL)" in report.html
    assert '<th style="text-align:right;">AAPL</th>' in report.html
    report.to_html("benchmark.html")


def test_html_renders_parameters_table(tmp_path):
    returns = sample_returns()
    parameters = {"Name": "alpha", "Trade Count": "42"}
    report = html(returns, title="Params", parameters=parameters)
    assert "Strategy Parameters" in report.html
    assert "alpha" in report.html
    assert "42" in report.html
    target = "params.html"
    report.to_html(target)
    # assert target.exists()


def test_metric_registry_resolves_all_registered_keys():
    keys = list(SUMMARY_METRIC_REGISTRY.keys())
    specs = resolve_summary_specs(keys)
    assert len(specs) == len(keys)
    assert all(spec.label for spec in specs)
    assert all(spec.value_key for spec in specs)


def test_tearsheet_summary_specs_reject_unknown_keys():
    with pytest.raises(ValueError):
        _resolve_summary_specs_tearsheet(["not-a-real-spec"])


def test_monthly_returns_basic():
    """Test that monthly_returns creates proper pivot table structure."""
    returns = sample_returns()
    monthly = monthly_returns(returns)

    # Check that result is a DataFrame
    assert isinstance(monthly, pd.DataFrame)

    # Check that all month columns are present (JAN-DEC + EOY)
    expected_cols = [
        "JAN",
        "FEB",
        "MAR",
        "APR",
        "MAY",
        "JUN",
        "JUL",
        "AUG",
        "SEP",
        "OCT",
        "NOV",
        "DEC",
        "EOY",
    ]
    assert list(monthly.columns) == expected_cols

    # Check that years are in the index
    assert len(monthly.index) > 0
    assert all(isinstance(year, str) for year in monthly.index)


def test_monthly_returns_without_eoy():
    """Test monthly_returns without end-of-year column."""
    returns = sample_returns()
    monthly = monthly_returns(returns, eoy=False)

    # Check that EOY column is not present
    expected_cols = [
        "JAN",
        "FEB",
        "MAR",
        "APR",
        "MAY",
        "JUN",
        "JUL",
        "AUG",
        "SEP",
        "OCT",
        "NOV",
        "DEC",
    ]
    assert list(monthly.columns) == expected_cols


def test_monthly_returns_compounded_vs_arithmetic():
    """Test that compounded and arithmetic aggregation produce different results."""
    returns = sample_returns()
    monthly_comp = monthly_returns(returns, compounded=True)
    monthly_arith = monthly_returns(returns, compounded=False)

    # Both should have same structure
    assert monthly_comp.shape == monthly_arith.shape

    # Values should generally differ (though may be close for small returns)
    # Just check that they're not identical
    assert not monthly_comp.equals(monthly_arith)


def test_monthly_returns_with_simple_data():
    """Test monthly_returns with simple synthetic data."""
    # Create a simple test case with known values
    dates = pd.date_range("2023-01-01", "2023-03-31", freq="D")
    returns = pd.Series([0.01] * len(dates), index=dates)

    monthly = monthly_returns(returns, eoy=True, compounded=True)

    # Should have one row for 2023
    assert "2023" in monthly.index

    # January, February, and March should have non-zero values
    assert monthly.loc["2023", "JAN"] != 0
    assert monthly.loc["2023", "FEB"] != 0
    assert monthly.loc["2023", "MAR"] != 0

    # Other months should be 0 (missing data)
    assert monthly.loc["2023", "APR"] == 0
    assert monthly.loc["2023", "DEC"] == 0


def test_monthly_returns_preserves_native_type():
    """Test that monthly_returns returns the same native type as input."""
    # Create pandas Series input
    dates = pd.date_range("2023-01-01", "2023-03-31", freq="D")
    pandas_returns = pd.Series([0.01] * len(dates), index=dates)

    # Call function with pandas Series
    result = monthly_returns(pandas_returns)

    # Result should be a pandas DataFrame (native type preserved)
    assert isinstance(result, pd.DataFrame)
    assert not hasattr(result, "to_pandas")  # Should be native pandas, not narwhals


def test_custom_panel_with_only_charts():
    """Test custom panel with only charts (should expand to 100% width)."""
    import plotly.graph_objects as go

    returns = sample_returns()

    # Create a custom Plotly figure
    custom_fig = go.Figure(
        data=[go.Scatter(x=returns.index, y=returns.cumsum(), name="Cumulative")]
    )
    custom_fig.update_layout(title="Custom Analysis")

    # Create panel with only charts
    panel = CustomPanel(title="Chart Analysis", charts=[custom_fig])

    # Generate tearsheet
    report = html(returns, custom_panels=[panel])

    # Verify panel appears in HTML
    assert "Chart Analysis" in report.html
    assert 'layout": "charts_only"' in report.html or "custom-panel-full" in report.html
    assert "Custom Analysis" in report.html


def test_custom_panel_with_only_metrics():
    """Test custom panel with only metrics (should expand to 100% width)."""
    returns = sample_returns()

    # Create panel with only metrics
    panel = CustomPanel(
        title="Custom Metrics",
        metrics={"Alpha": "2.3%", "Beta": "0.85", "R-Squared": "0.72"},
    )

    # Generate tearsheet
    report = html(returns, custom_panels=[panel])

    # Verify panel appears in HTML
    assert "Custom Metrics" in report.html
    assert "Alpha" in report.html
    assert "2.3%" in report.html
    assert "Beta" in report.html
    assert "0.85" in report.html
    assert "R-Squared" in report.html
    assert "0.72" in report.html
    assert (
        'layout": "metrics_only"' in report.html or "custom-panel-full" in report.html
    )


def test_custom_panel_with_both_charts_and_metrics():
    """Test custom panel with both charts and metrics (should use 70/30 split)."""
    import plotly.graph_objects as go

    returns = sample_returns()

    # Create a custom Plotly figure
    custom_fig = go.Figure(data=[go.Bar(x=["A", "B", "C"], y=[1, 2, 3])])
    custom_fig.update_layout(title="Custom Bar Chart")

    # Create panel with both charts and metrics
    panel = CustomPanel(
        title="Factor Analysis",
        charts=[custom_fig],
        metrics={"Sharpe": "1.5", "Sortino": "1.8", "Calmar": "2.1"},
    )

    # Generate tearsheet
    report = html(returns, custom_panels=[panel])

    # Verify panel appears in HTML with both components
    assert "Factor Analysis" in report.html
    assert "Custom Bar Chart" in report.html
    assert "Sharpe" in report.html
    assert "1.5" in report.html
    assert "Sortino" in report.html
    assert "1.8" in report.html
    assert 'layout": "both"' in report.html or "custom-panel-split" in report.html


def test_custom_panel_with_multiple_charts():
    """Test custom panel with multiple charts."""
    import plotly.graph_objects as go

    returns = sample_returns()

    # Create multiple custom Plotly figures
    fig1 = go.Figure(
        data=[go.Scatter(x=returns.index[:50], y=returns[:50], name="Recent")]
    )
    fig1.update_layout(title="Chart 1")

    fig2 = go.Figure(data=[go.Bar(x=["Q1", "Q2", "Q3"], y=[5, 10, 8])])
    fig2.update_layout(title="Chart 2")

    # Create panel with multiple charts
    panel = CustomPanel(title="Multi-Chart Panel", charts=[fig1, fig2])

    # Generate tearsheet
    report = html(returns, custom_panels=[panel])

    # Verify both charts appear
    assert "Multi-Chart Panel" in report.html
    assert "Chart 1" in report.html
    assert "Chart 2" in report.html


def test_custom_panel_empty_panel_is_skipped():
    """Test that empty custom panels (no charts or metrics) are skipped."""
    returns = sample_returns()

    # Create panel with no charts or metrics
    empty_panel = CustomPanel(title="Empty Panel")

    # Generate tearsheet
    report = html(returns, custom_panels=[empty_panel])

    # Empty panel should not appear in HTML
    assert "Empty Panel" not in report.html


def test_custom_panel_with_invalid_chart_is_handled():
    """Test that invalid charts are handled gracefully."""
    returns = sample_returns()

    # Create panel with an object that will fail chart conversion
    panel = CustomPanel(title="Invalid Chart Panel", charts=["not a plotly figure"])

    # Generate tearsheet (should not crash)
    report = html(returns, custom_panels=[panel])

    # Panel title might appear, but chart will be skipped due to error
    assert isinstance(report.html, str)


def test_multiple_custom_panels():
    """Test multiple custom panels are rendered in order."""
    import plotly.graph_objects as go

    returns = sample_returns()

    # Create multiple panels
    panel1 = CustomPanel(title="Panel One", metrics={"Metric A": "100"})
    panel2 = CustomPanel(
        title="Panel Two", charts=[go.Figure(data=[go.Scatter(x=[1, 2], y=[1, 2])])]
    )
    panel3 = CustomPanel(title="Panel Three", metrics={"Metric B": "200"})

    # Generate tearsheet
    report = html(returns, custom_panels=[panel1, panel2, panel3])

    report.to_html("panel.html")

    # Verify all panels appear
    assert "Panel One" in report.html
    assert "Panel Two" in report.html
    assert "Panel Three" in report.html
    assert "Metric A" in report.html
    assert "100" in report.html
    assert "Metric B" in report.html
    assert "200" in report.html


def test_portfolio_summary_values_populated():
    """Test that portfolio summary cards are populated with actual values, not N/A."""
    returns = sample_returns()

    # Generate tearsheet with default summary stats
    report = html(returns, title="Summary Test", risk_free_rate=0.02, periods=252)

    # Check that Portfolio Summary section exists
    assert "Portfolio Summary" in report.html

    # Find the portfolio summary section
    summary_start = report.html.find("Portfolio Summary")
    assert summary_start != -1, "Portfolio Summary section not found"

    # Extract a reasonable chunk of HTML after "Portfolio Summary"
    summary_section = report.html[summary_start : summary_start + 3000]

    # Default summary stats include: cagr, sharpe, max_drawdown, win_rate, romad, sortino
    # These should NOT all be N/A
    na_count = summary_section.count("N/A")

    # The summary should not be entirely N/A values (allow max 1 N/A for edge cases)
    assert na_count <= 1, f"Too many N/A values in portfolio summary: {na_count}"

    # Should have actual metric values
    # Some metrics have % suffix (max_drawdown, win_rate), others don't (sharpe, romad)
    # Check that we have at least some percentage values AND numeric values
    assert summary_section.count("%") >= 2, "Not enough percentage values in summary"

    # Check for numeric patterns that indicate populated values (e.g., "0.80", "15.20")
    # We should see decimal numbers which indicate actual calculated values
    import re

    numeric_values = re.findall(r"\d+\.\d+", summary_section)
    assert len(numeric_values) >= 4, (
        f"Not enough numeric values in summary: {len(numeric_values)}"
    )

    # Check that specific metrics are populated
    assert "CAGR" in summary_section
    assert "Sharpe Ratio" in summary_section
    assert "Max Drawdown" in summary_section
    assert "Win Rate" in summary_section
    assert "RoMaD" in summary_section
    assert "Sortino" in summary_section or "Sortino Ratio" in summary_section


def test_portfolio_summary_with_custom_metrics():
    """Test portfolio summary with custom metric selection."""
    returns = sample_returns()

    # Generate tearsheet with custom summary stats
    report = html(
        returns,
        summary_stats=["sharpe", "sortino", "calmar", "omega"],
        risk_free_rate=0.02,
        periods=252,
    )

    # Check that custom metrics are populated
    summary_start = report.html.find("Portfolio Summary")
    assert summary_start != -1
    summary_section = report.html[summary_start : summary_start + 3000]

    # Custom metrics should appear
    assert "Sharpe Ratio" in summary_section
    assert "Sortino" in summary_section or "Sortino Ratio" in summary_section
    assert "Calmar" in summary_section or "Calmar Ratio" in summary_section
    assert "Omega" in summary_section or "Omega Ratio" in summary_section

    # Should have actual values, not all N/A
    na_count = summary_section.count("N/A")
    assert na_count <= 1, f"Too many N/A values with custom metrics: {na_count}"
