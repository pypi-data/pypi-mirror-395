"""
Business Logic Services for {{ app_name }}
===========================================

Services contain business logic separated from views.
This promotes:
- Clean, testable code
- Reusable business rules
- Separation of concerns

Generated by ADEMA Framework.
"""
import logging
from typing import Optional, List, Dict, Any

try:
    from adema.base.services import AdemaBaseService, ServiceResult, CRUDService
except ImportError:
    # Fallback if adema is not installed
    from django.db import transaction
    from contextlib import contextmanager
    
    class ServiceResult:
        def __init__(self, success, data=None, message="", errors=None):
            self.success = success
            self.data = data
            self.message = message
            self.errors = errors or []
        
        @classmethod
        def ok(cls, data=None, message=""):
            return cls(True, data, message)
        
        @classmethod
        def fail(cls, message, errors=None):
            return cls(False, None, message, errors)
    
    class AdemaBaseService:
        def __init__(self):
            self.log = logging.getLogger(self.__class__.__name__)
        
        @contextmanager
        def transaction(self):
            with transaction.atomic():
                yield
    
    class CRUDService(AdemaBaseService):
        model_class = None


# =============================================================================
# {{ app_name|upper }} SERVICES
# =============================================================================

# Example service:
# 
# class {{ camel_case_app_name }}Service(AdemaBaseService):
#     """
#     Service for {{ app_name }} business logic.
#     
#     Example usage:
#         service = {{ camel_case_app_name }}Service()
#         result = service.process_item(item_id)
#         if result.success:
#             print(f"Processed: {result.data}")
#     """
#     
#     def process_item(self, item_id: str) -> ServiceResult:
#         """
#         Process an item with transaction support.
#         
#         Args:
#             item_id: UUID of the item to process
#             
#         Returns:
#             ServiceResult with the processed item or error
#         """
#         from ..models import YourModel
#         
#         item = YourModel.get_by_id(item_id)
#         if not item:
#             return ServiceResult.fail(f"Item {item_id} not found")
#         
#         try:
#             with self.transaction():
#                 self.log.info(f"Processing item {item_id}")
#                 
#                 # Your business logic here
#                 item.status = 'processed'
#                 item.save()
#                 
#                 self.log.info(f"Item {item_id} processed successfully")
#                 return ServiceResult.ok(item, "Item processed successfully")
#                 
#         except Exception as e:
#             self.log.error(f"Failed to process item {item_id}: {e}")
#             return ServiceResult.fail(str(e))
#     
#     def calculate_total(self, items: List) -> ServiceResult:
#         """Calculate total for a list of items."""
#         try:
#             total = sum(item.amount for item in items)
#             return ServiceResult.ok({'total': total, 'count': len(items)})
#         except Exception as e:
#             return ServiceResult.fail(str(e))


# Example CRUD service:
# 
# class {{ camel_case_app_name }}CRUDService(CRUDService):
#     """CRUD operations for {{ app_name }} model."""
#     model_class = YourModel  # Set your model here
#     
#     # Override methods for custom behavior:
#     # def create(self, **data) -> ServiceResult:
#     #     # Add validation or pre-processing
#     #     return super().create(**data)
