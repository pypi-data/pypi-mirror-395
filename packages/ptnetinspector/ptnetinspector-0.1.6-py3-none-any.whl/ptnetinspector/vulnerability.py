import csv
from collections import defaultdict
import re
import os
import ipaddress
from scapy.all import get_if_hwaddr

from ptnetinspector.utils.path import get_csv_path
from ptnetinspector.utils.ip_utils import has_additional_data, is_broadcast_ipv4, is_global_unicast_ipv6, is_multicast_ipv4, is_valid_ipv4, is_valid_ipv6, check_ipv6_addresses_generated_from_prefix, is_ipv6_predictable, is_link_local_ipv6
from ptnetinspector.utils.ip_utils import convert_preferenceRA
from ptnetinspector.utils.csv_helpers import sort_and_deduplicate_vul_csv, read_role_node_csv
from ptnetinspector.utils.interface import Interface
from ptnetinspector.send.send import IPMode


class Vulnerability:
    def __init__(self, interface: str, mode: list[str], ipver: IPMode, smac: str, network: str, prefix_len: int, 
                 rpref: int, dns: list[str],
                 role_file: str = None,
                 time_incoming_file: str = None,
                 time_all_file: str = None,
                 vulnerability_file: str = None):
        self.interface = interface
        self.mode = mode
        self.ipver = ipver
        self.smac = smac
        self.network = network
        self.prefix_len = prefix_len
        self.pref = convert_preferenceRA(rpref)
        self.dns = dns
        
        # Use centralized path functions for all files
        self.role_file = role_file or get_csv_path("role_node.csv")
        self.time_incoming_file = time_incoming_file or get_csv_path("time_incoming.csv")
        self.time_all_file = time_all_file or get_csv_path("time_all.csv")
        self.vulnerability_file = vulnerability_file or get_csv_path("vulnerability.csv")

    def handle_vulnerabilities(self, specific_mode: str):
        """Main entry to handle all vulnerabilities."""
        if specific_mode == "802.1x":
            self.store_eap_vulnerability()
        if specific_mode in ["p", "a", "a+"]:
            self.store_MDNS_vulnerability()
            self.store_llmnr_vulnerability()
            self.store_ws_vulnerability()
            self.store_icmp_vulnerability()
            if self.ipver.ipv6:
                self.store_mld_vulnerability()
                self.store_ipv6_vulnerability()
        if specific_mode == "a+" and self.ipver.ipv6:
            self.store_ra_vulnerability()
                
        sort_and_deduplicate_vul_csv(self.vulnerability_file)

    def _filter_modes(self, mode_string: str) -> str:
        """Filter mode string to only include modes running in this scan.
        
        Args:
            mode_string: Mode string like "a,a+", "p,a,a+", "a+" etc.
            
        Returns:
            Filtered mode string with only modes in self.mode, or empty string if none match.
        """
        modes = [m.strip() for m in mode_string.split(',')]
        active_modes = [m for m in modes if m in self.mode]
        return ','.join(active_modes) if active_modes else ""

    def _load_existing_rows(self):
        """Load existing vulnerability rows from CSV to avoid duplicates."""
        existing_rows = set()
        if os.path.exists(self.vulnerability_file):
            try:
                with open(self.vulnerability_file, 'r', newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        row_tuple = tuple(row[field].strip() for field in ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'])
                        existing_rows.add(row_tuple)
            except Exception:
                pass
        return existing_rows

    def _write_vulnerabilities(self, new_rows):
        """Write new vulnerability rows to CSV."""
        if not new_rows:
            return
        
        try:
            os.makedirs(os.path.dirname(self.vulnerability_file), exist_ok=True)
            write_header = not os.path.exists(self.vulnerability_file)
            with open(self.vulnerability_file, mode='a', newline='') as csvfile:
                fieldnames = ['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label']
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                if write_header:
                    writer.writeheader()
                writer.writerows(new_rows)
        except Exception:
            pass

    def _create_vuln_row(self, row_tuple):
        """Convert tuple to dictionary row."""
        return dict(zip(['ID', 'MAC', 'Mode', 'IPver', 'Code', 'Description', 'Label'], row_tuple))

    def _add_vuln_if_new(self, row_tuple, existing_rows, new_rows):
        """Add vulnerability if not already exists."""
        if row_tuple not in existing_rows:
            new_rows.append(self._create_vuln_row(row_tuple))
            existing_rows.add(row_tuple)

    def _get_ipver_values(self):
        """Get list of IP versions to process."""
        ipver_values = []
        if self.ipver.ipv4:
            ipver_values.append('4')
        if self.ipver.ipv6:
            ipver_values.append('6')
        return ipver_values

    def _extract_address(self, packet: str, addr_type: str) -> str:
        """Extract source or destination address from packet string."""
        ip_section = re.search(r'IP\s*\]\#\#\#(.*?)(?=###|\Z)', packet, re.DOTALL)
        if not ip_section:
            return ""
        
        match = re.search(rf'{addr_type}\s*=\s*([0-9A-Fa-f:.]+)', ip_section.group(1))
        addr = match.group(1) if match else ""
        
        # Filter out MAC addresses
        if re.fullmatch(r'[0-9A-Fa-f]{2}(?::[0-9A-Fa-f]{2}){5}', addr):
            return ""
        
        return addr

    def store_eap_vulnerability(self):
        """Check for 802.1x deployment by analyzing EAPOL patterns."""
        existing_rows = self._load_existing_rows()
        self.smac = get_if_hwaddr(self.interface)
        
        label = 2
        if os.path.exists(self.time_all_file) and has_additional_data(self.time_all_file):
            eapol_start_found = False
            eapol_start_timestamp = None
            try:
                with open(self.time_all_file, 'r', newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    for row in reader:
                        mac = row.get('MAC', '').strip()
                        packet = row.get('packet', '')
                        if mac == self.smac and 'type = EAPOL-Start' in packet:
                            eapol_start_found = True
                            eapol_start_timestamp = row.get('time', '')
                            break
                
                if eapol_start_found:
                    label = 1
                    with open(self.time_all_file, 'r', newline='') as csvfile:
                        reader = csv.DictReader(csvfile)
                        for row in reader:
                            mac = row.get('MAC', '').strip()
                            packet = row.get('packet', '')
                            timestamp = row.get('time', '')
                            
                            if mac != self.smac and 'EAP' in packet:
                                if not eapol_start_timestamp or timestamp >= eapol_start_timestamp:
                                    label = 0
                                    break
            except (FileNotFoundError, KeyError):
                label = 2
        
        network_row = ('Network', '', '802.1x', '', 'PTV-NET-NET-MISCONF-8021X',
                      'Network does not have 802.1x deployed', str(label))
            
        self._add_vuln_if_new(network_row, existing_rows, [])
        self._write_vulnerabilities([self._create_vuln_row(network_row)])

    def _process_query_response_vulnerability(self, query_check, response_check, role_dict, ipver_values,
                                             device_code, device_desc, net_code, net_desc, mode='a,a+',
                                             additional_query_check=None, additional_response_check=None):
        """
        Generic method to process vulnerabilities with query-response pattern.
        
        Args:
            query_check: Function to check if packet is a query (packet, mac, smac) -> bool
            response_check: Function to check if packet is a response (packet, mac) -> bool
            role_dict: Dictionary of device_id -> mac
            ipver_values: List of IP versions to check
            device_code: Device vulnerability code
            device_desc: Device vulnerability description
            net_code: Network vulnerability code
            net_desc: Network vulnerability description
            mode: Mode string (default: 'a,a+')
            additional_query_check: Optional additional query validation
            additional_response_check: Optional additional response validation
        """
        if not os.path.exists(self.time_all_file) or not has_additional_data(self.time_all_file):
            return
        
        # Filter mode to only active modes
        mode = self._filter_modes(mode)
        if not mode:
            return
        
        existing_rows = self._load_existing_rows()
        new_rows = []
        
        for ipver_value in ipver_values:
            query_found = False
            first_query_idx = -1
            response_macs = set()
            
            try:
                with open(self.time_all_file, 'r', newline='') as csvfile:
                    reader = csv.DictReader(csvfile)
                    current_index = 0
                    
                    for row in reader:
                        packet = row.get('packet', '')
                        mac = row.get('MAC', '').strip()
                        
                        # Check IP version
                        version_match = (ipver_value == '4' and 'version = 4' in packet) or \
                                      (ipver_value == '6' and 'version = 6' in packet)
                        
                        if not version_match:
                            current_index += 1
                            continue
                        
                        # Check for query
                        if not query_found and query_check(packet, mac, self.smac):
                            if additional_query_check is None or additional_query_check(packet):
                                query_found = True
                                first_query_idx = current_index
                        
                        # Check for response after query
                        if query_found and current_index > first_query_idx:
                            if response_check(packet, mac):
                                if additional_response_check is None or additional_response_check(packet):
                                    response_macs.add(mac)
                        
                        current_index += 1
                
                # Generate vulnerability entries
                if not query_found:
                    # N/A for all
                    for device_id, mac in role_dict.items():
                        row = (str(device_id), mac, mode, ipver_value, device_code, device_desc, '2')
                        self._add_vuln_if_new(row, existing_rows, new_rows)
                    
                    net_row = ('Network', '', mode, ipver_value, net_code, net_desc, '2')
                    self._add_vuln_if_new(net_row, existing_rows, new_rows)
                else:
                    # Label based on responses
                    for device_id, mac in role_dict.items():
                        label = '1' if mac in response_macs else '0'
                        row = (str(device_id), mac, mode, ipver_value, device_code, device_desc, label)
                        self._add_vuln_if_new(row, existing_rows, new_rows)
                    
                    net_label = '1' if response_macs else '0'
                    net_row = ('Network', '', mode, ipver_value, net_code, net_desc, net_label)
                    self._add_vuln_if_new(net_row, existing_rows, new_rows)
            
            except (FileNotFoundError, KeyError):
                continue
        
        self._write_vulnerabilities(new_rows)

    def store_MDNS_vulnerability(self):
        """Check for MDNS and DNS-SD vulnerabilities."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        
        ipver_values = self._get_ipver_values()
        if not ipver_values:
            return
        
        existing_rows = self._load_existing_rows()
        new_rows = []
        
        for ipver_value in ipver_values:
            self._process_mdns_dnssd(role_dict, ipver_value, existing_rows, new_rows)
        
        self._write_vulnerabilities(new_rows)

    def _process_mdns_dnssd(self, role_dict, ipver_value, existing_rows, new_rows):
        """Process MDNS and DNS-SD for a specific IP version."""
        mdns_query_found = False
        dnssd_query_found = False
        first_mdns_query_index = -1
        first_dnssd_query_index = -1
        mdns_response_macs = set()
        dnssd_response_macs = set()
        
        try:
            with open(self.time_all_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                current_index = 0
                
                for row in reader:
                    packet = row.get('packet', '')
                    mac = row.get('MAC', '').strip()
                    
                    version_match = (ipver_value == '4' and 'version = 4' in packet) or \
                                  (ipver_value == '6' and 'version = 6' in packet)
                    
                    if not version_match:
                        current_index += 1
                        continue
                    
                    # MDNS query
                    if not mdns_query_found and 'dport = mdns' in packet and 'qr = 0' in packet and mac == self.smac:
                        mdns_query_found = True
                        first_mdns_query_index = current_index
                    
                    # DNS-SD query
                    if not dnssd_query_found and 'dport = mdns' in packet and 'qr = 0' in packet and \
                       'dns-sd._udp.local' in packet and mac == self.smac:
                        dnssd_query_found = True
                        first_dnssd_query_index = current_index
                    
                    # MDNS response
                    if mdns_query_found and current_index > first_mdns_query_index and \
                       'dport = mdns' in packet and 'qr = 1' in packet:
                        mdns_response_macs.add(mac)
                    
                    # DNS-SD response
                    if dnssd_query_found and current_index > first_dnssd_query_index and \
                       'dport = mdns' in packet and 'qr = 1' in packet and 'dns-sd._udp.local' in packet:
                        dnssd_response_macs.add(mac)
                    
                    current_index += 1
            
            # Filter mode for this vulnerability type (MDNS/LLMNR/WS use a,a+)
            mode = self._filter_modes('a,a+')
            if not mode:
                return
            
            # Add MDNS vulnerabilities (different codes for IPv4 vs IPv6)
            if ipver_value == '4':
                mdns_device_code = 'PTV-NET-IDENT-MDNS-PTRDEV'
                mdns_device_desc = 'Device responds to IPv4 MDNS packets'
                mdns_net_code = 'PTV-NET-IDENT-MDNS-PTR'
                mdns_net_desc = 'Network allows the delivery of IPv4 MDNS packets'
            else:
                mdns_device_code = 'PTV-NET-IDENT-MDNS-PTR6DEV'
                mdns_device_desc = 'Device responds to IPv6 MDNS packets'
                mdns_net_code = 'PTV-NET-IDENT-MDNS-PTR6'
                mdns_net_desc = 'Network allows the delivery of IPv6 MDNS packets'

            self._add_protocol_vulnerabilities(role_dict, mdns_query_found, mdns_response_macs, ipver_value,
                                              mdns_device_code, mdns_device_desc,
                                              mdns_net_code, mdns_net_desc,
                                              mode, existing_rows, new_rows)
            
            # Add DNS-SD vulnerabilities (different codes for IPv4 vs IPv6)
            if ipver_value == '4':
                dnssd_device_code = 'PTV-NET-IDENT-DNS-SDDEV'
                dnssd_device_desc = 'Device responds to IPv4 DNS Service Discovery packets'
                dnssd_net_code = 'PTV-NET-IDENT-DNS-SD'
                dnssd_net_desc = 'Network allows devices discovery with IPv4 DNS Service Discovery'
            else:
                dnssd_device_code = 'PTV-NET-IDENT-DNS-SD6DEV'
                dnssd_device_desc = 'Device responds to IPv6 DNS Service Discovery packets'
                dnssd_net_code = 'PTV-NET-IDENT-DNS-SD6'
                dnssd_net_desc = 'Network allows devices discovery with IPv6 DNS Service Discovery'

            self._add_protocol_vulnerabilities(role_dict, dnssd_query_found, dnssd_response_macs, ipver_value,
                                              dnssd_device_code, dnssd_device_desc,
                                              dnssd_net_code, dnssd_net_desc,
                                              mode, existing_rows, new_rows)
        
        except (FileNotFoundError, KeyError):
            pass

    def _add_protocol_vulnerabilities(self, role_dict, query_found, response_macs, ipver_value,
                                     device_code, device_desc, net_code, net_desc, mode, existing_rows, new_rows):
        """Helper to add protocol vulnerabilities (MDNS, LLMNR, WS, DNS-SD)."""
        if not query_found:
            # N/A
            for device_id, mac in role_dict.items():
                row = (str(device_id), mac, mode, ipver_value, device_code, device_desc, '2')
                self._add_vuln_if_new(row, existing_rows, new_rows)
            
            net_row = ('Network', '', mode, ipver_value, net_code, net_desc, '2')
            self._add_vuln_if_new(net_row, existing_rows, new_rows)
        else:
            # Label based on responses
            for device_id, mac in role_dict.items():
                label = '1' if mac in response_macs else '0'
                row = (str(device_id), mac, mode, ipver_value, device_code, device_desc, label)
                self._add_vuln_if_new(row, existing_rows, new_rows)
            
            net_label = '1' if response_macs else '0'
            net_row = ('Network', '', mode, ipver_value, net_code, net_desc, net_label)
            self._add_vuln_if_new(net_row, existing_rows, new_rows)

    def store_llmnr_vulnerability(self):
        """Check for LLMNR vulnerabilities."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        
        ipver_values = self._get_ipver_values()
        if not ipver_values:
            return
        
        llmnr_query = lambda p, m, sm: 'dport = 5355' in p and 'qr = 0' in p and m == sm
        llmnr_response = lambda p, m: 'dport = 5355' in p and 'qr = 1' in p

        for ipver_value in ipver_values:
            if ipver_value == '4':
                device_code = 'PTV-NET-IDENT-LLMNR-PTRDEV'
                device_desc = 'Device responds to IPv4 LLMNR packets'
                net_code = 'PTV-NET-IDENT-LLMNR-PTR'
                net_desc = 'Network allows the delivery of IPv4 LLMNR packets'
            else:
                device_code = 'PTV-NET-IDENT-LLMNR-PTR6DEV'
                device_desc = 'Device responds to IPv6 LLMNR packets'
                net_code = 'PTV-NET-IDENT-LLMNR-PTR6'
                net_desc = 'Network allows the delivery of IPv6 LLMNR packets'
            
            self._process_query_response_vulnerability(
                llmnr_query, llmnr_response, role_dict, [ipver_value],
                device_code, device_desc, net_code, net_desc
            )

    def store_ws_vulnerability(self):
        """Check for WS-Discovery vulnerabilities."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return

        ipver_values = self._get_ipver_values()
        if not ipver_values:
            return

        def make_query(ipver_value):
            return lambda p, m, sm: f'version = {ipver_value}' in p and 'dport = 3702' in p and m == sm

        def make_response(ipver_value):
            return lambda p, m: f'version = {ipver_value}' in p and 'sport = 3702' in p

        for ipver_value in ipver_values:
            if ipver_value == '4':
                device_code = 'PTV-NET-IDENT-WSDEV'
                device_desc = 'Device responds to WS-Discovery IPv4 packets'
                net_code = 'PTV-NET-IDENT-WS'
                net_desc = 'Network allows devices discovery with IPv4 WS-Discovery'
            else:
                device_code = 'PTV-NET-IDENT-WS6DEV'
                device_desc = 'Device responds to WS-Discovery IPv6 packets'
                net_code = 'PTV-NET-IDENT-WS6'
                net_desc = 'Network allows devices discovery with IPv6 WS-Discovery'

            self._process_query_response_vulnerability(
                make_query(ipver_value), make_response(ipver_value), role_dict, [ipver_value],
                device_code, device_desc, net_code, net_desc
            )

    def store_mld_vulnerability(self):
        """Check for MLD vulnerabilities (MLDv1, MLDv2, and downgrade)."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict or not self.ipver.ipv6:
            return

        if not os.path.exists(self.time_all_file) or not has_additional_data(self.time_all_file):
            return

        # Filter mode for MLD (only a,a+)
        mode = self._filter_modes('a,a+')
        if not mode:
            return

        existing_rows = self._load_existing_rows()
        
        # Helper: check for global IPv6
        mac_pattern = re.compile(r'^([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}$')
        def contains_global_ipv6(packet_str: str) -> bool:
            for ipcand in re.findall(r'(?:src|dst)\s*=\s*([0-9A-Fa-f:]+)', packet_str):
                if ':' not in ipcand or mac_pattern.match(ipcand):
                    continue
                if is_global_unicast_ipv6(ipcand):
                    return True
            return False

        # Track MLD queries and responses
        v1_data = {'query_found': False, 'first_idx': -1, 'resp_macs': set(), 'glip_macs': set()}
        v2_data = {'query_found': False, 'first_idx': -1, 'resp_macs': set(), 'glip_macs': set(), 'downgrade_macs': set()}
        
        try:
            with open(self.time_all_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                current_index = 0
                
                for row in reader:
                    packet = row.get('packet', '')
                    mac = row.get('MAC', '').strip()

                    if 'version = 6' not in packet:
                        current_index += 1
                        continue

                    # MLDv1 query
                    if not v1_data['query_found'] and 'MLD - Multicast Listener Query' in packet and mac == self.smac:
                        v1_data['query_found'] = True
                        v1_data['first_idx'] = current_index
                    
                    # MLDv2 query
                    if not v2_data['query_found'] and 'MLDv2 - Multicast Listener Query' in packet and mac == self.smac:
                        v2_data['query_found'] = True
                        v2_data['first_idx'] = current_index

                    # MLDv1 responses
                    if v1_data['query_found'] and current_index > v1_data['first_idx']:
                        if ('MLD - Multicast Listener Report' in packet) or ('MLD - Multicast Listener Done' in packet):
                            v1_data['resp_macs'].add(mac)
                            if contains_global_ipv6(packet):
                                v1_data['glip_macs'].add(mac)

                    # MLDv2 responses
                    if v2_data['query_found'] and current_index > v2_data['first_idx']:
                        if 'MLDv2 - Multicast Listener Report' in packet:
                            v2_data['resp_macs'].add(mac)
                            if contains_global_ipv6(packet):
                                v2_data['glip_macs'].add(mac)
                        # Downgrade detection
                        if ('MLD - Multicast Listener Report' in packet) or ('MLD - Multicast Listener Done' in packet):
                            v2_data['downgrade_macs'].add(mac)

                    current_index += 1
        except (FileNotFoundError, KeyError):
            return

        new_rows = []

        # MLDv1 vulnerabilities
        self._add_mld_vulnerabilities(role_dict, v1_data, '1', mode, existing_rows, new_rows)
        
        # MLDv2 vulnerabilities (including downgrade)
        self._add_mld_vulnerabilities(role_dict, v2_data, '2', mode, existing_rows, new_rows, include_downgrade=True)

        self._write_vulnerabilities(new_rows)

    def _add_mld_vulnerabilities(self, role_dict, data, version, mode, existing_rows, new_rows, include_downgrade=False):
        """Helper to add MLD vulnerabilities for v1 or v2."""
        query_found = data['query_found']
        resp_macs = data['resp_macs']
        glip_macs = data['glip_macs']
        
        device_codes = {
            '1': ('PTV-NET-IDENT-ACTIVE-MLDV1DEV', 'PTV-NET-NET-MISCONF-MLD1GLIPDEV'),
            '2': ('PTV-NET-IDENT-ACTIVE-MLDV2DEV', 'PTV-NET-NET-MISCONF-MLD2GLIPDEV')
        }
        net_codes = {
            '1': ('PTV-NET-IDENT-ACTIVE-MLDV1', 'PTV-NET-NET-MISCONF-MLD1GLIP'),
            '2': ('PTV-NET-IDENT-ACTIVE-MLDV2', 'PTV-NET-NET-MISCONF-MLD2GLIP')
        }
        
        dev_code, dev_glip_code = device_codes[version]
        net_code, net_glip_code = net_codes[version]
        
        if not query_found:
            # N/A
            for device_id, mac in role_dict.items():
                rows = [
                    (str(device_id), mac, mode, '6', dev_code, f'Device responds to illegitimate MLDv{version} queries', '2'),
                    (str(device_id), mac, mode, '6', dev_glip_code, f'Device responds to MLDv{version} messages from a global address', '2'),
                ]
                if include_downgrade:
                    rows.append((str(device_id), mac, mode, '6', 'PTV-NET-IDENT-ACTIVE-MLDNVERDEV2',
                                'Device only responds to illegitimate MLDv1 queries even though MLDv2 queries are sent, possibly downgraded', '2'))
                
                for row in rows:
                    self._add_vuln_if_new(row, existing_rows, new_rows)
            
            net_rows = [
                ('Network', '', mode, '6', net_code, f'Network allows the delivery of illegitimate MLDv{version} queries', '2'),
                ('Network', '', mode, '6', net_glip_code, f'Network allows the delivery of MLDv{version} messages from a global address', '2'),
            ]
            for row in net_rows:
                self._add_vuln_if_new(row, existing_rows, new_rows)
        else:
            # Label based on responses
            for device_id, mac in role_dict.items():
                rows = [
                    (str(device_id), mac, mode, '6', dev_code, f'Device responds to illegitimate MLDv{version} queries',
                     '1' if mac in resp_macs else '0'),
                    (str(device_id), mac, mode, '6', dev_glip_code, f'Device responds to MLDv{version} messages from a global address',
                     '1' if mac in glip_macs else '0'),
                ]
                if include_downgrade:
                    rows.append((str(device_id), mac, mode, '6', 'PTV-NET-IDENT-ACTIVE-MLDNVERDEV2',
                                'Device only responds to illegitimate MLDv1 queries even though MLDv2 queries are sent, possibly downgraded',
                                '1' if mac in data.get('downgrade_macs', set()) else '0'))
                
                for row in rows:
                    self._add_vuln_if_new(row, existing_rows, new_rows)
            
            net_rows = [
                ('Network', '', mode, '6', net_code, f'Network allows the delivery of illegitimate MLDv{version} queries',
                 '1' if resp_macs else '0'),
                ('Network', '', mode, '6', net_glip_code, f'Network allows the delivery of MLDv{version} messages from a global address',
                 '1' if glip_macs else '0'),
            ]
            for row in net_rows:
                self._add_vuln_if_new(row, existing_rows, new_rows)

    def store_ipv6_vulnerability(self):
        """Check for predictable IPv6 addresses."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        
        addresses_file = get_csv_path("addresses.csv")
        if not os.path.exists(addresses_file) or not has_additional_data(addresses_file):
            return
        
        # Filter mode for IPv6 (p,a,a+)
        mode = self._filter_modes('p,a,a+')
        if not mode:
            return
        
        # Build MAC -> [IPs] mapping
        mac_ips = defaultdict(list)
        try:
            with open(addresses_file, newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    mac_ips[row['MAC'].strip()].append(row['IP'].strip())
        except (FileNotFoundError, KeyError):
            return
        
        existing_rows = self._load_existing_rows()
        new_rows = []
        
        for device_id, mac in role_dict.items():
            has_ipv6 = mac in mac_ips and any(
                is_global_unicast_ipv6(ip) or is_link_local_ipv6(ip) 
                for ip in mac_ips[mac]
            )
            
            # Check predictable global IPv6
            label_global = '2' if not has_ipv6 else '0'
            if has_ipv6:
                for ip in mac_ips[mac]:
                    if is_global_unicast_ipv6(ip) and is_ipv6_predictable(ip, mac):
                        label_global = '1'
                        break
            
            row = (str(device_id), mac, mode, '6', 'PTV-NET-IDENT-PREDICT-GLOBIP',
                  'Device uses predictable IPv6 global address', label_global)
            self._add_vuln_if_new(row, existing_rows, new_rows)
            
            # Check predictable link-local IPv6
            label_linklocal = '2' if not has_ipv6 else '0'
            if has_ipv6:
                for ip in mac_ips[mac]:
                    if is_link_local_ipv6(ip) and is_ipv6_predictable(ip, mac):
                        label_linklocal = '1'
                        break
            
            row = (str(device_id), mac, mode, '6', 'PTV-NET-IDENT-PREDICT-LINKLOCALIP',
                  'Device uses predictable IPv6 link-local address', label_linklocal)
            self._add_vuln_if_new(row, existing_rows, new_rows)
        
        self._write_vulnerabilities(new_rows)

    def store_icmp_vulnerability(self):
        """Check for ICMP/ICMPv6 vulnerabilities."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict:
            return
        
        if not os.path.exists(self.time_all_file) or not has_additional_data(self.time_all_file):
            return
        
        # Filter mode for ICMP (a,a+)
        mode = self._filter_modes('a,a+')
        if not mode:
            return
        
        existing_rows = self._load_existing_rows()
        new_rows = []
                
        # ICMPv6 response types
        icmp6_response_types = [
            "Destination unreachable", "Packet too big", "Time exceeded", "Parameter problem",
            "Echo Reply", "Redirect Message", "ICMP Node Information Query", "ICMP Node Information Response",
            "Inverse Neighbor Discovery Solicitation Message", "Inverse Neighbor Discovery Advertisement Message",
            "Private Experimentation"
        ]
        
        # Track vulnerabilities
        vuln_data = defaultdict(lambda: {'query_found': False, 'first_idx': -1, 'response_macs': set(), 
                                        'response_types': defaultdict(list), 'detected_macs': set()})
        
        # Define vulnerability checks
        vuln_checks = {}
        
        if self.ipver.ipv6:
            vuln_checks.update({
                'icmp6_multiecho': {
                    'query': lambda p, m: 'ICMPv6 Echo Request' in p and m == self.smac,
                    'response': lambda p: any(resp in p for resp in icmp6_response_types),
                    'mode': mode, 'ipver': '6'
                },
                'icmp6_invpacket': {
                    'query': lambda p, m: 'IPv6 Extension Header - Destination Options Header' in p and 'Unknown Option' in p and 'Raw' in p and m == self.smac,
                    'response': lambda p: any(resp in p for resp in icmp6_response_types),
                    'mode': mode, 'ipver': '6'
                },
                'icmp6_invechodo': {
                    'query': lambda p, m: 'ICMPv6 Echo Request' in p and 'Unknown Option' in p and 'IPv6 Extension Header - Destination Options Header' in p and m == self.smac,
                    'response': lambda p: any(resp in p for resp in icmp6_response_types),
                    'mode': mode, 'ipver': '6'
                },
                'icmp6_invechohbh': {
                    'query': lambda p, m: 'ICMPv6 Echo Request' in p and 'Unknown Option' in p and 'IPv6 Extension Header - Hop-by-Hop Options Header' in p and m == self.smac,
                    'response': lambda p: any(resp in p for resp in icmp6_response_types),
                    'mode': mode, 'ipver': '6'
                },
                'icmp6_redirect': {
                    'detect': lambda p: 'ICMPv6 Neighbor Discovery - Redirect' in p,
                    'mode': mode, 'ipver': '6'
                },
            })
        
        if self.ipver.ipv4:
            vuln_checks.update({
                'icmp_multiecho': {
                    'query': lambda p, m: 'type = echo-request' in p and is_multicast_ipv4(self._extract_address(p, 'dst')) and m == self.smac,
                    'response': lambda p: 'type = echo-reply' in p,
                    'mode': mode, 'ipver': '4'
                },
                'icmp_brcastecho': {
                    'query': lambda p, m: 'type = echo-request' in p and is_broadcast_ipv4(self._extract_address(p, 'dst')) and m == self.smac,
                    'response': lambda p: 'type = echo-reply' in p,
                    'mode': mode, 'ipver': '4'
                },
                'icmp_invpacket': {
                    'query': lambda p, m: 'icmp echo request' in p and 'type = 255' in p and m == self.smac,
                    'response': lambda p: 'type = dest-unreach code = host-unreachable' in p,
                    'mode': mode, 'ipver': '4'
                },
                'icmp_redirect': {
                    'detect': lambda p: 'type = redirect' in p,
                    'mode': mode, 'ipver': '4'
                },
            })
        
        # Process time_all.csv
        try:
            with open(self.time_all_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                current_index = 0
                
                for row in reader:
                    packet = row.get('packet', '')
                    mac = row.get('MAC', '').strip()
                    
                    for vuln_name, vuln_check in vuln_checks.items():
                        ipver = vuln_check['ipver']
                        version_match = f'version = {ipver}' in packet
                        
                        if not version_match:
                            continue
                        
                        # Check for redirect/detect-only vulnerabilities
                        if 'detect' in vuln_check:
                            if vuln_check['detect'](packet):
                                vuln_data[vuln_name]['detected_macs'].add(mac)
                            continue
                        
                        # Check for query
                        if not vuln_data[vuln_name]['query_found'] and vuln_check['query'](packet, mac):
                            vuln_data[vuln_name]['query_found'] = True
                            vuln_data[vuln_name]['first_idx'] = current_index
                        
                        # Check for response
                        if vuln_data[vuln_name]['query_found'] and current_index > vuln_data[vuln_name]['first_idx']:
                            if vuln_check['response'](packet):
                                vuln_data[vuln_name]['response_macs'].add(mac)
                                # Track response types for ICMPv6
                                if ipver == '6':
                                    for resp_type in icmp6_response_types:
                                        if resp_type in packet and resp_type not in vuln_data[vuln_name]['response_types'][mac]:
                                            vuln_data[vuln_name]['response_types'][mac].append(resp_type)
                    
                    current_index += 1
        
        except (FileNotFoundError, KeyError):
            return
        
        # Generate vulnerability entries
        vuln_codes = {
            'icmp6_redirect': ('PTV-NET-MITM-ICMP6REDIRDEV', 'Device communication can be redirected using ICMPv6 Redirect',
                              'PTV-NET-MITM-ICMP6REDIR', 'Network does not block ICMPv6 Redirect messages'),
            'icmp6_multiecho': ('PTV-NET-IDENT-ICMP6-MULTIECHODEV', 'Device responds to standard multicast ICMPv6 Echo Request',
                               'PTV-NET-IDENT-ICMP6-MULTIECHO', 'Network allows the delivery of standard multicast ICMPv6 Echo Request'),
            'icmp6_invechodo': ('PTV-NET-IDENT-ICMP6-INVECHODODEV', 'Device responds to invalid Destination Option ICMPv6 Echo Request',
                               'PTV-NET-IDENT-ICMP6-INVECHODO', 'Network allows the delivery of invalid Destination Option ICMPv6 Echo Request'),
            'icmp6_invechohbh': ('PTV-NET-IDENT-ICMP6-INVECHOHBHDEV', 'Device responds to invalid Hop-by-Hop ICMPv6 Echo Request',
                                'PTV-NET-IDENT-ICMP6-INVECHOHBH', 'Network allows the delivery of invalid Hop-by-Hop ICMPv6 Echo Request'),
            'icmp6_invpacket': ('PTV-NET-IDENT-ICMP6-INVPACKETDEV', 'Device responds to invalid ICMPv6 packets',
                               'PTV-NET-IDENT-ICMP6-INVPACKET', 'Network allows the delivery of invalid ICMPv6 packets'),
            'icmp_redirect': ('PTV-NET-MITM-ICMPREDIRDEV', 'Device communication can be redirected using ICMP Redirect',
                             'PTV-NET-MITM-ICMPREDIR', 'Network does not block ICMP Redirect messages'),
            'icmp_multiecho': ('PTV-NET-IDENT-ICMP-MULTIECHODEV', 'Device responds to standard multicast ICMP Echo Request',
                              'PTV-NET-IDENT-ICMP-MULTIECHO', 'Network allows the delivery of standard multicast ICMP Echo Request'),
            'icmp_brcastecho': ('PTV-NET-IDENT-ICMP-BRCASTECHODEV', 'Device responds to standard broadcast ICMP Echo Request',
                               'PTV-NET-IDENT-ICMP-BRCASTECHO', 'Network allows the delivery of standard broadcast ICMP Echo Request'),
            'icmp_invpacket': ('PTV-NET-IDENT-ICMP-INVPACKETDEV', 'Device responds to invalid ICMP packets',
                              'PTV-NET-IDENT-ICMP-INVPACKET', 'Network allows the delivery of invalid ICMP packets'),
        }
        
        for vuln_name, data in vuln_data.items():
            if vuln_name not in vuln_codes:
                continue
            
            vuln_mode = vuln_checks[vuln_name]['mode']
            ipver = vuln_checks[vuln_name]['ipver']
            dev_code, dev_desc, net_code, net_desc = vuln_codes[vuln_name]
            
            # Handle redirect/detect-only vulnerabilities
            if 'detect' in vuln_checks[vuln_name]:
                for device_id, mac in role_dict.items():
                    label = '1' if mac in data['detected_macs'] else '0'
                    row = (str(device_id), mac, vuln_mode, ipver, dev_code, dev_desc, label)
                    self._add_vuln_if_new(row, existing_rows, new_rows)
                
                net_label = '1' if data['detected_macs'] else '0'
                net_row = ('Network', '', vuln_mode, ipver, net_code, net_desc, net_label)
                self._add_vuln_if_new(net_row, existing_rows, new_rows)
                continue
            
            # Handle query-response vulnerabilities
            if not data['query_found']:
                # N/A
                for device_id, mac in role_dict.items():
                    row = (str(device_id), mac, vuln_mode, ipver, dev_code, dev_desc, '2')
                    self._add_vuln_if_new(row, existing_rows, new_rows)
                
                net_row = ('Network', '', vuln_mode, ipver, net_code, net_desc, '2')
                self._add_vuln_if_new(net_row, existing_rows, new_rows)
            else:
                for device_id, mac in role_dict.items():
                    # Add response type to description for ICMPv6
                    desc = dev_desc
                    if ipver == '6' and mac in data['response_types'] and data['response_types'][mac]:
                        response_string = ' / '.join(data['response_types'][mac])
                        desc = f"{dev_desc} with {response_string} message"
                    
                    label = '1' if mac in data['response_macs'] else '0'
                    row = (str(device_id), mac, vuln_mode, ipver, dev_code, desc, label)
                    self._add_vuln_if_new(row, existing_rows, new_rows)
                
                net_label = '1' if data['response_macs'] else '0'
                net_row = ('Network', '', vuln_mode, ipver, net_code, net_desc, net_label)
                self._add_vuln_if_new(net_row, existing_rows, new_rows)
        
        self._write_vulnerabilities(new_rows)
        
                
        # Ensure redirect vulnerabilities are present with label '0' if not already added, not optimal!!
        existing_rows = self._load_existing_rows()
        new_redirect_rows = []
        
        redirect_vulns = {
            '4': ('PTV-NET-MITM-ICMPREDIRDEV', 'Device communication can be redirected using ICMP Redirect',
                  'PTV-NET-MITM-ICMPREDIR', 'Network does not block ICMP Redirect messages'),
            '6': ('PTV-NET-MITM-ICMP6REDIRDEV', 'Device communication can be redirected using ICMPv6 Redirect',
                  'PTV-NET-MITM-ICMP6REDIR', 'Network does not block ICMPv6 Redirect messages'),
        }
        
        # Only process enabled IP versions
        ipver_to_process = []
        if self.ipver.ipv4:
            ipver_to_process.append('4')
        if self.ipver.ipv6:
            ipver_to_process.append('6')
        
        for ipver_value in ipver_to_process:
            if ipver_value not in redirect_vulns:
                continue
            
            dev_code, dev_desc, net_code, net_desc = redirect_vulns[ipver_value]
            
            # Check if this redirect vulnerability already exists for this ipver in mode
            redirect_exists = any(
                dev_code == row[4] and ipver_value == row[3] and mode == row[2]
                for row in existing_rows
            )
            
            if not redirect_exists:
                # Add redirect vulnerabilities with label '0' for all devices
                for device_id, mac in role_dict.items():
                    row = (str(device_id), mac, mode, ipver_value, dev_code, dev_desc, '0')
                    self._add_vuln_if_new(row, existing_rows, new_redirect_rows)
                
                # Add network-level redirect vulnerability with label '0'
                net_row = ('Network', '', mode, ipver_value, net_code, net_desc, '0')
                self._add_vuln_if_new(net_row, existing_rows, new_redirect_rows)
        
        if new_redirect_rows:
            self._write_vulnerabilities(new_redirect_rows)

    def store_ra_vulnerability(self):
        """Check for Router Advertisement vulnerabilities."""
        role_dict = read_role_node_csv(self.role_file)
        if not isinstance(role_dict, dict) or not role_dict or not self.ipver.ipv6:
            return
        
        if not os.path.exists(self.time_all_file) or not has_additional_data(self.time_all_file):
            return
        
        # Filter mode for RA (only a+)
        mode = self._filter_modes('a+')
        if not mode:
            return
        
        existing_rows = self._load_existing_rows()
        new_rows = []
        
        # Check if RA was sent
        ra_sent = False
        ra_first_idx = -1
        
        device_fakeradns = defaultdict(bool)
        device_fakera = defaultdict(bool)
        device_icmp6_outrange = defaultdict(bool)
        
        try:
            with open(self.time_all_file, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                current_index = 0
                
                for row in reader:
                    packet = row.get('packet', '')
                    mac = row.get('MAC', '').strip()
                    
                    # Check for RA sent
                    if not ra_sent and mac == self.smac and 'ICMPv6 Neighbor Discovery - Router Advertisement' in packet:
                        ra_sent = True
                        ra_first_idx = current_index
                    
                    # Process responses after RA
                    if ra_sent and current_index > ra_first_idx:
                        # Check FAKERADNS
                        if self.dns:
                            for dns_ip in self.dns:
                                if is_valid_ipv6(dns_ip) and f"dst = {dns_ip}" in packet:
                                    device_fakeradns[mac] = True
                                    device_fakera[mac] = True
                        
                        # Check ICMP6-OUTRANGE: responses to ICMPv6 traffic from outside the scanned prefix
                        src_ip = self._extract_address(packet, 'src')
                        dst_ip = self._extract_address(packet, 'dst')

                        if 'ICMPv6' in packet and src_ip and is_valid_ipv6(src_ip):
                            within_prefix = False
                            if self.network:
                                within_prefix = check_ipv6_addresses_generated_from_prefix(src_ip, f"{self.network}/{self.prefix_len}")
                            if not within_prefix and is_global_unicast_ipv6(src_ip):
                                device_icmp6_outrange[mac] = True
                                device_fakera[mac] = True

                        # Check network prefix for illegitimate RA-related sources
                        if self.network and src_ip:
                            if check_ipv6_addresses_generated_from_prefix(src_ip, f"{self.network}/{self.prefix_len}"):
                                device_fakera[mac] = True
                    
                    current_index += 1
        
        except (FileNotFoundError, KeyError):
            return
        
        # Generate vulnerabilities
        vuln_specs = [
            ('FAKERADNSDEV', 'Device connects to a fraudulent DNS server through a spoofed RA message', device_fakeradns, True),
            ('FAKERADEV', 'Device does not ignore the illegitimate RA packets', device_fakera, False),
            ('ICMP6-OUTRANGEDEV', 'Device responds to valid or invalid ICMPv6 packets from sources outside the scanned local network range', device_icmp6_outrange, False),
        ]
        
        for code_suffix, desc, device_dict, dns_required in vuln_specs:
            for device_number, mac in role_dict.items():
                if not ra_sent:
                    label = '2'
                elif dns_required and self.dns is None:
                    label = '2'
                else:
                    label = '1' if device_dict[mac] else '0'
                
                code = f'PTV-NET-MITM-{code_suffix}' if 'FAKERA' in code_suffix else f'PTV-NET-NET-MISCONF-{code_suffix}' if 'FAKERA' in code_suffix else f'PTV-NET-IDENT-{code_suffix}'
                row = (str(device_number), mac, mode, '6', code, desc, label)
                self._add_vuln_if_new(row, existing_rows, new_rows)
        
        # Network vulnerabilities
        net_vulns = [
            ('FAKERADNS', 'Network allows a client to be forced to use a fraudulent DNS server through a spoofed RA message',
             any(device_fakeradns.values()), True, 'MITM'),
            ('RAGUARD', 'Network does not have RA guard configured',
             any(device_fakera.values()), False, 'MISCONF'),
            ('FAKERA', 'Network allows the delivery of illegitimate RA packets',
             any(device_fakera.values()), False, 'NET-MISCONF'),
            ('ICMP6-OUTRANGE', 'Network allows valid or invalid ICMPv6 packets to be delivered from sources outside the scanned local network range',
             any(device_icmp6_outrange.values()), False, 'IDENT'),
        ]
        
        for code_suffix, desc, detected, dns_required, category in net_vulns:
            if not ra_sent:
                label = '2'
            elif dns_required and self.dns is None:
                label = '2'
            else:
                label = '1' if detected else '0'
            
            code = f'PTV-NET-{category}-{code_suffix}'
            row = ('Network', '', mode, '6', code, desc, label)
            self._add_vuln_if_new(row, existing_rows, new_rows)
        
        self._write_vulnerabilities(new_rows)
