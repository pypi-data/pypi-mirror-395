"""
Pytest configuration and fixtures.

Tests use the SAME database type as production to ensure consistency.
A separate test database is created/used to avoid affecting production data.
"""

import os
import pytest
from sqlalchemy import create_engine, text
from sqlalchemy.orm import sessionmaker, Session

# Set testing flag BEFORE importing app modules
os.environ["TESTING"] = "true"
os.environ["ENVIRONMENT"] = "testing"

from models import Base


def get_test_database_url() -> str:
    """
    Get the test database URL.

    Uses the same database TYPE as production, but with a '_test' suffix.
    This ensures tests run against the same database dialect.
    """
{% if is_sqlite %}
    # SQLite: Use a separate test database file
    return "sqlite:///{{ db_name }}_test.db"
{% elif is_mysql %}
    # MySQL: Use a separate test database
    db_user = os.getenv("DB_USER", "{{ db_user }}")
    db_password = os.getenv("DB_PASSWORD", "{{ db_password }}")
    db_host = os.getenv("DB_HOST", "{{ db_host }}")
    db_port = os.getenv("DB_PORT", "{{ db_port }}")
    return f"mysql+pymysql://{db_user}:{db_password}@{db_host}:{db_port}/{{ db_name }}_test"
{% else %}
    # PostgreSQL: Use a separate test database
    db_user = os.getenv("DB_USER", "{{ db_user }}")
    db_password = os.getenv("DB_PASSWORD", "{{ db_password }}")
    db_host = os.getenv("DB_HOST", "{{ db_host }}")
    db_port = os.getenv("DB_PORT", "{{ db_port }}")
    return f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{{ db_name }}_test"
{% endif %}


# Test database URL
TEST_DATABASE_URL = get_test_database_url()

{% if is_sqlite %}
# SQLite test engine
test_engine = create_engine(
    TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},
)
{% else %}
# Test engine with same configuration as production
test_engine = create_engine(
    TEST_DATABASE_URL,
    pool_pre_ping=True,
)
{% endif %}

# Test session factory
TestSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)


{% if not is_sqlite %}
def create_test_database():
    """Create the test database if it doesn't exist."""
{% if is_postgresql %}
    # Connect to default 'postgres' database to create test database
    admin_url = f"postgresql://{{ db_user }}:{{ db_password }}@{{ db_host }}:{{ db_port }}/postgres"
    admin_engine = create_engine(admin_url, isolation_level="AUTOCOMMIT")

    with admin_engine.connect() as conn:
        # Check if database exists
        result = conn.execute(
            text("SELECT 1 FROM pg_database WHERE datname = '{{ db_name }}_test'")
        )
        if not result.fetchone():
            conn.execute(text("CREATE DATABASE {{ db_name }}_test"))
            print("Created test database: {{ db_name }}_test")

    admin_engine.dispose()
{% elif is_mysql %}
    # Connect without database to create test database
    admin_url = f"mysql+pymysql://{{ db_user }}:{{ db_password }}@{{ db_host }}:{{ db_port }}"
    admin_engine = create_engine(admin_url)

    with admin_engine.connect() as conn:
        conn.execute(text("CREATE DATABASE IF NOT EXISTS {{ db_name }}_test"))
        print("Created test database: {{ db_name }}_test")

    admin_engine.dispose()
{% endif %}
{% endif %}


@pytest.fixture(scope="session", autouse=True)
def setup_test_database():
    """
    Set up the test database once per test session.

    Creates the test database and tables before any tests run.
    """
{% if not is_sqlite %}
    # Create test database if needed
    try:
        create_test_database()
    except Exception as e:
        print(f"Warning: Could not create test database: {e}")
        print("Make sure the database server is running!")
        raise
{% endif %}

    # Create all tables
    Base.metadata.create_all(bind=test_engine)

    yield

    # Optional: Drop tables after all tests (uncomment if desired)
    # Base.metadata.drop_all(bind=test_engine)


@pytest.fixture(scope="function")
def db_session() -> Session:
    """
    Provide a database session for each test function.

    Each test gets a fresh transaction that is rolled back after the test.
    This keeps tests isolated without needing to recreate tables.
    """
    connection = test_engine.connect()
    transaction = connection.begin()

    session = TestSessionLocal(bind=connection)

    yield session

    # Rollback the transaction after each test
    session.close()
    transaction.rollback()
    connection.close()


@pytest.fixture(scope="function")
def db(db_session) -> Session:
    """Alias for db_session for convenience."""
    return db_session


{% if is_fastapi %}
@pytest.fixture(scope="function")
def client(db_session):
    """
    Provide a test client with database session override.

    Usage:
        def test_endpoint(client):
            response = client.get("/health")
            assert response.status_code == 200
    """
    from fastapi.testclient import TestClient
    from main import app
    from data.db import get_db

    def override_get_db():
        yield db_session

    app.dependency_overrides[get_db] = override_get_db

    with TestClient(app) as test_client:
        yield test_client

    app.dependency_overrides.clear()
{% endif %}

{% if is_flask %}
@pytest.fixture(scope="function")
def client(db_session):
    """
    Provide a test client for Flask application.

    Usage:
        def test_endpoint(client):
            response = client.get("/health")
            assert response.status_code == 200
    """
    from app import create_app

    app = create_app()
    app.config["TESTING"] = True

    with app.test_client() as test_client:
        with app.app_context():
            yield test_client
{% endif %}
