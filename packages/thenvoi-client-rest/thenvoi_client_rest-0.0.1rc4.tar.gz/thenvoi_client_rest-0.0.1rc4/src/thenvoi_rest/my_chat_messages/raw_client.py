# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.datetime_utils import serialize_datetime
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.not_found_error import NotFoundError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.chat_message_request import ChatMessageRequest
from ..types.error import Error
from ..types.validation_error import ValidationError
from .types.create_my_chat_message_response import CreateMyChatMessageResponse
from .types.list_my_chat_messages_request_message_type import ListMyChatMessagesRequestMessageType
from .types.list_my_chat_messages_response import ListMyChatMessagesResponse

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawMyChatMessagesClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_my_chat_messages(
        self,
        chat_id: str,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        since: typing.Optional[dt.datetime] = None,
        message_type: typing.Optional[ListMyChatMessagesRequestMessageType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[ListMyChatMessagesResponse]:
        """
        Returns a paginated list of messages in a chat room where you are a participant.

        Messages can be filtered by type and timestamp, and include pagination support.
        Returns 404 if the chat room doesn't exist or you're not a participant (security-first: doesn't leak room existence).

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        page : typing.Optional[int]
            Page number

        per_page : typing.Optional[int]
            Items per page

        since : typing.Optional[dt.datetime]
            Filter messages after this timestamp

        message_type : typing.Optional[ListMyChatMessagesRequestMessageType]
            Filter by message type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[ListMyChatMessagesResponse]
            Chat Messages
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="GET",
            params={
                "page": page,
                "per_page": per_page,
                "since": serialize_datetime(since) if since is not None else None,
                "message_type": message_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatMessagesResponse,
                    parse_obj_as(
                        type_=ListMyChatMessagesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def create_my_chat_message(
        self, chat_id: str, *, message: ChatMessageRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> HttpResponse[CreateMyChatMessageResponse]:
        """
        Creates a new message in a chat room where you are a participant.

        The message will be sent from your user account. The mentions array is required and must contain at least one mention.
        Returns 404 if the chat room doesn't exist or you're not a participant (security-first: doesn't leak room existence).

        To mention users in the message:
        1. Include the username with @ prefix in the content (e.g. "@Task Owner hello")
        2. Add the corresponding user details in the mentions array
        3. The mentions array is required and must contain at least one mention

        Note: The message is always sent as the authenticated user. You cannot specify sender_type or sender_id.
        If @ prefixes are missing from usernames in the content, they will be automatically added.

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        message : ChatMessageRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[CreateMyChatMessageResponse]
            Created Message
        """
        _response = self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="POST",
            json={
                "message": convert_and_respect_annotation_metadata(
                    object_=message, annotation=ChatMessageRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateMyChatMessageResponse,
                    parse_obj_as(
                        type_=CreateMyChatMessageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawMyChatMessagesClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_my_chat_messages(
        self,
        chat_id: str,
        *,
        page: typing.Optional[int] = None,
        per_page: typing.Optional[int] = None,
        since: typing.Optional[dt.datetime] = None,
        message_type: typing.Optional[ListMyChatMessagesRequestMessageType] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[ListMyChatMessagesResponse]:
        """
        Returns a paginated list of messages in a chat room where you are a participant.

        Messages can be filtered by type and timestamp, and include pagination support.
        Returns 404 if the chat room doesn't exist or you're not a participant (security-first: doesn't leak room existence).

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        page : typing.Optional[int]
            Page number

        per_page : typing.Optional[int]
            Items per page

        since : typing.Optional[dt.datetime]
            Filter messages after this timestamp

        message_type : typing.Optional[ListMyChatMessagesRequestMessageType]
            Filter by message type

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[ListMyChatMessagesResponse]
            Chat Messages
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="GET",
            params={
                "page": page,
                "per_page": per_page,
                "since": serialize_datetime(since) if since is not None else None,
                "message_type": message_type,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    ListMyChatMessagesResponse,
                    parse_obj_as(
                        type_=ListMyChatMessagesResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def create_my_chat_message(
        self, chat_id: str, *, message: ChatMessageRequest, request_options: typing.Optional[RequestOptions] = None
    ) -> AsyncHttpResponse[CreateMyChatMessageResponse]:
        """
        Creates a new message in a chat room where you are a participant.

        The message will be sent from your user account. The mentions array is required and must contain at least one mention.
        Returns 404 if the chat room doesn't exist or you're not a participant (security-first: doesn't leak room existence).

        To mention users in the message:
        1. Include the username with @ prefix in the content (e.g. "@Task Owner hello")
        2. Add the corresponding user details in the mentions array
        3. The mentions array is required and must contain at least one mention

        Note: The message is always sent as the authenticated user. You cannot specify sender_type or sender_id.
        If @ prefixes are missing from usernames in the content, they will be automatically added.

        Parameters
        ----------
        chat_id : str
            Chat Room ID

        message : ChatMessageRequest

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[CreateMyChatMessageResponse]
            Created Message
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"api/v1/me/chats/{jsonable_encoder(chat_id)}/messages",
            method="POST",
            json={
                "message": convert_and_respect_annotation_metadata(
                    object_=message, annotation=ChatMessageRequest, direction="write"
                ),
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    CreateMyChatMessageResponse,
                    parse_obj_as(
                        type_=CreateMyChatMessageResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        Error,
                        parse_obj_as(
                            type_=Error,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Any,
                        parse_obj_as(
                            type_=typing.Any,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ValidationError,
                        parse_obj_as(
                            type_=ValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
