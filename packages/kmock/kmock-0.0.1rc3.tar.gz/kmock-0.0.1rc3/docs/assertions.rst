==========
Assertions
==========

.. highlight:: python

Request logging
===============

All incoming requests, including their parsed interpretations, are recorded for further assertions in tests and can be accessed either via the mock handler itself or via individual rules (i.e. ``kmock`` or ``kmock << …``).

The handler and the rules are iterables of requests that have been served by these rules; for the root handler, that ever arrived. This can be used in assertions::

    def test_me(kmock):
        rule1 = kmock['get /'] << b'hello'
        rule2 = kmock['post /'] << b'world'

        funcion_under_test()

        all_requests = list(kmock)
        requests1 = list(rule1)
        requests2 = list(rule2)
        assert len(all_requests) == 3
        assert requests1[0].path == '/'
        assert requests2[-1].path == '/'

The requests are of type :class:`kmock.Request`.

For convenience, the requests can be compared directly to any value that otherwise could be used in the handler filters (i.e., ``kmock[…]``). In particular, regular strings are automatically recognized as either an HTTP verb or path, or as a Kubernetes action or resource::

    def test_me(kmock):
        rule1 = kmock['get /'] << b'hello'
        rule2 = kmock['post /'] << b'world'

        funcion_under_test()

        requests1 = list(rule1)
        requests2 = list(rule2)
        assert requests1[0] == 'get'
        assert requests2[-1] == '/'


Server-side errors
==================

To catch server-side errors, usually coming from the callbacks of the mock server itself, ``kmock.errors`` (a list of exceptions) can be asserted to be empty.

Alternatively, the mock server can be created with the ``strict=True`` option. In this case, the assertion will be performed on the client (test) side when closing the fixture. However, the server shutdown usually happens outside of the test, so explicit checking might be more preferable in some cases.

The ``StopIteration`` exception is not escalated, it is processed internally to deactivate the response handler as "depleted".


Kubernetes objects
==================

:class:`KubernetesEmulator` —the in-memory stateful database of objects— exposes the property ``.objects`` to either pre-populate the server's database or to assert it after the test.

Objects are accessed with a 3- or 4-item key: the resource, the namespace, the name of the object, and an optional version index (an integer or a slice).

The objects are stored and fetched "as is", i.e. the server does not add or remove any implicit fields, such as the metadata, namespaces, names. These values are taken from the URL and used in the keys only. However, it uses some fields from the payload to retrieve the values of they cannot be figured from the URL — for example, the name of a newly created object.

To pre-populate the server::

    def test_me(kmock):
        kmock.objects[resource, 'ns1', 'n1'] = {'spec': 'val1'}
        kmock.objects[resource, 'ns1', 'n2'] = {'spec': 'val2'}
        function_under_test()

To assert the objects after the test::

    def test_me(kmock):
        function_under_test()
        assert kmock.objects[resource, 'ns1', 'n1']['spec'] == 'val1'
        assert kmock.objects[resource, 'ns1', 'n2']['spec'] == 'val2'

To access the selected versions of the object as it was manipulated via the API, use either ``.history[idx]``, or the 4th item in the main key. The usual magic with negative indexes or slices works::

    def test_me(kmock):
        function_under_test()

        assert kmock.objects[resource, 'ns1', 'n1', 0]['spec'] == 'val1'
        assert kmock.objects[resource, 'ns1', 'n2'].history[-1]['spec'] == 'val2'

        assert kmock.objects[resource, 'ns1', 'n1', :] == [{'spec': 'val1'}]
        assert kmock.objects[resource, 'ns1', 'n2'].history[:] == [{'spec': 'val2'}]

To avoid the dependency on very specific payloads generated by some realistic API clients, use the partial dict matching instead of the precise equality — with set-like ``<=`` and ``>=`` operations on objects::

    def test_me(kmock):
        function_under_test()
        assert kmock.objects[resource, 'ns1', 'n1', 0] >=
        assert {'spec': 'val2'} <= kmock.objects[resource, 'ns1', 'n2', -1]

Mind that the object should always be the "greater" operand, the pattern as the "lesser" operand. Usually, the object contains more fields than required by the pattern. But all fields present in the pattern MUST match. In other words, a pattern must be a sub-dict of the object.

Nested sub-dicts are also matched partially, recursively — either by selecting them by the key, or by adding them into the pattern.

Beware: accessing objects and sub-dicts always returns a dict-like wrapper instead of the originally stored dict. This includes iterating over object's fields, and converting them to ``dict()`` directly. To unwrap, use ``.raw``: e.g. ``obj.raw`` or ``obj['metadata'].raw``.
