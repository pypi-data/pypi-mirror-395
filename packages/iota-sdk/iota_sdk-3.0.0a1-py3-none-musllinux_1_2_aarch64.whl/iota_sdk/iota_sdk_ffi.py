

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import asyncio
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("iota_sdk_ffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_iota_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_iota_sdk_ffi_checksum_func_active_jwk_from_bcs() != 65415:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_active_jwk_to_bcs() != 37978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_address_from_bcs() != 8229:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_address_to_bcs() != 61852:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_argument_from_bcs() != 3719:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_argument_to_bcs() != 11813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_from_bcs() != 23378:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_to_bcs() != 26245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_from_bcs() != 39650:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_to_bcs() != 31251:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_base64_decode() != 57367:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_base64_encode() != 54791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_from_bcs() != 27639:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_to_bcs() != 45714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_from_bcs() != 28208:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_to_bcs() != 29002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_from_bcs() != 13721:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_to_bcs() != 3863:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bool_from_bcs() != 591:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_bool_to_bcs() != 11338:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_from_bcs() != 3386:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_to_bcs() != 32242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_from_bcs() != 49588:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_to_bcs() != 4565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_from_bcs() != 16404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_to_bcs() != 12967:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_changed_object_from_bcs() != 41461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_changed_object_to_bcs() != 58498:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_from_bcs() != 62657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_to_bcs() != 35587:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_from_bcs() != 1002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_to_bcs() != 52481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_from_bcs() != 23217:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_to_bcs() != 48157:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_from_bcs() != 40094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_to_bcs() != 62034:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_circom_g1_from_bcs() != 60233:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_circom_g1_to_bcs() != 19531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_circom_g2_from_bcs() != 1042:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_circom_g2_to_bcs() != 8225:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_from_bcs() != 5998:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_to_bcs() != 30279:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_command_from_bcs() != 25814:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_command_to_bcs() != 38816:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_from_bcs() != 22391:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_to_bcs() != 13457:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_from_bcs() != 30528:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_to_bcs() != 35973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_digest_from_bcs() != 56231:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_digest_to_bcs() != 10551:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_from_bcs() != 6221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_to_bcs() != 30464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_from_bcs() != 39614:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_to_bcs() != 17200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_from_bcs() != 36284:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_to_bcs() != 6697:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_event_from_bcs() != 11285:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_event_to_bcs() != 35514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_error_from_bcs() != 54349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_error_to_bcs() != 1185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_status_from_bcs() != 65175:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_status_to_bcs() != 42821:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_from_bcs() != 19124:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_from_bcs() != 3465:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_to_bcs() != 166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_to_bcs() != 35779:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_from_bcs() != 954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_to_bcs() != 38212:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_from_bcs() != 305:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_to_bcs() != 39838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_gas_payment_from_bcs() != 20862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_gas_payment_to_bcs() != 2681:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_generate_mnemonic() != 15726:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_genesis_object_from_bcs() != 15482:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_genesis_object_to_bcs() != 63349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_from_bcs() != 21010:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_to_bcs() != 17884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_hex_decode() != 35424:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_hex_encode() != 34343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i16_from_bcs() != 10273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i16_to_bcs() != 28969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i32_from_bcs() != 7849:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i32_to_bcs() != 52773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i64_from_bcs() != 17714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i64_to_bcs() != 38028:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i8_from_bcs() != 21810:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_i8_to_bcs() != 57592:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_id_operation_from_bcs() != 10384:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_id_operation_to_bcs() != 62670:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_identifier_from_bcs() != 3668:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_identifier_to_bcs() != 46605:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_input_from_bcs() != 13339:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_input_to_bcs() != 51152:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_jwk_from_bcs() != 14752:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_jwk_id_from_bcs() != 22836:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_jwk_id_to_bcs() != 2155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_jwk_to_bcs() != 29567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_from_bcs() != 17479:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_to_bcs() != 17288:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_merge_coins_from_bcs() != 33652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_merge_coins_to_bcs() != 40802:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_call_from_bcs() != 3402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_call_to_bcs() != 40106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_location_from_bcs() != 62161:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_location_to_bcs() != 25104:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_package_from_bcs() != 922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_package_to_bcs() != 53617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_struct_from_bcs() != 25715:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_move_struct_to_bcs() != 9518:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_from_bcs() != 56951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_to_bcs() != 57074:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_from_bcs() != 49092:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_to_bcs() != 11846:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_from_bcs() != 4473:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_from_bcs() != 55389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_to_bcs() != 8657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_from_bcs() != 26016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_to_bcs() != 49432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_to_bcs() != 50267:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_data_from_bcs() != 29702:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_data_to_bcs() != 13288:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_from_bcs() != 58875:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_id_from_bcs() != 39824:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_id_to_bcs() != 48535:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_in_from_bcs() != 36098:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_in_to_bcs() != 37270:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_out_from_bcs() != 55820:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_out_to_bcs() != 57777:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_reference_from_bcs() != 2613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_reference_to_bcs() != 50964:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_object_to_bcs() != 59689:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_owner_from_bcs() != 60479:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_owner_to_bcs() != 40596:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_from_bcs() != 19771:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_to_bcs() != 36019:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_from_bcs() != 5683:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_to_bcs() != 26250:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_from_bcs() != 28762:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_to_bcs() != 49182:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_publish_from_bcs() != 59778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_publish_to_bcs() != 44879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_from_bcs() != 17429:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_to_bcs() != 53446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_from_bcs() != 26826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_to_bcs() != 20301:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_from_bcs() != 19555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_to_bcs() != 65529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_from_bcs() != 44046:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_to_bcs() != 12590:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_from_bcs() != 17047:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_to_bcs() != 2418:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_from_bcs() != 42264:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_to_bcs() != 44178:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_simple_signature_from_bcs() != 19746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_simple_signature_to_bcs() != 36033:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_split_coins_from_bcs() != 55454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_split_coins_to_bcs() != 30667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_string_from_bcs() != 53853:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_string_to_bcs() != 54804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_struct_tag_from_bcs() != 24910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_struct_tag_to_bcs() != 23529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_system_package_from_bcs() != 60428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_system_package_to_bcs() != 40961:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_from_bcs() != 36911:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_to_bcs() != 43876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_from_bcs() != 64140:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_to_bcs() != 12420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_events_from_bcs() != 50477:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_events_to_bcs() != 49708:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_from_bcs() != 12318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_to_bcs() != 34807:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_from_bcs() != 52964:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_from_bcs() != 19749:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_to_bcs() != 38945:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_to_bcs() != 38438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_from_bcs() != 56096:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_to_bcs() != 62454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_from_bcs() != 34010:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_to_bcs() != 59364:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_from_bcs() != 30578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_to_bcs() != 22531:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_type_origin_from_bcs() != 63210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_type_origin_to_bcs() != 62869:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_type_tag_from_bcs() != 31167:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_type_tag_to_bcs() != 57365:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u16_from_bcs() != 3653:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u16_to_bcs() != 13254:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u32_from_bcs() != 335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u32_to_bcs() != 36384:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u64_from_bcs() != 63829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u64_to_bcs() != 2947:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u8_from_bcs() != 34764:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_u8_to_bcs() != 59020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_from_bcs() != 6308:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_to_bcs() != 46464:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_from_bcs() != 28910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_to_bcs() != 38998:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_upgrade_from_bcs() != 19484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_from_bcs() != 58871:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_to_bcs() != 8867:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_upgrade_to_bcs() != 32303:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_user_signature_from_bcs() != 8567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_user_signature_to_bcs() != 47630:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_from_bcs() != 21169:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_to_bcs() != 44404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_from_bcs() != 30352:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_from_bcs() != 27463:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_to_bcs() != 54694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_to_bcs() != 31448:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_from_bcs() != 28604:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_to_bcs() != 35325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_signature_from_bcs() != 57394:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_validator_signature_to_bcs() != 19559:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_version_assignment_from_bcs() != 23398:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_version_assignment_to_bcs() != 44956:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_from_bcs() != 48317:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_to_bcs() != 50917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_from_bcs() != 47140:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_to_bcs() != 58412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_from_bcs() != 13910:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_to_bcs() != 22664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_from_bcs() != 35391:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_to_bcs() != 39685:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_address_to_bytes() != 57710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_address_to_canonical_string() != 50168:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_address_to_hex() != 22032:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_address_to_short_string() != 56908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_argument_get_nested_result() != 53358:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_public_key() != 53765:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_scheme() != 8293:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_sign_checkpoint_summary() != 1487:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_try_sign() != 59341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_verifying_key() != 36438:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381publickey_to_bytes() != 9890:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381signature_to_bytes() != 56969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_public_key() != 59353:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_verify() != 54718:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_padded() != 44301:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_unpadded() != 33350:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_digest() != 52811:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_version_assignments() != 52539:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_computation_charge() != 25355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch() != 49990:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch_start_timestamp_ms() != 57669:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_non_refundable_storage_fee() != 28070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_protocol_version() != 40406:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_charge() != 35870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_rebate() != 21786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_system_packages() != 55002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge() != 4379:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge_burned() != 17712:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch() != 52992:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch_start_timestamp_ms() != 35398:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_non_refundable_storage_fee() != 38234:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_protocol_version() != 16414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_charge() != 4751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_rebate() != 52102:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_system_packages() != 48705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge() != 29832:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge_burned() != 40461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_eligible_active_validators() != 6336:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch() != 4081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch_start_timestamp_ms() != 22703:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_non_refundable_storage_fee() != 5224:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_protocol_version() != 48266:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_charge() != 7690:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_rebate() != 54084:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_system_packages() != 38309:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_as_ecmh_live_object_set_digest() != 41616:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_is_ecmh_live_object_set() != 22589:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_digest() != 22345:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_transaction_info() != 56465:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_checkpoint_commitments() != 61600:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_content_digest() != 31627:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_digest() != 14291:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_end_of_epoch_data() != 49930:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch() != 35840:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch_rolling_gas_cost_summary() != 10205:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_network_total_transactions() != 50558:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_previous_digest() != 933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_sequence_number() != 33896:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message() != 59962:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message_hex() != 52548:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_timestamp_ms() != 62474:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_version_specific_data() != 43828:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_effects() != 54822:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_signatures() != 36925:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_transaction() != 58570:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_dry_run() != 10983:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute() != 45165:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute_with_sponsor() != 64410:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_expiration() != 32958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_finish() != 56677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas() != 522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_budget() != 27427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_price() != 56003:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_station_sponsor() != 25572:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_make_move_vec() != 4858:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_merge_coins() != 43478:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_move_call() != 13617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_publish() != 25909:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_coins() != 65187:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_iota() != 65011:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_split_coins() != 2932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_sponsor() != 44990:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_stake() != 9961:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_transfer_objects() != 23790:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_unstake() != 40181:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_upgrade() != 59977:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_coin_balance() != 29928:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_coin_coin_type() != 18211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_coin_id() != 40013:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_commit_timestamp_ms() != 14198:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_commit_digest() != 34585:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_determined_version_assignments() != 32713:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_epoch() != 1832:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_round() != 6355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_sub_dag_index() != 56426:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_as_cancelled_transactions() != 59888:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_is_cancelled_transactions() != 10241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_digest_next_lexicographical() != 53914:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_digest_to_base58() != 54638:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_digest_to_bytes() != 14244:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_public_key() != 55389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_scheme() != 8128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_personal_message() != 59851:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_transaction() != 4951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bech32() != 64514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bytes() != 26261:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_der() != 61433:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_pem() != 34166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign() != 39795:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_simple() != 56024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_user() != 42020:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_verifying_key() != 59162:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_derive_address() != 37757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_scheme() != 3041:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_bytes() != 16656:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_flagged_bytes() != 62359:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519signature_to_bytes() != 31911:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_public_key() != 55026:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_der() != 56779:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_pem() != 56327:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify() != 24673:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_simple() != 29563:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_user() != 43622:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_key() != 10295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_observations() != 58594:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request() != 13326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_and_wait() != 22484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_status() != 48258:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_data() != 26598:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_id() != 9601:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_type() != 32731:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_owner() != 50201:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_version() != 36305:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_events() != 64664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_objects() != 14715:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_active_validators() != 29559:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_balance() != 9953:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_chain_id() != 45619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoint() != 9094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoints() != 36867:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coin_metadata() != 10872:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coins() != 47450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx() != 7552:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx_kind() != 37663:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_field() != 12346:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_fields() != 14745:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_object_field() != 28336:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch() != 62805:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_checkpoints() != 29086:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_transaction_blocks() != 61978:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_events() != 20245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_execute_tx() != 65277:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_gas_coins() != 24826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_default_name() != 53764:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_lookup() != 20908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_registrations() != 44467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_finalized() != 8647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_indexed_on_node() != 20156:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_latest_checkpoint_sequence_number() != 40336:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_max_page_size() != 44733:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents() != 40412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents_bcs() != 49694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_function() != 16965:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_module() != 51355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object() != 27424:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object_bcs() != 29653:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_objects() != 14040:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package() != 7913:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_latest() != 55024:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_versions() != 34213:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_packages() != 45891:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_protocol_config() != 58559:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_reference_gas_price() != 39065:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_run_query() != 54586:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_service_config() != 11931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_set_rpc_server() != 31958:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_supply() != 21504:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks() != 9583:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_digest() != 24739:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_seq_num() != 18624:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction() != 58857:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_data_effects() != 53397:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_effects() != 27010:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions() != 20537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_data_effects() != 46218:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_effects() != 25858:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_wait_for_tx() != 25664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_identifier_as_str() != 63815:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_makemovevector_elements() != 20773:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_makemovevector_type_tag() != 31154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coin() != 38884:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coins_to_merge() != 44350:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movecall_arguments() != 17202:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movecall_function() != 2751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movecall_module() != 35106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movecall_package() != 24481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movecall_type_arguments() != 46468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movefunction_is_entry() != 5688:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movefunction_name() != 15389:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movefunction_parameters() != 34373:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movefunction_return_type() != 2574:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movefunction_type_parameters() != 3798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movefunction_visibility() != 3892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackage_id() != 28435:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackage_linkage_table() != 40601:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackage_modules() != 49866:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackage_type_origin_table() != 7308:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackage_version() != 22970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_dependencies() != 61113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_digest() != 31652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_modules() != 63377:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_base64() != 1835:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_json() != 3153:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_bitmap() != 41489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_committee() != 17432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_signatures() != 5488:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_finish() != 31014:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_verifier() != 36902:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_signature() != 48209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_verifier() != 10820:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_derive_address() != 26282:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_is_valid() != 45468:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_members() != 62870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_scheme() != 15458:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_threshold() != 21653:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmember_public_key() != 7804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmember_weight() != 57194:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519() != 8241:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519_opt() != 28021:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1() != 52073:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1_opt() != 40194:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1() != 38170:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1_opt() != 28963:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin() != 17714:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin_opt() != 23106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_ed25519() != 1939:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256k1() != 49521:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256r1() != 16265:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_zklogin() != 37193:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_scheme() != 44341:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519() != 22855:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519_opt() != 56690:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1() != 49085:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1_opt() != 26984:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1() != 57510:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1_opt() != 12419:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin() != 39624:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin_opt() != 34526:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_ed25519() != 18913:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256k1() != 16841:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256r1() != 51171:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_zklogin() != 65193:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_verify() != 49901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_with_zklogin_verifier() != 20062:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_zklogin_verifier() != 5971:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_format() != 66:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_is_sln() != 9860:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_is_subname() != 22382:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_label() != 9695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_labels() != 44675:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_num_labels() != 62037:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_name_parent() != 40819:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_expiration_timestamp_ms() != 13855:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_id() != 17049:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name() != 16565:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name_str() != 19903:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_as_package() != 21763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_as_package_opt() != 61571:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_as_struct() != 5928:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_as_struct_opt() != 49657:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_data() != 4330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_digest() != 48655:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_object_id() != 6575:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_object_ref() != 13587:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_object_type() != 1843:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_owner() != 3724:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_previous_transaction() != 4427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_storage_rebate() != 24969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_object_version() != 18433:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_package_opt() != 50334:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_struct_opt() != 8956:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_package() != 11147:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_struct() != 58579:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectid_derive_dynamic_child_id() != 47819:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_address() != 21880:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_bytes() != 38367:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_canonical_string() != 62489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_hex() != 4418:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_short_string() != 63526:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct() != 15094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct_opt() != 14701:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_package() != 40585:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_struct() != 33698:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_as_address() != 19200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_as_address_opt() != 36265:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_as_object() != 42917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_as_object_opt() != 17159:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared() != 56096:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared_opt() != 4209:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_is_address() != 26982:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_is_immutable() != 23542:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_is_object() != 29892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_owner_is_shared() != 6506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_authenticator_data() != 36642:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_challenge() != 28147:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_client_data_json() != 26196:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_public_key() != 18555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_signature() != 5489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_derive_address() != 61803:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_inner() != 65008:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_passkeyverifier_verify() != 19101:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_message_bytes() != 347:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest() != 39344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest_hex() != 63754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_commands() != 49868:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_inputs() != 25458:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_publish_dependencies() != 57311:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_publish_modules() != 26011:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_public_key() != 27155:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_scheme() != 60810:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_personal_message() != 53577:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_transaction() != 34208:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bech32() != 60488:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bytes() != 18583:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_der() != 65507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_pem() != 12369:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign() != 5798:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_simple() != 11597:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_user() != 20597:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_verifying_key() != 51137:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_derive_address() != 48490:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_scheme() != 60874:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_bytes() != 49170:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_flagged_bytes() != 46673:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1signature_to_bytes() != 49705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_simple() != 36777:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_user() != 26362:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_public_key() != 56083:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_der() != 21325:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_pem() != 29137:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify() != 27904:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_simple() != 35045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_user() != 41639:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_public_key() != 58075:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_scheme() != 20973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_personal_message() != 113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_transaction() != 1687:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bech32() != 4230:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bytes() != 8648:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_der() != 48507:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_pem() != 34634:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign() != 39126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_simple() != 57038:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_user() != 36924:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_verifying_key() != 55895:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_derive_address() != 27344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_scheme() != 48083:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_bytes() != 21066:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_flagged_bytes() != 14205:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1signature_to_bytes() != 64948:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_simple() != 18491:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_user() != 19940:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_public_key() != 35474:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_der() != 49763:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_pem() != 51401:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify() != 32594:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_simple() != 35191:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_user() != 46052:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_public_key() != 11009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_scheme() != 19826:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_personal_message() != 2940:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_transaction() != 35221:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bech32() != 4776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bytes() != 1555:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_der() != 22161:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_pem() != 18854:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign() != 52266:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign_user() != 17485:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_verifying_key() != 20797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key() != 36693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key_opt() != 11858:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig() != 56126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig_opt() != 33862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_ed25519() != 64494:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256k1() != 39262:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256r1() != 49536:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_scheme() != 30423:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key() != 51778:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key_opt() != 20475:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig() != 36141:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig_opt() != 16111:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key() != 25197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key_opt() != 22487:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig() != 30390:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig_opt() != 51961:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_to_bytes() != 28081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simpleverifier_verify() != 8441:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_public_key() != 58667:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_scheme() != 7296:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_der() != 3936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_pem() != 55066:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_verify() != 22348:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_splitcoins_amounts() != 10377:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_splitcoins_coin() != 17278:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_address() != 20393:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type() != 37745:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type_opt() != 65306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_module() != 28022:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_name() != 62865:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_to_canonical_string() != 21212:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_structtag_type_args() != 48594:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_systempackage_dependencies() != 25411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_systempackage_modules() != 23597:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_systempackage_version() != 39738:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_as_v1() != 53004:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_digest() != 52429:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_expiration() != 47752:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_gas_payment() != 5316:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_kind() != 49492:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_sender() != 38190:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest() != 21125:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest_hex() != 44484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transaction_to_base64() != 51030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_execute_with_gas_station() != 6268:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_expiration() != 5328:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_finish() != 39582:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas() != 23371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_budget() != 48686:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_price() != 7437:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_station_sponsor() != 41106:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_make_move_vec() != 64922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_merge_coins() != 136:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_move_call() != 22281:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_publish() != 22805:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_coins() != 6220:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_iota() != 2185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_split_coins() != 17747:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_sponsor() != 25655:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_stake() != 41361:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_transfer_objects() != 16313:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_unstake() != 30530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_upgrade() != 14493:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_with_client() != 26579:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_as_v1() != 48710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_digest() != 46963:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_is_v1() != 39808:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionevents_digest() != 55750:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionevents_events() != 36651:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_digest() != 52708:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_expiration() != 9317:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_gas_payment() != 61676:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_kind() != 56302:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_sender() != 8513:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest() != 51695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest_hex() != 21009:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_to_base64() != 54846:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transferobjects_address() != 37833:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_transferobjects_objects() != 24154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag() != 1715:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag_opt() != 15734:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag() != 20180:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag_opt() != 55130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_address() != 38219:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_bool() != 30264:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_signer() != 57678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_struct() != 39029:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u128() != 65460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u16() != 34540:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u256() != 65130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u32() != 40795:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u64() != 28705:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u8() != 18761:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_vector() != 49992:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_typetag_to_canonical_string() != 24741:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_upgrade_dependencies() != 7113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_upgrade_modules() != 62138:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_upgrade_package() != 35757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_upgrade_ticket() != 11416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_upgradepolicy_as_u8() != 10203:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig() != 36332:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig_opt() != 21895:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey() != 17710:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey_opt() != 53755:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple() != 57455:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple_opt() != 47248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin() != 53484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin_opt() != 43934:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_multisig() != 61839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_passkey() != 35671:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_simple() != 58211:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_zklogin() != 38693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_scheme() != 25381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_base64() != 33757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_bytes() != 58893:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_verify() != 47797:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_with_zklogin_verifier() != 44658:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_zklogin_verifier() != 9821:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_bitmap_bytes() != 59039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_epoch() != 54283:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_signature() != 39125:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_add_signature() != 13923:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_committee() != 36159:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_finish() != 7324:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_committee() != 5093:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify() != 29238:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_aggregated() != 46271:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_checkpoint_summary() != 36331:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_duration() != 59803:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_validator() != 10003:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_epoch() != 15301:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_public_key() != 16384:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_signature() != 58273:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_versionassignment_object_id() != 50440:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_versionassignment_version() != 51219:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_inputs() != 1512:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_max_epoch() != 9769:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_signature() != 18838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_address_seed() != 4892:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_header_base64() != 32056:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss() != 1099:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss_base64_details() != 20914:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_jwk_id() != 37580:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_proof_points() != 28172:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_public_identifier() != 48158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_a() != 6891:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_b() != 36477:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_c() != 10897:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_address_seed() != 3936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address() != 14353:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_padded() != 45141:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_unpadded() != 51424:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_iss() != 58864:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_jwks() != 62366:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_verify() != 29967:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_with_jwks() != 49665:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_framework() != 52951:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_from_bytes() != 58901:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_from_hex() != 63442:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_generate() != 48865:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_std_lib() != 35825:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_system() != 4297:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_address_zero() != 46553:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_gas() != 14489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_input() != 33966:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_nested_result() != 57666:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_result() != 44025:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_generate() != 14780:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_new() != 52467:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_bytes() != 6069:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_str() != 26128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_generate() != 30791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_bytes() != 42745:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_str() != 5412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_generate() != 58435:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381verifyingkey_new() != 22402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_bytes() != 3672:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str() != 21214:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str_radix_10() != 17556:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_cancelledtransaction_new() != 59199:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_changeepoch_new() != 48694:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv2_new() != 52433:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv3_new() != 2388:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointcontents_new() != 27130:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointsummary_new() != 16062:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointtransactioninfo_new() != 65327:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_circomg1_new() != 39786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_circomg2_new() != 50489:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_coin_try_from_object() != 35349:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_make_move_vector() != 54610:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_merge_coins() != 1888:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_move_call() != 23161:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_publish() != 7239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_split_coins() != 59484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_transfer_objects() != 54265:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_upgrade() != 48835:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_consensuscommitprologuev1_new() != 50376:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_consensusdeterminedversionassignments_new_cancelled_transactions() != 929:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_base58() != 41234:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_bytes() != 65530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_digest_generate() != 8094:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_bech32() != 16842:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_der() != 42838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic() != 55789:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic_with_path() != 15255:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_pem() != 53776:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_generate() != 53932:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_new() != 12862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_bytes() != 60403:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_str() != 38751:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_generate() != 46412:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_bytes() != 61841:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_str() != 39607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_generate() != 41607:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_der() != 1677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_pem() != 37214:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_new() != 23280:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_create() != 42248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_expire() != 58811:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch() != 56235:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v2() != 13653:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v3() != 21107:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservation_new() != 22119:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_make_move_vec() != 1498:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_merge_coins() != 40848:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_move_entry_point() != 6711:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_publish() != 6398:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_split_coins() != 28564:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_transfer_objects() != 29560:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_upgrade() != 26115:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservations_new_v1() != 19098:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new() != 4619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_devnet() != 41429:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_localnet() != 53173:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_testnet() != 11124:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_genesisobject_new() != 35390:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_genesistransaction_new() != 47990:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new() != 32097:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_devnet() != 6494:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_localnet() != 2330:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_mainnet() != 3613:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_testnet() != 48529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_identifier_new() != 9398:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_immutable_or_owned() != 33908:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_pure() != 53404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_receiving() != 28060:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_shared() != 61970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_makemovevector_new() != 20934:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_mergecoins_new() != 1506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address() != 46522:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_from_hex() != 44452:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec() != 6097:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec_from_hex() != 4963:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool() != 52909:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool_vec() != 25067:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest() != 60114:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_from_base58() != 42108:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec() != 42012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec_from_base58() != 36057:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_option() != 48206:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string() != 18343:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string_vec() != 22295:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128() != 8902:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128_vec() != 64018:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16() != 62318:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16_vec() != 29254:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256() != 32008:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256_vec() != 50179:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32() != 16255:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32_vec() != 41122:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64() != 7097:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64_vec() != 17684:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8() != 10135:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8_vec() != 4587:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movecall_new() != 30411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movepackage_new() != 17506:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_base64() != 61420:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_json() != 13174:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_new() != 65225:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregatedsignature_new() != 3396:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_message() != 41388:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_transaction() != 27644:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_multisigcommittee_new() != 40069:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_multisigmember_new() != 63622:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_multisigverifier_new() != 53197:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_name_from_str() != 30248:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_nameregistration_new() != 19327:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_object_new() != 41346:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_package() != 5274:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_struct() != 1861:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_clock() != 14732:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_derive_id() != 16970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_bytes() != 41789:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_hex() != 30954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_system() != 9600:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_zero() != 40526:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_package() != 63533:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_struct() != 65488:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_address() != 6008:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_immutable() != 51786:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_object() != 381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_shared() != 36753:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address() != 14619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_from_hex() != 40759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec() != 326:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec_from_hex() != 60030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool() != 51030:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool_vec() != 65126:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest() != 54344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_from_base58() != 5017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec() != 19113:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec_from_base58() != 59134:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_gas() != 10767:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_move_arg() != 26972:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id() != 41681:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id_from_hex() != 47640:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_ref() != 24215:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_option() != 37559:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving() != 50553:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving_from_hex() != 48453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_res() != 47661:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared() != 59619:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_from_hex() != 60985:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut() != 43242:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut_from_hex() != 52415:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_string() != 60971:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128() != 47870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128_vec() != 37355:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16() != 58656:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16_vec() != 10787:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256() != 19985:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256_vec() != 57693:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32() != 13754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32_vec() != 50917:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64() != 6870:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64_vec() != 27400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8() != 22414:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8_vec() != 51245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_passkeypublickey_new() != 30856:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_passkeyverifier_new() != 23457:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_personalmessage_new() != 3617:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_programmabletransaction_new() != 38638:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_publish_new() != 4785:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_bech32() != 34529:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_der() != 45448:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic() != 33082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic_with_path() != 7431:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_pem() != 20937:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_generate() != 49496:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_new() != 35513:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_bytes() != 20339:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_str() != 24158:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_generate() != 36411:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_bytes() != 36237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_str() != 16397:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_generate() != 63087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifier_new() != 59813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_der() != 40127:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_pem() != 40573:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_new() != 16080:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_bech32() != 7016:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_der() != 63595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic() != 57849:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic_with_path() != 7709:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_pem() != 28166:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_generate() != 47736:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_new() != 32825:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_bytes() != 60002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_str() != 27991:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_generate() != 49992:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_bytes() != 8469:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_str() != 15312:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_generate() != 40260:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifier_new() != 59881:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_der() != 6292:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_pem() != 20421:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_new() != 57317:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bech32() != 51811:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bytes() != 9299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_der() != 24923:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_ed25519() != 22142:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_pem() != 2041:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256k1() != 46546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256r1() != 13117:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_ed25519() != 65185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256k1() != 56524:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256r1() != 19953:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifier_new() != 34783:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_der() != 21482:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_pem() != 11192:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_splitcoins_new() != 50321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new() != 61625:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_ascii_string() != 60972:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_balance() != 10874:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_clock() != 18419:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin() != 38232:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_manager() != 16973:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_metadata() != 56669:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config() != 33902:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config_setting() != 18224:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_address_key() != 6409:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_config_key() != 3059:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_global_pause_key() != 36813:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_display_created() != 24465:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_dynamic_object_field_wrapper() != 48905:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_field() != 4196:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_gas_coin() != 5754:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_id() != 62017:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_coin_type() != 44499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_admin_cap() != 5595:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_state() != 29781:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_treasury_cap() != 59282:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_name() != 26361:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_staked_iota() != 60970:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_string() != 47333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_system_epoch_info_event() != 36154:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_time_lock() != 38402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_timelocked_staked_iota() != 46742:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_transfer_receiving() != 40850:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_treasury_cap() != 2523:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_uid() != 54533:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_cap() != 6365:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_receipt() != 44298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_ticket() != 43936:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_version_updated() != 40840:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_systempackage_new() != 25070:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transaction_from_base64() != 30255:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transaction_new_v1() != 58632:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionbuilder_new() != 35216:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactioneffects_new_v1() != 63561:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionevents_new() != 1310:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_authenticator_state_update_v1() != 29264:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_consensus_commit_prologue_v1() != 27756:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_end_of_epoch() != 44556:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_genesis() != 45541:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_programmable_transaction() != 9153:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_randomness_state_update() != 37051:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_from_base64() != 19681:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_new() != 17484:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_transferobjects_new() != 22470:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_address() != 65087:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_bool() != 404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_signer() != 49791:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_struct() != 40686:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u128() != 24239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u16() != 14922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u256() != 41658:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u32() != 59185:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u64() != 29045:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u8() != 55184:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_vector() != 2453:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_upgrade_new() != 61663:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_additive() != 63459:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_compatible() != 63292:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_dep_only() != 44371:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_base64() != 8029:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_bytes() != 37499:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_multisig() != 39922:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_passkey() != 25378:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_simple() != 31310:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_zklogin() != 43856:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_usersignatureverifier_new() != 32322:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_validatoraggregatedsignature_new() != 15846:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary() != 25823:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureverifier_new() != 17424:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_validatorexecutiontimeobservation_new() != 47546:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_validatorsignature_new() != 2599:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_versionassignment_new() != 14186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginauthenticator_new() != 32812:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_zklogininputs_new() != 48962:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginproof_new() != 19950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginpublicidentifier_new() != 53294:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_dev() != 44446:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_mainnet() != 12123:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_address.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_framework.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_framework.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_std_lib.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_std_lib.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_system.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_system.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_zero.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_zero.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_canonical_string.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_canonical_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_short_string.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_short_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_argument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_argument.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_argument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_argument.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_gas.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_gas.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_input.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_input.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_nested_result.argtypes = (
    ctypes.c_uint16,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_nested_result.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_result.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_result.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_argument_get_nested_result.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_argument_get_nested_result.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381privatekey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381privatekey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_sign_checkpoint_summary.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_sign_checkpoint_summary.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_try_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_try_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_verifying_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_verifying_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381publickey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381publickey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381publickey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381signature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381signature_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381signature_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381verifyingkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381verifyingkey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381verifyingkey_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381verifyingkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bn254fieldelement.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bn254fieldelement.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bn254fieldelement.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bn254fieldelement.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str_radix_10.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str_radix_10.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_padded.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_padded.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_unpadded.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_unpadded.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_cancelledtransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_cancelledtransaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_cancelledtransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_cancelledtransaction.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_cancelledtransaction_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_cancelledtransaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_version_assignments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_version_assignments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepoch.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepoch.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepoch_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepoch_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_computation_charge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_computation_charge.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch_start_timestamp_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch_start_timestamp_ms.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_non_refundable_storage_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_non_refundable_storage_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_protocol_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_protocol_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_charge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_charge.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_rebate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_rebate.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_system_packages.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_system_packages.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepochv2.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepochv2.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepochv2.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepochv2.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepochv2_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepochv2_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge_burned.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge_burned.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch_start_timestamp_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch_start_timestamp_ms.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_non_refundable_storage_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_non_refundable_storage_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_protocol_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_protocol_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_charge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_charge.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_rebate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_rebate.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_system_packages.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_system_packages.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepochv3.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepochv3.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepochv3.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepochv3.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepochv3_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepochv3_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge_burned.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge_burned.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_eligible_active_validators.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_eligible_active_validators.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch_start_timestamp_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch_start_timestamp_ms.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_non_refundable_storage_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_non_refundable_storage_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_protocol_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_protocol_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_charge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_charge.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_rebate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_rebate.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_system_packages.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_system_packages.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointcommitment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointcommitment.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointcommitment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointcommitment.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_as_ecmh_live_object_set_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_as_ecmh_live_object_set_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_is_ecmh_live_object_set.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_is_ecmh_live_object_set.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointcontents.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointcontents.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointcontents.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointcontents.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointcontents_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointcontents_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_transaction_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_transaction_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointsummary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointsummary.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointsummary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointsummary.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointsummary_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointsummary_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_checkpoint_commitments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_checkpoint_commitments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_content_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_content_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_end_of_epoch_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_end_of_epoch_data.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch_rolling_gas_cost_summary.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch_rolling_gas_cost_summary.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_network_total_transactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_network_total_transactions.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_previous_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_previous_digest.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_sequence_number.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_sequence_number.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_timestamp_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_timestamp_ms.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_version_specific_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_version_specific_data.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointtransactioninfo.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointtransactioninfo.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointtransactioninfo.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointtransactioninfo.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointtransactioninfo_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointtransactioninfo_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_effects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_effects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_signatures.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_signatures.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_circomg1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_circomg1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_circomg1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_circomg1.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_circomg1_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_circomg1_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_circomg2.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_circomg2.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_circomg2.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_circomg2.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_circomg2_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_circomg2_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_clienttransactionbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_clienttransactionbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_clienttransactionbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_clienttransactionbuilder.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_dry_run.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_dry_run.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute_with_sponsor.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute_with_sponsor.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_expiration.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_finish.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_finish.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_budget.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_budget.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_price.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_price.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_station_sponsor.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_station_sponsor.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_make_move_vec.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_make_move_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_merge_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_merge_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_move_call.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_move_call.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_publish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_publish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_coins.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_iota.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_iota.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_split_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_split_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_sponsor.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_sponsor.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_stake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_stake.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_transfer_objects.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_transfer_objects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_unstake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_unstake.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_upgrade.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_upgrade.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_coin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_coin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_coin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_coin.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_coin_try_from_object.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_coin_try_from_object.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_balance.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_coin_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_coin_type.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_command.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_command.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_command.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_command.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_make_move_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_make_move_vector.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_merge_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_merge_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_move_call.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_move_call.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_publish.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_publish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_split_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_split_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_transfer_objects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_transfer_objects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_upgrade.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_upgrade.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_consensuscommitprologuev1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_consensuscommitprologuev1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_consensuscommitprologuev1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_consensuscommitprologuev1.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_consensuscommitprologuev1_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_consensuscommitprologuev1_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_commit_timestamp_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_commit_timestamp_ms.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_commit_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_commit_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_determined_version_assignments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_determined_version_assignments.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_round.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_round.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_sub_dag_index.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_sub_dag_index.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_consensusdeterminedversionassignments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_consensusdeterminedversionassignments.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_consensusdeterminedversionassignments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_consensusdeterminedversionassignments.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_consensusdeterminedversionassignments_new_cancelled_transactions.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_consensusdeterminedversionassignments_new_cancelled_transactions.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_as_cancelled_transactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_as_cancelled_transactions.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_is_cancelled_transactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_is_cancelled_transactions.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_digest.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_from_base58.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_from_base58.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_next_lexicographical.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_next_lexicographical.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_to_base58.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_to_base58.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519privatekey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519privatekey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic_with_path.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic_with_path.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_personal_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_personal_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_verifying_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_verifying_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519publickey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_derive_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_flagged_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_flagged_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519signature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519signature_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519signature_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519verifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519verifyingkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519verifyingkey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_simple.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_user.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_endofepochtransactionkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_endofepochtransactionkind.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_endofepochtransactionkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_endofepochtransactionkind.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_create.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_create.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_expire.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_expire.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v2.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v2.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v3.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v3.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservation.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservation.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservation_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservation_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_observations.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_observations.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservationkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservationkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservationkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservationkey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_make_move_vec.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_make_move_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_merge_coins.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_merge_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_move_entry_point.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_move_entry_point.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_publish.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_publish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_split_coins.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_split_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_transfer_objects.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_transfer_objects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_upgrade.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_upgrade.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservations.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservations.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservations.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservations.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservations_new_v1.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservations_new_v1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_faucetclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_faucetclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_faucetclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_faucetclient.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_devnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_devnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_localnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_localnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_testnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_testnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_and_wait.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_and_wait.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_status.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_status.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_genesisobject.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_genesisobject.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_genesisobject.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_genesisobject.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_genesisobject_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_genesisobject_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_type.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_owner.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_genesistransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_genesistransaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_genesistransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_genesistransaction.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_genesistransaction_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_genesistransaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesistransaction_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesistransaction_events.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesistransaction_objects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesistransaction_objects.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_graphqlclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_graphqlclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_graphqlclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_graphqlclient.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_devnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_devnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_localnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_localnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_mainnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_mainnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_testnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_testnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_active_validators.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_active_validators.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_balance.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_chain_id.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_chain_id.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoint.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoint.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoints.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoints.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coin_metadata.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coin_metadata.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coins.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_int8,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_int8,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx_kind.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_field.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_field.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_fields.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_fields.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_object_field.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_object_field.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_checkpoints.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_checkpoints.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_transaction_blocks.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_transaction_blocks.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_events.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_events.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_execute_tx.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_execute_tx.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_gas_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_gas_coins.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_default_name.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_default_name.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_lookup.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_lookup.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_registrations.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_registrations.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_finalized.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_finalized.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_indexed_on_node.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_indexed_on_node.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_latest_checkpoint_sequence_number.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_latest_checkpoint_sequence_number.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_max_page_size.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_max_page_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents_bcs.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_function.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_function.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_module.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_module.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object_bcs.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_objects.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_objects.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_latest.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_latest.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_versions.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_versions.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_packages.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_packages.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_protocol_config.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_protocol_config.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_reference_gas_price.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_reference_gas_price.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_run_query.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_run_query.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_service_config.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_service_config.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_set_rpc_server.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_set_rpc_server.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_supply.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_supply.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks.argtypes = (
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_digest.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_seq_num.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_seq_num.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_data_effects.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_data_effects.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_effects.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_effects.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_data_effects.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_data_effects.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_effects.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_effects.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_wait_for_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_wait_for_tx.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_identifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_identifier_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_identifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_identifier_as_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_identifier_as_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_identifier_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_identifier_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_input.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_input.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_input.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_input.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_immutable_or_owned.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_immutable_or_owned.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_pure.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_pure.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_receiving.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_receiving.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_shared.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_shared.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_makemovevector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_makemovevector.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_makemovevector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_makemovevector.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_makemovevector_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_makemovevector_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_makemovevector_elements.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_makemovevector_elements.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_makemovevector_type_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_makemovevector_type_tag.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_mergecoins.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_mergecoins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_mergecoins.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_mergecoins.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_mergecoins_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_mergecoins_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_mergecoins_coin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_mergecoins_coin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_mergecoins_coins_to_merge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_mergecoins_coins_to_merge.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movearg.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movearg.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movearg.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movearg.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_from_base58.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_from_base58.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec_from_base58.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec_from_base58.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_option.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_option.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_string_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_string_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movecall.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movecall.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movecall.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movecall.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movecall_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movecall_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_arguments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_arguments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_function.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_function.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_module.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_module.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_package.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_type_arguments.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_type_arguments.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movefunction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movefunction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movefunction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movefunction.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_is_entry.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_is_entry.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_name.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_parameters.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_parameters.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_return_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_return_type.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_type_parameters.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_type_parameters.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_visibility.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_visibility.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movepackage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movepackage.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movepackage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movepackage.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackage_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackage_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_linkage_table.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_linkage_table.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_modules.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_modules.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_type_origin_table.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_type_origin_table.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movepackagedata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movepackagedata.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movepackagedata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movepackagedata.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_base64.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_base64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_json.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_json.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_dependencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_dependencies.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_modules.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_modules.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_base64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_base64.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigaggregatedsignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigaggregatedsignature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigaggregatedsignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigaggregatedsignature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregatedsignature_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregatedsignature_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_bitmap.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_bitmap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_committee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_committee.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_signatures.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_signatures.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigaggregator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigaggregator.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigaggregator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigaggregator.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_message.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigcommittee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigcommittee.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigcommittee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigcommittee.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigcommittee_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigcommittee_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_derive_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_is_valid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_is_valid.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_members.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_members.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_threshold.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_threshold.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmember.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmember.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmember.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmember.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigmember_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigmember_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmember_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmember_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmember_weight.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmember_weight.restype = ctypes.c_uint8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmemberpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmemberpublickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmemberpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmemberpublickey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_ed25519.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256k1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256r1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_zklogin.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmembersignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmembersignature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmembersignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmembersignature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_ed25519.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256k1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256r1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_zklogin.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigverifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigverifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigverifier_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigverifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_with_zklogin_verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_with_zklogin_verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_zklogin_verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_zklogin_verifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_name.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_name_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_name_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_format.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_format.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_is_sln.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_is_sln.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_is_subname.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_is_subname.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_label.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_label.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_labels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_labels.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_num_labels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_num_labels.restype = ctypes.c_uint32
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_parent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_parent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_nameregistration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_nameregistration.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_nameregistration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_nameregistration.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_nameregistration_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_nameregistration_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_expiration_timestamp_ms.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_expiration_timestamp_ms.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_name_str.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_name_str.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_object.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_object.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_object.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_object.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_object_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_object_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_package.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_package_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_package_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_struct.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_struct_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_struct_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_data.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_ref.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_ref.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_type.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_owner.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_previous_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_previous_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_storage_rebate.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_storage_rebate.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objectdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objectdata.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objectdata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objectdata.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_package.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_struct.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_struct.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_as_package_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_as_package_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_as_struct_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_as_struct_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_is_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_is_package.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_is_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_is_struct.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objectid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objectid.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objectid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objectid.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_clock.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_clock.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_derive_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_derive_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_system.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_system.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_zero.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_zero.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_derive_dynamic_child_id.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_derive_dynamic_child_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_canonical_string.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_canonical_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_short_string.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_short_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_uniffi_trait_hash.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_uniffi_trait_hash.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objecttype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objecttype.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objecttype.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objecttype.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_package.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_package.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_struct.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_is_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_is_package.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_is_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_is_struct.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_owner.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_owner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_owner.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_immutable.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_immutable.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_object.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_object.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_shared.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_shared.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_address_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_address_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_object.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_object.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_object_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_object_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_shared.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_shared.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_shared_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_shared_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_address.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_immutable.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_immutable.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_object.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_object.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_shared.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_shared.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ptbargument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ptbargument.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ptbargument.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ptbargument.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_from_base58.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_from_base58.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec_from_base58.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec_from_base58.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_gas.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_gas.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_move_arg.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_move_arg.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_ref.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_ref.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_option.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_option.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_res.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_res.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut_from_hex.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut_from_hex.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8_vec.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeyauthenticator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeyauthenticator.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeyauthenticator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeyauthenticator.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_authenticator_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_authenticator_data.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_challenge.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_challenge.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_client_data_json.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_client_data_json.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeypublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeypublickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeypublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeypublickey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_passkeypublickey_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_passkeypublickey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_derive_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_inner.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_inner.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeyverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeyverifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeyverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeyverifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_passkeyverifier_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_passkeyverifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyverifier_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyverifier_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_personalmessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_personalmessage.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_personalmessage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_personalmessage.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_personalmessage_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_personalmessage_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_message_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_message_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_programmabletransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_programmabletransaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_programmabletransaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_programmabletransaction.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_programmabletransaction_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_programmabletransaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_commands.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_commands.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_inputs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_inputs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_publish.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_publish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_publish.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_publish.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_publish_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_publish_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_publish_dependencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_publish_dependencies.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_publish_modules.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_publish_modules.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1privatekey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1privatekey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic_with_path.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic_with_path.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_personal_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_personal_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_verifying_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_verifying_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1publickey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_derive_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_flagged_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_flagged_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1signature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1signature_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1signature_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1verifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifier_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_simple.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_user.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifyingkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1verifyingkey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_simple.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_user.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1privatekey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1privatekey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1privatekey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic_with_path.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic_with_path.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_personal_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_personal_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_verifying_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_verifying_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1publickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1publickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1publickey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_derive_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_flagged_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_flagged_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1signature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_str.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_str.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_generate.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_generate.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1signature_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1signature_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1verifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifier_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_simple.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_user.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifyingkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1verifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1verifyingkey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_simple.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_simple.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_user.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simplekeypair.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simplekeypair.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simplekeypair.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simplekeypair.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bech32.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bech32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_ed25519.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256k1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256r1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_personal_message.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_personal_message.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bech32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bech32.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign_user.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign_user.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_verifying_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_verifying_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simplesignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simplesignature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simplesignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simplesignature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_ed25519.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256k1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256r1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_ed25519.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_ed25519.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256k1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256k1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256r1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256r1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simpleverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simpleverifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simpleverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simpleverifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifier_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifier_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifier_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simpleverifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simpleverifyingkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simpleverifyingkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simpleverifyingkey.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_der.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_der.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_pem.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_pem.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_der.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_der.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_pem.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_pem.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_splitcoins.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_splitcoins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_splitcoins.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_splitcoins.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_splitcoins_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_splitcoins_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_splitcoins_amounts.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_splitcoins_amounts.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_splitcoins_coin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_splitcoins_coin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_structtag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_structtag.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_structtag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_structtag.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_ascii_string.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_ascii_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_balance.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_clock.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_clock.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_manager.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_manager.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_metadata.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_metadata.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config_setting.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config_setting.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_address_key.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_address_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_config_key.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_config_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_global_pause_key.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_global_pause_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_display_created.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_display_created.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_dynamic_object_field_wrapper.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_dynamic_object_field_wrapper.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_field.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_field.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_gas_coin.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_gas_coin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_id.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_coin_type.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_coin_type.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_admin_cap.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_admin_cap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_state.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_state.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_treasury_cap.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_treasury_cap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_staked_iota.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_staked_iota.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_string.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_system_epoch_info_event.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_system_epoch_info_event.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_time_lock.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_time_lock.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_timelocked_staked_iota.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_timelocked_staked_iota.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_transfer_receiving.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_transfer_receiving.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_treasury_cap.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_treasury_cap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_uid.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_uid.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_cap.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_cap.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_receipt.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_receipt.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_ticket.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_ticket.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_version_updated.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_version_updated.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_module.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_module.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_name.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_name.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_to_canonical_string.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_to_canonical_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_type_args.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_type_args.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_systempackage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_systempackage.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_systempackage.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_systempackage.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_systempackage_new.argtypes = (
    ctypes.c_uint64,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_systempackage_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_dependencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_dependencies.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_modules.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_modules.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transaction.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transaction_from_base64.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transaction_from_base64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transaction_new_v1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transaction_new_v1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_as_v1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_as_v1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_expiration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_gas_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_gas_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_sender.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_sender.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_to_base64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_to_base64.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionbuilder.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionbuilder_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_execute_with_gas_station.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_execute_with_gas_station.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_expiration.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_budget.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_budget.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_price.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_price.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_station_sponsor.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_station_sponsor.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_make_move_vec.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_make_move_vec.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_merge_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_merge_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_move_call.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_move_call.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_publish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_publish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_coins.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_iota.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_iota.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_split_coins.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_split_coins.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_sponsor.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_sponsor.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_stake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_stake.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_transfer_objects.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_transfer_objects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_unstake.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_unstake.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_upgrade.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_upgrade.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_with_client.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_with_client.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactioneffects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactioneffects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactioneffects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactioneffects.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactioneffects_new_v1.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactioneffects_new_v1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_as_v1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_as_v1.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_is_v1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_is_v1.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionevents.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionevents.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionevents.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionevents.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionevents_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionevents_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionevents_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionevents_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionevents_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionevents_events.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionkind.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionkind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionkind.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_authenticator_state_update_v1.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_authenticator_state_update_v1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_consensus_commit_prologue_v1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_consensus_commit_prologue_v1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_end_of_epoch.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_end_of_epoch.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_genesis.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_genesis.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_programmable_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_programmable_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_randomness_state_update.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_randomness_state_update.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionv1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionv1.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionv1.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionv1.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_from_base64.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_from_base64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_digest.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_expiration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_expiration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_gas_payment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_gas_payment.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_kind.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_kind.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_sender.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_sender.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest_hex.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest_hex.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_to_base64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_to_base64.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transferobjects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transferobjects.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transferobjects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transferobjects.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transferobjects_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transferobjects_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transferobjects_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transferobjects_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transferobjects_objects.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transferobjects_objects.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_typetag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_typetag.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_typetag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_typetag.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_address.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_bool.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_bool.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_signer.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_struct.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u128.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u128.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u16.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u16.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u256.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u256.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u32.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u32.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u64.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u8.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u8.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_vector.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_address.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_bool.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_bool.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_signer.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_struct.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_struct.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u128.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u128.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u16.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u16.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u256.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u256.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u32.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u32.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u64.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u8.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_vector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_vector.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_to_canonical_string.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_to_canonical_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_upgrade.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_upgrade.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_upgrade.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_upgrade.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgrade_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgrade_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_dependencies.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_dependencies.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_modules.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_modules.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_package.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_package.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_ticket.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_ticket.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_upgradepolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_upgradepolicy.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_upgradepolicy.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_upgradepolicy.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_additive.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_additive.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_compatible.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_compatible.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_dep_only.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_dep_only.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_as_u8.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_as_u8.restype = ctypes.c_uint8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_eq.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_eq.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_ne.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_ne.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_usersignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_usersignature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_usersignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_usersignature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_base64.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_base64.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_bytes.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_bytes.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_multisig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_multisig.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_passkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_passkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_simple.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_zklogin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin_opt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin_opt.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_multisig.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_multisig.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_passkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_passkey.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_simple.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_simple.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_zklogin.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_zklogin.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_scheme.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_scheme.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_to_base64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_to_base64.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_to_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_to_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_usersignatureverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_usersignatureverifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_usersignatureverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_usersignatureverifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignatureverifier_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignatureverifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_with_zklogin_verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_with_zklogin_verifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_zklogin_verifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_zklogin_verifier.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatoraggregatedsignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatoraggregatedsignature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatoraggregatedsignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatoraggregatedsignature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatoraggregatedsignature_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatoraggregatedsignature_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_bitmap_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_bitmap_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureaggregator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureaggregator.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureaggregator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureaggregator.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_add_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_add_signature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_committee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_committee.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureverifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureverifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureverifier_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureverifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_committee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_committee.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_aggregated.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_aggregated.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_checkpoint_summary.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_checkpoint_summary.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorexecutiontimeobservation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorexecutiontimeobservation.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorexecutiontimeobservation.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorexecutiontimeobservation.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorexecutiontimeobservation_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorexecutiontimeobservation_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_duration.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_duration.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_validator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_validator.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorsignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorsignature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorsignature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorsignature.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorsignature_new.argtypes = (
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorsignature_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_public_key.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_public_key.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_versionassignment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_versionassignment.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_versionassignment.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_versionassignment.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_versionassignment_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_versionassignment_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_versionassignment_object_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_versionassignment_object_id.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_versionassignment_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_versionassignment_version.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginauthenticator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginauthenticator.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginauthenticator.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginauthenticator.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginauthenticator_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginauthenticator_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_inputs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_inputs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_max_epoch.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_max_epoch.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_signature.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_signature.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zklogininputs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zklogininputs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zklogininputs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zklogininputs.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zklogininputs_new.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zklogininputs_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_address_seed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_address_seed.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_header_base64.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_header_base64.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss_base64_details.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss_base64_details.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_jwk_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_jwk_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_proof_points.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_proof_points.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_public_identifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_public_identifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginproof.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginproof.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginproof.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginproof.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginproof_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginproof_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_a.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_a.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_b.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_b.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_c.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_c.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginpublicidentifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginpublicidentifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginpublicidentifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginpublicidentifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginpublicidentifier_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginpublicidentifier_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_address_seed.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_address_seed.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_padded.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_padded.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_unpadded.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_unpadded.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_iss.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_iss.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginverifier.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginverifier.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginverifier.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_dev.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_dev.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_mainnet.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_mainnet.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_jwks.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_jwks.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_verify.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_verify.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_with_jwks.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_with_jwks.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_active_jwk_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_active_jwk_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_active_jwk_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_active_jwk_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_address_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_address_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_address_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_address_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_argument_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_argument_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_argument_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_argument_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_base64_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_base64_decode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_base64_encode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_base64_encode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bool_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bool_from_bcs.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bool_to_bcs.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bool_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_changed_object_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_changed_object_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_changed_object_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_changed_object_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g1_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g1_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g1_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g1_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g2_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g2_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g2_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g2_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_argument_error_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_argument_error_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_argument_error_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_argument_error_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_digest_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_digest_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_digest_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_digest_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_event_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_event_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_event_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_event_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_error_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_error_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_error_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_error_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_status_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_status_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_status_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_status_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_payment_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_payment_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_payment_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_payment_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_generate_mnemonic.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_generate_mnemonic.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_object_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_object_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_object_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_object_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_hex_decode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_hex_decode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_hex_encode.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_hex_encode.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i16_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i16_from_bcs.restype = ctypes.c_int16
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i16_to_bcs.argtypes = (
    ctypes.c_int16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i16_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i32_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i32_from_bcs.restype = ctypes.c_int32
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i32_to_bcs.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i32_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i64_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i64_from_bcs.restype = ctypes.c_int64
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i64_to_bcs.argtypes = (
    ctypes.c_int64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i64_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i8_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i8_from_bcs.restype = ctypes.c_int8
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i8_to_bcs.argtypes = (
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i8_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_id_operation_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_id_operation_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_id_operation_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_id_operation_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_identifier_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_identifier_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_identifier_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_identifier_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_input_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_input_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_input_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_input_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_id_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_id_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_id_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_id_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_make_move_vector_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_make_move_vector_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_make_move_vector_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_make_move_vector_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_merge_coins_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_merge_coins_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_merge_coins_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_merge_coins_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_call_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_call_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_call_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_call_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_location_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_location_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_location_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_location_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_package_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_package_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_package_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_package_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_struct_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_struct_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_struct_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_struct_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_committee_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_committee_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_committee_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_committee_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_data_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_data_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_data_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_data_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_id_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_id_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_id_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_id_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_in_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_in_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_in_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_in_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_out_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_out_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_out_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_out_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_reference_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_reference_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_reference_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_reference_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_owner_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_owner_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_owner_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_owner_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_publish_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_publish_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_publish_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_publish_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_signed_transaction_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_signed_transaction_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_signed_transaction_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_signed_transaction_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_simple_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_simple_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_simple_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_simple_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_split_coins_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_split_coins_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_split_coins_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_split_coins_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_string_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_string_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_string_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_string_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_struct_tag_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_struct_tag_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_struct_tag_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_struct_tag_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_system_package_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_system_package_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_system_package_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_system_package_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_events_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_events_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_events_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_events_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_kind_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_kind_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_kind_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_kind_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_v1_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_v1_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_v1_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_v1_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transfer_objects_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transfer_objects_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transfer_objects_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transfer_objects_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_argument_error_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_argument_error_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_argument_error_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_argument_error_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_origin_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_origin_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_origin_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_origin_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_tag_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_tag_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_tag_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_tag_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u16_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u16_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u16_to_bcs.argtypes = (
    ctypes.c_uint16,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u16_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u32_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u32_from_bcs.restype = ctypes.c_uint32
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u32_to_bcs.argtypes = (
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u32_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u64_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u64_from_bcs.restype = ctypes.c_uint64
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u64_to_bcs.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u64_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u8_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u8_from_bcs.restype = ctypes.c_uint8
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u8_to_bcs.argtypes = (
    ctypes.c_uint8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u8_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_info_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_info_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_info_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_info_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_user_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_user_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_user_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_user_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_signature_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_signature_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_signature_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_signature_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_version_assignment_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_version_assignment_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_version_assignment_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_version_assignment_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_from_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_to_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_from_bcs.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_from_bcs.restype = ctypes.c_void_p
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_to_bcs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_to_bcs.restype = _UniffiRustBuffer
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_free.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_free_void.restype = None
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_active_jwk_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_active_jwk_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_active_jwk_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_active_jwk_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_address_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_address_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_address_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_address_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_argument_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_argument_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_argument_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_argument_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_expire_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_authenticator_state_update_v1_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_base64_decode.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_base64_decode.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_base64_encode.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_base64_encode.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_public_key_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bls12381_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bn254_field_element_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bool_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bool_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bool_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_bool_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_cancelled_transaction_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_change_epoch_v2_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_changed_object_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_changed_object_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_changed_object_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_changed_object_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_commitment_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_contents_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_summary_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_checkpoint_transaction_info_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g1_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g1_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g1_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g1_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g2_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g2_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g2_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_circom_g2_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_argument_error_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_command_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_commit_prologue_v1_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_consensus_determined_version_assignments_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_digest_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_digest_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_digest_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_digest_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_public_key_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_ed25519_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_end_of_epoch_data_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_event_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_event_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_event_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_event_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_error_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_error_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_error_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_error_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_status_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_status_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_status_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_status_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_key_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observation_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_execution_time_observations_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_cost_summary_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_payment_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_payment_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_payment_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_gas_payment_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_generate_mnemonic.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_generate_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_object_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_object_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_object_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_object_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_genesis_transaction_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_hex_decode.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_hex_decode.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_hex_encode.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_hex_encode.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i16_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i16_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i16_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i16_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i32_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i32_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i32_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i32_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i64_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i64_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i64_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i64_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i8_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i8_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i8_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_i8_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_id_operation_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_id_operation_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_id_operation_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_id_operation_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_identifier_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_identifier_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_identifier_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_identifier_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_input_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_input_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_input_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_input_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_id_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_id_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_id_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_id_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_jwk_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_make_move_vector_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_merge_coins_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_merge_coins_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_merge_coins_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_merge_coins_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_call_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_call_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_call_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_call_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_location_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_location_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_location_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_location_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_package_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_package_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_package_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_package_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_struct_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_struct_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_struct_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_move_struct_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_aggregated_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_committee_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_public_key_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_multisig_member_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_data_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_data_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_data_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_data_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_id_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_id_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_id_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_id_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_in_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_in_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_in_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_in_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_out_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_out_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_out_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_out_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_reference_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_reference_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_reference_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_reference_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_object_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_owner_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_owner_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_owner_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_owner_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_package_upgrade_error_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_passkey_authenticator_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_programmable_transaction_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_publish_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_publish_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_publish_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_publish_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_randomness_state_update_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_public_key_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256k1_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_public_key_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_secp256r1_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_signed_transaction_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_simple_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_simple_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_simple_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_simple_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_split_coins_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_split_coins_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_split_coins_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_split_coins_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_string_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_string_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_string_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_string_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_struct_tag_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_struct_tag_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_struct_tag_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_struct_tag_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_system_package_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_system_package_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_system_package_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_system_package_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_effects_v1_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_events_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_events_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_events_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_events_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_expiration_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_kind_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transaction_v1_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_transfer_objects_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_argument_error_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_origin_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_origin_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_origin_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_origin_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_tag_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_tag_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_tag_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_type_tag_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u16_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u16_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u16_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u16_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u32_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u32_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u32_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u32_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u64_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u64_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u64_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u64_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u8_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u8_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u8_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_u8_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_kind_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_unchanged_shared_object_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_info_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_upgrade_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_user_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_user_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_user_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_user_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_aggregated_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_member_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_committee_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_execution_time_observation_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_signature_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_signature_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_signature_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_validator_signature_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_version_assignment_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_version_assignment_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_version_assignment_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_version_assignment_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_authenticator_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_claim_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_proof_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_from_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_from_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_to_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_func_zk_login_public_identifier_to_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_canonical_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_canonical_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_short_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_address_to_short_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_argument_get_nested_result.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_argument_get_nested_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_sign_checkpoint_summary.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_sign_checkpoint_summary.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_try_sign.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_try_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_verifying_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381privatekey_verifying_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381publickey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381publickey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381signature_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381signature_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bls12381verifyingkey_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_padded.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_padded.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_unpadded.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_bn254fieldelement_unpadded.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_version_assignments.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_cancelledtransaction_version_assignments.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_computation_charge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_computation_charge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch_start_timestamp_ms.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_epoch_start_timestamp_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_non_refundable_storage_fee.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_non_refundable_storage_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_protocol_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_protocol_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_charge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_charge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_rebate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_storage_rebate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_system_packages.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepoch_system_packages.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge_burned.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_computation_charge_burned.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch_start_timestamp_ms.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_epoch_start_timestamp_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_non_refundable_storage_fee.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_non_refundable_storage_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_protocol_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_protocol_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_charge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_charge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_rebate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_storage_rebate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_system_packages.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv2_system_packages.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge_burned.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_computation_charge_burned.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_eligible_active_validators.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_eligible_active_validators.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch_start_timestamp_ms.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_epoch_start_timestamp_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_non_refundable_storage_fee.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_non_refundable_storage_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_protocol_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_protocol_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_charge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_charge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_rebate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_storage_rebate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_system_packages.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_changeepochv3_system_packages.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_as_ecmh_live_object_set_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_as_ecmh_live_object_set_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_is_ecmh_live_object_set.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcommitment_is_ecmh_live_object_set.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_transaction_info.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointcontents_transaction_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_checkpoint_commitments.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_checkpoint_commitments.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_content_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_content_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_end_of_epoch_data.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_end_of_epoch_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch_rolling_gas_cost_summary.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_epoch_rolling_gas_cost_summary.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_network_total_transactions.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_network_total_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_previous_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_previous_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_sequence_number.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_sequence_number.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_signing_message_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_timestamp_ms.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_timestamp_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_version_specific_data.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointsummary_version_specific_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_effects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_effects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_signatures.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_signatures.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_checkpointtransactioninfo_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_dry_run.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_dry_run.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute_with_sponsor.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_execute_with_sponsor.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_expiration.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_budget.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_budget.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_price.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_price.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_station_sponsor.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_gas_station_sponsor.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_make_move_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_make_move_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_merge_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_merge_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_move_call.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_move_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_publish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_publish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_iota.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_send_iota.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_split_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_split_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_sponsor.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_sponsor.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_stake.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_stake.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_transfer_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_transfer_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_unstake.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_unstake.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_upgrade.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_clienttransactionbuilder_upgrade.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_coin_balance.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_coin_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_coin_coin_type.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_coin_coin_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_coin_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_coin_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_commit_timestamp_ms.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_commit_timestamp_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_commit_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_commit_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_determined_version_assignments.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_consensus_determined_version_assignments.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_round.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_round.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_sub_dag_index.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensuscommitprologuev1_sub_dag_index.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_as_cancelled_transactions.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_as_cancelled_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_is_cancelled_transactions.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_consensusdeterminedversionassignments_is_cancelled_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_digest_next_lexicographical.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_digest_next_lexicographical.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_digest_to_base58.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_digest_to_base58.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_digest_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_digest_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_personal_message.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_personal_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_sign_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_try_sign_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_verifying_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519privatekey_verifying_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_derive_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_derive_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_flagged_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519publickey_to_flagged_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519signature_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519signature_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_ed25519verifyingkey_verify_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_observations.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_executiontimeobservation_observations.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_and_wait.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_and_wait.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_status.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_faucetclient_request_status.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_data.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_type.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_object_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_owner.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_owner.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesisobject_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_events.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_genesistransaction_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_active_validators.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_active_validators.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_balance.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_chain_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_chain_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoint.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoint.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoints.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_checkpoints.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coin_metadata.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coin_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx_kind.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dry_run_tx_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_field.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_fields.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_fields.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_object_field.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_dynamic_object_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_checkpoints.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_checkpoints.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_transaction_blocks.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_epoch_total_transaction_blocks.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_events.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_execute_tx.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_execute_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_gas_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_gas_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_default_name.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_default_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_lookup.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_lookup.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_registrations.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_iota_names_registrations.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_finalized.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_finalized.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_indexed_on_node.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_is_tx_indexed_on_node.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_latest_checkpoint_sequence_number.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_latest_checkpoint_sequence_number.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_max_page_size.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_max_page_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_move_object_contents_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_function.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_function.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_module.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_normalized_move_module.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object_bcs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_object_bcs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_latest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_latest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_versions.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_package_versions.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_packages.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_packages.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_protocol_config.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_protocol_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_reference_gas_price.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_reference_gas_price.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_run_query.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_run_query.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_service_config.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_service_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_set_rpc_server.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_set_rpc_server.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_supply.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_supply.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_seq_num.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_total_transaction_blocks_by_seq_num.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_data_effects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_data_effects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_effects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transaction_effects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_data_effects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_data_effects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_effects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_transactions_effects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_wait_for_tx.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_graphqlclient_wait_for_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_identifier_as_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_identifier_as_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_makemovevector_elements.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_makemovevector_elements.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_makemovevector_type_tag.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_makemovevector_type_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coins_to_merge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_mergecoins_coins_to_merge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_arguments.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_arguments.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_function.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_function.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_module.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_module.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_type_arguments.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movecall_type_arguments.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_is_entry.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_is_entry.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_name.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_parameters.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_parameters.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_return_type.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_return_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_type_parameters.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_type_parameters.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_visibility.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movefunction_visibility.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_linkage_table.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_linkage_table.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_modules.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_modules.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_type_origin_table.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_type_origin_table.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackage_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_dependencies.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_dependencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_modules.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_modules.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_json.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_movepackagedata_to_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_bitmap.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_bitmap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_committee.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_committee.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_signatures.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregatedsignature_signatures.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_finish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_verifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_verifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_signature.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_verifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigaggregator_with_verifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_derive_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_derive_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_is_valid.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_is_valid.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_members.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_members.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_threshold.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigcommittee_threshold.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmember_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmember_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmember_weight.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmember_weight.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_ed25519_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256k1_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_secp256r1_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_as_zklogin_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_is_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmemberpublickey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_ed25519_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256k1_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_secp256r1_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_as_zklogin_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigmembersignature_is_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_with_zklogin_verifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_with_zklogin_verifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_zklogin_verifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_multisigverifier_zklogin_verifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_format.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_format.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_is_sln.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_is_sln.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_is_subname.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_is_subname.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_label.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_label.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_labels.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_labels.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_num_labels.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_num_labels.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_parent.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_name_parent.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_expiration_timestamp_ms.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_expiration_timestamp_ms.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_nameregistration_name_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_package_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_package_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_struct_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_as_struct_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_data.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_object_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_object_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_object_ref.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_object_ref.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_object_type.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_object_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_owner.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_owner.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_previous_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_previous_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_storage_rebate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_storage_rebate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_object_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_package_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_package_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_struct_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_as_struct_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectdata_is_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_derive_dynamic_child_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_derive_dynamic_child_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_canonical_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_canonical_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_short_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objectid_to_short_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_as_struct_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_objecttype_is_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_address_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_address_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_object.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_object_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_object_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_as_shared_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_immutable.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_immutable.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_object.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_shared.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_owner_is_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_authenticator_data.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_authenticator_data.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_challenge.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_challenge.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_client_data_json.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_client_data_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_signature.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyauthenticator_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_derive_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_derive_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_inner.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeypublickey_inner.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyverifier_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_passkeyverifier_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_message_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_message_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_personalmessage_signing_digest_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_commands.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_commands.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_inputs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_programmabletransaction_inputs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_publish_dependencies.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_publish_dependencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_publish_modules.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_publish_modules.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_personal_message.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_personal_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_sign_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_try_sign_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_verifying_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1privatekey_verifying_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_derive_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_derive_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_flagged_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1publickey_to_flagged_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1signature_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1signature_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifier_verify_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256k1verifyingkey_verify_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_personal_message.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_personal_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_sign_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_try_sign_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_verifying_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1privatekey_verifying_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_derive_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_derive_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_flagged_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1publickey_to_flagged_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1signature_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1signature_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifier_verify_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_secp256r1verifyingkey_verify_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_personal_message.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_personal_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_sign_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign_user.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_try_sign_user.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_verifying_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplekeypair_verifying_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_pub_key_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_ed25519_sig_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_is_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_pub_key_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256k1_sig_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_pub_key_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_secp256r1_sig_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simplesignature_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifier_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifier_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_to_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_simpleverifyingkey_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_splitcoins_amounts.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_splitcoins_amounts.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_splitcoins_coin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_splitcoins_coin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_coin_type_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_module.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_module.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_name.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_to_canonical_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_to_canonical_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_type_args.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_structtag_type_args.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_systempackage_dependencies.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_systempackage_dependencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_systempackage_modules.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_systempackage_modules.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_systempackage_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_systempackage_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_as_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_as_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_expiration.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_gas_payment.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_gas_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_kind.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_sender.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_sender.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_signing_digest_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_to_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transaction_to_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_execute_with_gas_station.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_execute_with_gas_station.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_expiration.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_budget.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_budget.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_price.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_price.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_station_sponsor.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_gas_station_sponsor.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_make_move_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_make_move_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_merge_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_merge_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_move_call.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_move_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_publish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_publish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_iota.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_send_iota.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_split_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_split_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_sponsor.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_sponsor.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_stake.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_stake.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_transfer_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_transfer_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_unstake.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_unstake.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_upgrade.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_upgrade.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_with_client.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionbuilder_with_client.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_as_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_as_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_is_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactioneffects_is_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionevents_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionevents_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionevents_events.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionevents_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_expiration.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_expiration.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_gas_payment.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_gas_payment.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_kind.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_kind.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_sender.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_sender.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_signing_digest_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_to_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transactionv1_to_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transferobjects_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transferobjects_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transferobjects_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_transferobjects_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_struct_tag_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_as_vector_type_tag_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_bool.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_signer.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u128.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u128.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u16.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u16.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u256.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u256.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u8.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_u8.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_vector.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_is_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_to_canonical_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_typetag_to_canonical_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_dependencies.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_dependencies.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_modules.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_modules.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_ticket.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgrade_ticket.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgradepolicy_as_u8.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_upgradepolicy_as_u8.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_multisig_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_passkey_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_simple_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin_opt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_as_zklogin_opt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_multisig.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_multisig.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_passkey.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_passkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_is_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_scheme.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_scheme.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignature_to_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_with_zklogin_verifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_with_zklogin_verifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_zklogin_verifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_usersignatureverifier_zklogin_verifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_bitmap_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_bitmap_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_signature.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatoraggregatedsignature_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_add_signature.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_add_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_committee.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_committee.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_finish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureaggregator_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_committee.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_committee.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_aggregated.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_aggregated.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_checkpoint_summary.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorcommitteesignatureverifier_verify_checkpoint_summary.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_duration.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_duration.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_validator.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorexecutiontimeobservation_validator.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_public_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_public_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_signature.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_validatorsignature_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_versionassignment_object_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_versionassignment_object_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_versionassignment_version.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_versionassignment_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_inputs.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_inputs.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_max_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_max_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_signature.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginauthenticator_signature.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_address_seed.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_address_seed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_header_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_header_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss_base64_details.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_iss_base64_details.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_jwk_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_jwk_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_proof_points.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_proof_points.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_public_identifier.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zklogininputs_public_identifier.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_a.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_a.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_b.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_b.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_c.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginproof_c.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_address_seed.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_address_seed.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_padded.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_padded.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_unpadded.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_derive_address_unpadded.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_iss.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginpublicidentifier_iss.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_jwks.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_jwks.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_verify.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_verify.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_with_jwks.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_method_zkloginverifier_with_jwks.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_framework.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_framework.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_std_lib.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_std_lib.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_system.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_system.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_zero.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_address_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_gas.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_gas.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_input.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_input.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_nested_result.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_nested_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_result.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_argument_new_result.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381privatekey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381publickey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381signature_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381verifyingkey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bls12381verifyingkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str_radix_10.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_bn254fieldelement_from_str_radix_10.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_cancelledtransaction_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_cancelledtransaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_changeepoch_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_changeepoch_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv2_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv2_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv3_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_changeepochv3_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointcontents_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointcontents_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointsummary_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointsummary_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointtransactioninfo_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_checkpointtransactioninfo_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_circomg1_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_circomg1_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_circomg2_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_circomg2_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_coin_try_from_object.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_coin_try_from_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_make_move_vector.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_make_move_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_merge_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_merge_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_move_call.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_move_call.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_publish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_publish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_split_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_split_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_transfer_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_transfer_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_upgrade.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_command_new_upgrade.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_consensuscommitprologuev1_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_consensuscommitprologuev1_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_consensusdeterminedversionassignments_new_cancelled_transactions.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_consensusdeterminedversionassignments_new_cancelled_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_base58.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_base58.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_digest_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_digest_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_digest_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic_with_path.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_mnemonic_with_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519privatekey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519publickey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519signature_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ed25519verifyingkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_create.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_create.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_expire.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_authenticator_state_expire.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v2.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v2.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v3.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_endofepochtransactionkind_new_change_epoch_v3.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservation_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservation_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_make_move_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_make_move_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_merge_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_merge_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_move_entry_point.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_move_entry_point.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_publish.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_publish.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_split_coins.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_split_coins.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_transfer_objects.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_transfer_objects.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_upgrade.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservationkey_new_upgrade.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservations_new_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_executiontimeobservations_new_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_devnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_devnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_localnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_localnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_testnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_faucetclient_new_testnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_genesisobject_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_genesisobject_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_genesistransaction_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_genesistransaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_devnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_devnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_localnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_localnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_mainnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_mainnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_testnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_graphqlclient_new_testnet.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_identifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_identifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_immutable_or_owned.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_immutable_or_owned.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_pure.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_pure.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_receiving.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_receiving.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_shared.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_input_new_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_makemovevector_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_makemovevector_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_mergecoins_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_mergecoins_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_address_vec_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_bool_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_from_base58.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_from_base58.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec_from_base58.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_digest_vec_from_base58.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_option.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_option.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_string_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u128_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u16_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u256_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u32_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u64_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movearg_u8_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movecall_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movecall_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackage_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackage_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_json.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_from_json.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_movepackagedata_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregatedsignature_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregatedsignature_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_message.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_message.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigaggregator_new_with_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigcommittee_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigcommittee_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigmember_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigmember_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigverifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_multisigverifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_name_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_name_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_nameregistration_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_nameregistration_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_object_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_object_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectdata_new_move_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_clock.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_clock.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_derive_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_derive_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_system.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_system.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_zero.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objectid_zero.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_package.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_package.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_objecttype_new_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_immutable.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_immutable.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_object.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_object.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_shared.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_owner_new_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_address_vec_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_bool_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_from_base58.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_from_base58.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec_from_base58.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_digest_vec_from_base58.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_gas.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_gas.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_move_arg.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_move_arg.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_id_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_ref.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_object_ref.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_option.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_option.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_receiving_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_res.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_res.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut_from_hex.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_shared_mut_from_hex.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u128_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u16_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u256_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u32_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u64_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8_vec.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_ptbargument_u8_vec.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_passkeypublickey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_passkeypublickey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_passkeyverifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_passkeyverifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_personalmessage_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_personalmessage_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_programmabletransaction_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_programmabletransaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_publish_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_publish_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic_with_path.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_mnemonic_with_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1privatekey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1publickey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1signature_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256k1verifyingkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic_with_path.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_mnemonic_with_path.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1privatekey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1publickey_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_str.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_from_str.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_generate.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1signature_generate.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_secp256r1verifyingkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bech32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bech32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplekeypair_from_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_ed25519.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_ed25519.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256k1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256k1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256r1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simplesignature_new_secp256r1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_der.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_der.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_pem.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_simpleverifyingkey_from_pem.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_splitcoins_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_splitcoins_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_ascii_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_ascii_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_balance.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_clock.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_clock.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_manager.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_manager.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_metadata.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_coin_metadata.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config_setting.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_config_setting.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_address_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_address_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_config_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_config_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_global_pause_key.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_deny_list_global_pause_key.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_display_created.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_display_created.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_dynamic_object_field_wrapper.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_dynamic_object_field_wrapper.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_field.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_field.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_gas_coin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_gas_coin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_id.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_coin_type.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_coin_type.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_admin_cap.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_admin_cap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_state.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_system_state.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_treasury_cap.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_iota_treasury_cap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_name.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_name.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_staked_iota.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_staked_iota.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_string.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_system_epoch_info_event.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_system_epoch_info_event.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_time_lock.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_time_lock.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_timelocked_staked_iota.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_timelocked_staked_iota.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_transfer_receiving.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_transfer_receiving.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_treasury_cap.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_treasury_cap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_uid.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_uid.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_cap.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_cap.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_receipt.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_receipt.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_ticket.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_upgrade_ticket.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_version_updated.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_structtag_new_version_updated.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_systempackage_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_systempackage_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transaction_from_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transaction_from_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transaction_new_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transaction_new_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionbuilder_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactioneffects_new_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactioneffects_new_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionevents_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionevents_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_authenticator_state_update_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_authenticator_state_update_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_consensus_commit_prologue_v1.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_consensus_commit_prologue_v1.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_end_of_epoch.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_end_of_epoch.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_genesis.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_genesis.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_programmable_transaction.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_programmable_transaction.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_randomness_state_update.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionkind_new_randomness_state_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_from_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_from_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transactionv1_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transferobjects_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_transferobjects_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_address.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_bool.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_bool.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_signer.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_signer.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_struct.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_struct.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u128.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u128.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u16.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u16.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u256.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u256.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u32.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u32.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u8.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_u8.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_vector.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_typetag_new_vector.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgrade_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgrade_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_additive.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_additive.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_compatible.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_compatible.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_dep_only.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_upgradepolicy_dep_only.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_base64.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_base64.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_bytes.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_from_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_multisig.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_multisig.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_passkey.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_passkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_simple.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_simple.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_zklogin.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignature_new_zklogin.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignatureverifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_usersignatureverifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatoraggregatedsignature_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatoraggregatedsignature_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureverifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorcommitteesignatureverifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorexecutiontimeobservation_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorexecutiontimeobservation_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorsignature_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_validatorsignature_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_versionassignment_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_versionassignment_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginauthenticator_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginauthenticator_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zklogininputs_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zklogininputs_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginproof_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginproof_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginpublicidentifier_new.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginpublicidentifier_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_dev.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_dev.restype = ctypes.c_uint16
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_mainnet.argtypes = (
)
_UniffiLib.uniffi_iota_sdk_ffi_checksum_constructor_zkloginverifier_new_mainnet.restype = ctypes.c_uint16
_UniffiLib.ffi_iota_sdk_ffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_iota_sdk_ffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i8"
    VALUE_MIN = -2**7
    VALUE_MAX = 2**7

    @staticmethod
    def read(buf):
        return buf.read_i8()

    @staticmethod
    def write(value, buf):
        buf.write_i8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i16"
    VALUE_MIN = -2**15
    VALUE_MAX = 2**15

    @staticmethod
    def read(buf):
        return buf.read_i16()

    @staticmethod
    def write(value, buf):
        buf.write_i16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.read_i64()

    @staticmethod
    def write(value, buf):
        buf.write_i64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)

# The Duration type.
Duration = datetime.timedelta

# There is a loss of precision when converting from Rust durations,
# which are accurate to the nanosecond,
# to Python durations, which are only accurate to the microsecond.
class _UniffiConverterDuration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        seconds = buf.read_u64()
        microseconds = buf.read_u32() / 1.0e3
        return datetime.timedelta(seconds=seconds, microseconds=microseconds)

    @staticmethod
    def check_lower(value):
        seconds = value.seconds + value.days * 24 * 3600
        if seconds < 0:
            raise ValueError("Invalid duration, must be non-negative")

    @staticmethod
    def write(value, buf):
        seconds = value.seconds + value.days * 24 * 3600
        nanoseconds = value.microseconds * 1000
        buf.write_i64(seconds)
        buf.write_u32(nanoseconds)






















































































































































































































class ActiveJwk:
    """
    A new Jwk

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    active-jwk = jwk-id jwk u64
    ```
    """

    jwk_id: "JwkId"
    """
    Identifier used to uniquely identify a Jwk
    """

    jwk: "Jwk"
    """
    The Jwk
    """

    epoch: "int"
    """
    Most recent epoch in which the jwk was validated
    """

    def __init__(self, *, jwk_id: "JwkId", jwk: "Jwk", epoch: "int"):
        self.jwk_id = jwk_id
        self.jwk = jwk
        self.epoch = epoch

    def __str__(self):
        return "ActiveJwk(jwk_id={}, jwk={}, epoch={})".format(self.jwk_id, self.jwk, self.epoch)

    def __eq__(self, other):
        if self.jwk_id != other.jwk_id:
            return False
        if self.jwk != other.jwk:
            return False
        if self.epoch != other.epoch:
            return False
        return True

class _UniffiConverterTypeActiveJwk(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ActiveJwk(
            jwk_id=_UniffiConverterTypeJwkId.read(buf),
            jwk=_UniffiConverterTypeJwk.read(buf),
            epoch=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeJwkId.check_lower(value.jwk_id)
        _UniffiConverterTypeJwk.check_lower(value.jwk)
        _UniffiConverterUInt64.check_lower(value.epoch)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeJwkId.write(value.jwk_id, buf)
        _UniffiConverterTypeJwk.write(value.jwk, buf)
        _UniffiConverterUInt64.write(value.epoch, buf)


class AuthenticatorStateExpire:
    """
    Expire old JWKs

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    authenticator-state-expire = u64 u64
    ```
    """

    min_epoch: "int"
    """
    Expire JWKs that have a lower epoch than this
    """

    authenticator_obj_initial_shared_version: "int"
    """
    The initial version of the authenticator object that it was shared at.
    """

    def __init__(self, *, min_epoch: "int", authenticator_obj_initial_shared_version: "int"):
        self.min_epoch = min_epoch
        self.authenticator_obj_initial_shared_version = authenticator_obj_initial_shared_version

    def __str__(self):
        return "AuthenticatorStateExpire(min_epoch={}, authenticator_obj_initial_shared_version={})".format(self.min_epoch, self.authenticator_obj_initial_shared_version)

    def __eq__(self, other):
        if self.min_epoch != other.min_epoch:
            return False
        if self.authenticator_obj_initial_shared_version != other.authenticator_obj_initial_shared_version:
            return False
        return True

class _UniffiConverterTypeAuthenticatorStateExpire(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AuthenticatorStateExpire(
            min_epoch=_UniffiConverterUInt64.read(buf),
            authenticator_obj_initial_shared_version=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.min_epoch)
        _UniffiConverterUInt64.check_lower(value.authenticator_obj_initial_shared_version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.min_epoch, buf)
        _UniffiConverterUInt64.write(value.authenticator_obj_initial_shared_version, buf)


class AuthenticatorStateUpdateV1:
    """
    Update the set of valid JWKs

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    authenticator-state-update = u64 ; epoch
    u64 ; round
    (vector active-jwk)
    u64 ; initial version of the authenticator object
    ```
    """

    epoch: "int"
    """
    Epoch of the authenticator state update transaction
    """

    round: "int"
    """
    Consensus round of the authenticator state update
    """

    new_active_jwks: "typing.List[ActiveJwk]"
    """
    newly active jwks
    """

    authenticator_obj_initial_shared_version: "int"
    def __init__(self, *, epoch: "int", round: "int", new_active_jwks: "typing.List[ActiveJwk]", authenticator_obj_initial_shared_version: "int"):
        self.epoch = epoch
        self.round = round
        self.new_active_jwks = new_active_jwks
        self.authenticator_obj_initial_shared_version = authenticator_obj_initial_shared_version

    def __str__(self):
        return "AuthenticatorStateUpdateV1(epoch={}, round={}, new_active_jwks={}, authenticator_obj_initial_shared_version={})".format(self.epoch, self.round, self.new_active_jwks, self.authenticator_obj_initial_shared_version)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.round != other.round:
            return False
        if self.new_active_jwks != other.new_active_jwks:
            return False
        if self.authenticator_obj_initial_shared_version != other.authenticator_obj_initial_shared_version:
            return False
        return True

class _UniffiConverterTypeAuthenticatorStateUpdateV1(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AuthenticatorStateUpdateV1(
            epoch=_UniffiConverterUInt64.read(buf),
            round=_UniffiConverterUInt64.read(buf),
            new_active_jwks=_UniffiConverterSequenceTypeActiveJwk.read(buf),
            authenticator_obj_initial_shared_version=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.epoch)
        _UniffiConverterUInt64.check_lower(value.round)
        _UniffiConverterSequenceTypeActiveJwk.check_lower(value.new_active_jwks)
        _UniffiConverterUInt64.check_lower(value.authenticator_obj_initial_shared_version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterUInt64.write(value.round, buf)
        _UniffiConverterSequenceTypeActiveJwk.write(value.new_active_jwks, buf)
        _UniffiConverterUInt64.write(value.authenticator_obj_initial_shared_version, buf)


class BatchSendStatus:
    status: "BatchSendStatusType"
    transferred_gas_objects: "typing.Optional[FaucetReceipt]"
    def __init__(self, *, status: "BatchSendStatusType", transferred_gas_objects: "typing.Optional[FaucetReceipt]"):
        self.status = status
        self.transferred_gas_objects = transferred_gas_objects

    def __str__(self):
        return "BatchSendStatus(status={}, transferred_gas_objects={})".format(self.status, self.transferred_gas_objects)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.transferred_gas_objects != other.transferred_gas_objects:
            return False
        return True

class _UniffiConverterTypeBatchSendStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BatchSendStatus(
            status=_UniffiConverterTypeBatchSendStatusType.read(buf),
            transferred_gas_objects=_UniffiConverterOptionalTypeFaucetReceipt.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeBatchSendStatusType.check_lower(value.status)
        _UniffiConverterOptionalTypeFaucetReceipt.check_lower(value.transferred_gas_objects)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeBatchSendStatusType.write(value.status, buf)
        _UniffiConverterOptionalTypeFaucetReceipt.write(value.transferred_gas_objects, buf)


class ChangedObject:
    """
    Input/output state of an object that was changed during execution

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    changed-object = object-id object-in object-out id-operation
    ```
    """

    object_id: "ObjectId"
    """
    Id of the object
    """

    input_state: "ObjectIn"
    """
    State of the object in the store prior to this transaction.
    """

    output_state: "ObjectOut"
    """
    State of the object in the store after this transaction.
    """

    id_operation: "IdOperation"
    """
    Whether this object ID is created or deleted in this transaction.
    This information isn't required by the protocol but is useful for
    providing more detailed semantics on object changes.
    """

    def __init__(self, *, object_id: "ObjectId", input_state: "ObjectIn", output_state: "ObjectOut", id_operation: "IdOperation"):
        self.object_id = object_id
        self.input_state = input_state
        self.output_state = output_state
        self.id_operation = id_operation

    def __str__(self):
        return "ChangedObject(object_id={}, input_state={}, output_state={}, id_operation={})".format(self.object_id, self.input_state, self.output_state, self.id_operation)

    def __eq__(self, other):
        if self.object_id != other.object_id:
            return False
        if self.input_state != other.input_state:
            return False
        if self.output_state != other.output_state:
            return False
        if self.id_operation != other.id_operation:
            return False
        return True

class _UniffiConverterTypeChangedObject(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ChangedObject(
            object_id=_UniffiConverterTypeObjectId.read(buf),
            input_state=_UniffiConverterTypeObjectIn.read(buf),
            output_state=_UniffiConverterTypeObjectOut.read(buf),
            id_operation=_UniffiConverterTypeIdOperation.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.object_id)
        _UniffiConverterTypeObjectIn.check_lower(value.input_state)
        _UniffiConverterTypeObjectOut.check_lower(value.output_state)
        _UniffiConverterTypeIdOperation.check_lower(value.id_operation)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.object_id, buf)
        _UniffiConverterTypeObjectIn.write(value.input_state, buf)
        _UniffiConverterTypeObjectOut.write(value.output_state, buf)
        _UniffiConverterTypeIdOperation.write(value.id_operation, buf)


class CheckpointSummaryPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[CheckpointSummary]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[CheckpointSummary]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "CheckpointSummaryPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeCheckpointSummaryPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CheckpointSummaryPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeCheckpointSummary.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeCheckpointSummary.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeCheckpointSummary.write(value.data, buf)


class CoinInfo:
    amount: "int"
    id: "ObjectId"
    transfer_tx_digest: "Digest"
    def __init__(self, *, amount: "int", id: "ObjectId", transfer_tx_digest: "Digest"):
        self.amount = amount
        self.id = id
        self.transfer_tx_digest = transfer_tx_digest

    def __str__(self):
        return "CoinInfo(amount={}, id={}, transfer_tx_digest={})".format(self.amount, self.id, self.transfer_tx_digest)

    def __eq__(self, other):
        if self.amount != other.amount:
            return False
        if self.id != other.id:
            return False
        if self.transfer_tx_digest != other.transfer_tx_digest:
            return False
        return True

class _UniffiConverterTypeCoinInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CoinInfo(
            amount=_UniffiConverterUInt64.read(buf),
            id=_UniffiConverterTypeObjectId.read(buf),
            transfer_tx_digest=_UniffiConverterTypeDigest.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.amount)
        _UniffiConverterTypeObjectId.check_lower(value.id)
        _UniffiConverterTypeDigest.check_lower(value.transfer_tx_digest)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.amount, buf)
        _UniffiConverterTypeObjectId.write(value.id, buf)
        _UniffiConverterTypeDigest.write(value.transfer_tx_digest, buf)


class CoinMetadata:
    """
    The coin metadata associated with the given coin type.
    """

    address: "ObjectId"
    """
    The CoinMetadata object ID.
    """

    decimals: "typing.Optional[int]"
    """
    The number of decimal places used to represent the token.
    """

    description: "typing.Optional[str]"
    """
    Optional description of the token, provided by the creator of the token.
    """

    icon_url: "typing.Optional[str]"
    """
    Icon URL of the coin.
    """

    name: "typing.Optional[str]"
    """
    Full, official name of the token.
    """

    symbol: "typing.Optional[str]"
    """
    The token's identifying abbreviation.
    """

    supply: "typing.Optional[BigInt]"
    """
    The overall quantity of tokens that will be issued.
    """

    version: "int"
    """
    Version of the token.
    """

    def __init__(self, *, address: "ObjectId", decimals: "typing.Optional[int]" = _DEFAULT, description: "typing.Optional[str]" = _DEFAULT, icon_url: "typing.Optional[str]" = _DEFAULT, name: "typing.Optional[str]" = _DEFAULT, symbol: "typing.Optional[str]" = _DEFAULT, supply: "typing.Optional[BigInt]" = _DEFAULT, version: "int"):
        self.address = address
        if decimals is _DEFAULT:
            self.decimals = None
        else:
            self.decimals = decimals
        if description is _DEFAULT:
            self.description = None
        else:
            self.description = description
        if icon_url is _DEFAULT:
            self.icon_url = None
        else:
            self.icon_url = icon_url
        if name is _DEFAULT:
            self.name = None
        else:
            self.name = name
        if symbol is _DEFAULT:
            self.symbol = None
        else:
            self.symbol = symbol
        if supply is _DEFAULT:
            self.supply = None
        else:
            self.supply = supply
        self.version = version

    def __str__(self):
        return "CoinMetadata(address={}, decimals={}, description={}, icon_url={}, name={}, symbol={}, supply={}, version={})".format(self.address, self.decimals, self.description, self.icon_url, self.name, self.symbol, self.supply, self.version)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.decimals != other.decimals:
            return False
        if self.description != other.description:
            return False
        if self.icon_url != other.icon_url:
            return False
        if self.name != other.name:
            return False
        if self.symbol != other.symbol:
            return False
        if self.supply != other.supply:
            return False
        if self.version != other.version:
            return False
        return True

class _UniffiConverterTypeCoinMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CoinMetadata(
            address=_UniffiConverterTypeObjectId.read(buf),
            decimals=_UniffiConverterOptionalInt32.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            icon_url=_UniffiConverterOptionalString.read(buf),
            name=_UniffiConverterOptionalString.read(buf),
            symbol=_UniffiConverterOptionalString.read(buf),
            supply=_UniffiConverterOptionalTypeBigInt.read(buf),
            version=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.address)
        _UniffiConverterOptionalInt32.check_lower(value.decimals)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalString.check_lower(value.icon_url)
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.symbol)
        _UniffiConverterOptionalTypeBigInt.check_lower(value.supply)
        _UniffiConverterUInt64.check_lower(value.version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.address, buf)
        _UniffiConverterOptionalInt32.write(value.decimals, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalString.write(value.icon_url, buf)
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.symbol, buf)
        _UniffiConverterOptionalTypeBigInt.write(value.supply, buf)
        _UniffiConverterUInt64.write(value.version, buf)


class CoinPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[Coin]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[Coin]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "CoinPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeCoinPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CoinPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeCoin.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeCoin.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeCoin.write(value.data, buf)


class DryRunEffect:
    """
    Effects of a single command in the dry run, including mutated references
    and return values.
    """

    mutated_references: "typing.List[DryRunMutation]"
    """
    Changes made to arguments that were mutably borrowed by this command.
    """

    return_values: "typing.List[DryRunReturn]"
    """
    Return results of this command.
    """

    def __init__(self, *, mutated_references: "typing.List[DryRunMutation]", return_values: "typing.List[DryRunReturn]"):
        self.mutated_references = mutated_references
        self.return_values = return_values

    def __str__(self):
        return "DryRunEffect(mutated_references={}, return_values={})".format(self.mutated_references, self.return_values)

    def __eq__(self, other):
        if self.mutated_references != other.mutated_references:
            return False
        if self.return_values != other.return_values:
            return False
        return True

class _UniffiConverterTypeDryRunEffect(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryRunEffect(
            mutated_references=_UniffiConverterSequenceTypeDryRunMutation.read(buf),
            return_values=_UniffiConverterSequenceTypeDryRunReturn.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeDryRunMutation.check_lower(value.mutated_references)
        _UniffiConverterSequenceTypeDryRunReturn.check_lower(value.return_values)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeDryRunMutation.write(value.mutated_references, buf)
        _UniffiConverterSequenceTypeDryRunReturn.write(value.return_values, buf)


class DryRunMutation:
    """
    A mutation to an argument that was mutably borrowed by a command.
    """

    input: "TransactionArgument"
    """
    The transaction argument that was mutated.
    """

    type_tag: "TypeTag"
    """
    The Move type of the mutated value.
    """

    bcs: "bytes"
    """
    The BCS representation of the mutated value.
    """

    def __init__(self, *, input: "TransactionArgument", type_tag: "TypeTag", bcs: "bytes"):
        self.input = input
        self.type_tag = type_tag
        self.bcs = bcs

    def __str__(self):
        return "DryRunMutation(input={}, type_tag={}, bcs={})".format(self.input, self.type_tag, self.bcs)

    def __eq__(self, other):
        if self.input != other.input:
            return False
        if self.type_tag != other.type_tag:
            return False
        if self.bcs != other.bcs:
            return False
        return True

class _UniffiConverterTypeDryRunMutation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryRunMutation(
            input=_UniffiConverterTypeTransactionArgument.read(buf),
            type_tag=_UniffiConverterTypeTypeTag.read(buf),
            bcs=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTransactionArgument.check_lower(value.input)
        _UniffiConverterTypeTypeTag.check_lower(value.type_tag)
        _UniffiConverterBytes.check_lower(value.bcs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTransactionArgument.write(value.input, buf)
        _UniffiConverterTypeTypeTag.write(value.type_tag, buf)
        _UniffiConverterBytes.write(value.bcs, buf)


class DryRunResult:
    """
    The result of a simulation (dry run), which includes the effects of the
    transaction, any errors that may have occurred, and intermediate results for
    each command.
    """

    error: "typing.Optional[str]"
    """
    The error that occurred during dry run execution, if any.
    """

    results: "typing.List[DryRunEffect]"
    """
    The intermediate results for each command of the dry run execution,
    including contents of mutated references and return values.
    """

    transaction: "typing.Optional[SignedTransaction]"
    """
    The transaction block representing the dry run execution.
    """

    effects: "typing.Optional[TransactionEffects]"
    """
    The effects of the transaction execution.
    """

    def __init__(self, *, error: "typing.Optional[str]", results: "typing.List[DryRunEffect]", transaction: "typing.Optional[SignedTransaction]", effects: "typing.Optional[TransactionEffects]"):
        self.error = error
        self.results = results
        self.transaction = transaction
        self.effects = effects

    def __str__(self):
        return "DryRunResult(error={}, results={}, transaction={}, effects={})".format(self.error, self.results, self.transaction, self.effects)

    def __eq__(self, other):
        if self.error != other.error:
            return False
        if self.results != other.results:
            return False
        if self.transaction != other.transaction:
            return False
        if self.effects != other.effects:
            return False
        return True

class _UniffiConverterTypeDryRunResult(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryRunResult(
            error=_UniffiConverterOptionalString.read(buf),
            results=_UniffiConverterSequenceTypeDryRunEffect.read(buf),
            transaction=_UniffiConverterOptionalTypeSignedTransaction.read(buf),
            effects=_UniffiConverterOptionalTypeTransactionEffects.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.error)
        _UniffiConverterSequenceTypeDryRunEffect.check_lower(value.results)
        _UniffiConverterOptionalTypeSignedTransaction.check_lower(value.transaction)
        _UniffiConverterOptionalTypeTransactionEffects.check_lower(value.effects)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.error, buf)
        _UniffiConverterSequenceTypeDryRunEffect.write(value.results, buf)
        _UniffiConverterOptionalTypeSignedTransaction.write(value.transaction, buf)
        _UniffiConverterOptionalTypeTransactionEffects.write(value.effects, buf)


class DryRunReturn:
    """
    A return value from a command in the dry run.
    """

    type_tag: "TypeTag"
    """
    The Move type of the return value.
    """

    bcs: "bytes"
    """
    The BCS representation of the return value.
    """

    def __init__(self, *, type_tag: "TypeTag", bcs: "bytes"):
        self.type_tag = type_tag
        self.bcs = bcs

    def __str__(self):
        return "DryRunReturn(type_tag={}, bcs={})".format(self.type_tag, self.bcs)

    def __eq__(self, other):
        if self.type_tag != other.type_tag:
            return False
        if self.bcs != other.bcs:
            return False
        return True

class _UniffiConverterTypeDryRunReturn(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DryRunReturn(
            type_tag=_UniffiConverterTypeTypeTag.read(buf),
            bcs=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTypeTag.check_lower(value.type_tag)
        _UniffiConverterBytes.check_lower(value.bcs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTypeTag.write(value.type_tag, buf)
        _UniffiConverterBytes.write(value.bcs, buf)


class DynamicFieldName:
    """
    The name part of a dynamic field, including its type, bcs, and json
    representation.
    """

    type_tag: "TypeTag"
    """
    The type name of this dynamic field name
    """

    bcs: "bytes"
    """
    The bcs bytes of this dynamic field name
    """

    json: "typing.Optional[Value]"
    """
    The json representation of the dynamic field name
    """

    def __init__(self, *, type_tag: "TypeTag", bcs: "bytes", json: "typing.Optional[Value]" = _DEFAULT):
        self.type_tag = type_tag
        self.bcs = bcs
        if json is _DEFAULT:
            self.json = None
        else:
            self.json = json

    def __str__(self):
        return "DynamicFieldName(type_tag={}, bcs={}, json={})".format(self.type_tag, self.bcs, self.json)

    def __eq__(self, other):
        if self.type_tag != other.type_tag:
            return False
        if self.bcs != other.bcs:
            return False
        if self.json != other.json:
            return False
        return True

class _UniffiConverterTypeDynamicFieldName(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DynamicFieldName(
            type_tag=_UniffiConverterTypeTypeTag.read(buf),
            bcs=_UniffiConverterBytes.read(buf),
            json=_UniffiConverterOptionalTypeValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTypeTag.check_lower(value.type_tag)
        _UniffiConverterBytes.check_lower(value.bcs)
        _UniffiConverterOptionalTypeValue.check_lower(value.json)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTypeTag.write(value.type_tag, buf)
        _UniffiConverterBytes.write(value.bcs, buf)
        _UniffiConverterOptionalTypeValue.write(value.json, buf)


class DynamicFieldOutput:
    """
    The output of a dynamic field query, that includes the name, value, and
    value's json representation.
    """

    name: "DynamicFieldName"
    """
    The name of the dynamic field
    """

    value: "typing.Optional[DynamicFieldValue]"
    """
    The dynamic field value typename and bcs
    """

    value_as_json: "typing.Optional[Value]"
    """
    The json representation of the dynamic field value object
    """

    def __init__(self, *, name: "DynamicFieldName", value: "typing.Optional[DynamicFieldValue]" = _DEFAULT, value_as_json: "typing.Optional[Value]" = _DEFAULT):
        self.name = name
        if value is _DEFAULT:
            self.value = None
        else:
            self.value = value
        if value_as_json is _DEFAULT:
            self.value_as_json = None
        else:
            self.value_as_json = value_as_json

    def __str__(self):
        return "DynamicFieldOutput(name={}, value={}, value_as_json={})".format(self.name, self.value, self.value_as_json)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.value != other.value:
            return False
        if self.value_as_json != other.value_as_json:
            return False
        return True

class _UniffiConverterTypeDynamicFieldOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DynamicFieldOutput(
            name=_UniffiConverterTypeDynamicFieldName.read(buf),
            value=_UniffiConverterOptionalTypeDynamicFieldValue.read(buf),
            value_as_json=_UniffiConverterOptionalTypeValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeDynamicFieldName.check_lower(value.name)
        _UniffiConverterOptionalTypeDynamicFieldValue.check_lower(value.value)
        _UniffiConverterOptionalTypeValue.check_lower(value.value_as_json)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDynamicFieldName.write(value.name, buf)
        _UniffiConverterOptionalTypeDynamicFieldValue.write(value.value, buf)
        _UniffiConverterOptionalTypeValue.write(value.value_as_json, buf)


class DynamicFieldOutputPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[DynamicFieldOutput]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[DynamicFieldOutput]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "DynamicFieldOutputPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeDynamicFieldOutputPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DynamicFieldOutputPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeDynamicFieldOutput.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeDynamicFieldOutput.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeDynamicFieldOutput.write(value.data, buf)


class DynamicFieldValue:
    """
    The value part of a dynamic field.
    """

    type_tag: "TypeTag"
    bcs: "bytes"
    def __init__(self, *, type_tag: "TypeTag", bcs: "bytes"):
        self.type_tag = type_tag
        self.bcs = bcs

    def __str__(self):
        return "DynamicFieldValue(type_tag={}, bcs={})".format(self.type_tag, self.bcs)

    def __eq__(self, other):
        if self.type_tag != other.type_tag:
            return False
        if self.bcs != other.bcs:
            return False
        return True

class _UniffiConverterTypeDynamicFieldValue(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return DynamicFieldValue(
            type_tag=_UniffiConverterTypeTypeTag.read(buf),
            bcs=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTypeTag.check_lower(value.type_tag)
        _UniffiConverterBytes.check_lower(value.bcs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTypeTag.write(value.type_tag, buf)
        _UniffiConverterBytes.write(value.bcs, buf)


class EndOfEpochData:
    """
    Data which, when included in a [`CheckpointSummary`], signals the end of an
    `Epoch`.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    end-of-epoch-data = (vector validator-committee-member) ; next_epoch_committee
    u64                                 ; next_epoch_protocol_version
    (vector checkpoint-commitment)      ; epoch_commitments
    ```
    """

    next_epoch_committee: "typing.List[ValidatorCommitteeMember]"
    next_epoch_protocol_version: "int"
    epoch_commitments: "typing.List[CheckpointCommitment]"
    epoch_supply_change: "int"
    def __init__(self, *, next_epoch_committee: "typing.List[ValidatorCommitteeMember]", next_epoch_protocol_version: "int", epoch_commitments: "typing.List[CheckpointCommitment]", epoch_supply_change: "int"):
        self.next_epoch_committee = next_epoch_committee
        self.next_epoch_protocol_version = next_epoch_protocol_version
        self.epoch_commitments = epoch_commitments
        self.epoch_supply_change = epoch_supply_change

    def __str__(self):
        return "EndOfEpochData(next_epoch_committee={}, next_epoch_protocol_version={}, epoch_commitments={}, epoch_supply_change={})".format(self.next_epoch_committee, self.next_epoch_protocol_version, self.epoch_commitments, self.epoch_supply_change)

    def __eq__(self, other):
        if self.next_epoch_committee != other.next_epoch_committee:
            return False
        if self.next_epoch_protocol_version != other.next_epoch_protocol_version:
            return False
        if self.epoch_commitments != other.epoch_commitments:
            return False
        if self.epoch_supply_change != other.epoch_supply_change:
            return False
        return True

class _UniffiConverterTypeEndOfEpochData(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EndOfEpochData(
            next_epoch_committee=_UniffiConverterSequenceTypeValidatorCommitteeMember.read(buf),
            next_epoch_protocol_version=_UniffiConverterUInt64.read(buf),
            epoch_commitments=_UniffiConverterSequenceTypeCheckpointCommitment.read(buf),
            epoch_supply_change=_UniffiConverterInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeValidatorCommitteeMember.check_lower(value.next_epoch_committee)
        _UniffiConverterUInt64.check_lower(value.next_epoch_protocol_version)
        _UniffiConverterSequenceTypeCheckpointCommitment.check_lower(value.epoch_commitments)
        _UniffiConverterInt64.check_lower(value.epoch_supply_change)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeValidatorCommitteeMember.write(value.next_epoch_committee, buf)
        _UniffiConverterUInt64.write(value.next_epoch_protocol_version, buf)
        _UniffiConverterSequenceTypeCheckpointCommitment.write(value.epoch_commitments, buf)
        _UniffiConverterInt64.write(value.epoch_supply_change, buf)


class Epoch:
    epoch_id: "int"
    """
    The epoch's id as a sequence number that starts at 0 and is incremented
    by one at every epoch change.
    """

    fund_inflow: "typing.Optional[str]"
    """
    The storage fees paid for transactions executed during the epoch.
    """

    fund_outflow: "typing.Optional[str]"
    """
    The storage fee rebates paid to users who deleted the data associated
    with past transactions.
    """

    fund_size: "typing.Optional[str]"
    """
    The storage fund available in this epoch.
    This fund is used to redistribute storage fees from past transactions
    to future validators.
    """

    live_object_set_digest: "typing.Optional[str]"
    """
    A commitment by the committee at the end of epoch on the contents of the
    live object set at that time. This can be used to verify state
    snapshots.
    """

    net_inflow: "typing.Optional[str]"
    """
    The difference between the fund inflow and outflow, representing
    the net amount of storage fees accumulated in this epoch.
    """

    protocol_configs: "typing.Optional[ProtocolConfigs]"
    """
    The epoch's corresponding protocol configuration, including the feature
    flags and the configuration options.
    """

    reference_gas_price: "typing.Optional[str]"
    """
    The minimum gas price that a quorum of validators are guaranteed to sign
    a transaction for.
    """

    start_timestamp: "int"
    """
    The epoch's starting timestamp.
    """

    end_timestamp: "typing.Optional[int]"
    """
    The epoch's ending timestamp. Note that this is available only on epochs
    that have ended.
    """

    system_state_version: "typing.Optional[int]"
    """
    The value of the `version` field of `0x5`, the
    `0x3::iota::IotaSystemState` object.  This version changes whenever
    the fields contained in the system state object (held in a dynamic
    field attached to `0x5`) change.
    """

    total_checkpoints: "typing.Optional[int]"
    """
    The total number of checkpoints in this epoch.
    """

    total_gas_fees: "typing.Optional[str]"
    """
    The total amount of gas fees (in IOTA) that were paid in this epoch.
    """

    total_stake_rewards: "typing.Optional[str]"
    """
    The total IOTA rewarded as stake.
    """

    total_transactions: "typing.Optional[int]"
    """
    The total number of transaction in this epoch.
    """

    validator_set: "typing.Optional[ValidatorSet]"
    """
    Validator related properties. For active validators, see
    `active_validators` API.
    For epochs other than the current the data provided refer to the start
    of the epoch.
    """

    def __init__(self, *, epoch_id: "int", fund_inflow: "typing.Optional[str]" = _DEFAULT, fund_outflow: "typing.Optional[str]" = _DEFAULT, fund_size: "typing.Optional[str]" = _DEFAULT, live_object_set_digest: "typing.Optional[str]" = _DEFAULT, net_inflow: "typing.Optional[str]" = _DEFAULT, protocol_configs: "typing.Optional[ProtocolConfigs]" = _DEFAULT, reference_gas_price: "typing.Optional[str]" = _DEFAULT, start_timestamp: "int", end_timestamp: "typing.Optional[int]" = _DEFAULT, system_state_version: "typing.Optional[int]" = _DEFAULT, total_checkpoints: "typing.Optional[int]" = _DEFAULT, total_gas_fees: "typing.Optional[str]" = _DEFAULT, total_stake_rewards: "typing.Optional[str]" = _DEFAULT, total_transactions: "typing.Optional[int]" = _DEFAULT, validator_set: "typing.Optional[ValidatorSet]" = _DEFAULT):
        self.epoch_id = epoch_id
        if fund_inflow is _DEFAULT:
            self.fund_inflow = None
        else:
            self.fund_inflow = fund_inflow
        if fund_outflow is _DEFAULT:
            self.fund_outflow = None
        else:
            self.fund_outflow = fund_outflow
        if fund_size is _DEFAULT:
            self.fund_size = None
        else:
            self.fund_size = fund_size
        if live_object_set_digest is _DEFAULT:
            self.live_object_set_digest = None
        else:
            self.live_object_set_digest = live_object_set_digest
        if net_inflow is _DEFAULT:
            self.net_inflow = None
        else:
            self.net_inflow = net_inflow
        if protocol_configs is _DEFAULT:
            self.protocol_configs = None
        else:
            self.protocol_configs = protocol_configs
        if reference_gas_price is _DEFAULT:
            self.reference_gas_price = None
        else:
            self.reference_gas_price = reference_gas_price
        self.start_timestamp = start_timestamp
        if end_timestamp is _DEFAULT:
            self.end_timestamp = None
        else:
            self.end_timestamp = end_timestamp
        if system_state_version is _DEFAULT:
            self.system_state_version = None
        else:
            self.system_state_version = system_state_version
        if total_checkpoints is _DEFAULT:
            self.total_checkpoints = None
        else:
            self.total_checkpoints = total_checkpoints
        if total_gas_fees is _DEFAULT:
            self.total_gas_fees = None
        else:
            self.total_gas_fees = total_gas_fees
        if total_stake_rewards is _DEFAULT:
            self.total_stake_rewards = None
        else:
            self.total_stake_rewards = total_stake_rewards
        if total_transactions is _DEFAULT:
            self.total_transactions = None
        else:
            self.total_transactions = total_transactions
        if validator_set is _DEFAULT:
            self.validator_set = None
        else:
            self.validator_set = validator_set

    def __str__(self):
        return "Epoch(epoch_id={}, fund_inflow={}, fund_outflow={}, fund_size={}, live_object_set_digest={}, net_inflow={}, protocol_configs={}, reference_gas_price={}, start_timestamp={}, end_timestamp={}, system_state_version={}, total_checkpoints={}, total_gas_fees={}, total_stake_rewards={}, total_transactions={}, validator_set={})".format(self.epoch_id, self.fund_inflow, self.fund_outflow, self.fund_size, self.live_object_set_digest, self.net_inflow, self.protocol_configs, self.reference_gas_price, self.start_timestamp, self.end_timestamp, self.system_state_version, self.total_checkpoints, self.total_gas_fees, self.total_stake_rewards, self.total_transactions, self.validator_set)

    def __eq__(self, other):
        if self.epoch_id != other.epoch_id:
            return False
        if self.fund_inflow != other.fund_inflow:
            return False
        if self.fund_outflow != other.fund_outflow:
            return False
        if self.fund_size != other.fund_size:
            return False
        if self.live_object_set_digest != other.live_object_set_digest:
            return False
        if self.net_inflow != other.net_inflow:
            return False
        if self.protocol_configs != other.protocol_configs:
            return False
        if self.reference_gas_price != other.reference_gas_price:
            return False
        if self.start_timestamp != other.start_timestamp:
            return False
        if self.end_timestamp != other.end_timestamp:
            return False
        if self.system_state_version != other.system_state_version:
            return False
        if self.total_checkpoints != other.total_checkpoints:
            return False
        if self.total_gas_fees != other.total_gas_fees:
            return False
        if self.total_stake_rewards != other.total_stake_rewards:
            return False
        if self.total_transactions != other.total_transactions:
            return False
        if self.validator_set != other.validator_set:
            return False
        return True

class _UniffiConverterTypeEpoch(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Epoch(
            epoch_id=_UniffiConverterUInt64.read(buf),
            fund_inflow=_UniffiConverterOptionalString.read(buf),
            fund_outflow=_UniffiConverterOptionalString.read(buf),
            fund_size=_UniffiConverterOptionalString.read(buf),
            live_object_set_digest=_UniffiConverterOptionalString.read(buf),
            net_inflow=_UniffiConverterOptionalString.read(buf),
            protocol_configs=_UniffiConverterOptionalTypeProtocolConfigs.read(buf),
            reference_gas_price=_UniffiConverterOptionalString.read(buf),
            start_timestamp=_UniffiConverterUInt64.read(buf),
            end_timestamp=_UniffiConverterOptionalUInt64.read(buf),
            system_state_version=_UniffiConverterOptionalUInt64.read(buf),
            total_checkpoints=_UniffiConverterOptionalUInt64.read(buf),
            total_gas_fees=_UniffiConverterOptionalString.read(buf),
            total_stake_rewards=_UniffiConverterOptionalString.read(buf),
            total_transactions=_UniffiConverterOptionalUInt64.read(buf),
            validator_set=_UniffiConverterOptionalTypeValidatorSet.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.epoch_id)
        _UniffiConverterOptionalString.check_lower(value.fund_inflow)
        _UniffiConverterOptionalString.check_lower(value.fund_outflow)
        _UniffiConverterOptionalString.check_lower(value.fund_size)
        _UniffiConverterOptionalString.check_lower(value.live_object_set_digest)
        _UniffiConverterOptionalString.check_lower(value.net_inflow)
        _UniffiConverterOptionalTypeProtocolConfigs.check_lower(value.protocol_configs)
        _UniffiConverterOptionalString.check_lower(value.reference_gas_price)
        _UniffiConverterUInt64.check_lower(value.start_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.end_timestamp)
        _UniffiConverterOptionalUInt64.check_lower(value.system_state_version)
        _UniffiConverterOptionalUInt64.check_lower(value.total_checkpoints)
        _UniffiConverterOptionalString.check_lower(value.total_gas_fees)
        _UniffiConverterOptionalString.check_lower(value.total_stake_rewards)
        _UniffiConverterOptionalUInt64.check_lower(value.total_transactions)
        _UniffiConverterOptionalTypeValidatorSet.check_lower(value.validator_set)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch_id, buf)
        _UniffiConverterOptionalString.write(value.fund_inflow, buf)
        _UniffiConverterOptionalString.write(value.fund_outflow, buf)
        _UniffiConverterOptionalString.write(value.fund_size, buf)
        _UniffiConverterOptionalString.write(value.live_object_set_digest, buf)
        _UniffiConverterOptionalString.write(value.net_inflow, buf)
        _UniffiConverterOptionalTypeProtocolConfigs.write(value.protocol_configs, buf)
        _UniffiConverterOptionalString.write(value.reference_gas_price, buf)
        _UniffiConverterUInt64.write(value.start_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.end_timestamp, buf)
        _UniffiConverterOptionalUInt64.write(value.system_state_version, buf)
        _UniffiConverterOptionalUInt64.write(value.total_checkpoints, buf)
        _UniffiConverterOptionalString.write(value.total_gas_fees, buf)
        _UniffiConverterOptionalString.write(value.total_stake_rewards, buf)
        _UniffiConverterOptionalUInt64.write(value.total_transactions, buf)
        _UniffiConverterOptionalTypeValidatorSet.write(value.validator_set, buf)


class EpochPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[Epoch]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[Epoch]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "EpochPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeEpochPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EpochPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeEpoch.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeEpoch.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeEpoch.write(value.data, buf)


class Event:
    """
    An event

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    event = object-id identifier address struct-tag bytes
    ```
    """

    package_id: "ObjectId"
    """
    Package id of the top-level function invoked by a MoveCall command which
    triggered this event to be emitted.
    """

    module: "str"
    """
    Module name of the top-level function invoked by a MoveCall command
    which triggered this event to be emitted.
    """

    sender: "Address"
    """
    Address of the account that sent the transaction where this event was
    emitted.
    """

    type: "str"
    """
    The type of the event emitted
    """

    contents: "bytes"
    """
    BCS serialized bytes of the event
    """

    timestamp: "str"
    """
    UTC timestamp in milliseconds since epoch (1/1/1970)
    """

    data: "str"
    """
    Structured contents of a Move value
    """

    json: "str"
    """
    Representation of a Move value in JSON
    """

    def __init__(self, *, package_id: "ObjectId", module: "str", sender: "Address", type: "str", contents: "bytes", timestamp: "str", data: "str", json: "str"):
        self.package_id = package_id
        self.module = module
        self.sender = sender
        self.type = type
        self.contents = contents
        self.timestamp = timestamp
        self.data = data
        self.json = json

    def __str__(self):
        return "Event(package_id={}, module={}, sender={}, type={}, contents={}, timestamp={}, data={}, json={})".format(self.package_id, self.module, self.sender, self.type, self.contents, self.timestamp, self.data, self.json)

    def __eq__(self, other):
        if self.package_id != other.package_id:
            return False
        if self.module != other.module:
            return False
        if self.sender != other.sender:
            return False
        if self.type != other.type:
            return False
        if self.contents != other.contents:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.data != other.data:
            return False
        if self.json != other.json:
            return False
        return True

class _UniffiConverterTypeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Event(
            package_id=_UniffiConverterTypeObjectId.read(buf),
            module=_UniffiConverterString.read(buf),
            sender=_UniffiConverterTypeAddress.read(buf),
            type=_UniffiConverterString.read(buf),
            contents=_UniffiConverterBytes.read(buf),
            timestamp=_UniffiConverterString.read(buf),
            data=_UniffiConverterString.read(buf),
            json=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.package_id)
        _UniffiConverterString.check_lower(value.module)
        _UniffiConverterTypeAddress.check_lower(value.sender)
        _UniffiConverterString.check_lower(value.type)
        _UniffiConverterBytes.check_lower(value.contents)
        _UniffiConverterString.check_lower(value.timestamp)
        _UniffiConverterString.check_lower(value.data)
        _UniffiConverterString.check_lower(value.json)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.package_id, buf)
        _UniffiConverterString.write(value.module, buf)
        _UniffiConverterTypeAddress.write(value.sender, buf)
        _UniffiConverterString.write(value.type, buf)
        _UniffiConverterBytes.write(value.contents, buf)
        _UniffiConverterString.write(value.timestamp, buf)
        _UniffiConverterString.write(value.data, buf)
        _UniffiConverterString.write(value.json, buf)


class EventFilter:
    emitting_module: "typing.Optional[str]"
    event_type: "typing.Optional[str]"
    sender: "typing.Optional[Address]"
    transaction_digest: "typing.Optional[str]"
    def __init__(self, *, emitting_module: "typing.Optional[str]" = _DEFAULT, event_type: "typing.Optional[str]" = _DEFAULT, sender: "typing.Optional[Address]" = _DEFAULT, transaction_digest: "typing.Optional[str]" = _DEFAULT):
        if emitting_module is _DEFAULT:
            self.emitting_module = None
        else:
            self.emitting_module = emitting_module
        if event_type is _DEFAULT:
            self.event_type = None
        else:
            self.event_type = event_type
        if sender is _DEFAULT:
            self.sender = None
        else:
            self.sender = sender
        if transaction_digest is _DEFAULT:
            self.transaction_digest = None
        else:
            self.transaction_digest = transaction_digest

    def __str__(self):
        return "EventFilter(emitting_module={}, event_type={}, sender={}, transaction_digest={})".format(self.emitting_module, self.event_type, self.sender, self.transaction_digest)

    def __eq__(self, other):
        if self.emitting_module != other.emitting_module:
            return False
        if self.event_type != other.event_type:
            return False
        if self.sender != other.sender:
            return False
        if self.transaction_digest != other.transaction_digest:
            return False
        return True

class _UniffiConverterTypeEventFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EventFilter(
            emitting_module=_UniffiConverterOptionalString.read(buf),
            event_type=_UniffiConverterOptionalString.read(buf),
            sender=_UniffiConverterOptionalTypeAddress.read(buf),
            transaction_digest=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.emitting_module)
        _UniffiConverterOptionalString.check_lower(value.event_type)
        _UniffiConverterOptionalTypeAddress.check_lower(value.sender)
        _UniffiConverterOptionalString.check_lower(value.transaction_digest)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.emitting_module, buf)
        _UniffiConverterOptionalString.write(value.event_type, buf)
        _UniffiConverterOptionalTypeAddress.write(value.sender, buf)
        _UniffiConverterOptionalString.write(value.transaction_digest, buf)


class EventPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[Event]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[Event]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "EventPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeEventPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return EventPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeEvent.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeEvent.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeEvent.write(value.data, buf)


class FaucetReceipt:
    sent: "typing.List[CoinInfo]"
    def __init__(self, *, sent: "typing.List[CoinInfo]"):
        self.sent = sent

    def __str__(self):
        return "FaucetReceipt(sent={})".format(self.sent)

    def __eq__(self, other):
        if self.sent != other.sent:
            return False
        return True

class _UniffiConverterTypeFaucetReceipt(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FaucetReceipt(
            sent=_UniffiConverterSequenceTypeCoinInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeCoinInfo.check_lower(value.sent)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeCoinInfo.write(value.sent, buf)


class GasCostSummary:
    """
    Summary of gas charges.

    Storage is charged independently of computation.
    There are 3 parts to the storage charges:
    `storage_cost`: it is the charge of storage at the time the transaction is
    executed.                 The cost of storage is the number of bytes of the
    objects being mutated                 multiplied by a variable storage cost
    per byte `storage_rebate`: this is the amount a user gets back when
    manipulating an object.                   The `storage_rebate` is the
    `storage_cost` for an object minus fees. `non_refundable_storage_fee`: not
    all the value of the object storage cost is
    given back to user and there is a small fraction that
    is kept by the system. This value tracks that charge.

    When looking at a gas cost summary the amount charged to the user is
    `computation_cost + storage_cost - storage_rebate`
    and that is the amount that is deducted from the gas coins.
    `non_refundable_storage_fee` is collected from the objects being
    mutated/deleted and it is tracked by the system in storage funds.

    Objects deleted, including the older versions of objects mutated, have the
    storage field on the objects added up to a pool of "potential rebate". This
    rebate then is reduced by the "nonrefundable rate" such that:
    `potential_rebate(storage cost of deleted/mutated objects) =
    storage_rebate + non_refundable_storage_fee`

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    gas-cost-summary = u64 ; computation-cost
    u64 ; storage-cost
    u64 ; storage-rebate
    u64 ; non-refundable-storage-fee
    ```
    """

    computation_cost: "int"
    """
    Cost of computation/execution
    """

    computation_cost_burned: "int"
    """
    The burned component of the computation/execution costs
    """

    storage_cost: "int"
    """
    Storage cost, it's the sum of all storage cost for all objects created
    or mutated.
    """

    storage_rebate: "int"
    """
    The amount of storage cost refunded to the user for all objects deleted
    or mutated in the transaction.
    """

    non_refundable_storage_fee: "int"
    """
    The fee for the rebate. The portion of the storage rebate kept by the
    system.
    """

    def __init__(self, *, computation_cost: "int", computation_cost_burned: "int", storage_cost: "int", storage_rebate: "int", non_refundable_storage_fee: "int"):
        self.computation_cost = computation_cost
        self.computation_cost_burned = computation_cost_burned
        self.storage_cost = storage_cost
        self.storage_rebate = storage_rebate
        self.non_refundable_storage_fee = non_refundable_storage_fee

    def __str__(self):
        return "GasCostSummary(computation_cost={}, computation_cost_burned={}, storage_cost={}, storage_rebate={}, non_refundable_storage_fee={})".format(self.computation_cost, self.computation_cost_burned, self.storage_cost, self.storage_rebate, self.non_refundable_storage_fee)

    def __eq__(self, other):
        if self.computation_cost != other.computation_cost:
            return False
        if self.computation_cost_burned != other.computation_cost_burned:
            return False
        if self.storage_cost != other.storage_cost:
            return False
        if self.storage_rebate != other.storage_rebate:
            return False
        if self.non_refundable_storage_fee != other.non_refundable_storage_fee:
            return False
        return True

class _UniffiConverterTypeGasCostSummary(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GasCostSummary(
            computation_cost=_UniffiConverterUInt64.read(buf),
            computation_cost_burned=_UniffiConverterUInt64.read(buf),
            storage_cost=_UniffiConverterUInt64.read(buf),
            storage_rebate=_UniffiConverterUInt64.read(buf),
            non_refundable_storage_fee=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.computation_cost)
        _UniffiConverterUInt64.check_lower(value.computation_cost_burned)
        _UniffiConverterUInt64.check_lower(value.storage_cost)
        _UniffiConverterUInt64.check_lower(value.storage_rebate)
        _UniffiConverterUInt64.check_lower(value.non_refundable_storage_fee)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.computation_cost, buf)
        _UniffiConverterUInt64.write(value.computation_cost_burned, buf)
        _UniffiConverterUInt64.write(value.storage_cost, buf)
        _UniffiConverterUInt64.write(value.storage_rebate, buf)
        _UniffiConverterUInt64.write(value.non_refundable_storage_fee, buf)


class GasPayment:
    """
    Payment information for executing a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    gas-payment = (vector object-ref) ; gas coin objects
    address             ; owner
    u64                 ; price
    u64                 ; budget
    ```
    """

    objects: "typing.List[ObjectReference]"
    owner: "Address"
    """
    Owner of the gas objects, either the transaction sender or a sponsor
    """

    price: "int"
    """
    Gas unit price to use when charging for computation

    Must be greater-than-or-equal-to the network's current RGP (reference
    gas price)
    """

    budget: "int"
    """
    Total budget willing to spend for the execution of a transaction
    """

    def __init__(self, *, objects: "typing.List[ObjectReference]", owner: "Address", price: "int", budget: "int"):
        self.objects = objects
        self.owner = owner
        self.price = price
        self.budget = budget

    def __str__(self):
        return "GasPayment(objects={}, owner={}, price={}, budget={})".format(self.objects, self.owner, self.price, self.budget)

    def __eq__(self, other):
        if self.objects != other.objects:
            return False
        if self.owner != other.owner:
            return False
        if self.price != other.price:
            return False
        if self.budget != other.budget:
            return False
        return True

class _UniffiConverterTypeGasPayment(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GasPayment(
            objects=_UniffiConverterSequenceTypeObjectReference.read(buf),
            owner=_UniffiConverterTypeAddress.read(buf),
            price=_UniffiConverterUInt64.read(buf),
            budget=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeObjectReference.check_lower(value.objects)
        _UniffiConverterTypeAddress.check_lower(value.owner)
        _UniffiConverterUInt64.check_lower(value.price)
        _UniffiConverterUInt64.check_lower(value.budget)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeObjectReference.write(value.objects, buf)
        _UniffiConverterTypeAddress.write(value.owner, buf)
        _UniffiConverterUInt64.write(value.price, buf)
        _UniffiConverterUInt64.write(value.budget, buf)


class GqlAddress:
    address: "Address"
    def __init__(self, *, address: "Address"):
        self.address = address

    def __str__(self):
        return "GqlAddress(address={})".format(self.address)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        return True

class _UniffiConverterTypeGqlAddress(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GqlAddress(
            address=_UniffiConverterTypeAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAddress.check_lower(value.address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.address, buf)


class Jwk:
    """
    A JSON Web Key

    Struct that contains info for a JWK. A list of them for different kids can
    be retrieved from the JWK endpoint (e.g. <https://www.googleapis.com/oauth2/v3/certs>).
    The JWK is used to verify the JWT token.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    jwk = string string string string
    ```
    """

    kty: "str"
    """
    Key type parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.1>
    """

    e: "str"
    """
    RSA public exponent, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3>
    """

    n: "str"
    """
    RSA modulus, <https://datatracker.ietf.org/doc/html/rfc7517#section-9.3>
    """

    alg: "str"
    """
    Algorithm parameter, <https://datatracker.ietf.org/doc/html/rfc7517#section-4.4>
    """

    def __init__(self, *, kty: "str", e: "str", n: "str", alg: "str"):
        self.kty = kty
        self.e = e
        self.n = n
        self.alg = alg

    def __str__(self):
        return "Jwk(kty={}, e={}, n={}, alg={})".format(self.kty, self.e, self.n, self.alg)

    def __eq__(self, other):
        if self.kty != other.kty:
            return False
        if self.e != other.e:
            return False
        if self.n != other.n:
            return False
        if self.alg != other.alg:
            return False
        return True

class _UniffiConverterTypeJwk(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Jwk(
            kty=_UniffiConverterString.read(buf),
            e=_UniffiConverterString.read(buf),
            n=_UniffiConverterString.read(buf),
            alg=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.kty)
        _UniffiConverterString.check_lower(value.e)
        _UniffiConverterString.check_lower(value.n)
        _UniffiConverterString.check_lower(value.alg)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.kty, buf)
        _UniffiConverterString.write(value.e, buf)
        _UniffiConverterString.write(value.n, buf)
        _UniffiConverterString.write(value.alg, buf)


class JwkId:
    """
    Key to uniquely identify a JWK

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    jwk-id = string string
    ```
    """

    iss: "str"
    """
    The issuer or identity of the OIDC provider.
    """

    kid: "str"
    """
    A key id use to uniquely identify a key from an OIDC provider.
    """

    def __init__(self, *, iss: "str", kid: "str"):
        self.iss = iss
        self.kid = kid

    def __str__(self):
        return "JwkId(iss={}, kid={})".format(self.iss, self.kid)

    def __eq__(self, other):
        if self.iss != other.iss:
            return False
        if self.kid != other.kid:
            return False
        return True

class _UniffiConverterTypeJwkId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return JwkId(
            iss=_UniffiConverterString.read(buf),
            kid=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.iss)
        _UniffiConverterString.check_lower(value.kid)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.iss, buf)
        _UniffiConverterString.write(value.kid, buf)


class MoveEnum:
    abilities: "typing.Optional[typing.List[MoveAbility]]"
    name: "str"
    type_parameters: "typing.Optional[typing.List[MoveStructTypeParameter]]"
    variants: "typing.Optional[typing.List[MoveEnumVariant]]"
    def __init__(self, *, abilities: "typing.Optional[typing.List[MoveAbility]]" = _DEFAULT, name: "str", type_parameters: "typing.Optional[typing.List[MoveStructTypeParameter]]" = _DEFAULT, variants: "typing.Optional[typing.List[MoveEnumVariant]]" = _DEFAULT):
        if abilities is _DEFAULT:
            self.abilities = None
        else:
            self.abilities = abilities
        self.name = name
        if type_parameters is _DEFAULT:
            self.type_parameters = None
        else:
            self.type_parameters = type_parameters
        if variants is _DEFAULT:
            self.variants = None
        else:
            self.variants = variants

    def __str__(self):
        return "MoveEnum(abilities={}, name={}, type_parameters={}, variants={})".format(self.abilities, self.name, self.type_parameters, self.variants)

    def __eq__(self, other):
        if self.abilities != other.abilities:
            return False
        if self.name != other.name:
            return False
        if self.type_parameters != other.type_parameters:
            return False
        if self.variants != other.variants:
            return False
        return True

class _UniffiConverterTypeMoveEnum(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveEnum(
            abilities=_UniffiConverterOptionalSequenceTypeMoveAbility.read(buf),
            name=_UniffiConverterString.read(buf),
            type_parameters=_UniffiConverterOptionalSequenceTypeMoveStructTypeParameter.read(buf),
            variants=_UniffiConverterOptionalSequenceTypeMoveEnumVariant.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeMoveAbility.check_lower(value.abilities)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalSequenceTypeMoveStructTypeParameter.check_lower(value.type_parameters)
        _UniffiConverterOptionalSequenceTypeMoveEnumVariant.check_lower(value.variants)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeMoveAbility.write(value.abilities, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalSequenceTypeMoveStructTypeParameter.write(value.type_parameters, buf)
        _UniffiConverterOptionalSequenceTypeMoveEnumVariant.write(value.variants, buf)


class MoveEnumConnection:
    nodes: "typing.List[MoveEnum]"
    page_info: "PageInfo"
    def __init__(self, *, nodes: "typing.List[MoveEnum]", page_info: "PageInfo"):
        self.nodes = nodes
        self.page_info = page_info

    def __str__(self):
        return "MoveEnumConnection(nodes={}, page_info={})".format(self.nodes, self.page_info)

    def __eq__(self, other):
        if self.nodes != other.nodes:
            return False
        if self.page_info != other.page_info:
            return False
        return True

class _UniffiConverterTypeMoveEnumConnection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveEnumConnection(
            nodes=_UniffiConverterSequenceTypeMoveEnum.read(buf),
            page_info=_UniffiConverterTypePageInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeMoveEnum.check_lower(value.nodes)
        _UniffiConverterTypePageInfo.check_lower(value.page_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeMoveEnum.write(value.nodes, buf)
        _UniffiConverterTypePageInfo.write(value.page_info, buf)


class MoveEnumVariant:
    fields: "typing.Optional[typing.List[MoveField]]"
    name: "str"
    def __init__(self, *, fields: "typing.Optional[typing.List[MoveField]]" = _DEFAULT, name: "str"):
        if fields is _DEFAULT:
            self.fields = None
        else:
            self.fields = fields
        self.name = name

    def __str__(self):
        return "MoveEnumVariant(fields={}, name={})".format(self.fields, self.name)

    def __eq__(self, other):
        if self.fields != other.fields:
            return False
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeMoveEnumVariant(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveEnumVariant(
            fields=_UniffiConverterOptionalSequenceTypeMoveField.read(buf),
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeMoveField.check_lower(value.fields)
        _UniffiConverterString.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeMoveField.write(value.fields, buf)
        _UniffiConverterString.write(value.name, buf)


class MoveField:
    name: "str"
    type: "typing.Optional[OpenMoveType]"
    def __init__(self, *, name: "str", type: "typing.Optional[OpenMoveType]" = _DEFAULT):
        self.name = name
        if type is _DEFAULT:
            self.type = None
        else:
            self.type = type

    def __str__(self):
        return "MoveField(name={}, type={})".format(self.name, self.type)

    def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.type != other.type:
            return False
        return True

class _UniffiConverterTypeMoveField(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveField(
            name=_UniffiConverterString.read(buf),
            type=_UniffiConverterOptionalTypeOpenMoveType.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalTypeOpenMoveType.check_lower(value.type)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalTypeOpenMoveType.write(value.type, buf)


class MoveFunctionConnection:
    nodes: "typing.List[MoveFunction]"
    page_info: "PageInfo"
    def __init__(self, *, nodes: "typing.List[MoveFunction]", page_info: "PageInfo"):
        self.nodes = nodes
        self.page_info = page_info

    def __str__(self):
        return "MoveFunctionConnection(nodes={}, page_info={})".format(self.nodes, self.page_info)

    def __eq__(self, other):
        if self.nodes != other.nodes:
            return False
        if self.page_info != other.page_info:
            return False
        return True

class _UniffiConverterTypeMoveFunctionConnection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveFunctionConnection(
            nodes=_UniffiConverterSequenceTypeMoveFunction.read(buf),
            page_info=_UniffiConverterTypePageInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeMoveFunction.check_lower(value.nodes)
        _UniffiConverterTypePageInfo.check_lower(value.page_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeMoveFunction.write(value.nodes, buf)
        _UniffiConverterTypePageInfo.write(value.page_info, buf)


class MoveFunctionTypeParameter:
    constraints: "typing.List[MoveAbility]"
    def __init__(self, *, constraints: "typing.List[MoveAbility]"):
        self.constraints = constraints

    def __str__(self):
        return "MoveFunctionTypeParameter(constraints={})".format(self.constraints)

    def __eq__(self, other):
        if self.constraints != other.constraints:
            return False
        return True

class _UniffiConverterTypeMoveFunctionTypeParameter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveFunctionTypeParameter(
            constraints=_UniffiConverterSequenceTypeMoveAbility.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeMoveAbility.check_lower(value.constraints)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeMoveAbility.write(value.constraints, buf)


class MoveLocation:
    """
    Location in move bytecode where an error occurred

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    move-location = object-id identifier u16 u16 (option identifier)
    ```
    """

    package: "ObjectId"
    """
    The package id
    """

    module: "str"
    """
    The module name
    """

    function: "int"
    """
    The function index
    """

    instruction: "int"
    """
    Index into the code stream for a jump. The offset is relative to the
    beginning of the instruction stream.
    """

    function_name: "typing.Optional[str]"
    """
    The name of the function if available
    """

    def __init__(self, *, package: "ObjectId", module: "str", function: "int", instruction: "int", function_name: "typing.Optional[str]" = _DEFAULT):
        self.package = package
        self.module = module
        self.function = function
        self.instruction = instruction
        if function_name is _DEFAULT:
            self.function_name = None
        else:
            self.function_name = function_name

    def __str__(self):
        return "MoveLocation(package={}, module={}, function={}, instruction={}, function_name={})".format(self.package, self.module, self.function, self.instruction, self.function_name)

    def __eq__(self, other):
        if self.package != other.package:
            return False
        if self.module != other.module:
            return False
        if self.function != other.function:
            return False
        if self.instruction != other.instruction:
            return False
        if self.function_name != other.function_name:
            return False
        return True

class _UniffiConverterTypeMoveLocation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveLocation(
            package=_UniffiConverterTypeObjectId.read(buf),
            module=_UniffiConverterString.read(buf),
            function=_UniffiConverterUInt16.read(buf),
            instruction=_UniffiConverterUInt16.read(buf),
            function_name=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.package)
        _UniffiConverterString.check_lower(value.module)
        _UniffiConverterUInt16.check_lower(value.function)
        _UniffiConverterUInt16.check_lower(value.instruction)
        _UniffiConverterOptionalString.check_lower(value.function_name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.package, buf)
        _UniffiConverterString.write(value.module, buf)
        _UniffiConverterUInt16.write(value.function, buf)
        _UniffiConverterUInt16.write(value.instruction, buf)
        _UniffiConverterOptionalString.write(value.function_name, buf)


class MoveModule:
    file_format_version: "int"
    enums: "typing.Optional[MoveEnumConnection]"
    friends: "MoveModuleConnection"
    functions: "typing.Optional[MoveFunctionConnection]"
    structs: "typing.Optional[MoveStructConnection]"
    def __init__(self, *, file_format_version: "int", enums: "typing.Optional[MoveEnumConnection]" = _DEFAULT, friends: "MoveModuleConnection", functions: "typing.Optional[MoveFunctionConnection]" = _DEFAULT, structs: "typing.Optional[MoveStructConnection]" = _DEFAULT):
        self.file_format_version = file_format_version
        if enums is _DEFAULT:
            self.enums = None
        else:
            self.enums = enums
        self.friends = friends
        if functions is _DEFAULT:
            self.functions = None
        else:
            self.functions = functions
        if structs is _DEFAULT:
            self.structs = None
        else:
            self.structs = structs

    def __str__(self):
        return "MoveModule(file_format_version={}, enums={}, friends={}, functions={}, structs={})".format(self.file_format_version, self.enums, self.friends, self.functions, self.structs)

    def __eq__(self, other):
        if self.file_format_version != other.file_format_version:
            return False
        if self.enums != other.enums:
            return False
        if self.friends != other.friends:
            return False
        if self.functions != other.functions:
            return False
        if self.structs != other.structs:
            return False
        return True

class _UniffiConverterTypeMoveModule(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveModule(
            file_format_version=_UniffiConverterInt32.read(buf),
            enums=_UniffiConverterOptionalTypeMoveEnumConnection.read(buf),
            friends=_UniffiConverterTypeMoveModuleConnection.read(buf),
            functions=_UniffiConverterOptionalTypeMoveFunctionConnection.read(buf),
            structs=_UniffiConverterOptionalTypeMoveStructConnection.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.file_format_version)
        _UniffiConverterOptionalTypeMoveEnumConnection.check_lower(value.enums)
        _UniffiConverterTypeMoveModuleConnection.check_lower(value.friends)
        _UniffiConverterOptionalTypeMoveFunctionConnection.check_lower(value.functions)
        _UniffiConverterOptionalTypeMoveStructConnection.check_lower(value.structs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.file_format_version, buf)
        _UniffiConverterOptionalTypeMoveEnumConnection.write(value.enums, buf)
        _UniffiConverterTypeMoveModuleConnection.write(value.friends, buf)
        _UniffiConverterOptionalTypeMoveFunctionConnection.write(value.functions, buf)
        _UniffiConverterOptionalTypeMoveStructConnection.write(value.structs, buf)


class MoveModuleConnection:
    nodes: "typing.List[MoveModuleQuery]"
    page_info: "PageInfo"
    def __init__(self, *, nodes: "typing.List[MoveModuleQuery]", page_info: "PageInfo"):
        self.nodes = nodes
        self.page_info = page_info

    def __str__(self):
        return "MoveModuleConnection(nodes={}, page_info={})".format(self.nodes, self.page_info)

    def __eq__(self, other):
        if self.nodes != other.nodes:
            return False
        if self.page_info != other.page_info:
            return False
        return True

class _UniffiConverterTypeMoveModuleConnection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveModuleConnection(
            nodes=_UniffiConverterSequenceTypeMoveModuleQuery.read(buf),
            page_info=_UniffiConverterTypePageInfo.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeMoveModuleQuery.check_lower(value.nodes)
        _UniffiConverterTypePageInfo.check_lower(value.page_info)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeMoveModuleQuery.write(value.nodes, buf)
        _UniffiConverterTypePageInfo.write(value.page_info, buf)


class MoveModuleQuery:
    package: "MovePackageQuery"
    name: "str"
    def __init__(self, *, package: "MovePackageQuery", name: "str"):
        self.package = package
        self.name = name

    def __str__(self):
        return "MoveModuleQuery(package={}, name={})".format(self.package, self.name)

    def __eq__(self, other):
        if self.package != other.package:
            return False
        if self.name != other.name:
            return False
        return True

class _UniffiConverterTypeMoveModuleQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveModuleQuery(
            package=_UniffiConverterTypeMovePackageQuery.read(buf),
            name=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeMovePackageQuery.check_lower(value.package)
        _UniffiConverterString.check_lower(value.name)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeMovePackageQuery.write(value.package, buf)
        _UniffiConverterString.write(value.name, buf)


class MoveObject:
    bcs: "typing.Optional[Base64]"
    def __init__(self, *, bcs: "typing.Optional[Base64]" = _DEFAULT):
        if bcs is _DEFAULT:
            self.bcs = None
        else:
            self.bcs = bcs

    def __str__(self):
        return "MoveObject(bcs={})".format(self.bcs)

    def __eq__(self, other):
        if self.bcs != other.bcs:
            return False
        return True

class _UniffiConverterTypeMoveObject(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveObject(
            bcs=_UniffiConverterOptionalTypeBase64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeBase64.check_lower(value.bcs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeBase64.write(value.bcs, buf)


class MovePackagePage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[MovePackage]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[MovePackage]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "MovePackagePage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeMovePackagePage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MovePackagePage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeMovePackage.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeMovePackage.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeMovePackage.write(value.data, buf)


class MovePackageQuery:
    address: "Address"
    bcs: "typing.Optional[Base64]"
    def __init__(self, *, address: "Address", bcs: "typing.Optional[Base64]" = _DEFAULT):
        self.address = address
        if bcs is _DEFAULT:
            self.bcs = None
        else:
            self.bcs = bcs

    def __str__(self):
        return "MovePackageQuery(address={}, bcs={})".format(self.address, self.bcs)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.bcs != other.bcs:
            return False
        return True

class _UniffiConverterTypeMovePackageQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MovePackageQuery(
            address=_UniffiConverterTypeAddress.read(buf),
            bcs=_UniffiConverterOptionalTypeBase64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAddress.check_lower(value.address)
        _UniffiConverterOptionalTypeBase64.check_lower(value.bcs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAddress.write(value.address, buf)
        _UniffiConverterOptionalTypeBase64.write(value.bcs, buf)


class MoveStruct:
    """
    A move struct

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-move-struct = compressed-struct-tag bool u64 object-contents

    compressed-struct-tag = other-struct-type / gas-coin-type / staked-iota-type / coin-type
    other-struct-type     = %x00 struct-tag
    gas-coin-type         = %x01
    staked-iota-type      = %x02
    coin-type             = %x03 type-tag

    ; first 32 bytes of the contents are the object's object-id
    object-contents = uleb128 (object-id *OCTET) ; length followed by contents
    ```
    """

    struct_type: "StructTag"
    """
    The type of this object
    """

    version: "int"
    """
    Number that increases each time a tx takes this object as a mutable
    input This is a lamport timestamp, not a sequentially increasing
    version
    """

    contents: "bytes"
    """
    BCS bytes of a Move struct value
    """

    def __init__(self, *, struct_type: "StructTag", version: "int", contents: "bytes"):
        self.struct_type = struct_type
        self.version = version
        self.contents = contents

    def __str__(self):
        return "MoveStruct(struct_type={}, version={}, contents={})".format(self.struct_type, self.version, self.contents)

    def __eq__(self, other):
        if self.struct_type != other.struct_type:
            return False
        if self.version != other.version:
            return False
        if self.contents != other.contents:
            return False
        return True

class _UniffiConverterTypeMoveStruct(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveStruct(
            struct_type=_UniffiConverterTypeStructTag.read(buf),
            version=_UniffiConverterUInt64.read(buf),
            contents=_UniffiConverterBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeStructTag.check_lower(value.struct_type)
        _UniffiConverterUInt64.check_lower(value.version)
        _UniffiConverterBytes.check_lower(value.contents)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeStructTag.write(value.struct_type, buf)
        _UniffiConverterUInt64.write(value.version, buf)
        _UniffiConverterBytes.write(value.contents, buf)


class MoveStructConnection:
    page_info: "PageInfo"
    nodes: "typing.List[MoveStructQuery]"
    def __init__(self, *, page_info: "PageInfo", nodes: "typing.List[MoveStructQuery]"):
        self.page_info = page_info
        self.nodes = nodes

    def __str__(self):
        return "MoveStructConnection(page_info={}, nodes={})".format(self.page_info, self.nodes)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.nodes != other.nodes:
            return False
        return True

class _UniffiConverterTypeMoveStructConnection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveStructConnection(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            nodes=_UniffiConverterSequenceTypeMoveStructQuery.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeMoveStructQuery.check_lower(value.nodes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeMoveStructQuery.write(value.nodes, buf)


class MoveStructQuery:
    abilities: "typing.Optional[typing.List[MoveAbility]]"
    name: "str"
    fields: "typing.Optional[typing.List[MoveField]]"
    type_parameters: "typing.Optional[typing.List[MoveStructTypeParameter]]"
    def __init__(self, *, abilities: "typing.Optional[typing.List[MoveAbility]]" = _DEFAULT, name: "str", fields: "typing.Optional[typing.List[MoveField]]" = _DEFAULT, type_parameters: "typing.Optional[typing.List[MoveStructTypeParameter]]" = _DEFAULT):
        if abilities is _DEFAULT:
            self.abilities = None
        else:
            self.abilities = abilities
        self.name = name
        if fields is _DEFAULT:
            self.fields = None
        else:
            self.fields = fields
        if type_parameters is _DEFAULT:
            self.type_parameters = None
        else:
            self.type_parameters = type_parameters

    def __str__(self):
        return "MoveStructQuery(abilities={}, name={}, fields={}, type_parameters={})".format(self.abilities, self.name, self.fields, self.type_parameters)

    def __eq__(self, other):
        if self.abilities != other.abilities:
            return False
        if self.name != other.name:
            return False
        if self.fields != other.fields:
            return False
        if self.type_parameters != other.type_parameters:
            return False
        return True

class _UniffiConverterTypeMoveStructQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveStructQuery(
            abilities=_UniffiConverterOptionalSequenceTypeMoveAbility.read(buf),
            name=_UniffiConverterString.read(buf),
            fields=_UniffiConverterOptionalSequenceTypeMoveField.read(buf),
            type_parameters=_UniffiConverterOptionalSequenceTypeMoveStructTypeParameter.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalSequenceTypeMoveAbility.check_lower(value.abilities)
        _UniffiConverterString.check_lower(value.name)
        _UniffiConverterOptionalSequenceTypeMoveField.check_lower(value.fields)
        _UniffiConverterOptionalSequenceTypeMoveStructTypeParameter.check_lower(value.type_parameters)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalSequenceTypeMoveAbility.write(value.abilities, buf)
        _UniffiConverterString.write(value.name, buf)
        _UniffiConverterOptionalSequenceTypeMoveField.write(value.fields, buf)
        _UniffiConverterOptionalSequenceTypeMoveStructTypeParameter.write(value.type_parameters, buf)


class MoveStructTypeParameter:
    constraints: "typing.List[MoveAbility]"
    is_phantom: "bool"
    def __init__(self, *, constraints: "typing.List[MoveAbility]", is_phantom: "bool"):
        self.constraints = constraints
        self.is_phantom = is_phantom

    def __str__(self):
        return "MoveStructTypeParameter(constraints={}, is_phantom={})".format(self.constraints, self.is_phantom)

    def __eq__(self, other):
        if self.constraints != other.constraints:
            return False
        if self.is_phantom != other.is_phantom:
            return False
        return True

class _UniffiConverterTypeMoveStructTypeParameter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return MoveStructTypeParameter(
            constraints=_UniffiConverterSequenceTypeMoveAbility.read(buf),
            is_phantom=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeMoveAbility.check_lower(value.constraints)
        _UniffiConverterBool.check_lower(value.is_phantom)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeMoveAbility.write(value.constraints, buf)
        _UniffiConverterBool.write(value.is_phantom, buf)


class NameRegistrationPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[NameRegistration]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[NameRegistration]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "NameRegistrationPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeNameRegistrationPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return NameRegistrationPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeNameRegistration.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeNameRegistration.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeNameRegistration.write(value.data, buf)


class ObjectFilter:
    type_tag: "typing.Optional[str]"
    owner: "typing.Optional[Address]"
    object_ids: "typing.Optional[typing.List[ObjectId]]"
    def __init__(self, *, type_tag: "typing.Optional[str]" = _DEFAULT, owner: "typing.Optional[Address]" = _DEFAULT, object_ids: "typing.Optional[typing.List[ObjectId]]" = _DEFAULT):
        if type_tag is _DEFAULT:
            self.type_tag = None
        else:
            self.type_tag = type_tag
        if owner is _DEFAULT:
            self.owner = None
        else:
            self.owner = owner
        if object_ids is _DEFAULT:
            self.object_ids = None
        else:
            self.object_ids = object_ids

    def __str__(self):
        return "ObjectFilter(type_tag={}, owner={}, object_ids={})".format(self.type_tag, self.owner, self.object_ids)

    def __eq__(self, other):
        if self.type_tag != other.type_tag:
            return False
        if self.owner != other.owner:
            return False
        if self.object_ids != other.object_ids:
            return False
        return True

class _UniffiConverterTypeObjectFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ObjectFilter(
            type_tag=_UniffiConverterOptionalString.read(buf),
            owner=_UniffiConverterOptionalTypeAddress.read(buf),
            object_ids=_UniffiConverterOptionalSequenceTypeObjectId.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.type_tag)
        _UniffiConverterOptionalTypeAddress.check_lower(value.owner)
        _UniffiConverterOptionalSequenceTypeObjectId.check_lower(value.object_ids)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.type_tag, buf)
        _UniffiConverterOptionalTypeAddress.write(value.owner, buf)
        _UniffiConverterOptionalSequenceTypeObjectId.write(value.object_ids, buf)


class ObjectPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[Object]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[Object]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "ObjectPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeObjectPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ObjectPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeObject.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeObject.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeObject.write(value.data, buf)


class ObjectRef:
    address: "ObjectId"
    digest: "str"
    version: "int"
    def __init__(self, *, address: "ObjectId", digest: "str", version: "int"):
        self.address = address
        self.digest = digest
        self.version = version

    def __str__(self):
        return "ObjectRef(address={}, digest={}, version={})".format(self.address, self.digest, self.version)

    def __eq__(self, other):
        if self.address != other.address:
            return False
        if self.digest != other.digest:
            return False
        if self.version != other.version:
            return False
        return True

class _UniffiConverterTypeObjectRef(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ObjectRef(
            address=_UniffiConverterTypeObjectId.read(buf),
            digest=_UniffiConverterString.read(buf),
            version=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.address)
        _UniffiConverterString.check_lower(value.digest)
        _UniffiConverterUInt64.check_lower(value.version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.address, buf)
        _UniffiConverterString.write(value.digest, buf)
        _UniffiConverterUInt64.write(value.version, buf)


class ObjectReference:
    """
    Reference to an object

    Contains sufficient information to uniquely identify a specific object.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-ref = object-id u64 digest
    ```
    """

    object_id: "ObjectId"
    version: "int"
    digest: "Digest"
    def __init__(self, *, object_id: "ObjectId", version: "int", digest: "Digest"):
        self.object_id = object_id
        self.version = version
        self.digest = digest

    def __str__(self):
        return "ObjectReference(object_id={}, version={}, digest={})".format(self.object_id, self.version, self.digest)

    def __eq__(self, other):
        if self.object_id != other.object_id:
            return False
        if self.version != other.version:
            return False
        if self.digest != other.digest:
            return False
        return True

class _UniffiConverterTypeObjectReference(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ObjectReference(
            object_id=_UniffiConverterTypeObjectId.read(buf),
            version=_UniffiConverterUInt64.read(buf),
            digest=_UniffiConverterTypeDigest.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.object_id)
        _UniffiConverterUInt64.check_lower(value.version)
        _UniffiConverterTypeDigest.check_lower(value.digest)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.object_id, buf)
        _UniffiConverterUInt64.write(value.version, buf)
        _UniffiConverterTypeDigest.write(value.digest, buf)


class OpenMoveType:
    repr: "str"
    def __init__(self, *, repr: "str"):
        self.repr = repr

    def __str__(self):
        return "OpenMoveType(repr={})".format(self.repr)

    def __eq__(self, other):
        if self.repr != other.repr:
            return False
        return True

class _UniffiConverterTypeOpenMoveType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OpenMoveType(
            repr=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.repr)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.repr, buf)


class PageInfo:
    """
    Information about pagination in a connection.
    """

    has_previous_page: "bool"
    """
    When paginating backwards, are there more items?
    """

    has_next_page: "bool"
    """
    Are there more items when paginating forwards?
    """

    start_cursor: "typing.Optional[str]"
    """
    When paginating backwards, the cursor to continue.
    """

    end_cursor: "typing.Optional[str]"
    """
    When paginating forwards, the cursor to continue.
    """

    def __init__(self, *, has_previous_page: "bool", has_next_page: "bool", start_cursor: "typing.Optional[str]" = _DEFAULT, end_cursor: "typing.Optional[str]" = _DEFAULT):
        self.has_previous_page = has_previous_page
        self.has_next_page = has_next_page
        if start_cursor is _DEFAULT:
            self.start_cursor = None
        else:
            self.start_cursor = start_cursor
        if end_cursor is _DEFAULT:
            self.end_cursor = None
        else:
            self.end_cursor = end_cursor

    def __str__(self):
        return "PageInfo(has_previous_page={}, has_next_page={}, start_cursor={}, end_cursor={})".format(self.has_previous_page, self.has_next_page, self.start_cursor, self.end_cursor)

    def __eq__(self, other):
        if self.has_previous_page != other.has_previous_page:
            return False
        if self.has_next_page != other.has_next_page:
            return False
        if self.start_cursor != other.start_cursor:
            return False
        if self.end_cursor != other.end_cursor:
            return False
        return True

class _UniffiConverterTypePageInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PageInfo(
            has_previous_page=_UniffiConverterBool.read(buf),
            has_next_page=_UniffiConverterBool.read(buf),
            start_cursor=_UniffiConverterOptionalString.read(buf),
            end_cursor=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBool.check_lower(value.has_previous_page)
        _UniffiConverterBool.check_lower(value.has_next_page)
        _UniffiConverterOptionalString.check_lower(value.start_cursor)
        _UniffiConverterOptionalString.check_lower(value.end_cursor)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBool.write(value.has_previous_page, buf)
        _UniffiConverterBool.write(value.has_next_page, buf)
        _UniffiConverterOptionalString.write(value.start_cursor, buf)
        _UniffiConverterOptionalString.write(value.end_cursor, buf)


class PaginationFilter:
    """
    Pagination options for querying the GraphQL server. It defaults to forward
    pagination with the GraphQL server's max page size.
    """

    direction: "Direction"
    """
    The direction of pagination.
    """

    cursor: "typing.Optional[str]"
    """
    An opaque cursor used for pagination.
    """

    limit: "typing.Optional[int]"
    """
    The maximum number of items to return. If this is omitted, it will
    lazily query the service configuration for the max page size.
    """

    def __init__(self, *, direction: "Direction", cursor: "typing.Optional[str]" = _DEFAULT, limit: "typing.Optional[int]" = _DEFAULT):
        self.direction = direction
        if cursor is _DEFAULT:
            self.cursor = None
        else:
            self.cursor = cursor
        if limit is _DEFAULT:
            self.limit = None
        else:
            self.limit = limit

    def __str__(self):
        return "PaginationFilter(direction={}, cursor={}, limit={})".format(self.direction, self.cursor, self.limit)

    def __eq__(self, other):
        if self.direction != other.direction:
            return False
        if self.cursor != other.cursor:
            return False
        if self.limit != other.limit:
            return False
        return True

class _UniffiConverterTypePaginationFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PaginationFilter(
            direction=_UniffiConverterTypeDirection.read(buf),
            cursor=_UniffiConverterOptionalString.read(buf),
            limit=_UniffiConverterOptionalInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeDirection.check_lower(value.direction)
        _UniffiConverterOptionalString.check_lower(value.cursor)
        _UniffiConverterOptionalInt32.check_lower(value.limit)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeDirection.write(value.direction, buf)
        _UniffiConverterOptionalString.write(value.cursor, buf)
        _UniffiConverterOptionalInt32.write(value.limit, buf)


class ProtocolConfigAttr:
    """
    A key-value protocol configuration attribute.
    """

    key: "str"
    value: "typing.Optional[str]"
    def __init__(self, *, key: "str", value: "typing.Optional[str]"):
        self.key = key
        self.value = value

    def __str__(self):
        return "ProtocolConfigAttr(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeProtocolConfigAttr(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProtocolConfigAttr(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterOptionalString.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterOptionalString.write(value.value, buf)


class ProtocolConfigFeatureFlag:
    """
    Feature flags are a form of boolean configuration that are usually used to
    gate features while they are in development. Once a lag has been enabled, it
    is rare for it to be disabled.
    """

    key: "str"
    value: "bool"
    def __init__(self, *, key: "str", value: "bool"):
        self.key = key
        self.value = value

    def __str__(self):
        return "ProtocolConfigFeatureFlag(key={}, value={})".format(self.key, self.value)

    def __eq__(self, other):
        if self.key != other.key:
            return False
        if self.value != other.value:
            return False
        return True

class _UniffiConverterTypeProtocolConfigFeatureFlag(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProtocolConfigFeatureFlag(
            key=_UniffiConverterString.read(buf),
            value=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.key)
        _UniffiConverterBool.check_lower(value.value)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.key, buf)
        _UniffiConverterBool.write(value.value, buf)


class ProtocolConfigs:
    """
    Information about the configuration of the protocol.
    Constants that control how the chain operates.
    These can only change during protocol upgrades which happen on epoch
    boundaries.
    """

    protocol_version: "int"
    """
    The protocol is not required to change on every epoch boundary, so the
    protocol version tracks which change to the protocol these configs
    are from.
    """

    feature_flags: "typing.List[ProtocolConfigFeatureFlag]"
    """
    List all available feature flags and their values. Feature flags are a
    form of boolean configuration that are usually used to gate features
    while they are in development. Once a flag has been enabled, it is
    rare for it to be disabled.
    """

    configs: "typing.List[ProtocolConfigAttr]"
    """
    List all available configurations and their values. These configurations
    can take any value (but they will all be represented in string
    form), and do not include feature flags.
    """

    def __init__(self, *, protocol_version: "int", feature_flags: "typing.List[ProtocolConfigFeatureFlag]", configs: "typing.List[ProtocolConfigAttr]"):
        self.protocol_version = protocol_version
        self.feature_flags = feature_flags
        self.configs = configs

    def __str__(self):
        return "ProtocolConfigs(protocol_version={}, feature_flags={}, configs={})".format(self.protocol_version, self.feature_flags, self.configs)

    def __eq__(self, other):
        if self.protocol_version != other.protocol_version:
            return False
        if self.feature_flags != other.feature_flags:
            return False
        if self.configs != other.configs:
            return False
        return True

class _UniffiConverterTypeProtocolConfigs(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ProtocolConfigs(
            protocol_version=_UniffiConverterUInt64.read(buf),
            feature_flags=_UniffiConverterSequenceTypeProtocolConfigFeatureFlag.read(buf),
            configs=_UniffiConverterSequenceTypeProtocolConfigAttr.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.protocol_version)
        _UniffiConverterSequenceTypeProtocolConfigFeatureFlag.check_lower(value.feature_flags)
        _UniffiConverterSequenceTypeProtocolConfigAttr.check_lower(value.configs)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.protocol_version, buf)
        _UniffiConverterSequenceTypeProtocolConfigFeatureFlag.write(value.feature_flags, buf)
        _UniffiConverterSequenceTypeProtocolConfigAttr.write(value.configs, buf)


class Query:
    query: "str"
    variables: "typing.Optional[Value]"
    def __init__(self, *, query: "str", variables: "typing.Optional[Value]" = _DEFAULT):
        self.query = query
        if variables is _DEFAULT:
            self.variables = None
        else:
            self.variables = variables

    def __str__(self):
        return "Query(query={}, variables={})".format(self.query, self.variables)

    def __eq__(self, other):
        if self.query != other.query:
            return False
        if self.variables != other.variables:
            return False
        return True

class _UniffiConverterTypeQuery(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Query(
            query=_UniffiConverterString.read(buf),
            variables=_UniffiConverterOptionalTypeValue.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.query)
        _UniffiConverterOptionalTypeValue.check_lower(value.variables)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.query, buf)
        _UniffiConverterOptionalTypeValue.write(value.variables, buf)


class RandomnessStateUpdate:
    """
    Randomness update

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    randomness-state-update = u64 u64 bytes u64
    ```
    """

    epoch: "int"
    """
    Epoch of the randomness state update transaction
    """

    randomness_round: "int"
    """
    Randomness round of the update
    """

    random_bytes: "bytes"
    """
    Updated random bytes
    """

    randomness_obj_initial_shared_version: "int"
    """
    The initial version of the randomness object that it was shared at
    """

    def __init__(self, *, epoch: "int", randomness_round: "int", random_bytes: "bytes", randomness_obj_initial_shared_version: "int"):
        self.epoch = epoch
        self.randomness_round = randomness_round
        self.random_bytes = random_bytes
        self.randomness_obj_initial_shared_version = randomness_obj_initial_shared_version

    def __str__(self):
        return "RandomnessStateUpdate(epoch={}, randomness_round={}, random_bytes={}, randomness_obj_initial_shared_version={})".format(self.epoch, self.randomness_round, self.random_bytes, self.randomness_obj_initial_shared_version)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.randomness_round != other.randomness_round:
            return False
        if self.random_bytes != other.random_bytes:
            return False
        if self.randomness_obj_initial_shared_version != other.randomness_obj_initial_shared_version:
            return False
        return True

class _UniffiConverterTypeRandomnessStateUpdate(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RandomnessStateUpdate(
            epoch=_UniffiConverterUInt64.read(buf),
            randomness_round=_UniffiConverterUInt64.read(buf),
            random_bytes=_UniffiConverterBytes.read(buf),
            randomness_obj_initial_shared_version=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.epoch)
        _UniffiConverterUInt64.check_lower(value.randomness_round)
        _UniffiConverterBytes.check_lower(value.random_bytes)
        _UniffiConverterUInt64.check_lower(value.randomness_obj_initial_shared_version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterUInt64.write(value.randomness_round, buf)
        _UniffiConverterBytes.write(value.random_bytes, buf)
        _UniffiConverterUInt64.write(value.randomness_obj_initial_shared_version, buf)


class ServiceConfig:
    default_page_size: "int"
    """
    Default number of elements allowed on a single page of a connection.
    """

    enabled_features: "typing.List[Feature]"
    """
    List of all features that are enabled on this RPC service.
    """

    max_move_value_depth: "int"
    """
    Maximum estimated cost of a database query used to serve a GraphQL
    request.  This is measured in the same units that the database uses
    in EXPLAIN queries.
    Maximum nesting allowed in struct fields when calculating the layout of
    a single Move Type.
    """

    max_output_nodes: "int"
    """
    The maximum number of output nodes in a GraphQL response.
    Non-connection nodes have a count of 1, while connection nodes are
    counted as the specified 'first' or 'last' number of items, or the
    default_page_size as set by the server if those arguments are not
    set. Counts accumulate multiplicatively down the query tree. For
    example, if a query starts with a connection of first: 10 and has a
    field to a connection with last: 20, the count at the second level
    would be 200 nodes. This is then summed to the count of 10 nodes
    at the first level, for a total of 210 nodes.
    """

    max_page_size: "int"
    """
    Maximum number of elements allowed on a single page of a connection.
    """

    max_query_depth: "int"
    """
    The maximum depth a GraphQL query can be to be accepted by this service.
    """

    max_query_nodes: "int"
    """
    The maximum number of nodes (field names) the service will accept in a
    single query.
    """

    max_query_payload_size: "int"
    """
    Maximum length of a query payload string.
    """

    max_type_argument_depth: "int"
    """
    Maximum nesting allowed in type arguments in Move Types resolved by this
    service.
    """

    max_type_argument_width: "int"
    """
    Maximum number of type arguments passed into a generic instantiation of
    a Move Type resolved by this service.
    """

    max_type_nodes: "int"
    """
    Maximum number of structs that need to be processed when calculating the
    layout of a single Move Type.
    """

    mutation_timeout_ms: "int"
    """
    Maximum time in milliseconds spent waiting for a response from fullnode
    after issuing a a transaction to execute. Note that the transaction
    may still succeed even in the case of a timeout. Transactions are
    idempotent, so a transaction that times out should be resubmitted
    until the network returns a definite response (success or failure, not
    timeout).
    """

    request_timeout_ms: "int"
    """
    Maximum time in milliseconds that will be spent to serve one query
    request.
    """

    def __init__(self, *, default_page_size: "int", enabled_features: "typing.List[Feature]", max_move_value_depth: "int", max_output_nodes: "int", max_page_size: "int", max_query_depth: "int", max_query_nodes: "int", max_query_payload_size: "int", max_type_argument_depth: "int", max_type_argument_width: "int", max_type_nodes: "int", mutation_timeout_ms: "int", request_timeout_ms: "int"):
        self.default_page_size = default_page_size
        self.enabled_features = enabled_features
        self.max_move_value_depth = max_move_value_depth
        self.max_output_nodes = max_output_nodes
        self.max_page_size = max_page_size
        self.max_query_depth = max_query_depth
        self.max_query_nodes = max_query_nodes
        self.max_query_payload_size = max_query_payload_size
        self.max_type_argument_depth = max_type_argument_depth
        self.max_type_argument_width = max_type_argument_width
        self.max_type_nodes = max_type_nodes
        self.mutation_timeout_ms = mutation_timeout_ms
        self.request_timeout_ms = request_timeout_ms

    def __str__(self):
        return "ServiceConfig(default_page_size={}, enabled_features={}, max_move_value_depth={}, max_output_nodes={}, max_page_size={}, max_query_depth={}, max_query_nodes={}, max_query_payload_size={}, max_type_argument_depth={}, max_type_argument_width={}, max_type_nodes={}, mutation_timeout_ms={}, request_timeout_ms={})".format(self.default_page_size, self.enabled_features, self.max_move_value_depth, self.max_output_nodes, self.max_page_size, self.max_query_depth, self.max_query_nodes, self.max_query_payload_size, self.max_type_argument_depth, self.max_type_argument_width, self.max_type_nodes, self.mutation_timeout_ms, self.request_timeout_ms)

    def __eq__(self, other):
        if self.default_page_size != other.default_page_size:
            return False
        if self.enabled_features != other.enabled_features:
            return False
        if self.max_move_value_depth != other.max_move_value_depth:
            return False
        if self.max_output_nodes != other.max_output_nodes:
            return False
        if self.max_page_size != other.max_page_size:
            return False
        if self.max_query_depth != other.max_query_depth:
            return False
        if self.max_query_nodes != other.max_query_nodes:
            return False
        if self.max_query_payload_size != other.max_query_payload_size:
            return False
        if self.max_type_argument_depth != other.max_type_argument_depth:
            return False
        if self.max_type_argument_width != other.max_type_argument_width:
            return False
        if self.max_type_nodes != other.max_type_nodes:
            return False
        if self.mutation_timeout_ms != other.mutation_timeout_ms:
            return False
        if self.request_timeout_ms != other.request_timeout_ms:
            return False
        return True

class _UniffiConverterTypeServiceConfig(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ServiceConfig(
            default_page_size=_UniffiConverterInt32.read(buf),
            enabled_features=_UniffiConverterSequenceTypeFeature.read(buf),
            max_move_value_depth=_UniffiConverterInt32.read(buf),
            max_output_nodes=_UniffiConverterInt32.read(buf),
            max_page_size=_UniffiConverterInt32.read(buf),
            max_query_depth=_UniffiConverterInt32.read(buf),
            max_query_nodes=_UniffiConverterInt32.read(buf),
            max_query_payload_size=_UniffiConverterInt32.read(buf),
            max_type_argument_depth=_UniffiConverterInt32.read(buf),
            max_type_argument_width=_UniffiConverterInt32.read(buf),
            max_type_nodes=_UniffiConverterInt32.read(buf),
            mutation_timeout_ms=_UniffiConverterInt32.read(buf),
            request_timeout_ms=_UniffiConverterInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterInt32.check_lower(value.default_page_size)
        _UniffiConverterSequenceTypeFeature.check_lower(value.enabled_features)
        _UniffiConverterInt32.check_lower(value.max_move_value_depth)
        _UniffiConverterInt32.check_lower(value.max_output_nodes)
        _UniffiConverterInt32.check_lower(value.max_page_size)
        _UniffiConverterInt32.check_lower(value.max_query_depth)
        _UniffiConverterInt32.check_lower(value.max_query_nodes)
        _UniffiConverterInt32.check_lower(value.max_query_payload_size)
        _UniffiConverterInt32.check_lower(value.max_type_argument_depth)
        _UniffiConverterInt32.check_lower(value.max_type_argument_width)
        _UniffiConverterInt32.check_lower(value.max_type_nodes)
        _UniffiConverterInt32.check_lower(value.mutation_timeout_ms)
        _UniffiConverterInt32.check_lower(value.request_timeout_ms)

    @staticmethod
    def write(value, buf):
        _UniffiConverterInt32.write(value.default_page_size, buf)
        _UniffiConverterSequenceTypeFeature.write(value.enabled_features, buf)
        _UniffiConverterInt32.write(value.max_move_value_depth, buf)
        _UniffiConverterInt32.write(value.max_output_nodes, buf)
        _UniffiConverterInt32.write(value.max_page_size, buf)
        _UniffiConverterInt32.write(value.max_query_depth, buf)
        _UniffiConverterInt32.write(value.max_query_nodes, buf)
        _UniffiConverterInt32.write(value.max_query_payload_size, buf)
        _UniffiConverterInt32.write(value.max_type_argument_depth, buf)
        _UniffiConverterInt32.write(value.max_type_argument_width, buf)
        _UniffiConverterInt32.write(value.max_type_nodes, buf)
        _UniffiConverterInt32.write(value.mutation_timeout_ms, buf)
        _UniffiConverterInt32.write(value.request_timeout_ms, buf)


class SignedTransaction:
    transaction: "Transaction"
    signatures: "typing.List[UserSignature]"
    def __init__(self, *, transaction: "Transaction", signatures: "typing.List[UserSignature]"):
        self.transaction = transaction
        self.signatures = signatures

    def __str__(self):
        return "SignedTransaction(transaction={}, signatures={})".format(self.transaction, self.signatures)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.signatures != other.signatures:
            return False
        return True

class _UniffiConverterTypeSignedTransaction(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignedTransaction(
            transaction=_UniffiConverterTypeTransaction.read(buf),
            signatures=_UniffiConverterSequenceTypeUserSignature.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTransaction.check_lower(value.transaction)
        _UniffiConverterSequenceTypeUserSignature.check_lower(value.signatures)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTransaction.write(value.transaction, buf)
        _UniffiConverterSequenceTypeUserSignature.write(value.signatures, buf)


class SignedTransactionPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[SignedTransaction]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[SignedTransaction]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "SignedTransactionPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeSignedTransactionPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SignedTransactionPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeSignedTransaction.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeSignedTransaction.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeSignedTransaction.write(value.data, buf)


class TransactionDataEffects:
    tx: "SignedTransaction"
    effects: "TransactionEffects"
    def __init__(self, *, tx: "SignedTransaction", effects: "TransactionEffects"):
        self.tx = tx
        self.effects = effects

    def __str__(self):
        return "TransactionDataEffects(tx={}, effects={})".format(self.tx, self.effects)

    def __eq__(self, other):
        if self.tx != other.tx:
            return False
        if self.effects != other.effects:
            return False
        return True

class _UniffiConverterTypeTransactionDataEffects(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionDataEffects(
            tx=_UniffiConverterTypeSignedTransaction.read(buf),
            effects=_UniffiConverterTypeTransactionEffects.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeSignedTransaction.check_lower(value.tx)
        _UniffiConverterTypeTransactionEffects.check_lower(value.effects)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeSignedTransaction.write(value.tx, buf)
        _UniffiConverterTypeTransactionEffects.write(value.effects, buf)


class TransactionDataEffectsPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[TransactionDataEffects]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[TransactionDataEffects]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "TransactionDataEffectsPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeTransactionDataEffectsPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionDataEffectsPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeTransactionDataEffects.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeTransactionDataEffects.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeTransactionDataEffects.write(value.data, buf)


class TransactionEffectsPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[TransactionEffects]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[TransactionEffects]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "TransactionEffectsPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeTransactionEffectsPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionEffectsPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeTransactionEffects.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeTransactionEffects.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeTransactionEffects.write(value.data, buf)


class TransactionEffectsV1:
    """
    Version 1 of TransactionEffects

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    effects-v1 = execution-status
    u64                                ; epoch
    gas-cost-summary
    digest                             ; transaction digest
    (option u32)                       ; gas object index
    (option digest)                    ; events digest
    (vector digest)                    ; list of transaction dependencies
    u64                                ; lamport version
    (vector changed-object)
    (vector unchanged-shared-object)
    (option digest)                    ; auxiliary data digest
    ```
    """

    status: "ExecutionStatus"
    """
    The status of the execution
    """

    epoch: "int"
    """
    The epoch when this transaction was executed.
    """

    gas_used: "GasCostSummary"
    """
    The gas used by this transaction
    """

    transaction_digest: "Digest"
    """
    The transaction digest
    """

    gas_object_index: "typing.Optional[int]"
    """
    The updated gas object reference, as an index into the `changed_objects`
    vector. Having a dedicated field for convenient access.
    System transaction that don't require gas will leave this as None.
    """

    events_digest: "typing.Optional[Digest]"
    """
    The digest of the events emitted during execution,
    can be None if the transaction does not emit any event.
    """

    dependencies: "typing.List[Digest]"
    """
    The set of transaction digests this transaction depends on.
    """

    lamport_version: "int"
    """
    The version number of all the written Move objects by this transaction.
    """

    changed_objects: "typing.List[ChangedObject]"
    """
    Objects whose state are changed in the object store.
    """

    unchanged_shared_objects: "typing.List[UnchangedSharedObject]"
    """
    Shared objects that are not mutated in this transaction. Unlike owned
    objects, read-only shared objects' version are not committed in the
    transaction, and in order for a node to catch up and execute it
    without consensus sequencing, the version needs to be committed in
    the effects.
    """

    auxiliary_data_digest: "typing.Optional[Digest]"
    """
    Auxiliary data that are not protocol-critical, generated as part of the
    effects but are stored separately. Storing it separately allows us
    to avoid bloating the effects with data that are not critical.
    It also provides more flexibility on the format and type of the data.
    """

    def __init__(self, *, status: "ExecutionStatus", epoch: "int", gas_used: "GasCostSummary", transaction_digest: "Digest", gas_object_index: "typing.Optional[int]" = _DEFAULT, events_digest: "typing.Optional[Digest]" = _DEFAULT, dependencies: "typing.List[Digest]", lamport_version: "int", changed_objects: "typing.List[ChangedObject]", unchanged_shared_objects: "typing.List[UnchangedSharedObject]", auxiliary_data_digest: "typing.Optional[Digest]" = _DEFAULT):
        self.status = status
        self.epoch = epoch
        self.gas_used = gas_used
        self.transaction_digest = transaction_digest
        if gas_object_index is _DEFAULT:
            self.gas_object_index = None
        else:
            self.gas_object_index = gas_object_index
        if events_digest is _DEFAULT:
            self.events_digest = None
        else:
            self.events_digest = events_digest
        self.dependencies = dependencies
        self.lamport_version = lamport_version
        self.changed_objects = changed_objects
        self.unchanged_shared_objects = unchanged_shared_objects
        if auxiliary_data_digest is _DEFAULT:
            self.auxiliary_data_digest = None
        else:
            self.auxiliary_data_digest = auxiliary_data_digest

    def __str__(self):
        return "TransactionEffectsV1(status={}, epoch={}, gas_used={}, transaction_digest={}, gas_object_index={}, events_digest={}, dependencies={}, lamport_version={}, changed_objects={}, unchanged_shared_objects={}, auxiliary_data_digest={})".format(self.status, self.epoch, self.gas_used, self.transaction_digest, self.gas_object_index, self.events_digest, self.dependencies, self.lamport_version, self.changed_objects, self.unchanged_shared_objects, self.auxiliary_data_digest)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.epoch != other.epoch:
            return False
        if self.gas_used != other.gas_used:
            return False
        if self.transaction_digest != other.transaction_digest:
            return False
        if self.gas_object_index != other.gas_object_index:
            return False
        if self.events_digest != other.events_digest:
            return False
        if self.dependencies != other.dependencies:
            return False
        if self.lamport_version != other.lamport_version:
            return False
        if self.changed_objects != other.changed_objects:
            return False
        if self.unchanged_shared_objects != other.unchanged_shared_objects:
            return False
        if self.auxiliary_data_digest != other.auxiliary_data_digest:
            return False
        return True

class _UniffiConverterTypeTransactionEffectsV1(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionEffectsV1(
            status=_UniffiConverterTypeExecutionStatus.read(buf),
            epoch=_UniffiConverterUInt64.read(buf),
            gas_used=_UniffiConverterTypeGasCostSummary.read(buf),
            transaction_digest=_UniffiConverterTypeDigest.read(buf),
            gas_object_index=_UniffiConverterOptionalUInt32.read(buf),
            events_digest=_UniffiConverterOptionalTypeDigest.read(buf),
            dependencies=_UniffiConverterSequenceTypeDigest.read(buf),
            lamport_version=_UniffiConverterUInt64.read(buf),
            changed_objects=_UniffiConverterSequenceTypeChangedObject.read(buf),
            unchanged_shared_objects=_UniffiConverterSequenceTypeUnchangedSharedObject.read(buf),
            auxiliary_data_digest=_UniffiConverterOptionalTypeDigest.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeExecutionStatus.check_lower(value.status)
        _UniffiConverterUInt64.check_lower(value.epoch)
        _UniffiConverterTypeGasCostSummary.check_lower(value.gas_used)
        _UniffiConverterTypeDigest.check_lower(value.transaction_digest)
        _UniffiConverterOptionalUInt32.check_lower(value.gas_object_index)
        _UniffiConverterOptionalTypeDigest.check_lower(value.events_digest)
        _UniffiConverterSequenceTypeDigest.check_lower(value.dependencies)
        _UniffiConverterUInt64.check_lower(value.lamport_version)
        _UniffiConverterSequenceTypeChangedObject.check_lower(value.changed_objects)
        _UniffiConverterSequenceTypeUnchangedSharedObject.check_lower(value.unchanged_shared_objects)
        _UniffiConverterOptionalTypeDigest.check_lower(value.auxiliary_data_digest)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeExecutionStatus.write(value.status, buf)
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterTypeGasCostSummary.write(value.gas_used, buf)
        _UniffiConverterTypeDigest.write(value.transaction_digest, buf)
        _UniffiConverterOptionalUInt32.write(value.gas_object_index, buf)
        _UniffiConverterOptionalTypeDigest.write(value.events_digest, buf)
        _UniffiConverterSequenceTypeDigest.write(value.dependencies, buf)
        _UniffiConverterUInt64.write(value.lamport_version, buf)
        _UniffiConverterSequenceTypeChangedObject.write(value.changed_objects, buf)
        _UniffiConverterSequenceTypeUnchangedSharedObject.write(value.unchanged_shared_objects, buf)
        _UniffiConverterOptionalTypeDigest.write(value.auxiliary_data_digest, buf)


class TransactionMetadata:
    gas_budget: "typing.Optional[int]"
    gas_objects: "typing.Optional[typing.List[ObjectRef]]"
    gas_price: "typing.Optional[int]"
    gas_sponsor: "typing.Optional[Address]"
    sender: "typing.Optional[Address]"
    def __init__(self, *, gas_budget: "typing.Optional[int]" = _DEFAULT, gas_objects: "typing.Optional[typing.List[ObjectRef]]" = _DEFAULT, gas_price: "typing.Optional[int]" = _DEFAULT, gas_sponsor: "typing.Optional[Address]" = _DEFAULT, sender: "typing.Optional[Address]" = _DEFAULT):
        if gas_budget is _DEFAULT:
            self.gas_budget = None
        else:
            self.gas_budget = gas_budget
        if gas_objects is _DEFAULT:
            self.gas_objects = None
        else:
            self.gas_objects = gas_objects
        if gas_price is _DEFAULT:
            self.gas_price = None
        else:
            self.gas_price = gas_price
        if gas_sponsor is _DEFAULT:
            self.gas_sponsor = None
        else:
            self.gas_sponsor = gas_sponsor
        if sender is _DEFAULT:
            self.sender = None
        else:
            self.sender = sender

    def __str__(self):
        return "TransactionMetadata(gas_budget={}, gas_objects={}, gas_price={}, gas_sponsor={}, sender={})".format(self.gas_budget, self.gas_objects, self.gas_price, self.gas_sponsor, self.sender)

    def __eq__(self, other):
        if self.gas_budget != other.gas_budget:
            return False
        if self.gas_objects != other.gas_objects:
            return False
        if self.gas_price != other.gas_price:
            return False
        if self.gas_sponsor != other.gas_sponsor:
            return False
        if self.sender != other.sender:
            return False
        return True

class _UniffiConverterTypeTransactionMetadata(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionMetadata(
            gas_budget=_UniffiConverterOptionalUInt64.read(buf),
            gas_objects=_UniffiConverterOptionalSequenceTypeObjectRef.read(buf),
            gas_price=_UniffiConverterOptionalUInt64.read(buf),
            gas_sponsor=_UniffiConverterOptionalTypeAddress.read(buf),
            sender=_UniffiConverterOptionalTypeAddress.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalUInt64.check_lower(value.gas_budget)
        _UniffiConverterOptionalSequenceTypeObjectRef.check_lower(value.gas_objects)
        _UniffiConverterOptionalUInt64.check_lower(value.gas_price)
        _UniffiConverterOptionalTypeAddress.check_lower(value.gas_sponsor)
        _UniffiConverterOptionalTypeAddress.check_lower(value.sender)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalUInt64.write(value.gas_budget, buf)
        _UniffiConverterOptionalSequenceTypeObjectRef.write(value.gas_objects, buf)
        _UniffiConverterOptionalUInt64.write(value.gas_price, buf)
        _UniffiConverterOptionalTypeAddress.write(value.gas_sponsor, buf)
        _UniffiConverterOptionalTypeAddress.write(value.sender, buf)


class TransactionsFilter:
    function: "typing.Optional[str]"
    kind: "typing.Optional[TransactionBlockKindInput]"
    after_checkpoint: "typing.Optional[int]"
    at_checkpoint: "typing.Optional[int]"
    before_checkpoint: "typing.Optional[int]"
    sign_address: "typing.Optional[Address]"
    recv_address: "typing.Optional[Address]"
    input_object: "typing.Optional[ObjectId]"
    changed_object: "typing.Optional[ObjectId]"
    transaction_ids: "typing.Optional[typing.List[str]]"
    wrapped_or_deleted_object: "typing.Optional[ObjectId]"
    def __init__(self, *, function: "typing.Optional[str]" = _DEFAULT, kind: "typing.Optional[TransactionBlockKindInput]" = _DEFAULT, after_checkpoint: "typing.Optional[int]" = _DEFAULT, at_checkpoint: "typing.Optional[int]" = _DEFAULT, before_checkpoint: "typing.Optional[int]" = _DEFAULT, sign_address: "typing.Optional[Address]" = _DEFAULT, recv_address: "typing.Optional[Address]" = _DEFAULT, input_object: "typing.Optional[ObjectId]" = _DEFAULT, changed_object: "typing.Optional[ObjectId]" = _DEFAULT, transaction_ids: "typing.Optional[typing.List[str]]" = _DEFAULT, wrapped_or_deleted_object: "typing.Optional[ObjectId]" = _DEFAULT):
        if function is _DEFAULT:
            self.function = None
        else:
            self.function = function
        if kind is _DEFAULT:
            self.kind = None
        else:
            self.kind = kind
        if after_checkpoint is _DEFAULT:
            self.after_checkpoint = None
        else:
            self.after_checkpoint = after_checkpoint
        if at_checkpoint is _DEFAULT:
            self.at_checkpoint = None
        else:
            self.at_checkpoint = at_checkpoint
        if before_checkpoint is _DEFAULT:
            self.before_checkpoint = None
        else:
            self.before_checkpoint = before_checkpoint
        if sign_address is _DEFAULT:
            self.sign_address = None
        else:
            self.sign_address = sign_address
        if recv_address is _DEFAULT:
            self.recv_address = None
        else:
            self.recv_address = recv_address
        if input_object is _DEFAULT:
            self.input_object = None
        else:
            self.input_object = input_object
        if changed_object is _DEFAULT:
            self.changed_object = None
        else:
            self.changed_object = changed_object
        if transaction_ids is _DEFAULT:
            self.transaction_ids = None
        else:
            self.transaction_ids = transaction_ids
        if wrapped_or_deleted_object is _DEFAULT:
            self.wrapped_or_deleted_object = None
        else:
            self.wrapped_or_deleted_object = wrapped_or_deleted_object

    def __str__(self):
        return "TransactionsFilter(function={}, kind={}, after_checkpoint={}, at_checkpoint={}, before_checkpoint={}, sign_address={}, recv_address={}, input_object={}, changed_object={}, transaction_ids={}, wrapped_or_deleted_object={})".format(self.function, self.kind, self.after_checkpoint, self.at_checkpoint, self.before_checkpoint, self.sign_address, self.recv_address, self.input_object, self.changed_object, self.transaction_ids, self.wrapped_or_deleted_object)

    def __eq__(self, other):
        if self.function != other.function:
            return False
        if self.kind != other.kind:
            return False
        if self.after_checkpoint != other.after_checkpoint:
            return False
        if self.at_checkpoint != other.at_checkpoint:
            return False
        if self.before_checkpoint != other.before_checkpoint:
            return False
        if self.sign_address != other.sign_address:
            return False
        if self.recv_address != other.recv_address:
            return False
        if self.input_object != other.input_object:
            return False
        if self.changed_object != other.changed_object:
            return False
        if self.transaction_ids != other.transaction_ids:
            return False
        if self.wrapped_or_deleted_object != other.wrapped_or_deleted_object:
            return False
        return True

class _UniffiConverterTypeTransactionsFilter(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransactionsFilter(
            function=_UniffiConverterOptionalString.read(buf),
            kind=_UniffiConverterOptionalTypeTransactionBlockKindInput.read(buf),
            after_checkpoint=_UniffiConverterOptionalUInt64.read(buf),
            at_checkpoint=_UniffiConverterOptionalUInt64.read(buf),
            before_checkpoint=_UniffiConverterOptionalUInt64.read(buf),
            sign_address=_UniffiConverterOptionalTypeAddress.read(buf),
            recv_address=_UniffiConverterOptionalTypeAddress.read(buf),
            input_object=_UniffiConverterOptionalTypeObjectId.read(buf),
            changed_object=_UniffiConverterOptionalTypeObjectId.read(buf),
            transaction_ids=_UniffiConverterOptionalSequenceString.read(buf),
            wrapped_or_deleted_object=_UniffiConverterOptionalTypeObjectId.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalString.check_lower(value.function)
        _UniffiConverterOptionalTypeTransactionBlockKindInput.check_lower(value.kind)
        _UniffiConverterOptionalUInt64.check_lower(value.after_checkpoint)
        _UniffiConverterOptionalUInt64.check_lower(value.at_checkpoint)
        _UniffiConverterOptionalUInt64.check_lower(value.before_checkpoint)
        _UniffiConverterOptionalTypeAddress.check_lower(value.sign_address)
        _UniffiConverterOptionalTypeAddress.check_lower(value.recv_address)
        _UniffiConverterOptionalTypeObjectId.check_lower(value.input_object)
        _UniffiConverterOptionalTypeObjectId.check_lower(value.changed_object)
        _UniffiConverterOptionalSequenceString.check_lower(value.transaction_ids)
        _UniffiConverterOptionalTypeObjectId.check_lower(value.wrapped_or_deleted_object)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalString.write(value.function, buf)
        _UniffiConverterOptionalTypeTransactionBlockKindInput.write(value.kind, buf)
        _UniffiConverterOptionalUInt64.write(value.after_checkpoint, buf)
        _UniffiConverterOptionalUInt64.write(value.at_checkpoint, buf)
        _UniffiConverterOptionalUInt64.write(value.before_checkpoint, buf)
        _UniffiConverterOptionalTypeAddress.write(value.sign_address, buf)
        _UniffiConverterOptionalTypeAddress.write(value.recv_address, buf)
        _UniffiConverterOptionalTypeObjectId.write(value.input_object, buf)
        _UniffiConverterOptionalTypeObjectId.write(value.changed_object, buf)
        _UniffiConverterOptionalSequenceString.write(value.transaction_ids, buf)
        _UniffiConverterOptionalTypeObjectId.write(value.wrapped_or_deleted_object, buf)


class TypeOrigin:
    """
    Identifies a struct and the module it was defined in

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    type-origin = identifier identifier object-id
    ```
    """

    module_name: "Identifier"
    struct_name: "Identifier"
    package: "ObjectId"
    def __init__(self, *, module_name: "Identifier", struct_name: "Identifier", package: "ObjectId"):
        self.module_name = module_name
        self.struct_name = struct_name
        self.package = package

    def __str__(self):
        return "TypeOrigin(module_name={}, struct_name={}, package={})".format(self.module_name, self.struct_name, self.package)

    def __eq__(self, other):
        if self.module_name != other.module_name:
            return False
        if self.struct_name != other.struct_name:
            return False
        if self.package != other.package:
            return False
        return True

class _UniffiConverterTypeTypeOrigin(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TypeOrigin(
            module_name=_UniffiConverterTypeIdentifier.read(buf),
            struct_name=_UniffiConverterTypeIdentifier.read(buf),
            package=_UniffiConverterTypeObjectId.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeIdentifier.check_lower(value.module_name)
        _UniffiConverterTypeIdentifier.check_lower(value.struct_name)
        _UniffiConverterTypeObjectId.check_lower(value.package)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeIdentifier.write(value.module_name, buf)
        _UniffiConverterTypeIdentifier.write(value.struct_name, buf)
        _UniffiConverterTypeObjectId.write(value.package, buf)


class UnchangedSharedObject:
    """
    A shared object that wasn't changed during execution

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    unchanged-shared-object = object-id unchanged-shared-object-kind
    ```
    """

    object_id: "ObjectId"
    kind: "UnchangedSharedKind"
    def __init__(self, *, object_id: "ObjectId", kind: "UnchangedSharedKind"):
        self.object_id = object_id
        self.kind = kind

    def __str__(self):
        return "UnchangedSharedObject(object_id={}, kind={})".format(self.object_id, self.kind)

    def __eq__(self, other):
        if self.object_id != other.object_id:
            return False
        if self.kind != other.kind:
            return False
        return True

class _UniffiConverterTypeUnchangedSharedObject(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UnchangedSharedObject(
            object_id=_UniffiConverterTypeObjectId.read(buf),
            kind=_UniffiConverterTypeUnchangedSharedKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.object_id)
        _UniffiConverterTypeUnchangedSharedKind.check_lower(value.kind)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.object_id, buf)
        _UniffiConverterTypeUnchangedSharedKind.write(value.kind, buf)


class UpgradeInfo:
    """
    Upgraded package info for the linkage table

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    upgrade-info = object-id u64
    ```
    """

    upgraded_id: "ObjectId"
    """
    Id of the upgraded packages
    """

    upgraded_version: "int"
    """
    Version of the upgraded package
    """

    def __init__(self, *, upgraded_id: "ObjectId", upgraded_version: "int"):
        self.upgraded_id = upgraded_id
        self.upgraded_version = upgraded_version

    def __str__(self):
        return "UpgradeInfo(upgraded_id={}, upgraded_version={})".format(self.upgraded_id, self.upgraded_version)

    def __eq__(self, other):
        if self.upgraded_id != other.upgraded_id:
            return False
        if self.upgraded_version != other.upgraded_version:
            return False
        return True

class _UniffiConverterTypeUpgradeInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return UpgradeInfo(
            upgraded_id=_UniffiConverterTypeObjectId.read(buf),
            upgraded_version=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeObjectId.check_lower(value.upgraded_id)
        _UniffiConverterUInt64.check_lower(value.upgraded_version)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeObjectId.write(value.upgraded_id, buf)
        _UniffiConverterUInt64.write(value.upgraded_version, buf)


class Validator:
    """
    Represents a validator in the system.
    """

    apy: "typing.Optional[int]"
    """
    The APY of this validator in basis points.
    To get the APY in percentage, divide by 100.
    """

    address: "Address"
    """
    The validator's address.
    """

    commission_rate: "typing.Optional[int]"
    """
    The fee charged by the validator for staking services.
    """

    credentials: "typing.Optional[ValidatorCredentials]"
    """
    Validator's credentials.
    """

    description: "typing.Optional[str]"
    """
    Validator's description.
    """

    exchange_rates_size: "typing.Optional[int]"
    """
    Number of exchange rates in the table.
    """

    gas_price: "typing.Optional[int]"
    """
    The reference gas price for this epoch.
    """

    name: "typing.Optional[str]"
    """
    Validator's name.
    """

    image_url: "typing.Optional[str]"
    """
    Validator's url containing their custom image.
    """

    next_epoch_commission_rate: "typing.Optional[int]"
    """
    The proposed next epoch fee for the validator's staking services.
    """

    next_epoch_credentials: "typing.Optional[ValidatorCredentials]"
    """
    Validator's credentials for the next epoch.
    """

    next_epoch_gas_price: "typing.Optional[int]"
    """
    The validator's gas price quote for the next epoch.
    """

    next_epoch_stake: "typing.Optional[int]"
    """
    The total number of IOTA tokens in this pool plus
    the pending stake amount for this epoch.
    """

    operation_cap: "typing.Optional[bytes]"
    """
    The validator's current valid `Cap` object. Validators can delegate
    the operation ability to another address. The address holding this `Cap`
    object can then update the reference gas price and tallying rule on
    behalf of the validator.
    """

    pending_pool_token_withdraw: "typing.Optional[int]"
    """
    Pending pool token withdrawn during the current epoch, emptied at epoch
    boundaries. Zero for past epochs.
    """

    pending_stake: "typing.Optional[int]"
    """
    Pending stake amount for the current epoch, emptied at epoch boundaries.
    Zero for past epochs.
    """

    pending_total_iota_withdraw: "typing.Optional[int]"
    """
    Pending stake withdrawn during the current epoch, emptied at epoch
    boundaries. Zero for past epochs.
    """

    pool_token_balance: "typing.Optional[int]"
    """
    Total number of pool tokens issued by the pool.
    """

    project_url: "typing.Optional[str]"
    """
    Validator's homepage URL.
    """

    rewards_pool: "typing.Optional[int]"
    """
    The epoch stake rewards will be added here at the end of each epoch.
    """

    staking_pool_activation_epoch: "typing.Optional[int]"
    """
    The epoch at which this pool became active.
    """

    staking_pool_id: "ObjectId"
    """
    The ID of this validator's `0x3::staking_pool::StakingPool`.
    """

    staking_pool_iota_balance: "typing.Optional[int]"
    """
    The total number of IOTA tokens in this pool.
    """

    voting_power: "typing.Optional[int]"
    """
    The voting power of this validator in basis points (e.g., 100 = 1%
    voting power).
    """

    def __init__(self, *, apy: "typing.Optional[int]" = _DEFAULT, address: "Address", commission_rate: "typing.Optional[int]" = _DEFAULT, credentials: "typing.Optional[ValidatorCredentials]" = _DEFAULT, description: "typing.Optional[str]" = _DEFAULT, exchange_rates_size: "typing.Optional[int]" = _DEFAULT, gas_price: "typing.Optional[int]" = _DEFAULT, name: "typing.Optional[str]" = _DEFAULT, image_url: "typing.Optional[str]" = _DEFAULT, next_epoch_commission_rate: "typing.Optional[int]" = _DEFAULT, next_epoch_credentials: "typing.Optional[ValidatorCredentials]" = _DEFAULT, next_epoch_gas_price: "typing.Optional[int]" = _DEFAULT, next_epoch_stake: "typing.Optional[int]" = _DEFAULT, operation_cap: "typing.Optional[bytes]" = _DEFAULT, pending_pool_token_withdraw: "typing.Optional[int]" = _DEFAULT, pending_stake: "typing.Optional[int]" = _DEFAULT, pending_total_iota_withdraw: "typing.Optional[int]" = _DEFAULT, pool_token_balance: "typing.Optional[int]" = _DEFAULT, project_url: "typing.Optional[str]" = _DEFAULT, rewards_pool: "typing.Optional[int]" = _DEFAULT, staking_pool_activation_epoch: "typing.Optional[int]" = _DEFAULT, staking_pool_id: "ObjectId", staking_pool_iota_balance: "typing.Optional[int]" = _DEFAULT, voting_power: "typing.Optional[int]" = _DEFAULT):
        if apy is _DEFAULT:
            self.apy = None
        else:
            self.apy = apy
        self.address = address
        if commission_rate is _DEFAULT:
            self.commission_rate = None
        else:
            self.commission_rate = commission_rate
        if credentials is _DEFAULT:
            self.credentials = None
        else:
            self.credentials = credentials
        if description is _DEFAULT:
            self.description = None
        else:
            self.description = description
        if exchange_rates_size is _DEFAULT:
            self.exchange_rates_size = None
        else:
            self.exchange_rates_size = exchange_rates_size
        if gas_price is _DEFAULT:
            self.gas_price = None
        else:
            self.gas_price = gas_price
        if name is _DEFAULT:
            self.name = None
        else:
            self.name = name
        if image_url is _DEFAULT:
            self.image_url = None
        else:
            self.image_url = image_url
        if next_epoch_commission_rate is _DEFAULT:
            self.next_epoch_commission_rate = None
        else:
            self.next_epoch_commission_rate = next_epoch_commission_rate
        if next_epoch_credentials is _DEFAULT:
            self.next_epoch_credentials = None
        else:
            self.next_epoch_credentials = next_epoch_credentials
        if next_epoch_gas_price is _DEFAULT:
            self.next_epoch_gas_price = None
        else:
            self.next_epoch_gas_price = next_epoch_gas_price
        if next_epoch_stake is _DEFAULT:
            self.next_epoch_stake = None
        else:
            self.next_epoch_stake = next_epoch_stake
        if operation_cap is _DEFAULT:
            self.operation_cap = None
        else:
            self.operation_cap = operation_cap
        if pending_pool_token_withdraw is _DEFAULT:
            self.pending_pool_token_withdraw = None
        else:
            self.pending_pool_token_withdraw = pending_pool_token_withdraw
        if pending_stake is _DEFAULT:
            self.pending_stake = None
        else:
            self.pending_stake = pending_stake
        if pending_total_iota_withdraw is _DEFAULT:
            self.pending_total_iota_withdraw = None
        else:
            self.pending_total_iota_withdraw = pending_total_iota_withdraw
        if pool_token_balance is _DEFAULT:
            self.pool_token_balance = None
        else:
            self.pool_token_balance = pool_token_balance
        if project_url is _DEFAULT:
            self.project_url = None
        else:
            self.project_url = project_url
        if rewards_pool is _DEFAULT:
            self.rewards_pool = None
        else:
            self.rewards_pool = rewards_pool
        if staking_pool_activation_epoch is _DEFAULT:
            self.staking_pool_activation_epoch = None
        else:
            self.staking_pool_activation_epoch = staking_pool_activation_epoch
        self.staking_pool_id = staking_pool_id
        if staking_pool_iota_balance is _DEFAULT:
            self.staking_pool_iota_balance = None
        else:
            self.staking_pool_iota_balance = staking_pool_iota_balance
        if voting_power is _DEFAULT:
            self.voting_power = None
        else:
            self.voting_power = voting_power

    def __str__(self):
        return "Validator(apy={}, address={}, commission_rate={}, credentials={}, description={}, exchange_rates_size={}, gas_price={}, name={}, image_url={}, next_epoch_commission_rate={}, next_epoch_credentials={}, next_epoch_gas_price={}, next_epoch_stake={}, operation_cap={}, pending_pool_token_withdraw={}, pending_stake={}, pending_total_iota_withdraw={}, pool_token_balance={}, project_url={}, rewards_pool={}, staking_pool_activation_epoch={}, staking_pool_id={}, staking_pool_iota_balance={}, voting_power={})".format(self.apy, self.address, self.commission_rate, self.credentials, self.description, self.exchange_rates_size, self.gas_price, self.name, self.image_url, self.next_epoch_commission_rate, self.next_epoch_credentials, self.next_epoch_gas_price, self.next_epoch_stake, self.operation_cap, self.pending_pool_token_withdraw, self.pending_stake, self.pending_total_iota_withdraw, self.pool_token_balance, self.project_url, self.rewards_pool, self.staking_pool_activation_epoch, self.staking_pool_id, self.staking_pool_iota_balance, self.voting_power)

    def __eq__(self, other):
        if self.apy != other.apy:
            return False
        if self.address != other.address:
            return False
        if self.commission_rate != other.commission_rate:
            return False
        if self.credentials != other.credentials:
            return False
        if self.description != other.description:
            return False
        if self.exchange_rates_size != other.exchange_rates_size:
            return False
        if self.gas_price != other.gas_price:
            return False
        if self.name != other.name:
            return False
        if self.image_url != other.image_url:
            return False
        if self.next_epoch_commission_rate != other.next_epoch_commission_rate:
            return False
        if self.next_epoch_credentials != other.next_epoch_credentials:
            return False
        if self.next_epoch_gas_price != other.next_epoch_gas_price:
            return False
        if self.next_epoch_stake != other.next_epoch_stake:
            return False
        if self.operation_cap != other.operation_cap:
            return False
        if self.pending_pool_token_withdraw != other.pending_pool_token_withdraw:
            return False
        if self.pending_stake != other.pending_stake:
            return False
        if self.pending_total_iota_withdraw != other.pending_total_iota_withdraw:
            return False
        if self.pool_token_balance != other.pool_token_balance:
            return False
        if self.project_url != other.project_url:
            return False
        if self.rewards_pool != other.rewards_pool:
            return False
        if self.staking_pool_activation_epoch != other.staking_pool_activation_epoch:
            return False
        if self.staking_pool_id != other.staking_pool_id:
            return False
        if self.staking_pool_iota_balance != other.staking_pool_iota_balance:
            return False
        if self.voting_power != other.voting_power:
            return False
        return True

class _UniffiConverterTypeValidator(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Validator(
            apy=_UniffiConverterOptionalInt32.read(buf),
            address=_UniffiConverterTypeAddress.read(buf),
            commission_rate=_UniffiConverterOptionalInt32.read(buf),
            credentials=_UniffiConverterOptionalTypeValidatorCredentials.read(buf),
            description=_UniffiConverterOptionalString.read(buf),
            exchange_rates_size=_UniffiConverterOptionalUInt64.read(buf),
            gas_price=_UniffiConverterOptionalUInt64.read(buf),
            name=_UniffiConverterOptionalString.read(buf),
            image_url=_UniffiConverterOptionalString.read(buf),
            next_epoch_commission_rate=_UniffiConverterOptionalInt32.read(buf),
            next_epoch_credentials=_UniffiConverterOptionalTypeValidatorCredentials.read(buf),
            next_epoch_gas_price=_UniffiConverterOptionalUInt64.read(buf),
            next_epoch_stake=_UniffiConverterOptionalUInt64.read(buf),
            operation_cap=_UniffiConverterOptionalBytes.read(buf),
            pending_pool_token_withdraw=_UniffiConverterOptionalUInt64.read(buf),
            pending_stake=_UniffiConverterOptionalUInt64.read(buf),
            pending_total_iota_withdraw=_UniffiConverterOptionalUInt64.read(buf),
            pool_token_balance=_UniffiConverterOptionalUInt64.read(buf),
            project_url=_UniffiConverterOptionalString.read(buf),
            rewards_pool=_UniffiConverterOptionalUInt64.read(buf),
            staking_pool_activation_epoch=_UniffiConverterOptionalUInt64.read(buf),
            staking_pool_id=_UniffiConverterTypeObjectId.read(buf),
            staking_pool_iota_balance=_UniffiConverterOptionalUInt64.read(buf),
            voting_power=_UniffiConverterOptionalInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalInt32.check_lower(value.apy)
        _UniffiConverterTypeAddress.check_lower(value.address)
        _UniffiConverterOptionalInt32.check_lower(value.commission_rate)
        _UniffiConverterOptionalTypeValidatorCredentials.check_lower(value.credentials)
        _UniffiConverterOptionalString.check_lower(value.description)
        _UniffiConverterOptionalUInt64.check_lower(value.exchange_rates_size)
        _UniffiConverterOptionalUInt64.check_lower(value.gas_price)
        _UniffiConverterOptionalString.check_lower(value.name)
        _UniffiConverterOptionalString.check_lower(value.image_url)
        _UniffiConverterOptionalInt32.check_lower(value.next_epoch_commission_rate)
        _UniffiConverterOptionalTypeValidatorCredentials.check_lower(value.next_epoch_credentials)
        _UniffiConverterOptionalUInt64.check_lower(value.next_epoch_gas_price)
        _UniffiConverterOptionalUInt64.check_lower(value.next_epoch_stake)
        _UniffiConverterOptionalBytes.check_lower(value.operation_cap)
        _UniffiConverterOptionalUInt64.check_lower(value.pending_pool_token_withdraw)
        _UniffiConverterOptionalUInt64.check_lower(value.pending_stake)
        _UniffiConverterOptionalUInt64.check_lower(value.pending_total_iota_withdraw)
        _UniffiConverterOptionalUInt64.check_lower(value.pool_token_balance)
        _UniffiConverterOptionalString.check_lower(value.project_url)
        _UniffiConverterOptionalUInt64.check_lower(value.rewards_pool)
        _UniffiConverterOptionalUInt64.check_lower(value.staking_pool_activation_epoch)
        _UniffiConverterTypeObjectId.check_lower(value.staking_pool_id)
        _UniffiConverterOptionalUInt64.check_lower(value.staking_pool_iota_balance)
        _UniffiConverterOptionalInt32.check_lower(value.voting_power)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalInt32.write(value.apy, buf)
        _UniffiConverterTypeAddress.write(value.address, buf)
        _UniffiConverterOptionalInt32.write(value.commission_rate, buf)
        _UniffiConverterOptionalTypeValidatorCredentials.write(value.credentials, buf)
        _UniffiConverterOptionalString.write(value.description, buf)
        _UniffiConverterOptionalUInt64.write(value.exchange_rates_size, buf)
        _UniffiConverterOptionalUInt64.write(value.gas_price, buf)
        _UniffiConverterOptionalString.write(value.name, buf)
        _UniffiConverterOptionalString.write(value.image_url, buf)
        _UniffiConverterOptionalInt32.write(value.next_epoch_commission_rate, buf)
        _UniffiConverterOptionalTypeValidatorCredentials.write(value.next_epoch_credentials, buf)
        _UniffiConverterOptionalUInt64.write(value.next_epoch_gas_price, buf)
        _UniffiConverterOptionalUInt64.write(value.next_epoch_stake, buf)
        _UniffiConverterOptionalBytes.write(value.operation_cap, buf)
        _UniffiConverterOptionalUInt64.write(value.pending_pool_token_withdraw, buf)
        _UniffiConverterOptionalUInt64.write(value.pending_stake, buf)
        _UniffiConverterOptionalUInt64.write(value.pending_total_iota_withdraw, buf)
        _UniffiConverterOptionalUInt64.write(value.pool_token_balance, buf)
        _UniffiConverterOptionalString.write(value.project_url, buf)
        _UniffiConverterOptionalUInt64.write(value.rewards_pool, buf)
        _UniffiConverterOptionalUInt64.write(value.staking_pool_activation_epoch, buf)
        _UniffiConverterTypeObjectId.write(value.staking_pool_id, buf)
        _UniffiConverterOptionalUInt64.write(value.staking_pool_iota_balance, buf)
        _UniffiConverterOptionalInt32.write(value.voting_power, buf)


class ValidatorCommittee:
    """
    The Validator Set for a particular epoch.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    validator-committee = u64 ; epoch
    (vector validator-committee-member)
    ```
    """

    epoch: "int"
    members: "typing.List[ValidatorCommitteeMember]"
    def __init__(self, *, epoch: "int", members: "typing.List[ValidatorCommitteeMember]"):
        self.epoch = epoch
        self.members = members

    def __str__(self):
        return "ValidatorCommittee(epoch={}, members={})".format(self.epoch, self.members)

    def __eq__(self, other):
        if self.epoch != other.epoch:
            return False
        if self.members != other.members:
            return False
        return True

class _UniffiConverterTypeValidatorCommittee(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorCommittee(
            epoch=_UniffiConverterUInt64.read(buf),
            members=_UniffiConverterSequenceTypeValidatorCommitteeMember.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.epoch)
        _UniffiConverterSequenceTypeValidatorCommitteeMember.check_lower(value.members)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.epoch, buf)
        _UniffiConverterSequenceTypeValidatorCommitteeMember.write(value.members, buf)


class ValidatorCommitteeMember:
    """
    A member of a Validator Committee

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    validator-committee-member = bls-public-key
    u64 ; stake
    ```
    """

    public_key: "Bls12381PublicKey"
    stake: "int"
    def __init__(self, *, public_key: "Bls12381PublicKey", stake: "int"):
        self.public_key = public_key
        self.stake = stake

    def __str__(self):
        return "ValidatorCommitteeMember(public_key={}, stake={})".format(self.public_key, self.stake)

    def __eq__(self, other):
        if self.public_key != other.public_key:
            return False
        if self.stake != other.stake:
            return False
        return True

class _UniffiConverterTypeValidatorCommitteeMember(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorCommitteeMember(
            public_key=_UniffiConverterTypeBls12381PublicKey.read(buf),
            stake=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeBls12381PublicKey.check_lower(value.public_key)
        _UniffiConverterUInt64.check_lower(value.stake)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeBls12381PublicKey.write(value.public_key, buf)
        _UniffiConverterUInt64.write(value.stake, buf)


class ValidatorConnection:
    page_info: "PageInfo"
    nodes: "typing.List[Validator]"
    def __init__(self, *, page_info: "PageInfo", nodes: "typing.List[Validator]"):
        self.page_info = page_info
        self.nodes = nodes

    def __str__(self):
        return "ValidatorConnection(page_info={}, nodes={})".format(self.page_info, self.nodes)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.nodes != other.nodes:
            return False
        return True

class _UniffiConverterTypeValidatorConnection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorConnection(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            nodes=_UniffiConverterSequenceTypeValidator.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeValidator.check_lower(value.nodes)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeValidator.write(value.nodes, buf)


class ValidatorCredentials:
    """
    The credentials related fields associated with a validator.
    """

    authority_pub_key: "typing.Optional[Base64]"
    network_pub_key: "typing.Optional[Base64]"
    protocol_pub_key: "typing.Optional[Base64]"
    proof_of_possession: "typing.Optional[Base64]"
    net_address: "typing.Optional[str]"
    p2p_address: "typing.Optional[str]"
    primary_address: "typing.Optional[str]"
    def __init__(self, *, authority_pub_key: "typing.Optional[Base64]" = _DEFAULT, network_pub_key: "typing.Optional[Base64]" = _DEFAULT, protocol_pub_key: "typing.Optional[Base64]" = _DEFAULT, proof_of_possession: "typing.Optional[Base64]" = _DEFAULT, net_address: "typing.Optional[str]" = _DEFAULT, p2p_address: "typing.Optional[str]" = _DEFAULT, primary_address: "typing.Optional[str]" = _DEFAULT):
        if authority_pub_key is _DEFAULT:
            self.authority_pub_key = None
        else:
            self.authority_pub_key = authority_pub_key
        if network_pub_key is _DEFAULT:
            self.network_pub_key = None
        else:
            self.network_pub_key = network_pub_key
        if protocol_pub_key is _DEFAULT:
            self.protocol_pub_key = None
        else:
            self.protocol_pub_key = protocol_pub_key
        if proof_of_possession is _DEFAULT:
            self.proof_of_possession = None
        else:
            self.proof_of_possession = proof_of_possession
        if net_address is _DEFAULT:
            self.net_address = None
        else:
            self.net_address = net_address
        if p2p_address is _DEFAULT:
            self.p2p_address = None
        else:
            self.p2p_address = p2p_address
        if primary_address is _DEFAULT:
            self.primary_address = None
        else:
            self.primary_address = primary_address

    def __str__(self):
        return "ValidatorCredentials(authority_pub_key={}, network_pub_key={}, protocol_pub_key={}, proof_of_possession={}, net_address={}, p2p_address={}, primary_address={})".format(self.authority_pub_key, self.network_pub_key, self.protocol_pub_key, self.proof_of_possession, self.net_address, self.p2p_address, self.primary_address)

    def __eq__(self, other):
        if self.authority_pub_key != other.authority_pub_key:
            return False
        if self.network_pub_key != other.network_pub_key:
            return False
        if self.protocol_pub_key != other.protocol_pub_key:
            return False
        if self.proof_of_possession != other.proof_of_possession:
            return False
        if self.net_address != other.net_address:
            return False
        if self.p2p_address != other.p2p_address:
            return False
        if self.primary_address != other.primary_address:
            return False
        return True

class _UniffiConverterTypeValidatorCredentials(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorCredentials(
            authority_pub_key=_UniffiConverterOptionalTypeBase64.read(buf),
            network_pub_key=_UniffiConverterOptionalTypeBase64.read(buf),
            protocol_pub_key=_UniffiConverterOptionalTypeBase64.read(buf),
            proof_of_possession=_UniffiConverterOptionalTypeBase64.read(buf),
            net_address=_UniffiConverterOptionalString.read(buf),
            p2p_address=_UniffiConverterOptionalString.read(buf),
            primary_address=_UniffiConverterOptionalString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeBase64.check_lower(value.authority_pub_key)
        _UniffiConverterOptionalTypeBase64.check_lower(value.network_pub_key)
        _UniffiConverterOptionalTypeBase64.check_lower(value.protocol_pub_key)
        _UniffiConverterOptionalTypeBase64.check_lower(value.proof_of_possession)
        _UniffiConverterOptionalString.check_lower(value.net_address)
        _UniffiConverterOptionalString.check_lower(value.p2p_address)
        _UniffiConverterOptionalString.check_lower(value.primary_address)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeBase64.write(value.authority_pub_key, buf)
        _UniffiConverterOptionalTypeBase64.write(value.network_pub_key, buf)
        _UniffiConverterOptionalTypeBase64.write(value.protocol_pub_key, buf)
        _UniffiConverterOptionalTypeBase64.write(value.proof_of_possession, buf)
        _UniffiConverterOptionalString.write(value.net_address, buf)
        _UniffiConverterOptionalString.write(value.p2p_address, buf)
        _UniffiConverterOptionalString.write(value.primary_address, buf)


class ValidatorPage:
    """
    A page of items returned by the GraphQL server.
    """

    page_info: "PageInfo"
    """
    Information about the page, such as the cursor and whether there are
    more pages.
    """

    data: "typing.List[Validator]"
    """
    The data returned by the server.
    """

    def __init__(self, *, page_info: "PageInfo", data: "typing.List[Validator]"):
        self.page_info = page_info
        self.data = data

    def __str__(self):
        return "ValidatorPage(page_info={}, data={})".format(self.page_info, self.data)

    def __eq__(self, other):
        if self.page_info != other.page_info:
            return False
        if self.data != other.data:
            return False
        return True

class _UniffiConverterTypeValidatorPage(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorPage(
            page_info=_UniffiConverterTypePageInfo.read(buf),
            data=_UniffiConverterSequenceTypeValidator.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePageInfo.check_lower(value.page_info)
        _UniffiConverterSequenceTypeValidator.check_lower(value.data)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePageInfo.write(value.page_info, buf)
        _UniffiConverterSequenceTypeValidator.write(value.data, buf)


class ValidatorSet:
    inactive_pools_id: "typing.Optional[ObjectId]"
    """
    Object ID of the `Table` storing the inactive staking pools.
    """

    inactive_pools_size: "typing.Optional[int]"
    """
    Size of the inactive pools `Table`.
    """

    pending_active_validators_id: "typing.Optional[ObjectId]"
    """
    Object ID of the wrapped object `TableVec` storing the pending active
    validators.
    """

    pending_active_validators_size: "typing.Optional[int]"
    """
    Size of the pending active validators table.
    """

    pending_removals: "typing.Optional[typing.List[int]]"
    """
    Validators that are pending removal from the active validator set,
    expressed as indices in to `activeValidators`.
    """

    staking_pool_mappings_id: "typing.Optional[ObjectId]"
    """
    Object ID of the `Table` storing the mapping from staking pool ids to
    the addresses of the corresponding validators. This is needed
    because a validator's address can potentially change but the object
    ID of its pool will not.
    """

    staking_pool_mappings_size: "typing.Optional[int]"
    """
    Size of the stake pool mappings `Table`.
    """

    total_stake: "typing.Optional[str]"
    """
    Total amount of stake for all active validators at the beginning of the
    epoch.
    """

    validator_candidates_size: "typing.Optional[int]"
    """
    Size of the validator candidates `Table`.
    """

    validator_candidates_id: "typing.Optional[ObjectId]"
    """
    Object ID of the `Table` storing the validator candidates.
    """

    def __init__(self, *, inactive_pools_id: "typing.Optional[ObjectId]" = _DEFAULT, inactive_pools_size: "typing.Optional[int]" = _DEFAULT, pending_active_validators_id: "typing.Optional[ObjectId]" = _DEFAULT, pending_active_validators_size: "typing.Optional[int]" = _DEFAULT, pending_removals: "typing.Optional[typing.List[int]]" = _DEFAULT, staking_pool_mappings_id: "typing.Optional[ObjectId]" = _DEFAULT, staking_pool_mappings_size: "typing.Optional[int]" = _DEFAULT, total_stake: "typing.Optional[str]" = _DEFAULT, validator_candidates_size: "typing.Optional[int]" = _DEFAULT, validator_candidates_id: "typing.Optional[ObjectId]" = _DEFAULT):
        if inactive_pools_id is _DEFAULT:
            self.inactive_pools_id = None
        else:
            self.inactive_pools_id = inactive_pools_id
        if inactive_pools_size is _DEFAULT:
            self.inactive_pools_size = None
        else:
            self.inactive_pools_size = inactive_pools_size
        if pending_active_validators_id is _DEFAULT:
            self.pending_active_validators_id = None
        else:
            self.pending_active_validators_id = pending_active_validators_id
        if pending_active_validators_size is _DEFAULT:
            self.pending_active_validators_size = None
        else:
            self.pending_active_validators_size = pending_active_validators_size
        if pending_removals is _DEFAULT:
            self.pending_removals = None
        else:
            self.pending_removals = pending_removals
        if staking_pool_mappings_id is _DEFAULT:
            self.staking_pool_mappings_id = None
        else:
            self.staking_pool_mappings_id = staking_pool_mappings_id
        if staking_pool_mappings_size is _DEFAULT:
            self.staking_pool_mappings_size = None
        else:
            self.staking_pool_mappings_size = staking_pool_mappings_size
        if total_stake is _DEFAULT:
            self.total_stake = None
        else:
            self.total_stake = total_stake
        if validator_candidates_size is _DEFAULT:
            self.validator_candidates_size = None
        else:
            self.validator_candidates_size = validator_candidates_size
        if validator_candidates_id is _DEFAULT:
            self.validator_candidates_id = None
        else:
            self.validator_candidates_id = validator_candidates_id

    def __str__(self):
        return "ValidatorSet(inactive_pools_id={}, inactive_pools_size={}, pending_active_validators_id={}, pending_active_validators_size={}, pending_removals={}, staking_pool_mappings_id={}, staking_pool_mappings_size={}, total_stake={}, validator_candidates_size={}, validator_candidates_id={})".format(self.inactive_pools_id, self.inactive_pools_size, self.pending_active_validators_id, self.pending_active_validators_size, self.pending_removals, self.staking_pool_mappings_id, self.staking_pool_mappings_size, self.total_stake, self.validator_candidates_size, self.validator_candidates_id)

    def __eq__(self, other):
        if self.inactive_pools_id != other.inactive_pools_id:
            return False
        if self.inactive_pools_size != other.inactive_pools_size:
            return False
        if self.pending_active_validators_id != other.pending_active_validators_id:
            return False
        if self.pending_active_validators_size != other.pending_active_validators_size:
            return False
        if self.pending_removals != other.pending_removals:
            return False
        if self.staking_pool_mappings_id != other.staking_pool_mappings_id:
            return False
        if self.staking_pool_mappings_size != other.staking_pool_mappings_size:
            return False
        if self.total_stake != other.total_stake:
            return False
        if self.validator_candidates_size != other.validator_candidates_size:
            return False
        if self.validator_candidates_id != other.validator_candidates_id:
            return False
        return True

class _UniffiConverterTypeValidatorSet(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ValidatorSet(
            inactive_pools_id=_UniffiConverterOptionalTypeObjectId.read(buf),
            inactive_pools_size=_UniffiConverterOptionalInt32.read(buf),
            pending_active_validators_id=_UniffiConverterOptionalTypeObjectId.read(buf),
            pending_active_validators_size=_UniffiConverterOptionalInt32.read(buf),
            pending_removals=_UniffiConverterOptionalSequenceInt32.read(buf),
            staking_pool_mappings_id=_UniffiConverterOptionalTypeObjectId.read(buf),
            staking_pool_mappings_size=_UniffiConverterOptionalInt32.read(buf),
            total_stake=_UniffiConverterOptionalString.read(buf),
            validator_candidates_size=_UniffiConverterOptionalInt32.read(buf),
            validator_candidates_id=_UniffiConverterOptionalTypeObjectId.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterOptionalTypeObjectId.check_lower(value.inactive_pools_id)
        _UniffiConverterOptionalInt32.check_lower(value.inactive_pools_size)
        _UniffiConverterOptionalTypeObjectId.check_lower(value.pending_active_validators_id)
        _UniffiConverterOptionalInt32.check_lower(value.pending_active_validators_size)
        _UniffiConverterOptionalSequenceInt32.check_lower(value.pending_removals)
        _UniffiConverterOptionalTypeObjectId.check_lower(value.staking_pool_mappings_id)
        _UniffiConverterOptionalInt32.check_lower(value.staking_pool_mappings_size)
        _UniffiConverterOptionalString.check_lower(value.total_stake)
        _UniffiConverterOptionalInt32.check_lower(value.validator_candidates_size)
        _UniffiConverterOptionalTypeObjectId.check_lower(value.validator_candidates_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterOptionalTypeObjectId.write(value.inactive_pools_id, buf)
        _UniffiConverterOptionalInt32.write(value.inactive_pools_size, buf)
        _UniffiConverterOptionalTypeObjectId.write(value.pending_active_validators_id, buf)
        _UniffiConverterOptionalInt32.write(value.pending_active_validators_size, buf)
        _UniffiConverterOptionalSequenceInt32.write(value.pending_removals, buf)
        _UniffiConverterOptionalTypeObjectId.write(value.staking_pool_mappings_id, buf)
        _UniffiConverterOptionalInt32.write(value.staking_pool_mappings_size, buf)
        _UniffiConverterOptionalString.write(value.total_stake, buf)
        _UniffiConverterOptionalInt32.write(value.validator_candidates_size, buf)
        _UniffiConverterOptionalTypeObjectId.write(value.validator_candidates_id, buf)


class ZkLoginClaim:
    """
    A claim of the iss in a zklogin proof

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-claim = string u8
    ```
    """

    value: "str"
    index_mod_4: "int"
    def __init__(self, *, value: "str", index_mod_4: "int"):
        self.value = value
        self.index_mod_4 = index_mod_4

    def __str__(self):
        return "ZkLoginClaim(value={}, index_mod_4={})".format(self.value, self.index_mod_4)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.index_mod_4 != other.index_mod_4:
            return False
        return True

class _UniffiConverterTypeZkLoginClaim(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ZkLoginClaim(
            value=_UniffiConverterString.read(buf),
            index_mod_4=_UniffiConverterUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.value)
        _UniffiConverterUInt8.check_lower(value.index_mod_4)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.value, buf)
        _UniffiConverterUInt8.write(value.index_mod_4, buf)





class BatchSendStatusType(enum.Enum):
    IN_PROGRESS = 0
    
    SUCCEEDED = 1
    
    DISCARDED = 2
    


class _UniffiConverterTypeBatchSendStatusType(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return BatchSendStatusType.IN_PROGRESS
        if variant == 2:
            return BatchSendStatusType.SUCCEEDED
        if variant == 3:
            return BatchSendStatusType.DISCARDED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == BatchSendStatusType.IN_PROGRESS:
            return
        if value == BatchSendStatusType.SUCCEEDED:
            return
        if value == BatchSendStatusType.DISCARDED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == BatchSendStatusType.IN_PROGRESS:
            buf.write_i32(1)
        if value == BatchSendStatusType.SUCCEEDED:
            buf.write_i32(2)
        if value == BatchSendStatusType.DISCARDED:
            buf.write_i32(3)







class CommandArgumentError:
    """
    An error with an argument to a command

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    command-argument-error =  type-mismatch
    =/ invalid-bcs-bytes
    =/ invalid-usage-of-pure-argument
    =/ invalid-argument-to-private-entry-function
    =/ index-out-of-bounds
    =/ secondary-index-out-of-bound
    =/ invalid-result-arity
    =/ invalid-gas-coin-usage
    =/ invalid-value-usage
    =/ invalid-object-by-value
    =/ invalid-object-by-mut-ref
    =/ shared-object-operation-not-allowed

    type-mismatch                               = %x00
    invalid-bcs-bytes                           = %x01
    invalid-usage-of-pure-argument              = %x02
    invalid-argument-to-private-entry-function  = %x03
    index-out-of-bounds                         = %x04 u16
    secondary-index-out-of-bound                = %x05 u16 u16
    invalid-result-arity                        = %x06 u16
    invalid-gas-coin-usage                      = %x07
    invalid-value-usage                         = %x08
    invalid-object-by-value                     = %x09
    invalid-object-by-mut-ref                   = %x0a
    shared-object-operation-not-allowed         = %x0b
    ```
    """

    def __init__(self):
        raise RuntimeError("CommandArgumentError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class TYPE_MISMATCH:
        """
        The type of the value does not match the expected type
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.TYPE_MISMATCH()".format()

        def __eq__(self, other):
            if not other.is_TYPE_MISMATCH():
                return False
            return True
    
    class INVALID_BCS_BYTES:
        """
        The argument cannot be deserialized into a value of the specified type
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_BCS_BYTES()".format()

        def __eq__(self, other):
            if not other.is_INVALID_BCS_BYTES():
                return False
            return True
    
    class INVALID_USAGE_OF_PURE_ARGUMENT:
        """
        The argument cannot be instantiated from raw bytes
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT()".format()

        def __eq__(self, other):
            if not other.is_INVALID_USAGE_OF_PURE_ARGUMENT():
                return False
            return True
    
    class INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION:
        """
        Invalid argument to private entry function.
        Private entry functions cannot take arguments from other Move functions.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION()".format()

        def __eq__(self, other):
            if not other.is_INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION():
                return False
            return True
    
    class INDEX_OUT_OF_BOUNDS:
        """
        Out of bounds access to input or results
        """

        index: "int"

        def __init__(self,index: "int"):
            self.index = index

        def __str__(self):
            return "CommandArgumentError.INDEX_OUT_OF_BOUNDS(index={})".format(self.index)

        def __eq__(self, other):
            if not other.is_INDEX_OUT_OF_BOUNDS():
                return False
            if self.index != other.index:
                return False
            return True
    
    class SECONDARY_INDEX_OUT_OF_BOUNDS:
        """
        Out of bounds access to subresult
        """

        result: "int"
        subresult: "int"

        def __init__(self,result: "int", subresult: "int"):
            self.result = result
            self.subresult = subresult

        def __str__(self):
            return "CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS(result={}, subresult={})".format(self.result, self.subresult)

        def __eq__(self, other):
            if not other.is_SECONDARY_INDEX_OUT_OF_BOUNDS():
                return False
            if self.result != other.result:
                return False
            if self.subresult != other.subresult:
                return False
            return True
    
    class INVALID_RESULT_ARITY:
        """
        Invalid usage of result.
        Expected a single result but found either no return value or multiple.
        """

        result: "int"

        def __init__(self,result: "int"):
            self.result = result

        def __str__(self):
            return "CommandArgumentError.INVALID_RESULT_ARITY(result={})".format(self.result)

        def __eq__(self, other):
            if not other.is_INVALID_RESULT_ARITY():
                return False
            if self.result != other.result:
                return False
            return True
    
    class INVALID_GAS_COIN_USAGE:
        """
        Invalid usage of Gas coin.
        The Gas coin can only be used by-value with a TransferObjects command.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_GAS_COIN_USAGE()".format()

        def __eq__(self, other):
            if not other.is_INVALID_GAS_COIN_USAGE():
                return False
            return True
    
    class INVALID_VALUE_USAGE:
        """
        Invalid usage of move value.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_VALUE_USAGE()".format()

        def __eq__(self, other):
            if not other.is_INVALID_VALUE_USAGE():
                return False
            return True
    
    class INVALID_OBJECT_BY_VALUE:
        """
        Immutable objects cannot be passed by-value.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_OBJECT_BY_VALUE()".format()

        def __eq__(self, other):
            if not other.is_INVALID_OBJECT_BY_VALUE():
                return False
            return True
    
    class INVALID_OBJECT_BY_MUT_REF:
        """
        Immutable objects cannot be passed by mutable reference, &mut.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_OBJECT_BY_MUT_REF()".format()

        def __eq__(self, other):
            if not other.is_INVALID_OBJECT_BY_MUT_REF():
                return False
            return True
    
    class SHARED_OBJECT_OPERATION_NOT_ALLOWED:
        """
        Shared object operations such a wrapping, freezing, or converting to
        owned are not allowed.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED()".format()

        def __eq__(self, other):
            if not other.is_SHARED_OBJECT_OPERATION_NOT_ALLOWED():
                return False
            return True
    
    class INVALID_ARGUMENT_ARITY:
        """
        Invalid argument arity. Expected a single argument but found a result
        that expanded to multiple arguments.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "CommandArgumentError.INVALID_ARGUMENT_ARITY()".format()

        def __eq__(self, other):
            if not other.is_INVALID_ARGUMENT_ARITY():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_TYPE_MISMATCH(self) -> bool:
        return isinstance(self, CommandArgumentError.TYPE_MISMATCH)
    def is_type_mismatch(self) -> bool:
        return isinstance(self, CommandArgumentError.TYPE_MISMATCH)
    def is_INVALID_BCS_BYTES(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_BCS_BYTES)
    def is_invalid_bcs_bytes(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_BCS_BYTES)
    def is_INVALID_USAGE_OF_PURE_ARGUMENT(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT)
    def is_invalid_usage_of_pure_argument(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT)
    def is_INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION)
    def is_invalid_argument_to_private_entry_function(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION)
    def is_INDEX_OUT_OF_BOUNDS(self) -> bool:
        return isinstance(self, CommandArgumentError.INDEX_OUT_OF_BOUNDS)
    def is_index_out_of_bounds(self) -> bool:
        return isinstance(self, CommandArgumentError.INDEX_OUT_OF_BOUNDS)
    def is_SECONDARY_INDEX_OUT_OF_BOUNDS(self) -> bool:
        return isinstance(self, CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS)
    def is_secondary_index_out_of_bounds(self) -> bool:
        return isinstance(self, CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS)
    def is_INVALID_RESULT_ARITY(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_RESULT_ARITY)
    def is_invalid_result_arity(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_RESULT_ARITY)
    def is_INVALID_GAS_COIN_USAGE(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_GAS_COIN_USAGE)
    def is_invalid_gas_coin_usage(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_GAS_COIN_USAGE)
    def is_INVALID_VALUE_USAGE(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_VALUE_USAGE)
    def is_invalid_value_usage(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_VALUE_USAGE)
    def is_INVALID_OBJECT_BY_VALUE(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_OBJECT_BY_VALUE)
    def is_invalid_object_by_value(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_OBJECT_BY_VALUE)
    def is_INVALID_OBJECT_BY_MUT_REF(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_OBJECT_BY_MUT_REF)
    def is_invalid_object_by_mut_ref(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_OBJECT_BY_MUT_REF)
    def is_SHARED_OBJECT_OPERATION_NOT_ALLOWED(self) -> bool:
        return isinstance(self, CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED)
    def is_shared_object_operation_not_allowed(self) -> bool:
        return isinstance(self, CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED)
    def is_INVALID_ARGUMENT_ARITY(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_ARGUMENT_ARITY)
    def is_invalid_argument_arity(self) -> bool:
        return isinstance(self, CommandArgumentError.INVALID_ARGUMENT_ARITY)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
CommandArgumentError.TYPE_MISMATCH = type("CommandArgumentError.TYPE_MISMATCH", (CommandArgumentError.TYPE_MISMATCH, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_BCS_BYTES = type("CommandArgumentError.INVALID_BCS_BYTES", (CommandArgumentError.INVALID_BCS_BYTES, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT = type("CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT", (CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION = type("CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION", (CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INDEX_OUT_OF_BOUNDS = type("CommandArgumentError.INDEX_OUT_OF_BOUNDS", (CommandArgumentError.INDEX_OUT_OF_BOUNDS, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS = type("CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS", (CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_RESULT_ARITY = type("CommandArgumentError.INVALID_RESULT_ARITY", (CommandArgumentError.INVALID_RESULT_ARITY, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_GAS_COIN_USAGE = type("CommandArgumentError.INVALID_GAS_COIN_USAGE", (CommandArgumentError.INVALID_GAS_COIN_USAGE, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_VALUE_USAGE = type("CommandArgumentError.INVALID_VALUE_USAGE", (CommandArgumentError.INVALID_VALUE_USAGE, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_OBJECT_BY_VALUE = type("CommandArgumentError.INVALID_OBJECT_BY_VALUE", (CommandArgumentError.INVALID_OBJECT_BY_VALUE, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_OBJECT_BY_MUT_REF = type("CommandArgumentError.INVALID_OBJECT_BY_MUT_REF", (CommandArgumentError.INVALID_OBJECT_BY_MUT_REF, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED = type("CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED", (CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED, CommandArgumentError,), {})  # type: ignore
CommandArgumentError.INVALID_ARGUMENT_ARITY = type("CommandArgumentError.INVALID_ARGUMENT_ARITY", (CommandArgumentError.INVALID_ARGUMENT_ARITY, CommandArgumentError,), {})  # type: ignore




class _UniffiConverterTypeCommandArgumentError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CommandArgumentError.TYPE_MISMATCH(
            )
        if variant == 2:
            return CommandArgumentError.INVALID_BCS_BYTES(
            )
        if variant == 3:
            return CommandArgumentError.INVALID_USAGE_OF_PURE_ARGUMENT(
            )
        if variant == 4:
            return CommandArgumentError.INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION(
            )
        if variant == 5:
            return CommandArgumentError.INDEX_OUT_OF_BOUNDS(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 6:
            return CommandArgumentError.SECONDARY_INDEX_OUT_OF_BOUNDS(
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 7:
            return CommandArgumentError.INVALID_RESULT_ARITY(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 8:
            return CommandArgumentError.INVALID_GAS_COIN_USAGE(
            )
        if variant == 9:
            return CommandArgumentError.INVALID_VALUE_USAGE(
            )
        if variant == 10:
            return CommandArgumentError.INVALID_OBJECT_BY_VALUE(
            )
        if variant == 11:
            return CommandArgumentError.INVALID_OBJECT_BY_MUT_REF(
            )
        if variant == 12:
            return CommandArgumentError.SHARED_OBJECT_OPERATION_NOT_ALLOWED(
            )
        if variant == 13:
            return CommandArgumentError.INVALID_ARGUMENT_ARITY(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_TYPE_MISMATCH():
            return
        if value.is_INVALID_BCS_BYTES():
            return
        if value.is_INVALID_USAGE_OF_PURE_ARGUMENT():
            return
        if value.is_INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION():
            return
        if value.is_INDEX_OUT_OF_BOUNDS():
            _UniffiConverterUInt16.check_lower(value.index)
            return
        if value.is_SECONDARY_INDEX_OUT_OF_BOUNDS():
            _UniffiConverterUInt16.check_lower(value.result)
            _UniffiConverterUInt16.check_lower(value.subresult)
            return
        if value.is_INVALID_RESULT_ARITY():
            _UniffiConverterUInt16.check_lower(value.result)
            return
        if value.is_INVALID_GAS_COIN_USAGE():
            return
        if value.is_INVALID_VALUE_USAGE():
            return
        if value.is_INVALID_OBJECT_BY_VALUE():
            return
        if value.is_INVALID_OBJECT_BY_MUT_REF():
            return
        if value.is_SHARED_OBJECT_OPERATION_NOT_ALLOWED():
            return
        if value.is_INVALID_ARGUMENT_ARITY():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_TYPE_MISMATCH():
            buf.write_i32(1)
        if value.is_INVALID_BCS_BYTES():
            buf.write_i32(2)
        if value.is_INVALID_USAGE_OF_PURE_ARGUMENT():
            buf.write_i32(3)
        if value.is_INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION():
            buf.write_i32(4)
        if value.is_INDEX_OUT_OF_BOUNDS():
            buf.write_i32(5)
            _UniffiConverterUInt16.write(value.index, buf)
        if value.is_SECONDARY_INDEX_OUT_OF_BOUNDS():
            buf.write_i32(6)
            _UniffiConverterUInt16.write(value.result, buf)
            _UniffiConverterUInt16.write(value.subresult, buf)
        if value.is_INVALID_RESULT_ARITY():
            buf.write_i32(7)
            _UniffiConverterUInt16.write(value.result, buf)
        if value.is_INVALID_GAS_COIN_USAGE():
            buf.write_i32(8)
        if value.is_INVALID_VALUE_USAGE():
            buf.write_i32(9)
        if value.is_INVALID_OBJECT_BY_VALUE():
            buf.write_i32(10)
        if value.is_INVALID_OBJECT_BY_MUT_REF():
            buf.write_i32(11)
        if value.is_SHARED_OBJECT_OPERATION_NOT_ALLOWED():
            buf.write_i32(12)
        if value.is_INVALID_ARGUMENT_ARITY():
            buf.write_i32(13)







class Direction(enum.Enum):
    """
    Pagination direction.
    """

    FORWARD = 0
    
    BACKWARD = 1
    


class _UniffiConverterTypeDirection(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Direction.FORWARD
        if variant == 2:
            return Direction.BACKWARD
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Direction.FORWARD:
            return
        if value == Direction.BACKWARD:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Direction.FORWARD:
            buf.write_i32(1)
        if value == Direction.BACKWARD:
            buf.write_i32(2)







class ExecutionError:
    """
    An error that can occur during the execution of a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text

    execution-error =  insufficient-gas
    =/ invalid-gas-object
    =/ invariant-violation
    =/ feature-not-yet-supported
    =/ object-too-big
    =/ package-too-big
    =/ circular-object-ownership
    =/ insufficient-coin-balance
    =/ coin-balance-overflow
    =/ publish-error-non-zero-address
    =/ iota-move-verification-error
    =/ move-primitive-runtime-error
    =/ move-abort
    =/ vm-verification-or-deserialization-error
    =/ vm-invariant-violation
    =/ function-not-found
    =/ arity-mismatch
    =/ type-arity-mismatch
    =/ non-entry-function-invoked
    =/ command-argument-error
    =/ type-argument-error
    =/ unused-value-without-drop
    =/ invalid-public-function-return-type
    =/ invalid-transfer-object
    =/ effects-too-large
    =/ publish-upgrade-missing-dependency
    =/ publish-upgrade-dependency-downgrade
    =/ package-upgrade-error
    =/ written-objects-too-large
    =/ certificate-denied
    =/ iota-move-verification-timeout
    =/ shared-object-operation-not-allowed
    =/ input-object-deleted
    =/ execution-cancelled-due-to-shared-object-congestion
    =/ address-denied-for-coin
    =/ coin-type-global-pause
    =/ execution-cancelled-due-to-randomness-unavailable

    insufficient-gas                                    = %x00
    invalid-gas-object                                  = %x01
    invariant-violation                                 = %x02
    feature-not-yet-supported                           = %x03
    object-too-big                                      = %x04 u64 u64
    package-too-big                                     = %x05 u64 u64
    circular-object-ownership                           = %x06 object-id
    insufficient-coin-balance                           = %x07
    coin-balance-overflow                               = %x08
    publish-error-non-zero-address                      = %x09
    iota-move-verification-error                        = %x0a
    move-primitive-runtime-error                        = %x0b (option move-location)
    move-abort                                          = %x0c move-location u64
    vm-verification-or-deserialization-error            = %x0d
    vm-invariant-violation                              = %x0e
    function-not-found                                  = %x0f
    arity-mismatch                                      = %x10
    type-arity-mismatch                                 = %x11
    non-entry-function-invoked                          = %x12
    command-argument-error                              = %x13 u16 command-argument-error
    type-argument-error                                 = %x14 u16 type-argument-error
    unused-value-without-drop                           = %x15 u16 u16
    invalid-public-function-return-type                 = %x16 u16
    invalid-transfer-object                             = %x17
    effects-too-large                                   = %x18 u64 u64
    publish-upgrade-missing-dependency                  = %x19
    publish-upgrade-dependency-downgrade                = %x1a
    package-upgrade-error                               = %x1b package-upgrade-error
    written-objects-too-large                           = %x1c u64 u64
    certificate-denied                                  = %x1d
    iota-move-verification-timeout                      = %x1e
    shared-object-operation-not-allowed                 = %x1f
    input-object-deleted                                = %x20
    execution-cancelled-due-to-shared-object-congestion = %x21 (vector object-id)
    address-denied-for-coin                             = %x22 address string
    coin-type-global-pause                              = %x23 string
    execution-cancelled-due-to-randomness-unavailable   = %x24
    ```
    """

    def __init__(self):
        raise RuntimeError("ExecutionError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INSUFFICIENT_GAS:
        """
        Insufficient Gas
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INSUFFICIENT_GAS()".format()

        def __eq__(self, other):
            if not other.is_INSUFFICIENT_GAS():
                return False
            return True
    
    class INVALID_GAS_OBJECT:
        """
        Invalid Gas Object.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INVALID_GAS_OBJECT()".format()

        def __eq__(self, other):
            if not other.is_INVALID_GAS_OBJECT():
                return False
            return True
    
    class INVARIANT_VIOLATION:
        """
        Invariant Violation
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INVARIANT_VIOLATION()".format()

        def __eq__(self, other):
            if not other.is_INVARIANT_VIOLATION():
                return False
            return True
    
    class FEATURE_NOT_YET_SUPPORTED:
        """
        Attempted to used feature that is not supported yet
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.FEATURE_NOT_YET_SUPPORTED()".format()

        def __eq__(self, other):
            if not other.is_FEATURE_NOT_YET_SUPPORTED():
                return False
            return True
    
    class OBJECT_TOO_BIG:
        """
        Move object is larger than the maximum allowed size
        """

        object_size: "int"
        max_object_size: "int"

        def __init__(self,object_size: "int", max_object_size: "int"):
            self.object_size = object_size
            self.max_object_size = max_object_size

        def __str__(self):
            return "ExecutionError.OBJECT_TOO_BIG(object_size={}, max_object_size={})".format(self.object_size, self.max_object_size)

        def __eq__(self, other):
            if not other.is_OBJECT_TOO_BIG():
                return False
            if self.object_size != other.object_size:
                return False
            if self.max_object_size != other.max_object_size:
                return False
            return True
    
    class PACKAGE_TOO_BIG:
        """
        Package is larger than the maximum allowed size
        """

        object_size: "int"
        max_object_size: "int"

        def __init__(self,object_size: "int", max_object_size: "int"):
            self.object_size = object_size
            self.max_object_size = max_object_size

        def __str__(self):
            return "ExecutionError.PACKAGE_TOO_BIG(object_size={}, max_object_size={})".format(self.object_size, self.max_object_size)

        def __eq__(self, other):
            if not other.is_PACKAGE_TOO_BIG():
                return False
            if self.object_size != other.object_size:
                return False
            if self.max_object_size != other.max_object_size:
                return False
            return True
    
    class CIRCULAR_OBJECT_OWNERSHIP:
        """
        Circular Object Ownership
        """

        object: "ObjectId"

        def __init__(self,object: "ObjectId"):
            self.object = object

        def __str__(self):
            return "ExecutionError.CIRCULAR_OBJECT_OWNERSHIP(object={})".format(self.object)

        def __eq__(self, other):
            if not other.is_CIRCULAR_OBJECT_OWNERSHIP():
                return False
            if self.object != other.object:
                return False
            return True
    
    class INSUFFICIENT_COIN_BALANCE:
        """
        Insufficient coin balance for requested operation
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INSUFFICIENT_COIN_BALANCE()".format()

        def __eq__(self, other):
            if not other.is_INSUFFICIENT_COIN_BALANCE():
                return False
            return True
    
    class COIN_BALANCE_OVERFLOW:
        """
        Coin balance overflowed an u64
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.COIN_BALANCE_OVERFLOW()".format()

        def __eq__(self, other):
            if not other.is_COIN_BALANCE_OVERFLOW():
                return False
            return True
    
    class PUBLISH_ERROR_NON_ZERO_ADDRESS:
        """
        Publish Error, Non-zero Address.
        The modules in the package must have their self-addresses set to zero.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS()".format()

        def __eq__(self, other):
            if not other.is_PUBLISH_ERROR_NON_ZERO_ADDRESS():
                return False
            return True
    
    class IOTA_MOVE_VERIFICATION:
        """
        IOTA Move Bytecode Verification Error.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.IOTA_MOVE_VERIFICATION()".format()

        def __eq__(self, other):
            if not other.is_IOTA_MOVE_VERIFICATION():
                return False
            return True
    
    class MOVE_PRIMITIVE_RUNTIME:
        """
        Error from a non-abort instruction.
        Possible causes:
        Arithmetic error, stack overflow, max value depth, etc."
        """

        location: "typing.Optional[MoveLocation]"

        def __init__(self,location: "typing.Optional[MoveLocation]"):
            self.location = location

        def __str__(self):
            return "ExecutionError.MOVE_PRIMITIVE_RUNTIME(location={})".format(self.location)

        def __eq__(self, other):
            if not other.is_MOVE_PRIMITIVE_RUNTIME():
                return False
            if self.location != other.location:
                return False
            return True
    
    class MOVE_ABORT:
        """
        Move runtime abort
        """

        location: "MoveLocation"
        code: "int"

        def __init__(self,location: "MoveLocation", code: "int"):
            self.location = location
            self.code = code

        def __str__(self):
            return "ExecutionError.MOVE_ABORT(location={}, code={})".format(self.location, self.code)

        def __eq__(self, other):
            if not other.is_MOVE_ABORT():
                return False
            if self.location != other.location:
                return False
            if self.code != other.code:
                return False
            return True
    
    class VM_VERIFICATION_OR_DESERIALIZATION:
        """
        Bytecode verification error.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION()".format()

        def __eq__(self, other):
            if not other.is_VM_VERIFICATION_OR_DESERIALIZATION():
                return False
            return True
    
    class VM_INVARIANT_VIOLATION:
        """
        MoveVm invariant violation
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.VM_INVARIANT_VIOLATION()".format()

        def __eq__(self, other):
            if not other.is_VM_INVARIANT_VIOLATION():
                return False
            return True
    
    class FUNCTION_NOT_FOUND:
        """
        Function not found
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.FUNCTION_NOT_FOUND()".format()

        def __eq__(self, other):
            if not other.is_FUNCTION_NOT_FOUND():
                return False
            return True
    
    class ARITY_MISMATCH:
        """
        Arity mismatch for Move function.
        The number of arguments does not match the number of parameters
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.ARITY_MISMATCH()".format()

        def __eq__(self, other):
            if not other.is_ARITY_MISMATCH():
                return False
            return True
    
    class TYPE_ARITY_MISMATCH:
        """
        Type arity mismatch for Move function.
        Mismatch between the number of actual versus expected type arguments.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.TYPE_ARITY_MISMATCH()".format()

        def __eq__(self, other):
            if not other.is_TYPE_ARITY_MISMATCH():
                return False
            return True
    
    class NON_ENTRY_FUNCTION_INVOKED:
        """
        Non Entry Function Invoked. Move Call must start with an entry function.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.NON_ENTRY_FUNCTION_INVOKED()".format()

        def __eq__(self, other):
            if not other.is_NON_ENTRY_FUNCTION_INVOKED():
                return False
            return True
    
    class COMMAND_ARGUMENT:
        """
        Invalid command argument
        """

        argument: "int"
        kind: "CommandArgumentError"

        def __init__(self,argument: "int", kind: "CommandArgumentError"):
            self.argument = argument
            self.kind = kind

        def __str__(self):
            return "ExecutionError.COMMAND_ARGUMENT(argument={}, kind={})".format(self.argument, self.kind)

        def __eq__(self, other):
            if not other.is_COMMAND_ARGUMENT():
                return False
            if self.argument != other.argument:
                return False
            if self.kind != other.kind:
                return False
            return True
    
    class TYPE_ARGUMENT:
        """
        Type argument error
        """

        type_argument: "int"
        """
        Index of the problematic type argument
        """

        kind: "TypeArgumentError"

        def __init__(self,type_argument: "int", kind: "TypeArgumentError"):
            self.type_argument = type_argument
            self.kind = kind

        def __str__(self):
            return "ExecutionError.TYPE_ARGUMENT(type_argument={}, kind={})".format(self.type_argument, self.kind)

        def __eq__(self, other):
            if not other.is_TYPE_ARGUMENT():
                return False
            if self.type_argument != other.type_argument:
                return False
            if self.kind != other.kind:
                return False
            return True
    
    class UNUSED_VALUE_WITHOUT_DROP:
        """
        Unused result without the drop ability.
        """

        result: "int"
        subresult: "int"

        def __init__(self,result: "int", subresult: "int"):
            self.result = result
            self.subresult = subresult

        def __str__(self):
            return "ExecutionError.UNUSED_VALUE_WITHOUT_DROP(result={}, subresult={})".format(self.result, self.subresult)

        def __eq__(self, other):
            if not other.is_UNUSED_VALUE_WITHOUT_DROP():
                return False
            if self.result != other.result:
                return False
            if self.subresult != other.subresult:
                return False
            return True
    
    class INVALID_PUBLIC_FUNCTION_RETURN_TYPE:
        """
        Invalid public Move function signature.
        Unsupported return type for return value
        """

        index: "int"

        def __init__(self,index: "int"):
            self.index = index

        def __str__(self):
            return "ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE(index={})".format(self.index)

        def __eq__(self, other):
            if not other.is_INVALID_PUBLIC_FUNCTION_RETURN_TYPE():
                return False
            if self.index != other.index:
                return False
            return True
    
    class INVALID_TRANSFER_OBJECT:
        """
        Invalid Transfer Object, object does not have public transfer.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INVALID_TRANSFER_OBJECT()".format()

        def __eq__(self, other):
            if not other.is_INVALID_TRANSFER_OBJECT():
                return False
            return True
    
    class EFFECTS_TOO_LARGE:
        """
        Effects from the transaction are too large
        """

        current_size: "int"
        max_size: "int"

        def __init__(self,current_size: "int", max_size: "int"):
            self.current_size = current_size
            self.max_size = max_size

        def __str__(self):
            return "ExecutionError.EFFECTS_TOO_LARGE(current_size={}, max_size={})".format(self.current_size, self.max_size)

        def __eq__(self, other):
            if not other.is_EFFECTS_TOO_LARGE():
                return False
            if self.current_size != other.current_size:
                return False
            if self.max_size != other.max_size:
                return False
            return True
    
    class PUBLISH_UPGRADE_MISSING_DEPENDENCY:
        """
        Publish or Upgrade is missing dependency
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY()".format()

        def __eq__(self, other):
            if not other.is_PUBLISH_UPGRADE_MISSING_DEPENDENCY():
                return False
            return True
    
    class PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE:
        """
        Publish or Upgrade dependency downgrade.

        Indirect (transitive) dependency of published or upgraded package has
        been assigned an on-chain version that is less than the version
        required by one of the package's transitive dependencies.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE()".format()

        def __eq__(self, other):
            if not other.is_PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE():
                return False
            return True
    
    class PACKAGE_UPGRADE:
        """
        Invalid package upgrade
        """

        kind: "PackageUpgradeError"

        def __init__(self,kind: "PackageUpgradeError"):
            self.kind = kind

        def __str__(self):
            return "ExecutionError.PACKAGE_UPGRADE(kind={})".format(self.kind)

        def __eq__(self, other):
            if not other.is_PACKAGE_UPGRADE():
                return False
            if self.kind != other.kind:
                return False
            return True
    
    class WRITTEN_OBJECTS_TOO_LARGE:
        """
        Indicates the transaction tried to write objects too large to storage
        """

        object_size: "int"
        max_object_size: "int"

        def __init__(self,object_size: "int", max_object_size: "int"):
            self.object_size = object_size
            self.max_object_size = max_object_size

        def __str__(self):
            return "ExecutionError.WRITTEN_OBJECTS_TOO_LARGE(object_size={}, max_object_size={})".format(self.object_size, self.max_object_size)

        def __eq__(self, other):
            if not other.is_WRITTEN_OBJECTS_TOO_LARGE():
                return False
            if self.object_size != other.object_size:
                return False
            if self.max_object_size != other.max_object_size:
                return False
            return True
    
    class CERTIFICATE_DENIED:
        """
        Certificate is on the deny list
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.CERTIFICATE_DENIED()".format()

        def __eq__(self, other):
            if not other.is_CERTIFICATE_DENIED():
                return False
            return True
    
    class IOTA_MOVE_VERIFICATION_TIMEOUT:
        """
        IOTA Move Bytecode verification timed out.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT()".format()

        def __eq__(self, other):
            if not other.is_IOTA_MOVE_VERIFICATION_TIMEOUT():
                return False
            return True
    
    class SHARED_OBJECT_OPERATION_NOT_ALLOWED:
        """
        The requested shared object operation is not allowed
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED()".format()

        def __eq__(self, other):
            if not other.is_SHARED_OBJECT_OPERATION_NOT_ALLOWED():
                return False
            return True
    
    class INPUT_OBJECT_DELETED:
        """
        Requested shared object has been deleted
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INPUT_OBJECT_DELETED()".format()

        def __eq__(self, other):
            if not other.is_INPUT_OBJECT_DELETED():
                return False
            return True
    
    class EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION:
        """
        Certificate is cancelled due to congestion on shared objects
        """

        congested_objects: "typing.List[ObjectId]"

        def __init__(self,congested_objects: "typing.List[ObjectId]"):
            self.congested_objects = congested_objects

        def __str__(self):
            return "ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION(congested_objects={})".format(self.congested_objects)

        def __eq__(self, other):
            if not other.is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION():
                return False
            if self.congested_objects != other.congested_objects:
                return False
            return True
    
    class EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2:
        """
        Certificate is cancelled due to congestion on shared objects;
        suggested gas price can be used to give this certificate more priority.
        """

        congested_objects: "typing.List[ObjectId]"
        suggested_gas_price: "int"

        def __init__(self,congested_objects: "typing.List[ObjectId]", suggested_gas_price: "int"):
            self.congested_objects = congested_objects
            self.suggested_gas_price = suggested_gas_price

        def __str__(self):
            return "ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2(congested_objects={}, suggested_gas_price={})".format(self.congested_objects, self.suggested_gas_price)

        def __eq__(self, other):
            if not other.is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2():
                return False
            if self.congested_objects != other.congested_objects:
                return False
            if self.suggested_gas_price != other.suggested_gas_price:
                return False
            return True
    
    class ADDRESS_DENIED_FOR_COIN:
        """
        Address is denied for this coin type
        """

        address: "Address"
        coin_type: "str"

        def __init__(self,address: "Address", coin_type: "str"):
            self.address = address
            self.coin_type = coin_type

        def __str__(self):
            return "ExecutionError.ADDRESS_DENIED_FOR_COIN(address={}, coin_type={})".format(self.address, self.coin_type)

        def __eq__(self, other):
            if not other.is_ADDRESS_DENIED_FOR_COIN():
                return False
            if self.address != other.address:
                return False
            if self.coin_type != other.coin_type:
                return False
            return True
    
    class COIN_TYPE_GLOBAL_PAUSE:
        """
        Coin type is globally paused for use
        """

        coin_type: "str"

        def __init__(self,coin_type: "str"):
            self.coin_type = coin_type

        def __str__(self):
            return "ExecutionError.COIN_TYPE_GLOBAL_PAUSE(coin_type={})".format(self.coin_type)

        def __eq__(self, other):
            if not other.is_COIN_TYPE_GLOBAL_PAUSE():
                return False
            if self.coin_type != other.coin_type:
                return False
            return True
    
    class EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE:
        """
        Certificate is cancelled because randomness could not be generated this
        epoch
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE()".format()

        def __eq__(self, other):
            if not other.is_EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE():
                return False
            return True
    
    class INVALID_LINKAGE:
        """
        A valid linkage was unable to be determined for the transaction or one
        of its commands.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionError.INVALID_LINKAGE()".format()

        def __eq__(self, other):
            if not other.is_INVALID_LINKAGE():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_INSUFFICIENT_GAS(self) -> bool:
        return isinstance(self, ExecutionError.INSUFFICIENT_GAS)
    def is_insufficient_gas(self) -> bool:
        return isinstance(self, ExecutionError.INSUFFICIENT_GAS)
    def is_INVALID_GAS_OBJECT(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_GAS_OBJECT)
    def is_invalid_gas_object(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_GAS_OBJECT)
    def is_INVARIANT_VIOLATION(self) -> bool:
        return isinstance(self, ExecutionError.INVARIANT_VIOLATION)
    def is_invariant_violation(self) -> bool:
        return isinstance(self, ExecutionError.INVARIANT_VIOLATION)
    def is_FEATURE_NOT_YET_SUPPORTED(self) -> bool:
        return isinstance(self, ExecutionError.FEATURE_NOT_YET_SUPPORTED)
    def is_feature_not_yet_supported(self) -> bool:
        return isinstance(self, ExecutionError.FEATURE_NOT_YET_SUPPORTED)
    def is_OBJECT_TOO_BIG(self) -> bool:
        return isinstance(self, ExecutionError.OBJECT_TOO_BIG)
    def is_object_too_big(self) -> bool:
        return isinstance(self, ExecutionError.OBJECT_TOO_BIG)
    def is_PACKAGE_TOO_BIG(self) -> bool:
        return isinstance(self, ExecutionError.PACKAGE_TOO_BIG)
    def is_package_too_big(self) -> bool:
        return isinstance(self, ExecutionError.PACKAGE_TOO_BIG)
    def is_CIRCULAR_OBJECT_OWNERSHIP(self) -> bool:
        return isinstance(self, ExecutionError.CIRCULAR_OBJECT_OWNERSHIP)
    def is_circular_object_ownership(self) -> bool:
        return isinstance(self, ExecutionError.CIRCULAR_OBJECT_OWNERSHIP)
    def is_INSUFFICIENT_COIN_BALANCE(self) -> bool:
        return isinstance(self, ExecutionError.INSUFFICIENT_COIN_BALANCE)
    def is_insufficient_coin_balance(self) -> bool:
        return isinstance(self, ExecutionError.INSUFFICIENT_COIN_BALANCE)
    def is_COIN_BALANCE_OVERFLOW(self) -> bool:
        return isinstance(self, ExecutionError.COIN_BALANCE_OVERFLOW)
    def is_coin_balance_overflow(self) -> bool:
        return isinstance(self, ExecutionError.COIN_BALANCE_OVERFLOW)
    def is_PUBLISH_ERROR_NON_ZERO_ADDRESS(self) -> bool:
        return isinstance(self, ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS)
    def is_publish_error_non_zero_address(self) -> bool:
        return isinstance(self, ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS)
    def is_IOTA_MOVE_VERIFICATION(self) -> bool:
        return isinstance(self, ExecutionError.IOTA_MOVE_VERIFICATION)
    def is_iota_move_verification(self) -> bool:
        return isinstance(self, ExecutionError.IOTA_MOVE_VERIFICATION)
    def is_MOVE_PRIMITIVE_RUNTIME(self) -> bool:
        return isinstance(self, ExecutionError.MOVE_PRIMITIVE_RUNTIME)
    def is_move_primitive_runtime(self) -> bool:
        return isinstance(self, ExecutionError.MOVE_PRIMITIVE_RUNTIME)
    def is_MOVE_ABORT(self) -> bool:
        return isinstance(self, ExecutionError.MOVE_ABORT)
    def is_move_abort(self) -> bool:
        return isinstance(self, ExecutionError.MOVE_ABORT)
    def is_VM_VERIFICATION_OR_DESERIALIZATION(self) -> bool:
        return isinstance(self, ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION)
    def is_vm_verification_or_deserialization(self) -> bool:
        return isinstance(self, ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION)
    def is_VM_INVARIANT_VIOLATION(self) -> bool:
        return isinstance(self, ExecutionError.VM_INVARIANT_VIOLATION)
    def is_vm_invariant_violation(self) -> bool:
        return isinstance(self, ExecutionError.VM_INVARIANT_VIOLATION)
    def is_FUNCTION_NOT_FOUND(self) -> bool:
        return isinstance(self, ExecutionError.FUNCTION_NOT_FOUND)
    def is_function_not_found(self) -> bool:
        return isinstance(self, ExecutionError.FUNCTION_NOT_FOUND)
    def is_ARITY_MISMATCH(self) -> bool:
        return isinstance(self, ExecutionError.ARITY_MISMATCH)
    def is_arity_mismatch(self) -> bool:
        return isinstance(self, ExecutionError.ARITY_MISMATCH)
    def is_TYPE_ARITY_MISMATCH(self) -> bool:
        return isinstance(self, ExecutionError.TYPE_ARITY_MISMATCH)
    def is_type_arity_mismatch(self) -> bool:
        return isinstance(self, ExecutionError.TYPE_ARITY_MISMATCH)
    def is_NON_ENTRY_FUNCTION_INVOKED(self) -> bool:
        return isinstance(self, ExecutionError.NON_ENTRY_FUNCTION_INVOKED)
    def is_non_entry_function_invoked(self) -> bool:
        return isinstance(self, ExecutionError.NON_ENTRY_FUNCTION_INVOKED)
    def is_COMMAND_ARGUMENT(self) -> bool:
        return isinstance(self, ExecutionError.COMMAND_ARGUMENT)
    def is_command_argument(self) -> bool:
        return isinstance(self, ExecutionError.COMMAND_ARGUMENT)
    def is_TYPE_ARGUMENT(self) -> bool:
        return isinstance(self, ExecutionError.TYPE_ARGUMENT)
    def is_type_argument(self) -> bool:
        return isinstance(self, ExecutionError.TYPE_ARGUMENT)
    def is_UNUSED_VALUE_WITHOUT_DROP(self) -> bool:
        return isinstance(self, ExecutionError.UNUSED_VALUE_WITHOUT_DROP)
    def is_unused_value_without_drop(self) -> bool:
        return isinstance(self, ExecutionError.UNUSED_VALUE_WITHOUT_DROP)
    def is_INVALID_PUBLIC_FUNCTION_RETURN_TYPE(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE)
    def is_invalid_public_function_return_type(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE)
    def is_INVALID_TRANSFER_OBJECT(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_TRANSFER_OBJECT)
    def is_invalid_transfer_object(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_TRANSFER_OBJECT)
    def is_EFFECTS_TOO_LARGE(self) -> bool:
        return isinstance(self, ExecutionError.EFFECTS_TOO_LARGE)
    def is_effects_too_large(self) -> bool:
        return isinstance(self, ExecutionError.EFFECTS_TOO_LARGE)
    def is_PUBLISH_UPGRADE_MISSING_DEPENDENCY(self) -> bool:
        return isinstance(self, ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY)
    def is_publish_upgrade_missing_dependency(self) -> bool:
        return isinstance(self, ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY)
    def is_PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE(self) -> bool:
        return isinstance(self, ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE)
    def is_publish_upgrade_dependency_downgrade(self) -> bool:
        return isinstance(self, ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE)
    def is_PACKAGE_UPGRADE(self) -> bool:
        return isinstance(self, ExecutionError.PACKAGE_UPGRADE)
    def is_package_upgrade(self) -> bool:
        return isinstance(self, ExecutionError.PACKAGE_UPGRADE)
    def is_WRITTEN_OBJECTS_TOO_LARGE(self) -> bool:
        return isinstance(self, ExecutionError.WRITTEN_OBJECTS_TOO_LARGE)
    def is_written_objects_too_large(self) -> bool:
        return isinstance(self, ExecutionError.WRITTEN_OBJECTS_TOO_LARGE)
    def is_CERTIFICATE_DENIED(self) -> bool:
        return isinstance(self, ExecutionError.CERTIFICATE_DENIED)
    def is_certificate_denied(self) -> bool:
        return isinstance(self, ExecutionError.CERTIFICATE_DENIED)
    def is_IOTA_MOVE_VERIFICATION_TIMEOUT(self) -> bool:
        return isinstance(self, ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT)
    def is_iota_move_verification_timeout(self) -> bool:
        return isinstance(self, ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT)
    def is_SHARED_OBJECT_OPERATION_NOT_ALLOWED(self) -> bool:
        return isinstance(self, ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED)
    def is_shared_object_operation_not_allowed(self) -> bool:
        return isinstance(self, ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED)
    def is_INPUT_OBJECT_DELETED(self) -> bool:
        return isinstance(self, ExecutionError.INPUT_OBJECT_DELETED)
    def is_input_object_deleted(self) -> bool:
        return isinstance(self, ExecutionError.INPUT_OBJECT_DELETED)
    def is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION(self) -> bool:
        return isinstance(self, ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION)
    def is_execution_cancelled_due_to_shared_object_congestion(self) -> bool:
        return isinstance(self, ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION)
    def is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2(self) -> bool:
        return isinstance(self, ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2)
    def is_execution_cancelled_due_to_shared_object_congestion_v2(self) -> bool:
        return isinstance(self, ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2)
    def is_ADDRESS_DENIED_FOR_COIN(self) -> bool:
        return isinstance(self, ExecutionError.ADDRESS_DENIED_FOR_COIN)
    def is_address_denied_for_coin(self) -> bool:
        return isinstance(self, ExecutionError.ADDRESS_DENIED_FOR_COIN)
    def is_COIN_TYPE_GLOBAL_PAUSE(self) -> bool:
        return isinstance(self, ExecutionError.COIN_TYPE_GLOBAL_PAUSE)
    def is_coin_type_global_pause(self) -> bool:
        return isinstance(self, ExecutionError.COIN_TYPE_GLOBAL_PAUSE)
    def is_EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE(self) -> bool:
        return isinstance(self, ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE)
    def is_execution_cancelled_due_to_randomness_unavailable(self) -> bool:
        return isinstance(self, ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE)
    def is_INVALID_LINKAGE(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_LINKAGE)
    def is_invalid_linkage(self) -> bool:
        return isinstance(self, ExecutionError.INVALID_LINKAGE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ExecutionError.INSUFFICIENT_GAS = type("ExecutionError.INSUFFICIENT_GAS", (ExecutionError.INSUFFICIENT_GAS, ExecutionError,), {})  # type: ignore
ExecutionError.INVALID_GAS_OBJECT = type("ExecutionError.INVALID_GAS_OBJECT", (ExecutionError.INVALID_GAS_OBJECT, ExecutionError,), {})  # type: ignore
ExecutionError.INVARIANT_VIOLATION = type("ExecutionError.INVARIANT_VIOLATION", (ExecutionError.INVARIANT_VIOLATION, ExecutionError,), {})  # type: ignore
ExecutionError.FEATURE_NOT_YET_SUPPORTED = type("ExecutionError.FEATURE_NOT_YET_SUPPORTED", (ExecutionError.FEATURE_NOT_YET_SUPPORTED, ExecutionError,), {})  # type: ignore
ExecutionError.OBJECT_TOO_BIG = type("ExecutionError.OBJECT_TOO_BIG", (ExecutionError.OBJECT_TOO_BIG, ExecutionError,), {})  # type: ignore
ExecutionError.PACKAGE_TOO_BIG = type("ExecutionError.PACKAGE_TOO_BIG", (ExecutionError.PACKAGE_TOO_BIG, ExecutionError,), {})  # type: ignore
ExecutionError.CIRCULAR_OBJECT_OWNERSHIP = type("ExecutionError.CIRCULAR_OBJECT_OWNERSHIP", (ExecutionError.CIRCULAR_OBJECT_OWNERSHIP, ExecutionError,), {})  # type: ignore
ExecutionError.INSUFFICIENT_COIN_BALANCE = type("ExecutionError.INSUFFICIENT_COIN_BALANCE", (ExecutionError.INSUFFICIENT_COIN_BALANCE, ExecutionError,), {})  # type: ignore
ExecutionError.COIN_BALANCE_OVERFLOW = type("ExecutionError.COIN_BALANCE_OVERFLOW", (ExecutionError.COIN_BALANCE_OVERFLOW, ExecutionError,), {})  # type: ignore
ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS = type("ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS", (ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS, ExecutionError,), {})  # type: ignore
ExecutionError.IOTA_MOVE_VERIFICATION = type("ExecutionError.IOTA_MOVE_VERIFICATION", (ExecutionError.IOTA_MOVE_VERIFICATION, ExecutionError,), {})  # type: ignore
ExecutionError.MOVE_PRIMITIVE_RUNTIME = type("ExecutionError.MOVE_PRIMITIVE_RUNTIME", (ExecutionError.MOVE_PRIMITIVE_RUNTIME, ExecutionError,), {})  # type: ignore
ExecutionError.MOVE_ABORT = type("ExecutionError.MOVE_ABORT", (ExecutionError.MOVE_ABORT, ExecutionError,), {})  # type: ignore
ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION = type("ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION", (ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION, ExecutionError,), {})  # type: ignore
ExecutionError.VM_INVARIANT_VIOLATION = type("ExecutionError.VM_INVARIANT_VIOLATION", (ExecutionError.VM_INVARIANT_VIOLATION, ExecutionError,), {})  # type: ignore
ExecutionError.FUNCTION_NOT_FOUND = type("ExecutionError.FUNCTION_NOT_FOUND", (ExecutionError.FUNCTION_NOT_FOUND, ExecutionError,), {})  # type: ignore
ExecutionError.ARITY_MISMATCH = type("ExecutionError.ARITY_MISMATCH", (ExecutionError.ARITY_MISMATCH, ExecutionError,), {})  # type: ignore
ExecutionError.TYPE_ARITY_MISMATCH = type("ExecutionError.TYPE_ARITY_MISMATCH", (ExecutionError.TYPE_ARITY_MISMATCH, ExecutionError,), {})  # type: ignore
ExecutionError.NON_ENTRY_FUNCTION_INVOKED = type("ExecutionError.NON_ENTRY_FUNCTION_INVOKED", (ExecutionError.NON_ENTRY_FUNCTION_INVOKED, ExecutionError,), {})  # type: ignore
ExecutionError.COMMAND_ARGUMENT = type("ExecutionError.COMMAND_ARGUMENT", (ExecutionError.COMMAND_ARGUMENT, ExecutionError,), {})  # type: ignore
ExecutionError.TYPE_ARGUMENT = type("ExecutionError.TYPE_ARGUMENT", (ExecutionError.TYPE_ARGUMENT, ExecutionError,), {})  # type: ignore
ExecutionError.UNUSED_VALUE_WITHOUT_DROP = type("ExecutionError.UNUSED_VALUE_WITHOUT_DROP", (ExecutionError.UNUSED_VALUE_WITHOUT_DROP, ExecutionError,), {})  # type: ignore
ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE = type("ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE", (ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE, ExecutionError,), {})  # type: ignore
ExecutionError.INVALID_TRANSFER_OBJECT = type("ExecutionError.INVALID_TRANSFER_OBJECT", (ExecutionError.INVALID_TRANSFER_OBJECT, ExecutionError,), {})  # type: ignore
ExecutionError.EFFECTS_TOO_LARGE = type("ExecutionError.EFFECTS_TOO_LARGE", (ExecutionError.EFFECTS_TOO_LARGE, ExecutionError,), {})  # type: ignore
ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY = type("ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY", (ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY, ExecutionError,), {})  # type: ignore
ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE = type("ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE", (ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE, ExecutionError,), {})  # type: ignore
ExecutionError.PACKAGE_UPGRADE = type("ExecutionError.PACKAGE_UPGRADE", (ExecutionError.PACKAGE_UPGRADE, ExecutionError,), {})  # type: ignore
ExecutionError.WRITTEN_OBJECTS_TOO_LARGE = type("ExecutionError.WRITTEN_OBJECTS_TOO_LARGE", (ExecutionError.WRITTEN_OBJECTS_TOO_LARGE, ExecutionError,), {})  # type: ignore
ExecutionError.CERTIFICATE_DENIED = type("ExecutionError.CERTIFICATE_DENIED", (ExecutionError.CERTIFICATE_DENIED, ExecutionError,), {})  # type: ignore
ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT = type("ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT", (ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT, ExecutionError,), {})  # type: ignore
ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED = type("ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED", (ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED, ExecutionError,), {})  # type: ignore
ExecutionError.INPUT_OBJECT_DELETED = type("ExecutionError.INPUT_OBJECT_DELETED", (ExecutionError.INPUT_OBJECT_DELETED, ExecutionError,), {})  # type: ignore
ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION = type("ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION", (ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION, ExecutionError,), {})  # type: ignore
ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2 = type("ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2", (ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2, ExecutionError,), {})  # type: ignore
ExecutionError.ADDRESS_DENIED_FOR_COIN = type("ExecutionError.ADDRESS_DENIED_FOR_COIN", (ExecutionError.ADDRESS_DENIED_FOR_COIN, ExecutionError,), {})  # type: ignore
ExecutionError.COIN_TYPE_GLOBAL_PAUSE = type("ExecutionError.COIN_TYPE_GLOBAL_PAUSE", (ExecutionError.COIN_TYPE_GLOBAL_PAUSE, ExecutionError,), {})  # type: ignore
ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE = type("ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE", (ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE, ExecutionError,), {})  # type: ignore
ExecutionError.INVALID_LINKAGE = type("ExecutionError.INVALID_LINKAGE", (ExecutionError.INVALID_LINKAGE, ExecutionError,), {})  # type: ignore




class _UniffiConverterTypeExecutionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExecutionError.INSUFFICIENT_GAS(
            )
        if variant == 2:
            return ExecutionError.INVALID_GAS_OBJECT(
            )
        if variant == 3:
            return ExecutionError.INVARIANT_VIOLATION(
            )
        if variant == 4:
            return ExecutionError.FEATURE_NOT_YET_SUPPORTED(
            )
        if variant == 5:
            return ExecutionError.OBJECT_TOO_BIG(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 6:
            return ExecutionError.PACKAGE_TOO_BIG(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 7:
            return ExecutionError.CIRCULAR_OBJECT_OWNERSHIP(
                _UniffiConverterTypeObjectId.read(buf),
            )
        if variant == 8:
            return ExecutionError.INSUFFICIENT_COIN_BALANCE(
            )
        if variant == 9:
            return ExecutionError.COIN_BALANCE_OVERFLOW(
            )
        if variant == 10:
            return ExecutionError.PUBLISH_ERROR_NON_ZERO_ADDRESS(
            )
        if variant == 11:
            return ExecutionError.IOTA_MOVE_VERIFICATION(
            )
        if variant == 12:
            return ExecutionError.MOVE_PRIMITIVE_RUNTIME(
                _UniffiConverterOptionalTypeMoveLocation.read(buf),
            )
        if variant == 13:
            return ExecutionError.MOVE_ABORT(
                _UniffiConverterTypeMoveLocation.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 14:
            return ExecutionError.VM_VERIFICATION_OR_DESERIALIZATION(
            )
        if variant == 15:
            return ExecutionError.VM_INVARIANT_VIOLATION(
            )
        if variant == 16:
            return ExecutionError.FUNCTION_NOT_FOUND(
            )
        if variant == 17:
            return ExecutionError.ARITY_MISMATCH(
            )
        if variant == 18:
            return ExecutionError.TYPE_ARITY_MISMATCH(
            )
        if variant == 19:
            return ExecutionError.NON_ENTRY_FUNCTION_INVOKED(
            )
        if variant == 20:
            return ExecutionError.COMMAND_ARGUMENT(
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterTypeCommandArgumentError.read(buf),
            )
        if variant == 21:
            return ExecutionError.TYPE_ARGUMENT(
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterTypeTypeArgumentError.read(buf),
            )
        if variant == 22:
            return ExecutionError.UNUSED_VALUE_WITHOUT_DROP(
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 23:
            return ExecutionError.INVALID_PUBLIC_FUNCTION_RETURN_TYPE(
                _UniffiConverterUInt16.read(buf),
            )
        if variant == 24:
            return ExecutionError.INVALID_TRANSFER_OBJECT(
            )
        if variant == 25:
            return ExecutionError.EFFECTS_TOO_LARGE(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 26:
            return ExecutionError.PUBLISH_UPGRADE_MISSING_DEPENDENCY(
            )
        if variant == 27:
            return ExecutionError.PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE(
            )
        if variant == 28:
            return ExecutionError.PACKAGE_UPGRADE(
                _UniffiConverterTypePackageUpgradeError.read(buf),
            )
        if variant == 29:
            return ExecutionError.WRITTEN_OBJECTS_TOO_LARGE(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 30:
            return ExecutionError.CERTIFICATE_DENIED(
            )
        if variant == 31:
            return ExecutionError.IOTA_MOVE_VERIFICATION_TIMEOUT(
            )
        if variant == 32:
            return ExecutionError.SHARED_OBJECT_OPERATION_NOT_ALLOWED(
            )
        if variant == 33:
            return ExecutionError.INPUT_OBJECT_DELETED(
            )
        if variant == 34:
            return ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION(
                _UniffiConverterSequenceTypeObjectId.read(buf),
            )
        if variant == 35:
            return ExecutionError.EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2(
                _UniffiConverterSequenceTypeObjectId.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 36:
            return ExecutionError.ADDRESS_DENIED_FOR_COIN(
                _UniffiConverterTypeAddress.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 37:
            return ExecutionError.COIN_TYPE_GLOBAL_PAUSE(
                _UniffiConverterString.read(buf),
            )
        if variant == 38:
            return ExecutionError.EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE(
            )
        if variant == 39:
            return ExecutionError.INVALID_LINKAGE(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_INSUFFICIENT_GAS():
            return
        if value.is_INVALID_GAS_OBJECT():
            return
        if value.is_INVARIANT_VIOLATION():
            return
        if value.is_FEATURE_NOT_YET_SUPPORTED():
            return
        if value.is_OBJECT_TOO_BIG():
            _UniffiConverterUInt64.check_lower(value.object_size)
            _UniffiConverterUInt64.check_lower(value.max_object_size)
            return
        if value.is_PACKAGE_TOO_BIG():
            _UniffiConverterUInt64.check_lower(value.object_size)
            _UniffiConverterUInt64.check_lower(value.max_object_size)
            return
        if value.is_CIRCULAR_OBJECT_OWNERSHIP():
            _UniffiConverterTypeObjectId.check_lower(value.object)
            return
        if value.is_INSUFFICIENT_COIN_BALANCE():
            return
        if value.is_COIN_BALANCE_OVERFLOW():
            return
        if value.is_PUBLISH_ERROR_NON_ZERO_ADDRESS():
            return
        if value.is_IOTA_MOVE_VERIFICATION():
            return
        if value.is_MOVE_PRIMITIVE_RUNTIME():
            _UniffiConverterOptionalTypeMoveLocation.check_lower(value.location)
            return
        if value.is_MOVE_ABORT():
            _UniffiConverterTypeMoveLocation.check_lower(value.location)
            _UniffiConverterUInt64.check_lower(value.code)
            return
        if value.is_VM_VERIFICATION_OR_DESERIALIZATION():
            return
        if value.is_VM_INVARIANT_VIOLATION():
            return
        if value.is_FUNCTION_NOT_FOUND():
            return
        if value.is_ARITY_MISMATCH():
            return
        if value.is_TYPE_ARITY_MISMATCH():
            return
        if value.is_NON_ENTRY_FUNCTION_INVOKED():
            return
        if value.is_COMMAND_ARGUMENT():
            _UniffiConverterUInt16.check_lower(value.argument)
            _UniffiConverterTypeCommandArgumentError.check_lower(value.kind)
            return
        if value.is_TYPE_ARGUMENT():
            _UniffiConverterUInt16.check_lower(value.type_argument)
            _UniffiConverterTypeTypeArgumentError.check_lower(value.kind)
            return
        if value.is_UNUSED_VALUE_WITHOUT_DROP():
            _UniffiConverterUInt16.check_lower(value.result)
            _UniffiConverterUInt16.check_lower(value.subresult)
            return
        if value.is_INVALID_PUBLIC_FUNCTION_RETURN_TYPE():
            _UniffiConverterUInt16.check_lower(value.index)
            return
        if value.is_INVALID_TRANSFER_OBJECT():
            return
        if value.is_EFFECTS_TOO_LARGE():
            _UniffiConverterUInt64.check_lower(value.current_size)
            _UniffiConverterUInt64.check_lower(value.max_size)
            return
        if value.is_PUBLISH_UPGRADE_MISSING_DEPENDENCY():
            return
        if value.is_PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE():
            return
        if value.is_PACKAGE_UPGRADE():
            _UniffiConverterTypePackageUpgradeError.check_lower(value.kind)
            return
        if value.is_WRITTEN_OBJECTS_TOO_LARGE():
            _UniffiConverterUInt64.check_lower(value.object_size)
            _UniffiConverterUInt64.check_lower(value.max_object_size)
            return
        if value.is_CERTIFICATE_DENIED():
            return
        if value.is_IOTA_MOVE_VERIFICATION_TIMEOUT():
            return
        if value.is_SHARED_OBJECT_OPERATION_NOT_ALLOWED():
            return
        if value.is_INPUT_OBJECT_DELETED():
            return
        if value.is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION():
            _UniffiConverterSequenceTypeObjectId.check_lower(value.congested_objects)
            return
        if value.is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2():
            _UniffiConverterSequenceTypeObjectId.check_lower(value.congested_objects)
            _UniffiConverterUInt64.check_lower(value.suggested_gas_price)
            return
        if value.is_ADDRESS_DENIED_FOR_COIN():
            _UniffiConverterTypeAddress.check_lower(value.address)
            _UniffiConverterString.check_lower(value.coin_type)
            return
        if value.is_COIN_TYPE_GLOBAL_PAUSE():
            _UniffiConverterString.check_lower(value.coin_type)
            return
        if value.is_EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE():
            return
        if value.is_INVALID_LINKAGE():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_INSUFFICIENT_GAS():
            buf.write_i32(1)
        if value.is_INVALID_GAS_OBJECT():
            buf.write_i32(2)
        if value.is_INVARIANT_VIOLATION():
            buf.write_i32(3)
        if value.is_FEATURE_NOT_YET_SUPPORTED():
            buf.write_i32(4)
        if value.is_OBJECT_TOO_BIG():
            buf.write_i32(5)
            _UniffiConverterUInt64.write(value.object_size, buf)
            _UniffiConverterUInt64.write(value.max_object_size, buf)
        if value.is_PACKAGE_TOO_BIG():
            buf.write_i32(6)
            _UniffiConverterUInt64.write(value.object_size, buf)
            _UniffiConverterUInt64.write(value.max_object_size, buf)
        if value.is_CIRCULAR_OBJECT_OWNERSHIP():
            buf.write_i32(7)
            _UniffiConverterTypeObjectId.write(value.object, buf)
        if value.is_INSUFFICIENT_COIN_BALANCE():
            buf.write_i32(8)
        if value.is_COIN_BALANCE_OVERFLOW():
            buf.write_i32(9)
        if value.is_PUBLISH_ERROR_NON_ZERO_ADDRESS():
            buf.write_i32(10)
        if value.is_IOTA_MOVE_VERIFICATION():
            buf.write_i32(11)
        if value.is_MOVE_PRIMITIVE_RUNTIME():
            buf.write_i32(12)
            _UniffiConverterOptionalTypeMoveLocation.write(value.location, buf)
        if value.is_MOVE_ABORT():
            buf.write_i32(13)
            _UniffiConverterTypeMoveLocation.write(value.location, buf)
            _UniffiConverterUInt64.write(value.code, buf)
        if value.is_VM_VERIFICATION_OR_DESERIALIZATION():
            buf.write_i32(14)
        if value.is_VM_INVARIANT_VIOLATION():
            buf.write_i32(15)
        if value.is_FUNCTION_NOT_FOUND():
            buf.write_i32(16)
        if value.is_ARITY_MISMATCH():
            buf.write_i32(17)
        if value.is_TYPE_ARITY_MISMATCH():
            buf.write_i32(18)
        if value.is_NON_ENTRY_FUNCTION_INVOKED():
            buf.write_i32(19)
        if value.is_COMMAND_ARGUMENT():
            buf.write_i32(20)
            _UniffiConverterUInt16.write(value.argument, buf)
            _UniffiConverterTypeCommandArgumentError.write(value.kind, buf)
        if value.is_TYPE_ARGUMENT():
            buf.write_i32(21)
            _UniffiConverterUInt16.write(value.type_argument, buf)
            _UniffiConverterTypeTypeArgumentError.write(value.kind, buf)
        if value.is_UNUSED_VALUE_WITHOUT_DROP():
            buf.write_i32(22)
            _UniffiConverterUInt16.write(value.result, buf)
            _UniffiConverterUInt16.write(value.subresult, buf)
        if value.is_INVALID_PUBLIC_FUNCTION_RETURN_TYPE():
            buf.write_i32(23)
            _UniffiConverterUInt16.write(value.index, buf)
        if value.is_INVALID_TRANSFER_OBJECT():
            buf.write_i32(24)
        if value.is_EFFECTS_TOO_LARGE():
            buf.write_i32(25)
            _UniffiConverterUInt64.write(value.current_size, buf)
            _UniffiConverterUInt64.write(value.max_size, buf)
        if value.is_PUBLISH_UPGRADE_MISSING_DEPENDENCY():
            buf.write_i32(26)
        if value.is_PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE():
            buf.write_i32(27)
        if value.is_PACKAGE_UPGRADE():
            buf.write_i32(28)
            _UniffiConverterTypePackageUpgradeError.write(value.kind, buf)
        if value.is_WRITTEN_OBJECTS_TOO_LARGE():
            buf.write_i32(29)
            _UniffiConverterUInt64.write(value.object_size, buf)
            _UniffiConverterUInt64.write(value.max_object_size, buf)
        if value.is_CERTIFICATE_DENIED():
            buf.write_i32(30)
        if value.is_IOTA_MOVE_VERIFICATION_TIMEOUT():
            buf.write_i32(31)
        if value.is_SHARED_OBJECT_OPERATION_NOT_ALLOWED():
            buf.write_i32(32)
        if value.is_INPUT_OBJECT_DELETED():
            buf.write_i32(33)
        if value.is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION():
            buf.write_i32(34)
            _UniffiConverterSequenceTypeObjectId.write(value.congested_objects, buf)
        if value.is_EXECUTION_CANCELLED_DUE_TO_SHARED_OBJECT_CONGESTION_V2():
            buf.write_i32(35)
            _UniffiConverterSequenceTypeObjectId.write(value.congested_objects, buf)
            _UniffiConverterUInt64.write(value.suggested_gas_price, buf)
        if value.is_ADDRESS_DENIED_FOR_COIN():
            buf.write_i32(36)
            _UniffiConverterTypeAddress.write(value.address, buf)
            _UniffiConverterString.write(value.coin_type, buf)
        if value.is_COIN_TYPE_GLOBAL_PAUSE():
            buf.write_i32(37)
            _UniffiConverterString.write(value.coin_type, buf)
        if value.is_EXECUTION_CANCELLED_DUE_TO_RANDOMNESS_UNAVAILABLE():
            buf.write_i32(38)
        if value.is_INVALID_LINKAGE():
            buf.write_i32(39)







class ExecutionStatus:
    """
    The status of an executed Transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    execution-status = success / failure
    success = %x00
    failure = %x01 execution-error (option u64)
    ```
    """

    def __init__(self):
        raise RuntimeError("ExecutionStatus cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class SUCCESS:
        """
        The Transaction successfully executed.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ExecutionStatus.SUCCESS()".format()

        def __eq__(self, other):
            if not other.is_SUCCESS():
                return False
            return True
    
    class FAILURE:
        """
        The Transaction didn't execute successfully.

        Failed transactions are still committed to the blockchain but any
        intended effects are rolled back to prior to this transaction
        executing with the caveat that gas objects are still smashed and gas
        usage is still charged.
        """

        error: "ExecutionError"
        """
        The error encountered during execution.
        """

        command: "typing.Optional[int]"
        """
        The command, if any, during which the error occurred.
        """


        def __init__(self,error: "ExecutionError", command: "typing.Optional[int]"):
            self.error = error
            self.command = command

        def __str__(self):
            return "ExecutionStatus.FAILURE(error={}, command={})".format(self.error, self.command)

        def __eq__(self, other):
            if not other.is_FAILURE():
                return False
            if self.error != other.error:
                return False
            if self.command != other.command:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_SUCCESS(self) -> bool:
        return isinstance(self, ExecutionStatus.SUCCESS)
    def is_success(self) -> bool:
        return isinstance(self, ExecutionStatus.SUCCESS)
    def is_FAILURE(self) -> bool:
        return isinstance(self, ExecutionStatus.FAILURE)
    def is_failure(self) -> bool:
        return isinstance(self, ExecutionStatus.FAILURE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ExecutionStatus.SUCCESS = type("ExecutionStatus.SUCCESS", (ExecutionStatus.SUCCESS, ExecutionStatus,), {})  # type: ignore
ExecutionStatus.FAILURE = type("ExecutionStatus.FAILURE", (ExecutionStatus.FAILURE, ExecutionStatus,), {})  # type: ignore




class _UniffiConverterTypeExecutionStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExecutionStatus.SUCCESS(
            )
        if variant == 2:
            return ExecutionStatus.FAILURE(
                _UniffiConverterTypeExecutionError.read(buf),
                _UniffiConverterOptionalUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_SUCCESS():
            return
        if value.is_FAILURE():
            _UniffiConverterTypeExecutionError.check_lower(value.error)
            _UniffiConverterOptionalUInt64.check_lower(value.command)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_SUCCESS():
            buf.write_i32(1)
        if value.is_FAILURE():
            buf.write_i32(2)
            _UniffiConverterTypeExecutionError.write(value.error, buf)
            _UniffiConverterOptionalUInt64.write(value.command, buf)







class Feature(enum.Enum):
    ANALYTICS = 0
    
    COINS = 1
    
    DYNAMIC_FIELDS = 2
    
    SUBSCRIPTIONS = 3
    
    SYSTEM_STATE = 4
    


class _UniffiConverterTypeFeature(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Feature.ANALYTICS
        if variant == 2:
            return Feature.COINS
        if variant == 3:
            return Feature.DYNAMIC_FIELDS
        if variant == 4:
            return Feature.SUBSCRIPTIONS
        if variant == 5:
            return Feature.SYSTEM_STATE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Feature.ANALYTICS:
            return
        if value == Feature.COINS:
            return
        if value == Feature.DYNAMIC_FIELDS:
            return
        if value == Feature.SUBSCRIPTIONS:
            return
        if value == Feature.SYSTEM_STATE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Feature.ANALYTICS:
            buf.write_i32(1)
        if value == Feature.COINS:
            buf.write_i32(2)
        if value == Feature.DYNAMIC_FIELDS:
            buf.write_i32(3)
        if value == Feature.SUBSCRIPTIONS:
            buf.write_i32(4)
        if value == Feature.SYSTEM_STATE:
            buf.write_i32(5)







class IdOperation(enum.Enum):
    """
    Defines what happened to an ObjectId during execution

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    id-operation =  id-operation-none
    =/ id-operation-created
    =/ id-operation-deleted

    id-operation-none       = %x00
    id-operation-created    = %x01
    id-operation-deleted    = %x02
    ```
    """

    NONE = 0
    
    CREATED = 1
    
    DELETED = 2
    


class _UniffiConverterTypeIdOperation(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return IdOperation.NONE
        if variant == 2:
            return IdOperation.CREATED
        if variant == 3:
            return IdOperation.DELETED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == IdOperation.NONE:
            return
        if value == IdOperation.CREATED:
            return
        if value == IdOperation.DELETED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == IdOperation.NONE:
            buf.write_i32(1)
        if value == IdOperation.CREATED:
            buf.write_i32(2)
        if value == IdOperation.DELETED:
            buf.write_i32(3)







class MnemonicLength(enum.Enum):
    WORDS12 = 12
    
    WORDS24 = 24
    


class _UniffiConverterTypeMnemonicLength(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MnemonicLength.WORDS12
        if variant == 2:
            return MnemonicLength.WORDS24
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == MnemonicLength.WORDS12:
            return
        if value == MnemonicLength.WORDS24:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == MnemonicLength.WORDS12:
            buf.write_i32(1)
        if value == MnemonicLength.WORDS24:
            buf.write_i32(2)







class MoveAbility(enum.Enum):
    COPY = 0
    
    DROP = 1
    
    KEY = 2
    
    STORE = 3
    


class _UniffiConverterTypeMoveAbility(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MoveAbility.COPY
        if variant == 2:
            return MoveAbility.DROP
        if variant == 3:
            return MoveAbility.KEY
        if variant == 4:
            return MoveAbility.STORE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == MoveAbility.COPY:
            return
        if value == MoveAbility.DROP:
            return
        if value == MoveAbility.KEY:
            return
        if value == MoveAbility.STORE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == MoveAbility.COPY:
            buf.write_i32(1)
        if value == MoveAbility.DROP:
            buf.write_i32(2)
        if value == MoveAbility.KEY:
            buf.write_i32(3)
        if value == MoveAbility.STORE:
            buf.write_i32(4)







class MoveVisibility(enum.Enum):
    PUBLIC = 0
    
    PRIVATE = 1
    
    FRIEND = 2
    


class _UniffiConverterTypeMoveVisibility(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return MoveVisibility.PUBLIC
        if variant == 2:
            return MoveVisibility.PRIVATE
        if variant == 3:
            return MoveVisibility.FRIEND
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == MoveVisibility.PUBLIC:
            return
        if value == MoveVisibility.PRIVATE:
            return
        if value == MoveVisibility.FRIEND:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == MoveVisibility.PUBLIC:
            buf.write_i32(1)
        if value == MoveVisibility.PRIVATE:
            buf.write_i32(2)
        if value == MoveVisibility.FRIEND:
            buf.write_i32(3)







class NameFormat(enum.Enum):
    """
    Two different view options for a name.
    `At` -> `test@example` | `Dot` -> `test.example.iota`
    """

    AT = 0
    
    DOT = 1
    


class _UniffiConverterTypeNameFormat(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NameFormat.AT
        if variant == 2:
            return NameFormat.DOT
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == NameFormat.AT:
            return
        if value == NameFormat.DOT:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == NameFormat.AT:
            buf.write_i32(1)
        if value == NameFormat.DOT:
            buf.write_i32(2)







class ObjectIn:
    """
    State of an object prior to execution

    If an object exists (at root-level) in the store prior to this transaction,
    it should be Data, otherwise it's Missing, e.g. wrapped objects should be
    Missing.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-in = object-in-missing / object-in-data

    object-in-missing = %x00
    object-in-data    = %x01 u64 digest owner
    ```
    """

    def __init__(self):
        raise RuntimeError("ObjectIn cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MISSING:

        def __init__(self,):
            pass

        def __str__(self):
            return "ObjectIn.MISSING()".format()

        def __eq__(self, other):
            if not other.is_MISSING():
                return False
            return True
    
    class DATA:
        """
        The old version, digest and owner.
        """

        version: "int"
        digest: "Digest"
        owner: "Owner"

        def __init__(self,version: "int", digest: "Digest", owner: "Owner"):
            self.version = version
            self.digest = digest
            self.owner = owner

        def __str__(self):
            return "ObjectIn.DATA(version={}, digest={}, owner={})".format(self.version, self.digest, self.owner)

        def __eq__(self, other):
            if not other.is_DATA():
                return False
            if self.version != other.version:
                return False
            if self.digest != other.digest:
                return False
            if self.owner != other.owner:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_MISSING(self) -> bool:
        return isinstance(self, ObjectIn.MISSING)
    def is_missing(self) -> bool:
        return isinstance(self, ObjectIn.MISSING)
    def is_DATA(self) -> bool:
        return isinstance(self, ObjectIn.DATA)
    def is_data(self) -> bool:
        return isinstance(self, ObjectIn.DATA)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ObjectIn.MISSING = type("ObjectIn.MISSING", (ObjectIn.MISSING, ObjectIn,), {})  # type: ignore
ObjectIn.DATA = type("ObjectIn.DATA", (ObjectIn.DATA, ObjectIn,), {})  # type: ignore




class _UniffiConverterTypeObjectIn(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ObjectIn.MISSING(
            )
        if variant == 2:
            return ObjectIn.DATA(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypeDigest.read(buf),
                _UniffiConverterTypeOwner.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_MISSING():
            return
        if value.is_DATA():
            _UniffiConverterUInt64.check_lower(value.version)
            _UniffiConverterTypeDigest.check_lower(value.digest)
            _UniffiConverterTypeOwner.check_lower(value.owner)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_MISSING():
            buf.write_i32(1)
        if value.is_DATA():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.version, buf)
            _UniffiConverterTypeDigest.write(value.digest, buf)
            _UniffiConverterTypeOwner.write(value.owner, buf)







class ObjectOut:
    """
    State of an object after execution

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-out  =  object-out-missing
    =/ object-out-object-write
    =/ object-out-package-write


    object-out-missing        = %x00
    object-out-object-write   = %x01 digest owner
    object-out-package-write  = %x02 version digest
    ```
    """

    def __init__(self):
        raise RuntimeError("ObjectOut cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class MISSING:
        """
        Same definition as in ObjectIn.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "ObjectOut.MISSING()".format()

        def __eq__(self, other):
            if not other.is_MISSING():
                return False
            return True
    
    class OBJECT_WRITE:
        """
        Any written object, including all of mutated, created, unwrapped today.
        """

        digest: "Digest"
        owner: "Owner"

        def __init__(self,digest: "Digest", owner: "Owner"):
            self.digest = digest
            self.owner = owner

        def __str__(self):
            return "ObjectOut.OBJECT_WRITE(digest={}, owner={})".format(self.digest, self.owner)

        def __eq__(self, other):
            if not other.is_OBJECT_WRITE():
                return False
            if self.digest != other.digest:
                return False
            if self.owner != other.owner:
                return False
            return True
    
    class PACKAGE_WRITE:
        """
        Packages writes need to be tracked separately with version because
        we don't use lamport version for package publish and upgrades.
        """

        version: "int"
        digest: "Digest"

        def __init__(self,version: "int", digest: "Digest"):
            self.version = version
            self.digest = digest

        def __str__(self):
            return "ObjectOut.PACKAGE_WRITE(version={}, digest={})".format(self.version, self.digest)

        def __eq__(self, other):
            if not other.is_PACKAGE_WRITE():
                return False
            if self.version != other.version:
                return False
            if self.digest != other.digest:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_MISSING(self) -> bool:
        return isinstance(self, ObjectOut.MISSING)
    def is_missing(self) -> bool:
        return isinstance(self, ObjectOut.MISSING)
    def is_OBJECT_WRITE(self) -> bool:
        return isinstance(self, ObjectOut.OBJECT_WRITE)
    def is_object_write(self) -> bool:
        return isinstance(self, ObjectOut.OBJECT_WRITE)
    def is_PACKAGE_WRITE(self) -> bool:
        return isinstance(self, ObjectOut.PACKAGE_WRITE)
    def is_package_write(self) -> bool:
        return isinstance(self, ObjectOut.PACKAGE_WRITE)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ObjectOut.MISSING = type("ObjectOut.MISSING", (ObjectOut.MISSING, ObjectOut,), {})  # type: ignore
ObjectOut.OBJECT_WRITE = type("ObjectOut.OBJECT_WRITE", (ObjectOut.OBJECT_WRITE, ObjectOut,), {})  # type: ignore
ObjectOut.PACKAGE_WRITE = type("ObjectOut.PACKAGE_WRITE", (ObjectOut.PACKAGE_WRITE, ObjectOut,), {})  # type: ignore




class _UniffiConverterTypeObjectOut(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ObjectOut.MISSING(
            )
        if variant == 2:
            return ObjectOut.OBJECT_WRITE(
                _UniffiConverterTypeDigest.read(buf),
                _UniffiConverterTypeOwner.read(buf),
            )
        if variant == 3:
            return ObjectOut.PACKAGE_WRITE(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypeDigest.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_MISSING():
            return
        if value.is_OBJECT_WRITE():
            _UniffiConverterTypeDigest.check_lower(value.digest)
            _UniffiConverterTypeOwner.check_lower(value.owner)
            return
        if value.is_PACKAGE_WRITE():
            _UniffiConverterUInt64.check_lower(value.version)
            _UniffiConverterTypeDigest.check_lower(value.digest)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_MISSING():
            buf.write_i32(1)
        if value.is_OBJECT_WRITE():
            buf.write_i32(2)
            _UniffiConverterTypeDigest.write(value.digest, buf)
            _UniffiConverterTypeOwner.write(value.owner, buf)
        if value.is_PACKAGE_WRITE():
            buf.write_i32(3)
            _UniffiConverterUInt64.write(value.version, buf)
            _UniffiConverterTypeDigest.write(value.digest, buf)







class PackageUpgradeError:
    """
    An error with a upgrading a package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    package-upgrade-error = unable-to-fetch-package /
    not-a-package           /
    incompatible-upgrade    /
    digest-does-not-match   /
    unknown-upgrade-policy  /
    package-id-does-not-match

    unable-to-fetch-package     = %x00 object-id
    not-a-package               = %x01 object-id
    incompatible-upgrade        = %x02
    digest-does-not-match       = %x03 digest
    unknown-upgrade-policy      = %x04 u8
    package-id-does-not-match   = %x05 object-id object-id
    ```
    """

    def __init__(self):
        raise RuntimeError("PackageUpgradeError cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class UNABLE_TO_FETCH_PACKAGE:
        """
        Unable to fetch package
        """

        package_id: "ObjectId"

        def __init__(self,package_id: "ObjectId"):
            self.package_id = package_id

        def __str__(self):
            return "PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE(package_id={})".format(self.package_id)

        def __eq__(self, other):
            if not other.is_UNABLE_TO_FETCH_PACKAGE():
                return False
            if self.package_id != other.package_id:
                return False
            return True
    
    class NOT_A_PACKAGE:
        """
        Object is not a package
        """

        object_id: "ObjectId"

        def __init__(self,object_id: "ObjectId"):
            self.object_id = object_id

        def __str__(self):
            return "PackageUpgradeError.NOT_A_PACKAGE(object_id={})".format(self.object_id)

        def __eq__(self, other):
            if not other.is_NOT_A_PACKAGE():
                return False
            if self.object_id != other.object_id:
                return False
            return True
    
    class INCOMPATIBLE_UPGRADE:
        """
        Package upgrade is incompatible with previous version
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "PackageUpgradeError.INCOMPATIBLE_UPGRADE()".format()

        def __eq__(self, other):
            if not other.is_INCOMPATIBLE_UPGRADE():
                return False
            return True
    
    class DIGEST_DOES_NOT_MATCH:
        """
        Digest in upgrade ticket and computed digest differ
        """

        digest: "Digest"

        def __init__(self,digest: "Digest"):
            self.digest = digest

        def __str__(self):
            return "PackageUpgradeError.DIGEST_DOES_NOT_MATCH(digest={})".format(self.digest)

        def __eq__(self, other):
            if not other.is_DIGEST_DOES_NOT_MATCH():
                return False
            if self.digest != other.digest:
                return False
            return True
    
    class UNKNOWN_UPGRADE_POLICY:
        """
        Upgrade policy is not valid
        """

        policy: "int"

        def __init__(self,policy: "int"):
            self.policy = policy

        def __str__(self):
            return "PackageUpgradeError.UNKNOWN_UPGRADE_POLICY(policy={})".format(self.policy)

        def __eq__(self, other):
            if not other.is_UNKNOWN_UPGRADE_POLICY():
                return False
            if self.policy != other.policy:
                return False
            return True
    
    class PACKAGE_ID_DOES_NOT_MATCH:
        """
        PackageId does not matach PackageId in upgrade ticket
        """

        package_id: "ObjectId"
        ticket_id: "ObjectId"

        def __init__(self,package_id: "ObjectId", ticket_id: "ObjectId"):
            self.package_id = package_id
            self.ticket_id = ticket_id

        def __str__(self):
            return "PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH(package_id={}, ticket_id={})".format(self.package_id, self.ticket_id)

        def __eq__(self, other):
            if not other.is_PACKAGE_ID_DOES_NOT_MATCH():
                return False
            if self.package_id != other.package_id:
                return False
            if self.ticket_id != other.ticket_id:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_UNABLE_TO_FETCH_PACKAGE(self) -> bool:
        return isinstance(self, PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE)
    def is_unable_to_fetch_package(self) -> bool:
        return isinstance(self, PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE)
    def is_NOT_A_PACKAGE(self) -> bool:
        return isinstance(self, PackageUpgradeError.NOT_A_PACKAGE)
    def is_not_a_package(self) -> bool:
        return isinstance(self, PackageUpgradeError.NOT_A_PACKAGE)
    def is_INCOMPATIBLE_UPGRADE(self) -> bool:
        return isinstance(self, PackageUpgradeError.INCOMPATIBLE_UPGRADE)
    def is_incompatible_upgrade(self) -> bool:
        return isinstance(self, PackageUpgradeError.INCOMPATIBLE_UPGRADE)
    def is_DIGEST_DOES_NOT_MATCH(self) -> bool:
        return isinstance(self, PackageUpgradeError.DIGEST_DOES_NOT_MATCH)
    def is_digest_does_not_match(self) -> bool:
        return isinstance(self, PackageUpgradeError.DIGEST_DOES_NOT_MATCH)
    def is_UNKNOWN_UPGRADE_POLICY(self) -> bool:
        return isinstance(self, PackageUpgradeError.UNKNOWN_UPGRADE_POLICY)
    def is_unknown_upgrade_policy(self) -> bool:
        return isinstance(self, PackageUpgradeError.UNKNOWN_UPGRADE_POLICY)
    def is_PACKAGE_ID_DOES_NOT_MATCH(self) -> bool:
        return isinstance(self, PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH)
    def is_package_id_does_not_match(self) -> bool:
        return isinstance(self, PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE = type("PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE", (PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE, PackageUpgradeError,), {})  # type: ignore
PackageUpgradeError.NOT_A_PACKAGE = type("PackageUpgradeError.NOT_A_PACKAGE", (PackageUpgradeError.NOT_A_PACKAGE, PackageUpgradeError,), {})  # type: ignore
PackageUpgradeError.INCOMPATIBLE_UPGRADE = type("PackageUpgradeError.INCOMPATIBLE_UPGRADE", (PackageUpgradeError.INCOMPATIBLE_UPGRADE, PackageUpgradeError,), {})  # type: ignore
PackageUpgradeError.DIGEST_DOES_NOT_MATCH = type("PackageUpgradeError.DIGEST_DOES_NOT_MATCH", (PackageUpgradeError.DIGEST_DOES_NOT_MATCH, PackageUpgradeError,), {})  # type: ignore
PackageUpgradeError.UNKNOWN_UPGRADE_POLICY = type("PackageUpgradeError.UNKNOWN_UPGRADE_POLICY", (PackageUpgradeError.UNKNOWN_UPGRADE_POLICY, PackageUpgradeError,), {})  # type: ignore
PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH = type("PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH", (PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH, PackageUpgradeError,), {})  # type: ignore




class _UniffiConverterTypePackageUpgradeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PackageUpgradeError.UNABLE_TO_FETCH_PACKAGE(
                _UniffiConverterTypeObjectId.read(buf),
            )
        if variant == 2:
            return PackageUpgradeError.NOT_A_PACKAGE(
                _UniffiConverterTypeObjectId.read(buf),
            )
        if variant == 3:
            return PackageUpgradeError.INCOMPATIBLE_UPGRADE(
            )
        if variant == 4:
            return PackageUpgradeError.DIGEST_DOES_NOT_MATCH(
                _UniffiConverterTypeDigest.read(buf),
            )
        if variant == 5:
            return PackageUpgradeError.UNKNOWN_UPGRADE_POLICY(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 6:
            return PackageUpgradeError.PACKAGE_ID_DOES_NOT_MATCH(
                _UniffiConverterTypeObjectId.read(buf),
                _UniffiConverterTypeObjectId.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_UNABLE_TO_FETCH_PACKAGE():
            _UniffiConverterTypeObjectId.check_lower(value.package_id)
            return
        if value.is_NOT_A_PACKAGE():
            _UniffiConverterTypeObjectId.check_lower(value.object_id)
            return
        if value.is_INCOMPATIBLE_UPGRADE():
            return
        if value.is_DIGEST_DOES_NOT_MATCH():
            _UniffiConverterTypeDigest.check_lower(value.digest)
            return
        if value.is_UNKNOWN_UPGRADE_POLICY():
            _UniffiConverterUInt8.check_lower(value.policy)
            return
        if value.is_PACKAGE_ID_DOES_NOT_MATCH():
            _UniffiConverterTypeObjectId.check_lower(value.package_id)
            _UniffiConverterTypeObjectId.check_lower(value.ticket_id)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_UNABLE_TO_FETCH_PACKAGE():
            buf.write_i32(1)
            _UniffiConverterTypeObjectId.write(value.package_id, buf)
        if value.is_NOT_A_PACKAGE():
            buf.write_i32(2)
            _UniffiConverterTypeObjectId.write(value.object_id, buf)
        if value.is_INCOMPATIBLE_UPGRADE():
            buf.write_i32(3)
        if value.is_DIGEST_DOES_NOT_MATCH():
            buf.write_i32(4)
            _UniffiConverterTypeDigest.write(value.digest, buf)
        if value.is_UNKNOWN_UPGRADE_POLICY():
            buf.write_i32(5)
            _UniffiConverterUInt8.write(value.policy, buf)
        if value.is_PACKAGE_ID_DOES_NOT_MATCH():
            buf.write_i32(6)
            _UniffiConverterTypeObjectId.write(value.package_id, buf)
            _UniffiConverterTypeObjectId.write(value.ticket_id, buf)




# SdkFfiError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SdkFfiError(Exception):
    pass

_UniffiTempSdkFfiError = SdkFfiError

class SdkFfiError:  # type: ignore
    class Generic(_UniffiTempSdkFfiError):

        def __repr__(self):
            return "SdkFfiError.Generic({})".format(repr(str(self)))
    _UniffiTempSdkFfiError.Generic = Generic # type: ignore

SdkFfiError = _UniffiTempSdkFfiError # type: ignore
del _UniffiTempSdkFfiError


class _UniffiConverterTypeSdkFfiError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SdkFfiError.Generic(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SdkFfiError.Generic):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SdkFfiError.Generic):
            buf.write_i32(1)





class SignatureScheme(enum.Enum):
    """
    Flag use to disambiguate the signature schemes supported by IOTA.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    signature-scheme = ed25519-flag / secp256k1-flag / secp256r1-flag /
    multisig-flag / bls-flag / zklogin-flag / passkey-flag
    ed25519-flag     = %x00
    secp256k1-flag   = %x01
    secp256r1-flag   = %x02
    multisig-flag    = %x03
    bls-flag         = %x04
    zklogin-flag     = %x05
    passkey-flag     = %x06
    ```
    """

    ED25519 = 0
    
    SECP256K1 = 1
    
    SECP256R1 = 2
    
    MULTISIG = 3
    
    BLS12381 = 4
    
    ZK_LOGIN = 5
    
    PASSKEY = 6
    


class _UniffiConverterTypeSignatureScheme(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignatureScheme.ED25519
        if variant == 2:
            return SignatureScheme.SECP256K1
        if variant == 3:
            return SignatureScheme.SECP256R1
        if variant == 4:
            return SignatureScheme.MULTISIG
        if variant == 5:
            return SignatureScheme.BLS12381
        if variant == 6:
            return SignatureScheme.ZK_LOGIN
        if variant == 7:
            return SignatureScheme.PASSKEY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == SignatureScheme.ED25519:
            return
        if value == SignatureScheme.SECP256K1:
            return
        if value == SignatureScheme.SECP256R1:
            return
        if value == SignatureScheme.MULTISIG:
            return
        if value == SignatureScheme.BLS12381:
            return
        if value == SignatureScheme.ZK_LOGIN:
            return
        if value == SignatureScheme.PASSKEY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == SignatureScheme.ED25519:
            buf.write_i32(1)
        if value == SignatureScheme.SECP256K1:
            buf.write_i32(2)
        if value == SignatureScheme.SECP256R1:
            buf.write_i32(3)
        if value == SignatureScheme.MULTISIG:
            buf.write_i32(4)
        if value == SignatureScheme.BLS12381:
            buf.write_i32(5)
        if value == SignatureScheme.ZK_LOGIN:
            buf.write_i32(6)
        if value == SignatureScheme.PASSKEY:
            buf.write_i32(7)







class TransactionArgument:
    """
    A transaction argument used in programmable transactions.
    """

    def __init__(self):
        raise RuntimeError("TransactionArgument cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class GAS_COIN:
        """
        Reference to the gas coin.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TransactionArgument.GAS_COIN()".format()

        def __eq__(self, other):
            if not other.is_GAS_COIN():
                return False
            return True
    
    class INPUT:
        """
        An input to the programmable transaction block.
        """

        ix: "int"
        """
        Index of the programmable transaction block input (0-indexed).
        """


        def __init__(self,ix: "int"):
            self.ix = ix

        def __str__(self):
            return "TransactionArgument.INPUT(ix={})".format(self.ix)

        def __eq__(self, other):
            if not other.is_INPUT():
                return False
            if self.ix != other.ix:
                return False
            return True
    
    class RESULT:
        """
        The result of another transaction command.
        """

        cmd: "int"
        """
        The index of the previous command (0-indexed) that returned this
        result.
        """

        ix: "typing.Optional[int]"
        """
        If the previous command returns multiple values, this is the index
        of the individual result among the multiple results from
        that command (also 0-indexed).
        """


        def __init__(self,cmd: "int", ix: "typing.Optional[int]"):
            self.cmd = cmd
            self.ix = ix

        def __str__(self):
            return "TransactionArgument.RESULT(cmd={}, ix={})".format(self.cmd, self.ix)

        def __eq__(self, other):
            if not other.is_RESULT():
                return False
            if self.cmd != other.cmd:
                return False
            if self.ix != other.ix:
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_GAS_COIN(self) -> bool:
        return isinstance(self, TransactionArgument.GAS_COIN)
    def is_gas_coin(self) -> bool:
        return isinstance(self, TransactionArgument.GAS_COIN)
    def is_INPUT(self) -> bool:
        return isinstance(self, TransactionArgument.INPUT)
    def is_input(self) -> bool:
        return isinstance(self, TransactionArgument.INPUT)
    def is_RESULT(self) -> bool:
        return isinstance(self, TransactionArgument.RESULT)
    def is_result(self) -> bool:
        return isinstance(self, TransactionArgument.RESULT)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TransactionArgument.GAS_COIN = type("TransactionArgument.GAS_COIN", (TransactionArgument.GAS_COIN, TransactionArgument,), {})  # type: ignore
TransactionArgument.INPUT = type("TransactionArgument.INPUT", (TransactionArgument.INPUT, TransactionArgument,), {})  # type: ignore
TransactionArgument.RESULT = type("TransactionArgument.RESULT", (TransactionArgument.RESULT, TransactionArgument,), {})  # type: ignore




class _UniffiConverterTypeTransactionArgument(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionArgument.GAS_COIN(
            )
        if variant == 2:
            return TransactionArgument.INPUT(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 3:
            return TransactionArgument.RESULT(
                _UniffiConverterUInt32.read(buf),
                _UniffiConverterOptionalUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_GAS_COIN():
            return
        if value.is_INPUT():
            _UniffiConverterUInt32.check_lower(value.ix)
            return
        if value.is_RESULT():
            _UniffiConverterUInt32.check_lower(value.cmd)
            _UniffiConverterOptionalUInt32.check_lower(value.ix)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_GAS_COIN():
            buf.write_i32(1)
        if value.is_INPUT():
            buf.write_i32(2)
            _UniffiConverterUInt32.write(value.ix, buf)
        if value.is_RESULT():
            buf.write_i32(3)
            _UniffiConverterUInt32.write(value.cmd, buf)
            _UniffiConverterOptionalUInt32.write(value.ix, buf)







class TransactionBlockKindInput(enum.Enum):
    SYSTEM_TX = 0
    
    PROGRAMMABLE_TX = 1
    
    GENESIS = 2
    
    CONSENSUS_COMMIT_PROLOGUE_V1 = 3
    
    AUTHENTICATOR_STATE_UPDATE_V1 = 4
    
    RANDOMNESS_STATE_UPDATE = 5
    
    END_OF_EPOCH_TX = 6
    


class _UniffiConverterTypeTransactionBlockKindInput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionBlockKindInput.SYSTEM_TX
        if variant == 2:
            return TransactionBlockKindInput.PROGRAMMABLE_TX
        if variant == 3:
            return TransactionBlockKindInput.GENESIS
        if variant == 4:
            return TransactionBlockKindInput.CONSENSUS_COMMIT_PROLOGUE_V1
        if variant == 5:
            return TransactionBlockKindInput.AUTHENTICATOR_STATE_UPDATE_V1
        if variant == 6:
            return TransactionBlockKindInput.RANDOMNESS_STATE_UPDATE
        if variant == 7:
            return TransactionBlockKindInput.END_OF_EPOCH_TX
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TransactionBlockKindInput.SYSTEM_TX:
            return
        if value == TransactionBlockKindInput.PROGRAMMABLE_TX:
            return
        if value == TransactionBlockKindInput.GENESIS:
            return
        if value == TransactionBlockKindInput.CONSENSUS_COMMIT_PROLOGUE_V1:
            return
        if value == TransactionBlockKindInput.AUTHENTICATOR_STATE_UPDATE_V1:
            return
        if value == TransactionBlockKindInput.RANDOMNESS_STATE_UPDATE:
            return
        if value == TransactionBlockKindInput.END_OF_EPOCH_TX:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TransactionBlockKindInput.SYSTEM_TX:
            buf.write_i32(1)
        if value == TransactionBlockKindInput.PROGRAMMABLE_TX:
            buf.write_i32(2)
        if value == TransactionBlockKindInput.GENESIS:
            buf.write_i32(3)
        if value == TransactionBlockKindInput.CONSENSUS_COMMIT_PROLOGUE_V1:
            buf.write_i32(4)
        if value == TransactionBlockKindInput.AUTHENTICATOR_STATE_UPDATE_V1:
            buf.write_i32(5)
        if value == TransactionBlockKindInput.RANDOMNESS_STATE_UPDATE:
            buf.write_i32(6)
        if value == TransactionBlockKindInput.END_OF_EPOCH_TX:
            buf.write_i32(7)







class TransactionExpiration:
    """
    A TTL for a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-expiration =  %x00      ; none
    =/ %x01 u64  ; epoch
    ```
    """

    def __init__(self):
        raise RuntimeError("TransactionExpiration cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class NONE:
        """
        The transaction has no expiration
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "TransactionExpiration.NONE()".format()

        def __eq__(self, other):
            if not other.is_NONE():
                return False
            return True
    
    class EPOCH:
        """
        Validators wont sign a transaction unless the expiration Epoch
        is greater than or equal to the current epoch
        """

        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __str__(self):
            return f"TransactionExpiration.EPOCH{self._values!r}"

        def __eq__(self, other):
            if not other.is_EPOCH():
                return False
            return self._values == other._values
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_NONE(self) -> bool:
        return isinstance(self, TransactionExpiration.NONE)
    def is_none(self) -> bool:
        return isinstance(self, TransactionExpiration.NONE)
    def is_EPOCH(self) -> bool:
        return isinstance(self, TransactionExpiration.EPOCH)
    def is_epoch(self) -> bool:
        return isinstance(self, TransactionExpiration.EPOCH)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
TransactionExpiration.NONE = type("TransactionExpiration.NONE", (TransactionExpiration.NONE, TransactionExpiration,), {})  # type: ignore
TransactionExpiration.EPOCH = type("TransactionExpiration.EPOCH", (TransactionExpiration.EPOCH, TransactionExpiration,), {})  # type: ignore




class _UniffiConverterTypeTransactionExpiration(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionExpiration.NONE(
            )
        if variant == 2:
            return TransactionExpiration.EPOCH(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_NONE():
            return
        if value.is_EPOCH():
            _UniffiConverterUInt64.check_lower(value._values[0])
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_NONE():
            buf.write_i32(1)
        if value.is_EPOCH():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value._values[0], buf)







class TypeArgumentError(enum.Enum):
    """
    An error with a type argument

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    type-argument-error = type-not-found / constraint-not-satisfied
    type-not-found = %x00
    constraint-not-satisfied = %x01
    ```
    """

    TYPE_NOT_FOUND = 0
    """
    A type was not found in the module specified
    """

    
    CONSTRAINT_NOT_SATISFIED = 1
    """
    A type provided did not match the specified constraint
    """

    


class _UniffiConverterTypeTypeArgumentError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TypeArgumentError.TYPE_NOT_FOUND
        if variant == 2:
            return TypeArgumentError.CONSTRAINT_NOT_SATISFIED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == TypeArgumentError.TYPE_NOT_FOUND:
            return
        if value == TypeArgumentError.CONSTRAINT_NOT_SATISFIED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == TypeArgumentError.TYPE_NOT_FOUND:
            buf.write_i32(1)
        if value == TypeArgumentError.CONSTRAINT_NOT_SATISFIED:
            buf.write_i32(2)







class UnchangedSharedKind:
    """
    Type of unchanged shared object

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    unchanged-shared-object-kind =  read-only-root
    =/ mutate-deleted
    =/ read-deleted
    =/ cancelled
    =/ per-epoch-config

    read-only-root      = %x00 u64 digest
    mutate-deleted      = %x01 u64
    read-deleted        = %x02 u64
    cancelled           = %x03 u64
    per-epoch-config    = %x04
    ```
    """

    def __init__(self):
        raise RuntimeError("UnchangedSharedKind cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class READ_ONLY_ROOT:
        """
        Read-only shared objects from the input. We don't really need
        ObjectDigest for protocol correctness, but it will make it easier to
        verify untrusted read.
        """

        version: "int"
        digest: "Digest"

        def __init__(self,version: "int", digest: "Digest"):
            self.version = version
            self.digest = digest

        def __str__(self):
            return "UnchangedSharedKind.READ_ONLY_ROOT(version={}, digest={})".format(self.version, self.digest)

        def __eq__(self, other):
            if not other.is_READ_ONLY_ROOT():
                return False
            if self.version != other.version:
                return False
            if self.digest != other.digest:
                return False
            return True
    
    class MUTATE_DELETED:
        """
        Deleted shared objects that appear mutably/owned in the input.
        """

        version: "int"

        def __init__(self,version: "int"):
            self.version = version

        def __str__(self):
            return "UnchangedSharedKind.MUTATE_DELETED(version={})".format(self.version)

        def __eq__(self, other):
            if not other.is_MUTATE_DELETED():
                return False
            if self.version != other.version:
                return False
            return True
    
    class READ_DELETED:
        """
        Deleted shared objects that appear as read-only in the input.
        """

        version: "int"

        def __init__(self,version: "int"):
            self.version = version

        def __str__(self):
            return "UnchangedSharedKind.READ_DELETED(version={})".format(self.version)

        def __eq__(self, other):
            if not other.is_READ_DELETED():
                return False
            if self.version != other.version:
                return False
            return True
    
    class CANCELLED:
        """
        Shared objects in cancelled transaction. The sequence number embed
        cancellation reason.
        """

        version: "int"

        def __init__(self,version: "int"):
            self.version = version

        def __str__(self):
            return "UnchangedSharedKind.CANCELLED(version={})".format(self.version)

        def __eq__(self, other):
            if not other.is_CANCELLED():
                return False
            if self.version != other.version:
                return False
            return True
    
    class PER_EPOCH_CONFIG:
        """
        Read of a per-epoch config object that should remain the same during an
        epoch.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "UnchangedSharedKind.PER_EPOCH_CONFIG()".format()

        def __eq__(self, other):
            if not other.is_PER_EPOCH_CONFIG():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_READ_ONLY_ROOT(self) -> bool:
        return isinstance(self, UnchangedSharedKind.READ_ONLY_ROOT)
    def is_read_only_root(self) -> bool:
        return isinstance(self, UnchangedSharedKind.READ_ONLY_ROOT)
    def is_MUTATE_DELETED(self) -> bool:
        return isinstance(self, UnchangedSharedKind.MUTATE_DELETED)
    def is_mutate_deleted(self) -> bool:
        return isinstance(self, UnchangedSharedKind.MUTATE_DELETED)
    def is_READ_DELETED(self) -> bool:
        return isinstance(self, UnchangedSharedKind.READ_DELETED)
    def is_read_deleted(self) -> bool:
        return isinstance(self, UnchangedSharedKind.READ_DELETED)
    def is_CANCELLED(self) -> bool:
        return isinstance(self, UnchangedSharedKind.CANCELLED)
    def is_cancelled(self) -> bool:
        return isinstance(self, UnchangedSharedKind.CANCELLED)
    def is_PER_EPOCH_CONFIG(self) -> bool:
        return isinstance(self, UnchangedSharedKind.PER_EPOCH_CONFIG)
    def is_per_epoch_config(self) -> bool:
        return isinstance(self, UnchangedSharedKind.PER_EPOCH_CONFIG)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
UnchangedSharedKind.READ_ONLY_ROOT = type("UnchangedSharedKind.READ_ONLY_ROOT", (UnchangedSharedKind.READ_ONLY_ROOT, UnchangedSharedKind,), {})  # type: ignore
UnchangedSharedKind.MUTATE_DELETED = type("UnchangedSharedKind.MUTATE_DELETED", (UnchangedSharedKind.MUTATE_DELETED, UnchangedSharedKind,), {})  # type: ignore
UnchangedSharedKind.READ_DELETED = type("UnchangedSharedKind.READ_DELETED", (UnchangedSharedKind.READ_DELETED, UnchangedSharedKind,), {})  # type: ignore
UnchangedSharedKind.CANCELLED = type("UnchangedSharedKind.CANCELLED", (UnchangedSharedKind.CANCELLED, UnchangedSharedKind,), {})  # type: ignore
UnchangedSharedKind.PER_EPOCH_CONFIG = type("UnchangedSharedKind.PER_EPOCH_CONFIG", (UnchangedSharedKind.PER_EPOCH_CONFIG, UnchangedSharedKind,), {})  # type: ignore




class _UniffiConverterTypeUnchangedSharedKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return UnchangedSharedKind.READ_ONLY_ROOT(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterTypeDigest.read(buf),
            )
        if variant == 2:
            return UnchangedSharedKind.MUTATE_DELETED(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return UnchangedSharedKind.READ_DELETED(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 4:
            return UnchangedSharedKind.CANCELLED(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 5:
            return UnchangedSharedKind.PER_EPOCH_CONFIG(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_READ_ONLY_ROOT():
            _UniffiConverterUInt64.check_lower(value.version)
            _UniffiConverterTypeDigest.check_lower(value.digest)
            return
        if value.is_MUTATE_DELETED():
            _UniffiConverterUInt64.check_lower(value.version)
            return
        if value.is_READ_DELETED():
            _UniffiConverterUInt64.check_lower(value.version)
            return
        if value.is_CANCELLED():
            _UniffiConverterUInt64.check_lower(value.version)
            return
        if value.is_PER_EPOCH_CONFIG():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_READ_ONLY_ROOT():
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.version, buf)
            _UniffiConverterTypeDigest.write(value.digest, buf)
        if value.is_MUTATE_DELETED():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.version, buf)
        if value.is_READ_DELETED():
            buf.write_i32(3)
            _UniffiConverterUInt64.write(value.version, buf)
        if value.is_CANCELLED():
            buf.write_i32(4)
            _UniffiConverterUInt64.write(value.version, buf)
        if value.is_PER_EPOCH_CONFIG():
            buf.write_i32(5)







class WaitForTx(enum.Enum):
    """
    Determines what to wait for after executing a transaction.
    """

    INDEXED = 0
    """
    Indicates that the transaction effects will be usable in subsequent
    transactions, and that the transaction itself is indexed on the node.
    """

    
    FINALIZED = 1
    """
    Indicates that the transaction has been included in a checkpoint, and
    all queries may include it.
    """

    


class _UniffiConverterTypeWaitForTx(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WaitForTx.INDEXED
        if variant == 2:
            return WaitForTx.FINALIZED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == WaitForTx.INDEXED:
            return
        if value == WaitForTx.FINALIZED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == WaitForTx.INDEXED:
            buf.write_i32(1)
        if value == WaitForTx.FINALIZED:
            buf.write_i32(2)





class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalDuration(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterDuration.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterDuration.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterDuration.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeAddress.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeAddress.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeAddress.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeArgument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeArgument.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeArgument.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeArgument.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCheckpointSummary(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCheckpointSummary.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCheckpointSummary.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCheckpointSummary.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDigest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDigest.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDigest.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDigest.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEd25519PublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEd25519PublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEd25519PublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEd25519PublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEd25519Signature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEd25519Signature.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEd25519Signature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEd25519Signature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveArg(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveArg.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveArg.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveArg.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveFunction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveFunction.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveFunction.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveFunction.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMovePackage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMovePackage.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMovePackage.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMovePackage.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMultisigAggregatedSignature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMultisigAggregatedSignature.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMultisigAggregatedSignature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMultisigAggregatedSignature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeName(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeName.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeName.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeName.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeObject(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeObject.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeObject.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeObject.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeObjectId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeObjectId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeObjectId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeObjectId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePasskeyAuthenticator(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePasskeyAuthenticator.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePasskeyAuthenticator.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePasskeyAuthenticator.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePtbArgument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePtbArgument.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePtbArgument.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePtbArgument.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSecp256k1PublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSecp256k1PublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSecp256k1PublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSecp256k1PublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSecp256k1Signature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSecp256k1Signature.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSecp256k1Signature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSecp256k1Signature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSecp256r1PublicKey(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSecp256r1PublicKey.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSecp256r1PublicKey.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSecp256r1PublicKey.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSecp256r1Signature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSecp256r1Signature.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSecp256r1Signature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSecp256r1Signature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSimpleSignature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSimpleSignature.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSimpleSignature.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSimpleSignature.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeStructTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeStructTag.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeStructTag.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeStructTag.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionEffects(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionEffects.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionEffects.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionEffects.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTypeTag.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTypeTag.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTypeTag.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeZkLoginAuthenticator(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeZkLoginAuthenticator.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeZkLoginAuthenticator.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeZkLoginAuthenticator.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeZkLoginPublicIdentifier(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeZkLoginPublicIdentifier.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeZkLoginPublicIdentifier.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeZkLoginPublicIdentifier.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeZkloginVerifier(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeZkloginVerifier.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeZkloginVerifier.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeZkloginVerifier.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeBatchSendStatus(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeBatchSendStatus.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeBatchSendStatus.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeBatchSendStatus.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCoinMetadata(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCoinMetadata.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCoinMetadata.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCoinMetadata.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDynamicFieldOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDynamicFieldOutput.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDynamicFieldOutput.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDynamicFieldOutput.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeDynamicFieldValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeDynamicFieldValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeDynamicFieldValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeDynamicFieldValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEndOfEpochData(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEndOfEpochData.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEndOfEpochData.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEndOfEpochData.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEpoch(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEpoch.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEpoch.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEpoch.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeEventFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeEventFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeEventFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeEventFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeFaucetReceipt(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeFaucetReceipt.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeFaucetReceipt.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeFaucetReceipt.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveEnumConnection(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveEnumConnection.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveEnumConnection.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveEnumConnection.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveFunctionConnection(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveFunctionConnection.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveFunctionConnection.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveFunctionConnection.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveLocation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveLocation.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveLocation.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveLocation.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveModule(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveModule.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveModule.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveModule.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveStruct(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveStruct.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveStruct.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveStruct.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveStructConnection(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveStructConnection.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveStructConnection.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveStructConnection.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeObjectFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeObjectFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeObjectFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeObjectFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeOpenMoveType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeOpenMoveType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeOpenMoveType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeOpenMoveType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypePaginationFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypePaginationFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypePaginationFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypePaginationFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeProtocolConfigs(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeProtocolConfigs.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeProtocolConfigs.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeProtocolConfigs.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeSignedTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeSignedTransaction.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeSignedTransaction.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeSignedTransaction.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionDataEffects(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionDataEffects.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionDataEffects.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionDataEffects.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionsFilter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionsFilter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionsFilter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionsFilter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeValidatorCredentials(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeValidatorCredentials.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeValidatorCredentials.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeValidatorCredentials.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeValidatorSet(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeValidatorSet.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeValidatorSet.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeValidatorSet.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMnemonicLength(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMnemonicLength.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMnemonicLength.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMnemonicLength.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeMoveVisibility(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeMoveVisibility.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeMoveVisibility.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeMoveVisibility.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNameFormat(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNameFormat.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNameFormat.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNameFormat.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransactionBlockKindInput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransactionBlockKindInput.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransactionBlockKindInput.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransactionBlockKindInput.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeWaitForTx(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeWaitForTx.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeWaitForTx.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeWaitForTx.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeObjectId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeObjectId.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeObjectId.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeObjectId.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeMoveEnumVariant(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeMoveEnumVariant.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeMoveEnumVariant.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeMoveEnumVariant.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeMoveField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeMoveField.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeMoveField.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeMoveField.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeMoveFunctionTypeParameter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeMoveFunctionTypeParameter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeMoveFunctionTypeParameter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeMoveFunctionTypeParameter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeMoveStructTypeParameter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeMoveStructTypeParameter.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeMoveStructTypeParameter.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeMoveStructTypeParameter.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeObjectRef(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeObjectRef.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeObjectRef.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeObjectRef.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeOpenMoveType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeOpenMoveType.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeOpenMoveType.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeOpenMoveType.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalSequenceTypeMoveAbility(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterSequenceTypeMoveAbility.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterSequenceTypeMoveAbility.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterSequenceTypeMoveAbility.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalMapStringSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterMapStringSequenceString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterMapStringSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterMapStringSequenceString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeBase64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeBase64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeBase64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeBase64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeBigInt(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeBigInt.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeBigInt.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeBigInt.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeValue(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeValue.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeValue.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeValue.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt16(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt16.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt16.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt16.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt32.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt32.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterInt32.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterInt32.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterInt32.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt64.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt64.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBool(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBool.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBool.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBool.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterBytes.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterBytes.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterBytes.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAddress(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAddress.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAddress.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAddress.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeArgument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeArgument.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeArgument.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeArgument.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCancelledTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCancelledTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCancelledTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCancelledTransaction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCheckpointCommitment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCheckpointCommitment.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCheckpointCommitment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCheckpointCommitment.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCheckpointSummary(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCheckpointSummary.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCheckpointSummary.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCheckpointSummary.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCheckpointTransactionInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCheckpointTransactionInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCheckpointTransactionInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCheckpointTransactionInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCoin(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCoin.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCoin.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCoin.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCommand(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCommand.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCommand.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCommand.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDigest(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDigest.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDigest.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDigest.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEndOfEpochTransactionKind(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEndOfEpochTransactionKind.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEndOfEpochTransactionKind.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEndOfEpochTransactionKind.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeExecutionTimeObservation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeExecutionTimeObservation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeExecutionTimeObservation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeExecutionTimeObservation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeGenesisObject(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeGenesisObject.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeGenesisObject.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeGenesisObject.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeInput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeInput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeInput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeInput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveArg(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveArg.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveArg.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveArg.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveFunction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveFunction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveFunction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveFunction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMovePackage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMovePackage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMovePackage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMovePackage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMultisigMember(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMultisigMember.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMultisigMember.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMultisigMember.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMultisigMemberSignature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMultisigMemberSignature.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMultisigMemberSignature.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMultisigMemberSignature.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeNameRegistration(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeNameRegistration.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeNameRegistration.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeNameRegistration.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeObject(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeObject.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeObject.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeObject.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeObjectId(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeObjectId.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeObjectId.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeObjectId.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePtbArgument(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePtbArgument.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePtbArgument.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePtbArgument.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSystemPackage(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSystemPackage.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSystemPackage.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSystemPackage.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTransactionEffects(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTransactionEffects.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTransactionEffects.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTransactionEffects.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTypeTag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTypeTag.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTypeTag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTypeTag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeUserSignature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeUserSignature.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUserSignature.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeUserSignature.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeValidatorExecutionTimeObservation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeValidatorExecutionTimeObservation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeValidatorExecutionTimeObservation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeValidatorExecutionTimeObservation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeVersionAssignment(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeVersionAssignment.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeVersionAssignment.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeVersionAssignment.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeActiveJwk(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeActiveJwk.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeActiveJwk.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeActiveJwk.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeChangedObject(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeChangedObject.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeChangedObject.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeChangedObject.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCoinInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCoinInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCoinInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCoinInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDryRunEffect(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDryRunEffect.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDryRunEffect.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDryRunEffect.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDryRunMutation(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDryRunMutation.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDryRunMutation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDryRunMutation.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDryRunReturn(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDryRunReturn.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDryRunReturn.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDryRunReturn.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeDynamicFieldOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeDynamicFieldOutput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeDynamicFieldOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeDynamicFieldOutput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEpoch(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEpoch.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEpoch.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEpoch.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeEvent.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeEvent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeEvent.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveEnum(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveEnum.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveEnum.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveEnum.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveEnumVariant(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveEnumVariant.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveEnumVariant.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveEnumVariant.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveField(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveField.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveField.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveField.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveFunctionTypeParameter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveFunctionTypeParameter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveFunctionTypeParameter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveFunctionTypeParameter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveModuleQuery(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveModuleQuery.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveModuleQuery.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveModuleQuery.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveStructQuery(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveStructQuery.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveStructQuery.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveStructQuery.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveStructTypeParameter(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveStructTypeParameter.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveStructTypeParameter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveStructTypeParameter.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeObjectRef(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeObjectRef.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeObjectRef.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeObjectRef.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeObjectReference(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeObjectReference.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeObjectReference.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeObjectReference.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOpenMoveType(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOpenMoveType.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOpenMoveType.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOpenMoveType.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeProtocolConfigAttr(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeProtocolConfigAttr.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeProtocolConfigAttr.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeProtocolConfigAttr.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeProtocolConfigFeatureFlag(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeProtocolConfigFeatureFlag.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeProtocolConfigFeatureFlag.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeProtocolConfigFeatureFlag.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeSignedTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeSignedTransaction.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeSignedTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeSignedTransaction.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTransactionDataEffects(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTransactionDataEffects.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTransactionDataEffects.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTransactionDataEffects.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTypeOrigin(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTypeOrigin.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTypeOrigin.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTypeOrigin.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeUnchangedSharedObject(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeUnchangedSharedObject.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeUnchangedSharedObject.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeUnchangedSharedObject.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeValidator(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeValidator.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeValidator.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeValidator.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeValidatorCommitteeMember(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeValidatorCommitteeMember.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeValidatorCommitteeMember.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeValidatorCommitteeMember.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFeature(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFeature.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFeature.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFeature.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeMoveAbility(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeMoveAbility.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeMoveAbility.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeMoveAbility.read(buf) for i in range(count)
        ]



class _UniffiConverterMapStringSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterString.check_lower(key)
            _UniffiConverterSequenceString.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterString.write(key, buf)
            _UniffiConverterSequenceString.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterString.read(buf)
            val = _UniffiConverterSequenceString.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeIdentifierBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeIdentifier.check_lower(key)
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeIdentifier.write(key, buf)
            _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeIdentifier.read(buf)
            val = _UniffiConverterBytes.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeObjectIdTypeUpgradeInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeObjectId.check_lower(key)
            _UniffiConverterTypeUpgradeInfo.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeObjectId.write(key, buf)
            _UniffiConverterTypeUpgradeInfo.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeObjectId.read(buf)
            val = _UniffiConverterTypeUpgradeInfo.read(buf)
            d[key] = val
        return d



class _UniffiConverterMapTypeJwkIdTypeJwk(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, items):
        for (key, value) in items.items():
            _UniffiConverterTypeJwkId.check_lower(key)
            _UniffiConverterTypeJwk.check_lower(value)

    @classmethod
    def write(cls, items, buf):
        buf.write_i32(len(items))
        for (key, value) in items.items():
            _UniffiConverterTypeJwkId.write(key, buf)
            _UniffiConverterTypeJwk.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = _UniffiConverterTypeJwkId.read(buf)
            val = _UniffiConverterTypeJwk.read(buf)
            d[key] = val
        return d


class _UniffiConverterTypeBase64:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeBigInt:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)


class _UniffiConverterTypeValue:
    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value, buf)

    @staticmethod
    def read(buf):
        return _UniffiConverterString.read(buf)

    @staticmethod
    def lift(value):
        return _UniffiConverterString.lift(value)

    @staticmethod
    def check_lower(value):
        return _UniffiConverterString.check_lower(value)

    @staticmethod
    def lower(value):
        return _UniffiConverterString.lower(value)

# objects.
class AddressProtocol(typing.Protocol):
    """
    Unique identifier for an Account on the IOTA blockchain.

    An `Address` is a 32-byte pseudonymous identifier used to uniquely identify
    an account and asset-ownership on the IOTA blockchain. Often, human-readable
    addresses are encoded in hexadecimal with a `0x` prefix. For example, this
    is a valid IOTA address:
    `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`.

    # Deriving an Address

    Addresses are cryptographically derived from a number of user account
    authenticators, the simplest of which is an
    `Ed25519PublicKey`.

    Deriving an address consists of the Blake2b256 hash of the sequence of bytes
    of its corresponding authenticator, prefixed with a domain-separator (except
    ed25519, for compatibility reasons). For each other authenticator, this
    domain-separator is the single byte-value of its
    `SignatureScheme` flag. E.g. `hash(signature schema flag || authenticator
    bytes)`.

    Each authenticator has a method for deriving its `Address` as well as
    documentation for the specifics of how the derivation is done. See
    `Ed25519PublicKey::derive_address` for an example.

    ## Relationship to ObjectIds

    `ObjectId`s and `Address`es share the same 32-byte addressable space but
    are derived leveraging different domain-separator values to ensure that,
    cryptographically, there won't be any overlap, e.g. there can't be a
    valid `Object` who's `ObjectId` is equal to that of the `Address` of a user
    account.

    # BCS

    An `Address`'s BCS serialized form is defined by the following:

    ```text
    address = 32OCTET
    ```
    """

    def to_bytes(self, ):
        raise NotImplementedError
    def to_canonical_string(self, with_prefix: "bool"):
        """
        Returns the string representation of this address using the
        canonical display, with or without a `0x` prefix.
        """

        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_short_string(self, with_prefix: "bool"):
        """
        Returns the shortest possible string representation of the address (i.e.
        with leading zeroes trimmed).
        """

        raise NotImplementedError
# Address is a Rust-only trait - it's a wrapper around a Rust implementation.
class Address():
    """
    Unique identifier for an Account on the IOTA blockchain.

    An `Address` is a 32-byte pseudonymous identifier used to uniquely identify
    an account and asset-ownership on the IOTA blockchain. Often, human-readable
    addresses are encoded in hexadecimal with a `0x` prefix. For example, this
    is a valid IOTA address:
    `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`.

    # Deriving an Address

    Addresses are cryptographically derived from a number of user account
    authenticators, the simplest of which is an
    `Ed25519PublicKey`.

    Deriving an address consists of the Blake2b256 hash of the sequence of bytes
    of its corresponding authenticator, prefixed with a domain-separator (except
    ed25519, for compatibility reasons). For each other authenticator, this
    domain-separator is the single byte-value of its
    `SignatureScheme` flag. E.g. `hash(signature schema flag || authenticator
    bytes)`.

    Each authenticator has a method for deriving its `Address` as well as
    documentation for the specifics of how the derivation is done. See
    `Ed25519PublicKey::derive_address` for an example.

    ## Relationship to ObjectIds

    `ObjectId`s and `Address`es share the same 32-byte addressable space but
    are derived leveraging different domain-separator values to ensure that,
    cryptographically, there won't be any overlap, e.g. there can't be a
    valid `Object` who's `ObjectId` is equal to that of the `Address` of a user
    account.

    # BCS

    An `Address`'s BCS serialized form is defined by the following:

    ```text
    address = 32OCTET
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_address, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_address, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def framework(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_framework,)
        return cls._make_instance_(pointer)

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_generate,)
        return cls._make_instance_(pointer)

    @classmethod
    def std_lib(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_std_lib,)
        return cls._make_instance_(pointer)

    @classmethod
    def system(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_system,)
        return cls._make_instance_(pointer)

    @classmethod
    def zero(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_address_zero,)
        return cls._make_instance_(pointer)



    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_canonical_string(self, with_prefix: "bool") -> "str":
        """
        Returns the string representation of this address using the
        canonical display, with or without a `0x` prefix.
        """

        _UniffiConverterBool.check_lower(with_prefix)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_canonical_string,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(with_prefix))
        )





    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_hex,self._uniffi_clone_pointer(),)
        )





    def to_short_string(self, with_prefix: "bool") -> "str":
        """
        Returns the shortest possible string representation of the address (i.e.
        with leading zeroes trimmed).
        """

        _UniffiConverterBool.check_lower(with_prefix)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_address_to_short_string,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(with_prefix))
        )






class _UniffiConverterTypeAddress:

    @staticmethod
    def lift(value: int):
        return Address._make_instance_(value)

    @staticmethod
    def check_lower(value: Address):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AddressProtocol):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AddressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ArgumentProtocol(typing.Protocol):
    """
    An argument to a programmable transaction command

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    argument    =  argument-gas
    =/ argument-input
    =/ argument-result
    =/ argument-nested-result

    argument-gas            = %x00
    argument-input          = %x01 u16
    argument-result         = %x02 u16
    argument-nested-result  = %x03 u16 u16
    ```
    """

    def get_nested_result(self, ix: "int"):
        """
        Get the nested result for this result at the given index. Returns None
        if this is not a Result.
        """

        raise NotImplementedError
# Argument is a Rust-only trait - it's a wrapper around a Rust implementation.
class Argument():
    """
    An argument to a programmable transaction command

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    argument    =  argument-gas
    =/ argument-input
    =/ argument-result
    =/ argument-nested-result

    argument-gas            = %x00
    argument-input          = %x01 u16
    argument-result         = %x02 u16
    argument-nested-result  = %x03 u16 u16
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_argument, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_argument, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_gas(cls, ):
        """
        The gas coin. The gas coin can only be used by-ref, except for with
        `TransferObjects`, which can use it by-value.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_gas,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_input(cls, input: "int"):
        """
        One of the input objects or primitive values (from
        `ProgrammableTransaction` inputs)
        """

        _UniffiConverterUInt16.check_lower(input)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_input,
        _UniffiConverterUInt16.lower(input))
        return cls._make_instance_(pointer)

    @classmethod
    def new_nested_result(cls, command_index: "int",subresult_index: "int"):
        """
        Like a `Result` but it accesses a nested result. Currently, the only
        usage of this is to access a value from a Move call with multiple
        return values.
        """

        _UniffiConverterUInt16.check_lower(command_index)
        
        _UniffiConverterUInt16.check_lower(subresult_index)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_nested_result,
        _UniffiConverterUInt16.lower(command_index),
        _UniffiConverterUInt16.lower(subresult_index))
        return cls._make_instance_(pointer)

    @classmethod
    def new_result(cls, result: "int"):
        """
        The result of another command (from `ProgrammableTransaction` commands)
        """

        _UniffiConverterUInt16.check_lower(result)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_argument_new_result,
        _UniffiConverterUInt16.lower(result))
        return cls._make_instance_(pointer)



    def get_nested_result(self, ix: "int") -> "typing.Optional[Argument]":
        """
        Get the nested result for this result at the given index. Returns None
        if this is not a Result.
        """

        _UniffiConverterUInt16.check_lower(ix)
        
        return _UniffiConverterOptionalTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_argument_get_nested_result,self._uniffi_clone_pointer(),
        _UniffiConverterUInt16.lower(ix))
        )






class _UniffiConverterTypeArgument:

    @staticmethod
    def lift(value: int):
        return Argument._make_instance_(value)

    @staticmethod
    def check_lower(value: Argument):
        if not isinstance(value, Argument):
            raise TypeError("Expected Argument instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ArgumentProtocol):
        if not isinstance(value, Argument):
            raise TypeError("Expected Argument instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ArgumentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Bls12381PrivateKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def sign_checkpoint_summary(self, summary: "CheckpointSummary"):
        raise NotImplementedError
    def try_sign(self, message: "bytes"):
        raise NotImplementedError
    def verifying_key(self, ):
        raise NotImplementedError
# Bls12381PrivateKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Bls12381PrivateKey():
    _pointer: ctypes.c_void_p
    def __init__(self, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_new,
        _UniffiConverterBytes.lower(bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381privatekey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381privatekey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381privatekey_generate,)
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Bls12381PublicKey":
        return _UniffiConverterTypeBls12381PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_public_key,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_scheme,self._uniffi_clone_pointer(),)
        )





    def sign_checkpoint_summary(self, summary: "CheckpointSummary") -> "ValidatorSignature":
        _UniffiConverterTypeCheckpointSummary.check_lower(summary)
        
        return _UniffiConverterTypeValidatorSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_sign_checkpoint_summary,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCheckpointSummary.lower(summary))
        )





    def try_sign(self, message: "bytes") -> "Bls12381Signature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeBls12381Signature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_try_sign,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def verifying_key(self, ) -> "Bls12381VerifyingKey":
        return _UniffiConverterTypeBls12381VerifyingKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381privatekey_verifying_key,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBls12381PrivateKey:

    @staticmethod
    def lift(value: int):
        return Bls12381PrivateKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Bls12381PrivateKey):
        if not isinstance(value, Bls12381PrivateKey):
            raise TypeError("Expected Bls12381PrivateKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bls12381PrivateKeyProtocol):
        if not isinstance(value, Bls12381PrivateKey):
            raise TypeError("Expected Bls12381PrivateKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bls12381PrivateKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Bls12381PublicKeyProtocol(typing.Protocol):
    """
    A bls12381 min-sig public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    bls-public-key = %x60 96OCTECT
    ```

    Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
    fixed-length of 96, IOTA's binary representation of a min-sig
    `Bls12381PublicKey` is prefixed with its length meaning its serialized
    binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
    """

    def to_bytes(self, ):
        raise NotImplementedError
# Bls12381PublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Bls12381PublicKey():
    """
    A bls12381 min-sig public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    bls-public-key = %x60 96OCTECT
    ```

    Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
    fixed-length of 96, IOTA's binary representation of a min-sig
    `Bls12381PublicKey` is prefixed with its length meaning its serialized
    binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381publickey_generate,)
        return cls._make_instance_(pointer)



    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381publickey_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBls12381PublicKey:

    @staticmethod
    def lift(value: int):
        return Bls12381PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Bls12381PublicKey):
        if not isinstance(value, Bls12381PublicKey):
            raise TypeError("Expected Bls12381PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bls12381PublicKeyProtocol):
        if not isinstance(value, Bls12381PublicKey):
            raise TypeError("Expected Bls12381PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bls12381PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Bls12381SignatureProtocol(typing.Protocol):
    """
    A bls12381 min-sig public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    bls-public-key = %x60 96OCTECT
    ```

    Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
    fixed-length of 96, IOTA's binary representation of a min-sig
    `Bls12381PublicKey` is prefixed with its length meaning its serialized
    binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
    """

    def to_bytes(self, ):
        raise NotImplementedError
# Bls12381Signature is a Rust-only trait - it's a wrapper around a Rust implementation.
class Bls12381Signature():
    """
    A bls12381 min-sig public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    bls-public-key = %x60 96OCTECT
    ```

    Due to historical reasons, even though a min-sig `Bls12381PublicKey` has a
    fixed-length of 96, IOTA's binary representation of a min-sig
    `Bls12381PublicKey` is prefixed with its length meaning its serialized
    binary form (in bcs) is 97 bytes long vs a more compact 96 bytes.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381signature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381signature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381signature_generate,)
        return cls._make_instance_(pointer)



    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381signature_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBls12381Signature:

    @staticmethod
    def lift(value: int):
        return Bls12381Signature._make_instance_(value)

    @staticmethod
    def check_lower(value: Bls12381Signature):
        if not isinstance(value, Bls12381Signature):
            raise TypeError("Expected Bls12381Signature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bls12381SignatureProtocol):
        if not isinstance(value, Bls12381Signature):
            raise TypeError("Expected Bls12381Signature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bls12381SignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Bls12381VerifyingKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def verify(self, message: "bytes",signature: "Bls12381Signature"):
        raise NotImplementedError
# Bls12381VerifyingKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Bls12381VerifyingKey():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "Bls12381PublicKey"):
        _UniffiConverterTypeBls12381PublicKey.check_lower(public_key)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bls12381verifyingkey_new,
        _UniffiConverterTypeBls12381PublicKey.lower(public_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bls12381verifyingkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bls12381verifyingkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def public_key(self, ) -> "Bls12381PublicKey":
        return _UniffiConverterTypeBls12381PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_public_key,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",signature: "Bls12381Signature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeBls12381Signature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bls12381verifyingkey_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeBls12381Signature.lower(signature))







class _UniffiConverterTypeBls12381VerifyingKey:

    @staticmethod
    def lift(value: int):
        return Bls12381VerifyingKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Bls12381VerifyingKey):
        if not isinstance(value, Bls12381VerifyingKey):
            raise TypeError("Expected Bls12381VerifyingKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bls12381VerifyingKeyProtocol):
        if not isinstance(value, Bls12381VerifyingKey):
            raise TypeError("Expected Bls12381VerifyingKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bls12381VerifyingKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Bn254FieldElementProtocol(typing.Protocol):
    """
    A point on the BN254 elliptic curve.

    This is a 32-byte, or 256-bit, value that is generally represented as
    radix10 when a human-readable display format is needed, and is represented
    as a 32-byte big-endian value while in memory.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    bn254-field-element = *DIGIT ; which is then interpreted as a radix10 encoded 32-byte value
    ```
    """

    def padded(self, ):
        raise NotImplementedError
    def unpadded(self, ):
        raise NotImplementedError
# Bn254FieldElement is a Rust-only trait - it's a wrapper around a Rust implementation.
class Bn254FieldElement():
    """
    A point on the BN254 elliptic curve.

    This is a 32-byte, or 256-bit, value that is generally represented as
    radix10 when a human-readable display format is needed, and is represented
    as a 32-byte big-endian value while in memory.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    bn254-field-element = *DIGIT ; which is then interpreted as a radix10 encoded 32-byte value
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_bn254fieldelement, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_bn254fieldelement, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str_radix_10(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_bn254fieldelement_from_str_radix_10,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def padded(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_padded,self._uniffi_clone_pointer(),)
        )





    def unpadded(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_bn254fieldelement_unpadded,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeBn254FieldElement:

    @staticmethod
    def lift(value: int):
        return Bn254FieldElement._make_instance_(value)

    @staticmethod
    def check_lower(value: Bn254FieldElement):
        if not isinstance(value, Bn254FieldElement):
            raise TypeError("Expected Bn254FieldElement instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Bn254FieldElementProtocol):
        if not isinstance(value, Bn254FieldElement):
            raise TypeError("Expected Bn254FieldElement instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Bn254FieldElementProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CancelledTransactionProtocol(typing.Protocol):
    """
    A transaction that was cancelled

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    cancelled-transaction = digest (vector version-assignment)
    ```
    """

    def digest(self, ):
        raise NotImplementedError
    def version_assignments(self, ):
        raise NotImplementedError
# CancelledTransaction is a Rust-only trait - it's a wrapper around a Rust implementation.
class CancelledTransaction():
    """
    A transaction that was cancelled

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    cancelled-transaction = digest (vector version-assignment)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, digest: "Digest",version_assignments: "typing.List[VersionAssignment]"):
        _UniffiConverterTypeDigest.check_lower(digest)
        
        _UniffiConverterSequenceTypeVersionAssignment.check_lower(version_assignments)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_cancelledtransaction_new,
        _UniffiConverterTypeDigest.lower(digest),
        _UniffiConverterSequenceTypeVersionAssignment.lower(version_assignments))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_cancelledtransaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_cancelledtransaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_digest,self._uniffi_clone_pointer(),)
        )





    def version_assignments(self, ) -> "typing.List[VersionAssignment]":
        return _UniffiConverterSequenceTypeVersionAssignment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_cancelledtransaction_version_assignments,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCancelledTransaction:

    @staticmethod
    def lift(value: int):
        return CancelledTransaction._make_instance_(value)

    @staticmethod
    def check_lower(value: CancelledTransaction):
        if not isinstance(value, CancelledTransaction):
            raise TypeError("Expected CancelledTransaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CancelledTransactionProtocol):
        if not isinstance(value, CancelledTransaction):
            raise TypeError("Expected CancelledTransaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CancelledTransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ChangeEpochProtocol(typing.Protocol):
    """
    System transaction used to change the epoch

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    change-epoch = u64  ; next epoch
    u64  ; protocol version
    u64  ; storage charge
    u64  ; computation charge
    u64  ; storage rebate
    u64  ; non-refundable storage fee
    u64  ; epoch start timestamp
    (vector system-package)
    ```
    """

    def computation_charge(self, ):
        """
        The total amount of gas charged for computation during the epoch.
        """

        raise NotImplementedError
    def epoch(self, ):
        """
        The next (to become) epoch ID.
        """

        raise NotImplementedError
    def epoch_start_timestamp_ms(self, ):
        """
        Unix timestamp when epoch started
        """

        raise NotImplementedError
    def non_refundable_storage_fee(self, ):
        """
        The non-refundable storage fee.
        """

        raise NotImplementedError
    def protocol_version(self, ):
        """
        The protocol version in effect in the new epoch.
        """

        raise NotImplementedError
    def storage_charge(self, ):
        """
        The total amount of gas charged for storage during the epoch.
        """

        raise NotImplementedError
    def storage_rebate(self, ):
        """
        The amount of storage rebate refunded to the txn senders.
        """

        raise NotImplementedError
    def system_packages(self, ):
        """
        System packages (specifically framework and move stdlib) that are
        written before the new epoch starts.
        """

        raise NotImplementedError
# ChangeEpoch is a Rust-only trait - it's a wrapper around a Rust implementation.
class ChangeEpoch():
    """
    System transaction used to change the epoch

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    change-epoch = u64  ; next epoch
    u64  ; protocol version
    u64  ; storage charge
    u64  ; computation charge
    u64  ; storage rebate
    u64  ; non-refundable storage fee
    u64  ; epoch start timestamp
    (vector system-package)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",protocol_version: "int",storage_charge: "int",computation_charge: "int",storage_rebate: "int",non_refundable_storage_fee: "int",epoch_start_timestamp_ms: "int",system_packages: "typing.List[SystemPackage]"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterUInt64.check_lower(protocol_version)
        
        _UniffiConverterUInt64.check_lower(storage_charge)
        
        _UniffiConverterUInt64.check_lower(computation_charge)
        
        _UniffiConverterUInt64.check_lower(storage_rebate)
        
        _UniffiConverterUInt64.check_lower(non_refundable_storage_fee)
        
        _UniffiConverterUInt64.check_lower(epoch_start_timestamp_ms)
        
        _UniffiConverterSequenceTypeSystemPackage.check_lower(system_packages)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepoch_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterUInt64.lower(protocol_version),
        _UniffiConverterUInt64.lower(storage_charge),
        _UniffiConverterUInt64.lower(computation_charge),
        _UniffiConverterUInt64.lower(storage_rebate),
        _UniffiConverterUInt64.lower(non_refundable_storage_fee),
        _UniffiConverterUInt64.lower(epoch_start_timestamp_ms),
        _UniffiConverterSequenceTypeSystemPackage.lower(system_packages))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepoch, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepoch, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def computation_charge(self, ) -> "int":
        """
        The total amount of gas charged for computation during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_computation_charge,self._uniffi_clone_pointer(),)
        )





    def epoch(self, ) -> "int":
        """
        The next (to become) epoch ID.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch,self._uniffi_clone_pointer(),)
        )





    def epoch_start_timestamp_ms(self, ) -> "int":
        """
        Unix timestamp when epoch started
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_epoch_start_timestamp_ms,self._uniffi_clone_pointer(),)
        )





    def non_refundable_storage_fee(self, ) -> "int":
        """
        The non-refundable storage fee.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_non_refundable_storage_fee,self._uniffi_clone_pointer(),)
        )





    def protocol_version(self, ) -> "int":
        """
        The protocol version in effect in the new epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_protocol_version,self._uniffi_clone_pointer(),)
        )





    def storage_charge(self, ) -> "int":
        """
        The total amount of gas charged for storage during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_charge,self._uniffi_clone_pointer(),)
        )





    def storage_rebate(self, ) -> "int":
        """
        The amount of storage rebate refunded to the txn senders.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_storage_rebate,self._uniffi_clone_pointer(),)
        )





    def system_packages(self, ) -> "typing.List[SystemPackage]":
        """
        System packages (specifically framework and move stdlib) that are
        written before the new epoch starts.
        """

        return _UniffiConverterSequenceTypeSystemPackage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepoch_system_packages,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeChangeEpoch:

    @staticmethod
    def lift(value: int):
        return ChangeEpoch._make_instance_(value)

    @staticmethod
    def check_lower(value: ChangeEpoch):
        if not isinstance(value, ChangeEpoch):
            raise TypeError("Expected ChangeEpoch instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ChangeEpochProtocol):
        if not isinstance(value, ChangeEpoch):
            raise TypeError("Expected ChangeEpoch instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ChangeEpochProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ChangeEpochV2Protocol(typing.Protocol):
    """
    System transaction used to change the epoch

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    change-epoch = u64  ; next epoch
    u64  ; protocol version
    u64  ; storage charge
    u64  ; computation charge
    u64  ; computation charge burned
    u64  ; storage rebate
    u64  ; non-refundable storage fee
    u64  ; epoch start timestamp
    (vector system-package)
    ```
    """

    def computation_charge(self, ):
        """
        The total amount of gas charged for computation during the epoch.
        """

        raise NotImplementedError
    def computation_charge_burned(self, ):
        """
        The total amount of gas burned for computation during the epoch.
        """

        raise NotImplementedError
    def epoch(self, ):
        """
        The next (to become) epoch ID.
        """

        raise NotImplementedError
    def epoch_start_timestamp_ms(self, ):
        """
        Unix timestamp when epoch started
        """

        raise NotImplementedError
    def non_refundable_storage_fee(self, ):
        """
        The non-refundable storage fee.
        """

        raise NotImplementedError
    def protocol_version(self, ):
        """
        The protocol version in effect in the new epoch.
        """

        raise NotImplementedError
    def storage_charge(self, ):
        """
        The total amount of gas charged for storage during the epoch.
        """

        raise NotImplementedError
    def storage_rebate(self, ):
        """
        The amount of storage rebate refunded to the txn senders.
        """

        raise NotImplementedError
    def system_packages(self, ):
        """
        System packages (specifically framework and move stdlib) that are
        written before the new epoch starts.
        """

        raise NotImplementedError
# ChangeEpochV2 is a Rust-only trait - it's a wrapper around a Rust implementation.
class ChangeEpochV2():
    """
    System transaction used to change the epoch

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    change-epoch = u64  ; next epoch
    u64  ; protocol version
    u64  ; storage charge
    u64  ; computation charge
    u64  ; computation charge burned
    u64  ; storage rebate
    u64  ; non-refundable storage fee
    u64  ; epoch start timestamp
    (vector system-package)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",protocol_version: "int",storage_charge: "int",computation_charge: "int",computation_charge_burned: "int",storage_rebate: "int",non_refundable_storage_fee: "int",epoch_start_timestamp_ms: "int",system_packages: "typing.List[SystemPackage]"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterUInt64.check_lower(protocol_version)
        
        _UniffiConverterUInt64.check_lower(storage_charge)
        
        _UniffiConverterUInt64.check_lower(computation_charge)
        
        _UniffiConverterUInt64.check_lower(computation_charge_burned)
        
        _UniffiConverterUInt64.check_lower(storage_rebate)
        
        _UniffiConverterUInt64.check_lower(non_refundable_storage_fee)
        
        _UniffiConverterUInt64.check_lower(epoch_start_timestamp_ms)
        
        _UniffiConverterSequenceTypeSystemPackage.check_lower(system_packages)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepochv2_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterUInt64.lower(protocol_version),
        _UniffiConverterUInt64.lower(storage_charge),
        _UniffiConverterUInt64.lower(computation_charge),
        _UniffiConverterUInt64.lower(computation_charge_burned),
        _UniffiConverterUInt64.lower(storage_rebate),
        _UniffiConverterUInt64.lower(non_refundable_storage_fee),
        _UniffiConverterUInt64.lower(epoch_start_timestamp_ms),
        _UniffiConverterSequenceTypeSystemPackage.lower(system_packages))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepochv2, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepochv2, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def computation_charge(self, ) -> "int":
        """
        The total amount of gas charged for computation during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge,self._uniffi_clone_pointer(),)
        )





    def computation_charge_burned(self, ) -> "int":
        """
        The total amount of gas burned for computation during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_computation_charge_burned,self._uniffi_clone_pointer(),)
        )





    def epoch(self, ) -> "int":
        """
        The next (to become) epoch ID.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch,self._uniffi_clone_pointer(),)
        )





    def epoch_start_timestamp_ms(self, ) -> "int":
        """
        Unix timestamp when epoch started
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_epoch_start_timestamp_ms,self._uniffi_clone_pointer(),)
        )





    def non_refundable_storage_fee(self, ) -> "int":
        """
        The non-refundable storage fee.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_non_refundable_storage_fee,self._uniffi_clone_pointer(),)
        )





    def protocol_version(self, ) -> "int":
        """
        The protocol version in effect in the new epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_protocol_version,self._uniffi_clone_pointer(),)
        )





    def storage_charge(self, ) -> "int":
        """
        The total amount of gas charged for storage during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_charge,self._uniffi_clone_pointer(),)
        )





    def storage_rebate(self, ) -> "int":
        """
        The amount of storage rebate refunded to the txn senders.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_storage_rebate,self._uniffi_clone_pointer(),)
        )





    def system_packages(self, ) -> "typing.List[SystemPackage]":
        """
        System packages (specifically framework and move stdlib) that are
        written before the new epoch starts.
        """

        return _UniffiConverterSequenceTypeSystemPackage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv2_system_packages,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeChangeEpochV2:

    @staticmethod
    def lift(value: int):
        return ChangeEpochV2._make_instance_(value)

    @staticmethod
    def check_lower(value: ChangeEpochV2):
        if not isinstance(value, ChangeEpochV2):
            raise TypeError("Expected ChangeEpochV2 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ChangeEpochV2Protocol):
        if not isinstance(value, ChangeEpochV2):
            raise TypeError("Expected ChangeEpochV2 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ChangeEpochV2Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ChangeEpochV3Protocol(typing.Protocol):
    def computation_charge(self, ):
        """
        The total amount of gas charged for computation during the epoch.
        """

        raise NotImplementedError
    def computation_charge_burned(self, ):
        """
        The total amount of gas burned for computation during the epoch.
        """

        raise NotImplementedError
    def eligible_active_validators(self, ):
        """
        Vector of active validator indices eligible to take part in committee
        selection because they support the new, target protocol version.
        """

        raise NotImplementedError
    def epoch(self, ):
        """
        The next (to become) epoch ID.
        """

        raise NotImplementedError
    def epoch_start_timestamp_ms(self, ):
        """
        Unix timestamp when epoch started
        """

        raise NotImplementedError
    def non_refundable_storage_fee(self, ):
        """
        The non-refundable storage fee.
        """

        raise NotImplementedError
    def protocol_version(self, ):
        """
        The protocol version in effect in the new epoch.
        """

        raise NotImplementedError
    def storage_charge(self, ):
        """
        The total amount of gas charged for storage during the epoch.
        """

        raise NotImplementedError
    def storage_rebate(self, ):
        """
        The amount of storage rebate refunded to the txn senders.
        """

        raise NotImplementedError
    def system_packages(self, ):
        """
        System packages (specifically framework and move stdlib) that are
        written before the new epoch starts.
        """

        raise NotImplementedError
# ChangeEpochV3 is a Rust-only trait - it's a wrapper around a Rust implementation.
class ChangeEpochV3():
    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",protocol_version: "int",storage_charge: "int",computation_charge: "int",computation_charge_burned: "int",storage_rebate: "int",non_refundable_storage_fee: "int",epoch_start_timestamp_ms: "int",system_packages: "typing.List[SystemPackage]",eligible_active_validators: "typing.List[int]"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterUInt64.check_lower(protocol_version)
        
        _UniffiConverterUInt64.check_lower(storage_charge)
        
        _UniffiConverterUInt64.check_lower(computation_charge)
        
        _UniffiConverterUInt64.check_lower(computation_charge_burned)
        
        _UniffiConverterUInt64.check_lower(storage_rebate)
        
        _UniffiConverterUInt64.check_lower(non_refundable_storage_fee)
        
        _UniffiConverterUInt64.check_lower(epoch_start_timestamp_ms)
        
        _UniffiConverterSequenceTypeSystemPackage.check_lower(system_packages)
        
        _UniffiConverterSequenceUInt64.check_lower(eligible_active_validators)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_changeepochv3_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterUInt64.lower(protocol_version),
        _UniffiConverterUInt64.lower(storage_charge),
        _UniffiConverterUInt64.lower(computation_charge),
        _UniffiConverterUInt64.lower(computation_charge_burned),
        _UniffiConverterUInt64.lower(storage_rebate),
        _UniffiConverterUInt64.lower(non_refundable_storage_fee),
        _UniffiConverterUInt64.lower(epoch_start_timestamp_ms),
        _UniffiConverterSequenceTypeSystemPackage.lower(system_packages),
        _UniffiConverterSequenceUInt64.lower(eligible_active_validators))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_changeepochv3, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_changeepochv3, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def computation_charge(self, ) -> "int":
        """
        The total amount of gas charged for computation during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge,self._uniffi_clone_pointer(),)
        )





    def computation_charge_burned(self, ) -> "int":
        """
        The total amount of gas burned for computation during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_computation_charge_burned,self._uniffi_clone_pointer(),)
        )





    def eligible_active_validators(self, ) -> "typing.List[int]":
        """
        Vector of active validator indices eligible to take part in committee
        selection because they support the new, target protocol version.
        """

        return _UniffiConverterSequenceUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_eligible_active_validators,self._uniffi_clone_pointer(),)
        )





    def epoch(self, ) -> "int":
        """
        The next (to become) epoch ID.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch,self._uniffi_clone_pointer(),)
        )





    def epoch_start_timestamp_ms(self, ) -> "int":
        """
        Unix timestamp when epoch started
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_epoch_start_timestamp_ms,self._uniffi_clone_pointer(),)
        )





    def non_refundable_storage_fee(self, ) -> "int":
        """
        The non-refundable storage fee.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_non_refundable_storage_fee,self._uniffi_clone_pointer(),)
        )





    def protocol_version(self, ) -> "int":
        """
        The protocol version in effect in the new epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_protocol_version,self._uniffi_clone_pointer(),)
        )





    def storage_charge(self, ) -> "int":
        """
        The total amount of gas charged for storage during the epoch.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_charge,self._uniffi_clone_pointer(),)
        )





    def storage_rebate(self, ) -> "int":
        """
        The amount of storage rebate refunded to the txn senders.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_storage_rebate,self._uniffi_clone_pointer(),)
        )





    def system_packages(self, ) -> "typing.List[SystemPackage]":
        """
        System packages (specifically framework and move stdlib) that are
        written before the new epoch starts.
        """

        return _UniffiConverterSequenceTypeSystemPackage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_changeepochv3_system_packages,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeChangeEpochV3:

    @staticmethod
    def lift(value: int):
        return ChangeEpochV3._make_instance_(value)

    @staticmethod
    def check_lower(value: ChangeEpochV3):
        if not isinstance(value, ChangeEpochV3):
            raise TypeError("Expected ChangeEpochV3 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ChangeEpochV3Protocol):
        if not isinstance(value, ChangeEpochV3):
            raise TypeError("Expected ChangeEpochV3 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ChangeEpochV3Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CheckpointCommitmentProtocol(typing.Protocol):
    """
    A commitment made by a checkpoint.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ; CheckpointCommitment is an enum and each variant is prefixed with its index
    checkpoint-commitment = ecmh-live-object-set
    ecmh-live-object-set = %x00 digest
    ```
    """

    def as_ecmh_live_object_set_digest(self, ):
        raise NotImplementedError
    def is_ecmh_live_object_set(self, ):
        raise NotImplementedError
# CheckpointCommitment is a Rust-only trait - it's a wrapper around a Rust implementation.
class CheckpointCommitment():
    """
    A commitment made by a checkpoint.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ; CheckpointCommitment is an enum and each variant is prefixed with its index
    checkpoint-commitment = ecmh-live-object-set
    ecmh-live-object-set = %x00 digest
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointcommitment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointcommitment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_ecmh_live_object_set_digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_as_ecmh_live_object_set_digest,self._uniffi_clone_pointer(),)
        )





    def is_ecmh_live_object_set(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcommitment_is_ecmh_live_object_set,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCheckpointCommitment:

    @staticmethod
    def lift(value: int):
        return CheckpointCommitment._make_instance_(value)

    @staticmethod
    def check_lower(value: CheckpointCommitment):
        if not isinstance(value, CheckpointCommitment):
            raise TypeError("Expected CheckpointCommitment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CheckpointCommitmentProtocol):
        if not isinstance(value, CheckpointCommitment):
            raise TypeError("Expected CheckpointCommitment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CheckpointCommitmentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CheckpointContentsProtocol(typing.Protocol):
    """
    The committed to contents of a checkpoint.

    `CheckpointContents` contains a list of digests of Transactions, their
    effects, and the user signatures that authorized their execution included in
    a checkpoint.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    checkpoint-contents = %x00 checkpoint-contents-v1 ; variant 0

    checkpoint-contents-v1 = (vector (digest digest)) ; vector of transaction and effect digests
    (vector (vector bcs-user-signature)) ; set of user signatures for each
    ; transaction. MUST be the same
    ; length as the vector of digests
    ```
    """

    def digest(self, ):
        raise NotImplementedError
    def transaction_info(self, ):
        raise NotImplementedError
# CheckpointContents is a Rust-only trait - it's a wrapper around a Rust implementation.
class CheckpointContents():
    """
    The committed to contents of a checkpoint.

    `CheckpointContents` contains a list of digests of Transactions, their
    effects, and the user signatures that authorized their execution included in
    a checkpoint.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    checkpoint-contents = %x00 checkpoint-contents-v1 ; variant 0

    checkpoint-contents-v1 = (vector (digest digest)) ; vector of transaction and effect digests
    (vector (vector bcs-user-signature)) ; set of user signatures for each
    ; transaction. MUST be the same
    ; length as the vector of digests
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, transaction_info: "typing.List[CheckpointTransactionInfo]"):
        _UniffiConverterSequenceTypeCheckpointTransactionInfo.check_lower(transaction_info)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointcontents_new,
        _UniffiConverterSequenceTypeCheckpointTransactionInfo.lower(transaction_info))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointcontents, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointcontents, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_digest,self._uniffi_clone_pointer(),)
        )





    def transaction_info(self, ) -> "typing.List[CheckpointTransactionInfo]":
        return _UniffiConverterSequenceTypeCheckpointTransactionInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointcontents_transaction_info,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCheckpointContents:

    @staticmethod
    def lift(value: int):
        return CheckpointContents._make_instance_(value)

    @staticmethod
    def check_lower(value: CheckpointContents):
        if not isinstance(value, CheckpointContents):
            raise TypeError("Expected CheckpointContents instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CheckpointContentsProtocol):
        if not isinstance(value, CheckpointContents):
            raise TypeError("Expected CheckpointContents instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CheckpointContentsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CheckpointSummaryProtocol(typing.Protocol):
    """
    A header for a Checkpoint on the IOTA blockchain.

    On the IOTA network, checkpoints define the history of the blockchain. They
    are quite similar to the concept of blocks used by other blockchains like
    Bitcoin or Ethereum. The IOTA blockchain, however, forms checkpoints after
    transaction execution has already happened to provide a certified history of
    the chain, instead of being formed before execution.

    Checkpoints commit to a variety of state including but not limited to:
    - The hash of the previous checkpoint.
    - The set of transaction digests, their corresponding effects digests, as
    well as the set of user signatures which authorized its execution.
    - The object's produced by a transaction.
    - The set of live objects that make up the current state of the chain.
    - On epoch transitions, the next validator committee.

    `CheckpointSummary`s themselves don't directly include all of the above
    information but they are the top-level type by which all the above are
    committed to transitively via cryptographic hashes included in the summary.
    `CheckpointSummary`s are signed and certified by a quorum of the validator
    committee in a given epoch in order to allow verification of the chain's
    state.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    checkpoint-summary = u64                            ; epoch
    u64                            ; sequence_number
    u64                            ; network_total_transactions
    digest                         ; content_digest
    (option digest)                ; previous_digest
    gas-cost-summary               ; epoch_rolling_gas_cost_summary
    u64                            ; timestamp_ms
    (vector checkpoint-commitment) ; checkpoint_commitments
    (option end-of-epoch-data)     ; end_of_epoch_data
    bytes                          ; version_specific_data
    ```
    """

    def checkpoint_commitments(self, ):
        """
        Commitments to checkpoint-specific state.
        """

        raise NotImplementedError
    def content_digest(self, ):
        """
        The hash of the `CheckpointContents` for this checkpoint.
        """

        raise NotImplementedError
    def digest(self, ):
        raise NotImplementedError
    def end_of_epoch_data(self, ):
        """
        Extra data only present in the final checkpoint of an epoch.
        """

        raise NotImplementedError
    def epoch(self, ):
        """
        Epoch that this checkpoint belongs to.
        """

        raise NotImplementedError
    def epoch_rolling_gas_cost_summary(self, ):
        """
        The running total gas costs of all transactions included in the current
        epoch so far until this checkpoint.
        """

        raise NotImplementedError
    def network_total_transactions(self, ):
        """
        Total number of transactions committed since genesis, including those in
        this checkpoint.
        """

        raise NotImplementedError
    def previous_digest(self, ):
        """
        The hash of the previous `CheckpointSummary`.

        This will be only be `None` for the first, or genesis checkpoint.
        """

        raise NotImplementedError
    def sequence_number(self, ):
        """
        The height of this checkpoint.
        """

        raise NotImplementedError
    def signing_message(self, ):
        raise NotImplementedError
    def signing_message_hex(self, ):
        raise NotImplementedError
    def timestamp_ms(self, ):
        """
        Timestamp of the checkpoint - number of milliseconds from the Unix epoch
        Checkpoint timestamps are monotonic, but not strongly monotonic -
        subsequent checkpoints can have same timestamp if they originate
        from the same underlining consensus commit
        """

        raise NotImplementedError
    def version_specific_data(self, ):
        """
        CheckpointSummary is not an evolvable structure - it must be readable by
        any version of the code. Therefore, in order to allow extensions to
        be added to CheckpointSummary, we allow opaque data to be added to
        checkpoints which can be deserialized based on the current
        protocol version.
        """

        raise NotImplementedError
# CheckpointSummary is a Rust-only trait - it's a wrapper around a Rust implementation.
class CheckpointSummary():
    """
    A header for a Checkpoint on the IOTA blockchain.

    On the IOTA network, checkpoints define the history of the blockchain. They
    are quite similar to the concept of blocks used by other blockchains like
    Bitcoin or Ethereum. The IOTA blockchain, however, forms checkpoints after
    transaction execution has already happened to provide a certified history of
    the chain, instead of being formed before execution.

    Checkpoints commit to a variety of state including but not limited to:
    - The hash of the previous checkpoint.
    - The set of transaction digests, their corresponding effects digests, as
    well as the set of user signatures which authorized its execution.
    - The object's produced by a transaction.
    - The set of live objects that make up the current state of the chain.
    - On epoch transitions, the next validator committee.

    `CheckpointSummary`s themselves don't directly include all of the above
    information but they are the top-level type by which all the above are
    committed to transitively via cryptographic hashes included in the summary.
    `CheckpointSummary`s are signed and certified by a quorum of the validator
    committee in a given epoch in order to allow verification of the chain's
    state.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    checkpoint-summary = u64                            ; epoch
    u64                            ; sequence_number
    u64                            ; network_total_transactions
    digest                         ; content_digest
    (option digest)                ; previous_digest
    gas-cost-summary               ; epoch_rolling_gas_cost_summary
    u64                            ; timestamp_ms
    (vector checkpoint-commitment) ; checkpoint_commitments
    (option end-of-epoch-data)     ; end_of_epoch_data
    bytes                          ; version_specific_data
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",sequence_number: "int",network_total_transactions: "int",content_digest: "Digest",previous_digest: "typing.Optional[Digest]",epoch_rolling_gas_cost_summary: "GasCostSummary",timestamp_ms: "int",checkpoint_commitments: "typing.List[CheckpointCommitment]",end_of_epoch_data: "typing.Optional[EndOfEpochData]",version_specific_data: "bytes"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterUInt64.check_lower(sequence_number)
        
        _UniffiConverterUInt64.check_lower(network_total_transactions)
        
        _UniffiConverterTypeDigest.check_lower(content_digest)
        
        _UniffiConverterOptionalTypeDigest.check_lower(previous_digest)
        
        _UniffiConverterTypeGasCostSummary.check_lower(epoch_rolling_gas_cost_summary)
        
        _UniffiConverterUInt64.check_lower(timestamp_ms)
        
        _UniffiConverterSequenceTypeCheckpointCommitment.check_lower(checkpoint_commitments)
        
        _UniffiConverterOptionalTypeEndOfEpochData.check_lower(end_of_epoch_data)
        
        _UniffiConverterBytes.check_lower(version_specific_data)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointsummary_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterUInt64.lower(sequence_number),
        _UniffiConverterUInt64.lower(network_total_transactions),
        _UniffiConverterTypeDigest.lower(content_digest),
        _UniffiConverterOptionalTypeDigest.lower(previous_digest),
        _UniffiConverterTypeGasCostSummary.lower(epoch_rolling_gas_cost_summary),
        _UniffiConverterUInt64.lower(timestamp_ms),
        _UniffiConverterSequenceTypeCheckpointCommitment.lower(checkpoint_commitments),
        _UniffiConverterOptionalTypeEndOfEpochData.lower(end_of_epoch_data),
        _UniffiConverterBytes.lower(version_specific_data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointsummary, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointsummary, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def checkpoint_commitments(self, ) -> "typing.List[CheckpointCommitment]":
        """
        Commitments to checkpoint-specific state.
        """

        return _UniffiConverterSequenceTypeCheckpointCommitment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_checkpoint_commitments,self._uniffi_clone_pointer(),)
        )





    def content_digest(self, ) -> "Digest":
        """
        The hash of the `CheckpointContents` for this checkpoint.
        """

        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_content_digest,self._uniffi_clone_pointer(),)
        )





    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_digest,self._uniffi_clone_pointer(),)
        )





    def end_of_epoch_data(self, ) -> "typing.Optional[EndOfEpochData]":
        """
        Extra data only present in the final checkpoint of an epoch.
        """

        return _UniffiConverterOptionalTypeEndOfEpochData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_end_of_epoch_data,self._uniffi_clone_pointer(),)
        )





    def epoch(self, ) -> "int":
        """
        Epoch that this checkpoint belongs to.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch,self._uniffi_clone_pointer(),)
        )





    def epoch_rolling_gas_cost_summary(self, ) -> "GasCostSummary":
        """
        The running total gas costs of all transactions included in the current
        epoch so far until this checkpoint.
        """

        return _UniffiConverterTypeGasCostSummary.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_epoch_rolling_gas_cost_summary,self._uniffi_clone_pointer(),)
        )





    def network_total_transactions(self, ) -> "int":
        """
        Total number of transactions committed since genesis, including those in
        this checkpoint.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_network_total_transactions,self._uniffi_clone_pointer(),)
        )





    def previous_digest(self, ) -> "typing.Optional[Digest]":
        """
        The hash of the previous `CheckpointSummary`.

        This will be only be `None` for the first, or genesis checkpoint.
        """

        return _UniffiConverterOptionalTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_previous_digest,self._uniffi_clone_pointer(),)
        )





    def sequence_number(self, ) -> "int":
        """
        The height of this checkpoint.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_sequence_number,self._uniffi_clone_pointer(),)
        )





    def signing_message(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message,self._uniffi_clone_pointer(),)
        )





    def signing_message_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_signing_message_hex,self._uniffi_clone_pointer(),)
        )





    def timestamp_ms(self, ) -> "int":
        """
        Timestamp of the checkpoint - number of milliseconds from the Unix epoch
        Checkpoint timestamps are monotonic, but not strongly monotonic -
        subsequent checkpoints can have same timestamp if they originate
        from the same underlining consensus commit
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_timestamp_ms,self._uniffi_clone_pointer(),)
        )





    def version_specific_data(self, ) -> "bytes":
        """
        CheckpointSummary is not an evolvable structure - it must be readable by
        any version of the code. Therefore, in order to allow extensions to
        be added to CheckpointSummary, we allow opaque data to be added to
        checkpoints which can be deserialized based on the current
        protocol version.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointsummary_version_specific_data,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCheckpointSummary:

    @staticmethod
    def lift(value: int):
        return CheckpointSummary._make_instance_(value)

    @staticmethod
    def check_lower(value: CheckpointSummary):
        if not isinstance(value, CheckpointSummary):
            raise TypeError("Expected CheckpointSummary instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CheckpointSummaryProtocol):
        if not isinstance(value, CheckpointSummary):
            raise TypeError("Expected CheckpointSummary instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CheckpointSummaryProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CheckpointTransactionInfoProtocol(typing.Protocol):
    """
    Transaction information committed to in a checkpoint
    """

    def effects(self, ):
        raise NotImplementedError
    def signatures(self, ):
        raise NotImplementedError
    def transaction(self, ):
        raise NotImplementedError
# CheckpointTransactionInfo is a Rust-only trait - it's a wrapper around a Rust implementation.
class CheckpointTransactionInfo():
    """
    Transaction information committed to in a checkpoint
    """

    _pointer: ctypes.c_void_p
    def __init__(self, transaction: "Digest",effects: "Digest",signatures: "typing.List[UserSignature]"):
        _UniffiConverterTypeDigest.check_lower(transaction)
        
        _UniffiConverterTypeDigest.check_lower(effects)
        
        _UniffiConverterSequenceTypeUserSignature.check_lower(signatures)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_checkpointtransactioninfo_new,
        _UniffiConverterTypeDigest.lower(transaction),
        _UniffiConverterTypeDigest.lower(effects),
        _UniffiConverterSequenceTypeUserSignature.lower(signatures))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_checkpointtransactioninfo, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_checkpointtransactioninfo, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def effects(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_effects,self._uniffi_clone_pointer(),)
        )





    def signatures(self, ) -> "typing.List[UserSignature]":
        return _UniffiConverterSequenceTypeUserSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_signatures,self._uniffi_clone_pointer(),)
        )





    def transaction(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_checkpointtransactioninfo_transaction,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCheckpointTransactionInfo:

    @staticmethod
    def lift(value: int):
        return CheckpointTransactionInfo._make_instance_(value)

    @staticmethod
    def check_lower(value: CheckpointTransactionInfo):
        if not isinstance(value, CheckpointTransactionInfo):
            raise TypeError("Expected CheckpointTransactionInfo instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CheckpointTransactionInfoProtocol):
        if not isinstance(value, CheckpointTransactionInfo):
            raise TypeError("Expected CheckpointTransactionInfo instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CheckpointTransactionInfoProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CircomG1Protocol(typing.Protocol):
    """
    A G1 point

    This represents the canonical decimal representation of the projective
    coordinates in Fq.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    circom-g1 = %x03 3(bn254-field-element)
    ```
    """

    pass
# CircomG1 is a Rust-only trait - it's a wrapper around a Rust implementation.
class CircomG1():
    """
    A G1 point

    This represents the canonical decimal representation of the projective
    coordinates in Fq.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    circom-g1 = %x03 3(bn254-field-element)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, el_0: "Bn254FieldElement",el_1: "Bn254FieldElement",el_2: "Bn254FieldElement"):
        _UniffiConverterTypeBn254FieldElement.check_lower(el_0)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_1)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_2)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_circomg1_new,
        _UniffiConverterTypeBn254FieldElement.lower(el_0),
        _UniffiConverterTypeBn254FieldElement.lower(el_1),
        _UniffiConverterTypeBn254FieldElement.lower(el_2))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_circomg1, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_circomg1, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeCircomG1:

    @staticmethod
    def lift(value: int):
        return CircomG1._make_instance_(value)

    @staticmethod
    def check_lower(value: CircomG1):
        if not isinstance(value, CircomG1):
            raise TypeError("Expected CircomG1 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CircomG1Protocol):
        if not isinstance(value, CircomG1):
            raise TypeError("Expected CircomG1 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CircomG1Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CircomG2Protocol(typing.Protocol):
    """
    A G2 point

    This represents the canonical decimal representation of the coefficients of
    the projective coordinates in Fq2.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    circom-g2 = %x03 3(%x02 2(bn254-field-element))
    ```
    """

    pass
# CircomG2 is a Rust-only trait - it's a wrapper around a Rust implementation.
class CircomG2():
    """
    A G2 point

    This represents the canonical decimal representation of the coefficients of
    the projective coordinates in Fq2.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    circom-g2 = %x03 3(%x02 2(bn254-field-element))
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, el_0_0: "Bn254FieldElement",el_0_1: "Bn254FieldElement",el_1_0: "Bn254FieldElement",el_1_1: "Bn254FieldElement",el_2_0: "Bn254FieldElement",el_2_1: "Bn254FieldElement"):
        _UniffiConverterTypeBn254FieldElement.check_lower(el_0_0)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_0_1)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_1_0)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_1_1)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_2_0)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(el_2_1)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_circomg2_new,
        _UniffiConverterTypeBn254FieldElement.lower(el_0_0),
        _UniffiConverterTypeBn254FieldElement.lower(el_0_1),
        _UniffiConverterTypeBn254FieldElement.lower(el_1_0),
        _UniffiConverterTypeBn254FieldElement.lower(el_1_1),
        _UniffiConverterTypeBn254FieldElement.lower(el_2_0),
        _UniffiConverterTypeBn254FieldElement.lower(el_2_1))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_circomg2, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_circomg2, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeCircomG2:

    @staticmethod
    def lift(value: int):
        return CircomG2._make_instance_(value)

    @staticmethod
    def check_lower(value: CircomG2):
        if not isinstance(value, CircomG2):
            raise TypeError("Expected CircomG2 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CircomG2Protocol):
        if not isinstance(value, CircomG2):
            raise TypeError("Expected CircomG2 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CircomG2Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ClientTransactionBuilderProtocol(typing.Protocol):
    """
    A builder for creating transactions which uses a GraphQL client to
    automatically resolve inputs. Use `finish` to finalize the transaction data.
    """

    def dry_run(self, skip_checks: "typing.Union[object, bool]" = _DEFAULT):
        """
        Dry run the transaction.
        """

        raise NotImplementedError
    def execute(self, keypair: "SimpleKeypair",wait_for: "typing.Union[object, typing.Optional[WaitForTx]]" = _DEFAULT):
        """
        Execute the transaction and optionally wait for finalization.
        """

        raise NotImplementedError
    def execute_with_sponsor(self, keypair: "SimpleKeypair",sponsor_keypair: "SimpleKeypair",wait_for: "typing.Union[object, typing.Optional[WaitForTx]]" = _DEFAULT):
        """
        Execute the transaction and optionally wait for finalization.
        """

        raise NotImplementedError
    def expiration(self, epoch: "int"):
        """
        Set the expiration of the transaction to be a specific epoch.
        """

        raise NotImplementedError
    def finish(self, ):
        """
        Convert this builder into a transaction.
        """

        raise NotImplementedError
    def gas(self, object_ids: "typing.List[ObjectId]"):
        """
        Add gas coins that will be consumed. Optional.
        """

        raise NotImplementedError
    def gas_budget(self, budget: "int"):
        """
        Set the gas budget for the transaction.
        """

        raise NotImplementedError
    def gas_price(self, price: "int"):
        """
        Set the gas price for the transaction.
        """

        raise NotImplementedError
    def gas_station_sponsor(self, url: "str",duration: "typing.Union[object, typing.Optional[Duration]]" = _DEFAULT,headers: "typing.Union[object, typing.Optional[dict[str, typing.List[str]]]]" = _DEFAULT):
        """
        Set the gas station sponsor.
        """

        raise NotImplementedError
    def make_move_vec(self, elements: "typing.List[MoveArg]",type_tag: "TypeTag",name: "str"):
        """
        Make a move vector from a list of elements. The elements must all be of
        the type indicated by `type_tag`.
        """

        raise NotImplementedError
    def merge_coins(self, primary_coin: "PtbArgument",consumed_coins: "typing.List[PtbArgument]"):
        """
        Merge multiple coins into one.

        This method combines the balances of multiple coins of the same coin
        type into a single coin. The `primary_coin` will receive the balances
        from all `consumed_coins`. After merging, the `consumed_coins` will
        be consumed and no longer exist.
        """

        raise NotImplementedError
    def move_call(self, package: "Address",module: "Identifier",function: "Identifier",arguments: "typing.Union[object, typing.List[PtbArgument]]" = _DEFAULT,type_args: "typing.Union[object, typing.List[TypeTag]]" = _DEFAULT,names: "typing.Union[object, typing.List[str]]" = _DEFAULT):
        """
        Call a Move function with the given arguments.
        """

        raise NotImplementedError
    def publish(self, package_data: "MovePackageData",upgrade_cap_name: "str"):
        """
        Publish a list of modules with the given dependencies. The result
        assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
        Move type. Note that the upgrade capability needs to be handled
        after this call:
        - transfer it to the transaction sender or another address
        - burn it
        - wrap it for access control
        - discard the it to make a package immutable

        The arguments required for this command are:
        - `modules`: is the modules' bytecode to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package
        """

        raise NotImplementedError
    def send_coins(self, coins: "typing.List[PtbArgument]",recipient: "Address",amount: "typing.Union[object, typing.Optional[PtbArgument]]" = _DEFAULT):
        """
        Transfer some coins to a recipient address. If multiple coins are
        provided then they will be merged.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS.
        If `amount` is provided, that amount is split from the provided coins
        and sent.
        If `amount` is `None`, the entire coins are transferred.

        All provided coins must have the same coin type. Mixing coins of
        different types will result in an error.

        If you intend to transfer all provided coins to another address in a
        single transaction, consider using
        `TransactionBuilder::transfer_objects()` instead.
        """

        raise NotImplementedError
    def send_iota(self, recipient: "Address",amount: "PtbArgument"):
        """
        Send IOTA to a recipient address.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS. That amount is split from the gas coin and
        sent.
        """

        raise NotImplementedError
    def split_coins(self, coin: "PtbArgument",amounts: "typing.List[PtbArgument]",names: "typing.Union[object, typing.List[str]]" = _DEFAULT):
        """
        Split a coin into many.
        """

        raise NotImplementedError
    def sponsor(self, sponsor: "Address"):
        """
        Set the sponsor of the transaction.
        """

        raise NotImplementedError
    def stake(self, stake: "PtbArgument",validator_address: "Address"):
        """
        Add stake to a validator's staking pool.

        This is a high-level function which will split the provided stake amount
        from the gas coin and then stake using the resulting coin.
        """

        raise NotImplementedError
    def transfer_objects(self, recipient: "Address",objects: "typing.List[PtbArgument]"):
        """
        Transfer a list of objects to the given address, without producing any
        result.
        """

        raise NotImplementedError
    def unstake(self, staked_iota: "PtbArgument"):
        """
        Withdraw stake from a validator's staking pool.
        """

        raise NotImplementedError
    def upgrade(self, package_id: "ObjectId",package_data: "MovePackageData",upgrade_ticket: "PtbArgument",name: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        """
        Upgrade a Move package.

        - `modules`: is the modules' bytecode for the modules to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package to be upgraded
        - `package`: is the ID of the current package being upgraded
        - `ticket`: is the upgrade ticket

        To get the ticket, you have to call the
        `0x2::package::authorize_upgrade` function, and pass the package
        ID, the upgrade policy, and package digest.
        """

        raise NotImplementedError
# ClientTransactionBuilder is a Rust-only trait - it's a wrapper around a Rust implementation.
class ClientTransactionBuilder():
    """
    A builder for creating transactions which uses a GraphQL client to
    automatically resolve inputs. Use `finish` to finalize the transaction data.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_clienttransactionbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_clienttransactionbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def dry_run(self, skip_checks: "typing.Union[object, bool]" = _DEFAULT) -> "DryRunResult":
        """
        Dry run the transaction.
        """

        if skip_checks is _DEFAULT:
            skip_checks = False
        _UniffiConverterBool.check_lower(skip_checks)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_dry_run(
                self._uniffi_clone_pointer(), 
        _UniffiConverterBool.lower(skip_checks)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDryRunResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def execute(self, keypair: "SimpleKeypair",wait_for: "typing.Union[object, typing.Optional[WaitForTx]]" = _DEFAULT) -> "TransactionEffects":
        """
        Execute the transaction and optionally wait for finalization.
        """

        _UniffiConverterTypeSimpleKeypair.check_lower(keypair)
        
        if wait_for is _DEFAULT:
            wait_for = None
        _UniffiConverterOptionalTypeWaitForTx.check_lower(wait_for)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSimpleKeypair.lower(keypair),
        _UniffiConverterOptionalTypeWaitForTx.lower(wait_for)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeTransactionEffects.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def execute_with_sponsor(self, keypair: "SimpleKeypair",sponsor_keypair: "SimpleKeypair",wait_for: "typing.Union[object, typing.Optional[WaitForTx]]" = _DEFAULT) -> "TransactionEffects":
        """
        Execute the transaction and optionally wait for finalization.
        """

        _UniffiConverterTypeSimpleKeypair.check_lower(keypair)
        
        _UniffiConverterTypeSimpleKeypair.check_lower(sponsor_keypair)
        
        if wait_for is _DEFAULT:
            wait_for = None
        _UniffiConverterOptionalTypeWaitForTx.check_lower(wait_for)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_execute_with_sponsor(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSimpleKeypair.lower(keypair),
        _UniffiConverterTypeSimpleKeypair.lower(sponsor_keypair),
        _UniffiConverterOptionalTypeWaitForTx.lower(wait_for)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeTransactionEffects.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )




    def expiration(self, epoch: "int") -> "ClientTransactionBuilder":
        """
        Set the expiration of the transaction to be a specific epoch.
        """

        _UniffiConverterUInt64.check_lower(epoch)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_expiration,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(epoch))
        )




    async def finish(self, ) -> "Transaction":
        """
        Convert this builder into a transaction.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_finish(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )




    def gas(self, object_ids: "typing.List[ObjectId]") -> "ClientTransactionBuilder":
        """
        Add gas coins that will be consumed. Optional.
        """

        _UniffiConverterSequenceTypeObjectId.check_lower(object_ids)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeObjectId.lower(object_ids))
        )





    def gas_budget(self, budget: "int") -> "ClientTransactionBuilder":
        """
        Set the gas budget for the transaction.
        """

        _UniffiConverterUInt64.check_lower(budget)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_budget,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(budget))
        )





    def gas_price(self, price: "int") -> "ClientTransactionBuilder":
        """
        Set the gas price for the transaction.
        """

        _UniffiConverterUInt64.check_lower(price)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_price,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(price))
        )





    def gas_station_sponsor(self, url: "str",duration: "typing.Union[object, typing.Optional[Duration]]" = _DEFAULT,headers: "typing.Union[object, typing.Optional[dict[str, typing.List[str]]]]" = _DEFAULT) -> "ClientTransactionBuilder":
        """
        Set the gas station sponsor.
        """

        _UniffiConverterString.check_lower(url)
        
        if duration is _DEFAULT:
            duration = None
        _UniffiConverterOptionalDuration.check_lower(duration)
        
        if headers is _DEFAULT:
            headers = None
        _UniffiConverterOptionalMapStringSequenceString.check_lower(headers)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_gas_station_sponsor,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalDuration.lower(duration),
        _UniffiConverterOptionalMapStringSequenceString.lower(headers))
        )





    def make_move_vec(self, elements: "typing.List[MoveArg]",type_tag: "TypeTag",name: "str") -> "ClientTransactionBuilder":
        """
        Make a move vector from a list of elements. The elements must all be of
        the type indicated by `type_tag`.
        """

        _UniffiConverterSequenceTypeMoveArg.check_lower(elements)
        
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_make_move_vec,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeMoveArg.lower(elements),
        _UniffiConverterTypeTypeTag.lower(type_tag),
        _UniffiConverterString.lower(name))
        )





    def merge_coins(self, primary_coin: "PtbArgument",consumed_coins: "typing.List[PtbArgument]") -> "ClientTransactionBuilder":
        """
        Merge multiple coins into one.

        This method combines the balances of multiple coins of the same coin
        type into a single coin. The `primary_coin` will receive the balances
        from all `consumed_coins`. After merging, the `consumed_coins` will
        be consumed and no longer exist.
        """

        _UniffiConverterTypePtbArgument.check_lower(primary_coin)
        
        _UniffiConverterSequenceTypePtbArgument.check_lower(consumed_coins)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_merge_coins,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(primary_coin),
        _UniffiConverterSequenceTypePtbArgument.lower(consumed_coins))
        )





    def move_call(self, package: "Address",module: "Identifier",function: "Identifier",arguments: "typing.Union[object, typing.List[PtbArgument]]" = _DEFAULT,type_args: "typing.Union[object, typing.List[TypeTag]]" = _DEFAULT,names: "typing.Union[object, typing.List[str]]" = _DEFAULT) -> "ClientTransactionBuilder":
        """
        Call a Move function with the given arguments.
        """

        _UniffiConverterTypeAddress.check_lower(package)
        
        _UniffiConverterTypeIdentifier.check_lower(module)
        
        _UniffiConverterTypeIdentifier.check_lower(function)
        
        if arguments is _DEFAULT:
            arguments = []
        _UniffiConverterSequenceTypePtbArgument.check_lower(arguments)
        
        if type_args is _DEFAULT:
            type_args = []
        _UniffiConverterSequenceTypeTypeTag.check_lower(type_args)
        
        if names is _DEFAULT:
            names = []
        _UniffiConverterSequenceString.check_lower(names)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_move_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(package),
        _UniffiConverterTypeIdentifier.lower(module),
        _UniffiConverterTypeIdentifier.lower(function),
        _UniffiConverterSequenceTypePtbArgument.lower(arguments),
        _UniffiConverterSequenceTypeTypeTag.lower(type_args),
        _UniffiConverterSequenceString.lower(names))
        )





    def publish(self, package_data: "MovePackageData",upgrade_cap_name: "str") -> "ClientTransactionBuilder":
        """
        Publish a list of modules with the given dependencies. The result
        assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
        Move type. Note that the upgrade capability needs to be handled
        after this call:
        - transfer it to the transaction sender or another address
        - burn it
        - wrap it for access control
        - discard the it to make a package immutable

        The arguments required for this command are:
        - `modules`: is the modules' bytecode to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package
        """

        _UniffiConverterTypeMovePackageData.check_lower(package_data)
        
        _UniffiConverterString.check_lower(upgrade_cap_name)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_publish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMovePackageData.lower(package_data),
        _UniffiConverterString.lower(upgrade_cap_name))
        )





    def send_coins(self, coins: "typing.List[PtbArgument]",recipient: "Address",amount: "typing.Union[object, typing.Optional[PtbArgument]]" = _DEFAULT) -> "ClientTransactionBuilder":
        """
        Transfer some coins to a recipient address. If multiple coins are
        provided then they will be merged.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS.
        If `amount` is provided, that amount is split from the provided coins
        and sent.
        If `amount` is `None`, the entire coins are transferred.

        All provided coins must have the same coin type. Mixing coins of
        different types will result in an error.

        If you intend to transfer all provided coins to another address in a
        single transaction, consider using
        `TransactionBuilder::transfer_objects()` instead.
        """

        _UniffiConverterSequenceTypePtbArgument.check_lower(coins)
        
        _UniffiConverterTypeAddress.check_lower(recipient)
        
        if amount is _DEFAULT:
            amount = None
        _UniffiConverterOptionalTypePtbArgument.check_lower(amount)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_coins,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePtbArgument.lower(coins),
        _UniffiConverterTypeAddress.lower(recipient),
        _UniffiConverterOptionalTypePtbArgument.lower(amount))
        )





    def send_iota(self, recipient: "Address",amount: "PtbArgument") -> "ClientTransactionBuilder":
        """
        Send IOTA to a recipient address.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS. That amount is split from the gas coin and
        sent.
        """

        _UniffiConverterTypeAddress.check_lower(recipient)
        
        _UniffiConverterTypePtbArgument.check_lower(amount)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_send_iota,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(recipient),
        _UniffiConverterTypePtbArgument.lower(amount))
        )





    def split_coins(self, coin: "PtbArgument",amounts: "typing.List[PtbArgument]",names: "typing.Union[object, typing.List[str]]" = _DEFAULT) -> "ClientTransactionBuilder":
        """
        Split a coin into many.
        """

        _UniffiConverterTypePtbArgument.check_lower(coin)
        
        _UniffiConverterSequenceTypePtbArgument.check_lower(amounts)
        
        if names is _DEFAULT:
            names = []
        _UniffiConverterSequenceString.check_lower(names)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_split_coins,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(coin),
        _UniffiConverterSequenceTypePtbArgument.lower(amounts),
        _UniffiConverterSequenceString.lower(names))
        )





    def sponsor(self, sponsor: "Address") -> "ClientTransactionBuilder":
        """
        Set the sponsor of the transaction.
        """

        _UniffiConverterTypeAddress.check_lower(sponsor)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_sponsor,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(sponsor))
        )





    def stake(self, stake: "PtbArgument",validator_address: "Address") -> "ClientTransactionBuilder":
        """
        Add stake to a validator's staking pool.

        This is a high-level function which will split the provided stake amount
        from the gas coin and then stake using the resulting coin.
        """

        _UniffiConverterTypePtbArgument.check_lower(stake)
        
        _UniffiConverterTypeAddress.check_lower(validator_address)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_stake,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(stake),
        _UniffiConverterTypeAddress.lower(validator_address))
        )





    def transfer_objects(self, recipient: "Address",objects: "typing.List[PtbArgument]") -> "ClientTransactionBuilder":
        """
        Transfer a list of objects to the given address, without producing any
        result.
        """

        _UniffiConverterTypeAddress.check_lower(recipient)
        
        _UniffiConverterSequenceTypePtbArgument.check_lower(objects)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_transfer_objects,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(recipient),
        _UniffiConverterSequenceTypePtbArgument.lower(objects))
        )





    def unstake(self, staked_iota: "PtbArgument") -> "ClientTransactionBuilder":
        """
        Withdraw stake from a validator's staking pool.
        """

        _UniffiConverterTypePtbArgument.check_lower(staked_iota)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_unstake,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(staked_iota))
        )





    def upgrade(self, package_id: "ObjectId",package_data: "MovePackageData",upgrade_ticket: "PtbArgument",name: "typing.Union[object, typing.Optional[str]]" = _DEFAULT) -> "ClientTransactionBuilder":
        """
        Upgrade a Move package.

        - `modules`: is the modules' bytecode for the modules to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package to be upgraded
        - `package`: is the ID of the current package being upgraded
        - `ticket`: is the upgrade ticket

        To get the ticket, you have to call the
        `0x2::package::authorize_upgrade` function, and pass the package
        ID, the upgrade policy, and package digest.
        """

        _UniffiConverterTypeObjectId.check_lower(package_id)
        
        _UniffiConverterTypeMovePackageData.check_lower(package_data)
        
        _UniffiConverterTypePtbArgument.check_lower(upgrade_ticket)
        
        if name is _DEFAULT:
            name = None
        _UniffiConverterOptionalString.check_lower(name)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_clienttransactionbuilder_upgrade,self._uniffi_clone_pointer(),
        _UniffiConverterTypeObjectId.lower(package_id),
        _UniffiConverterTypeMovePackageData.lower(package_data),
        _UniffiConverterTypePtbArgument.lower(upgrade_ticket),
        _UniffiConverterOptionalString.lower(name))
        )






class _UniffiConverterTypeClientTransactionBuilder:

    @staticmethod
    def lift(value: int):
        return ClientTransactionBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: ClientTransactionBuilder):
        if not isinstance(value, ClientTransactionBuilder):
            raise TypeError("Expected ClientTransactionBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ClientTransactionBuilderProtocol):
        if not isinstance(value, ClientTransactionBuilder):
            raise TypeError("Expected ClientTransactionBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ClientTransactionBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CoinProtocol(typing.Protocol):
    def balance(self, ):
        raise NotImplementedError
    def coin_type(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
# Coin is a Rust-only trait - it's a wrapper around a Rust implementation.
class Coin():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_coin, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_coin, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def try_from_object(cls, object: "Object"):
        _UniffiConverterTypeObject.check_lower(object)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_coin_try_from_object,
        _UniffiConverterTypeObject.lower(object))
        return cls._make_instance_(pointer)



    def balance(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_balance,self._uniffi_clone_pointer(),)
        )





    def coin_type(self, ) -> "TypeTag":
        return _UniffiConverterTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_coin_type,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "ObjectId":
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_coin_id,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCoin:

    @staticmethod
    def lift(value: int):
        return Coin._make_instance_(value)

    @staticmethod
    def check_lower(value: Coin):
        if not isinstance(value, Coin):
            raise TypeError("Expected Coin instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CoinProtocol):
        if not isinstance(value, Coin):
            raise TypeError("Expected Coin instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CoinProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class CommandProtocol(typing.Protocol):
    """
    A single command in a programmable transaction.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    command =  command-move-call
    =/ command-transfer-objects
    =/ command-split-coins
    =/ command-merge-coins
    =/ command-publish
    =/ command-make-move-vector
    =/ command-upgrade

    command-move-call           = %x00 move-call
    command-transfer-objects    = %x01 transfer-objects
    command-split-coins         = %x02 split-coins
    command-merge-coins         = %x03 merge-coins
    command-publish             = %x04 publish
    command-make-move-vector    = %x05 make-move-vector
    command-upgrade             = %x06 upgrade
    ```
    """

    pass
# Command is a Rust-only trait - it's a wrapper around a Rust implementation.
class Command():
    """
    A single command in a programmable transaction.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    command =  command-move-call
    =/ command-transfer-objects
    =/ command-split-coins
    =/ command-merge-coins
    =/ command-publish
    =/ command-make-move-vector
    =/ command-upgrade

    command-move-call           = %x00 move-call
    command-transfer-objects    = %x01 transfer-objects
    command-split-coins         = %x02 split-coins
    command-merge-coins         = %x03 merge-coins
    command-publish             = %x04 publish
    command-make-move-vector    = %x05 make-move-vector
    command-upgrade             = %x06 upgrade
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_command, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_command, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_make_move_vector(cls, make_move_vector: "MakeMoveVector"):
        """
        Given n-values of the same type, it constructs a vector. For non objects
        or an empty vector, the type tag must be specified.
        """

        _UniffiConverterTypeMakeMoveVector.check_lower(make_move_vector)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_make_move_vector,
        _UniffiConverterTypeMakeMoveVector.lower(make_move_vector))
        return cls._make_instance_(pointer)

    @classmethod
    def new_merge_coins(cls, merge_coins: "MergeCoins"):
        """
        It merges n-coins into the first coin
        """

        _UniffiConverterTypeMergeCoins.check_lower(merge_coins)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_merge_coins,
        _UniffiConverterTypeMergeCoins.lower(merge_coins))
        return cls._make_instance_(pointer)

    @classmethod
    def new_move_call(cls, move_call: "MoveCall"):
        """
        A call to either an entry or a public Move function
        """

        _UniffiConverterTypeMoveCall.check_lower(move_call)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_move_call,
        _UniffiConverterTypeMoveCall.lower(move_call))
        return cls._make_instance_(pointer)

    @classmethod
    def new_publish(cls, publish: "Publish"):
        """
        Publishes a Move package. It takes the package bytes and a list of the
        package's transitive dependencies to link against on-chain.
        """

        _UniffiConverterTypePublish.check_lower(publish)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_publish,
        _UniffiConverterTypePublish.lower(publish))
        return cls._make_instance_(pointer)

    @classmethod
    def new_split_coins(cls, split_coins: "SplitCoins"):
        """
        It splits off some amounts into a new coins with those amounts
        """

        _UniffiConverterTypeSplitCoins.check_lower(split_coins)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_split_coins,
        _UniffiConverterTypeSplitCoins.lower(split_coins))
        return cls._make_instance_(pointer)

    @classmethod
    def new_transfer_objects(cls, transfer_objects: "TransferObjects"):
        """
        It sends n-objects to the specified address. These objects must have
        store (public transfer) and either the previous owner must be an
        address or the object must be newly created.
        """

        _UniffiConverterTypeTransferObjects.check_lower(transfer_objects)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_transfer_objects,
        _UniffiConverterTypeTransferObjects.lower(transfer_objects))
        return cls._make_instance_(pointer)

    @classmethod
    def new_upgrade(cls, upgrade: "Upgrade"):
        """
        Upgrades a Move package
        Takes (in order):
        1. A vector of serialized modules for the package.
        2. A vector of object ids for the transitive dependencies of the new
        package.
        3. The object ID of the package being upgraded.
        4. An argument holding the `UpgradeTicket` that must have been produced
        from an earlier command in the same programmable transaction.
        """

        _UniffiConverterTypeUpgrade.check_lower(upgrade)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_command_new_upgrade,
        _UniffiConverterTypeUpgrade.lower(upgrade))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeCommand:

    @staticmethod
    def lift(value: int):
        return Command._make_instance_(value)

    @staticmethod
    def check_lower(value: Command):
        if not isinstance(value, Command):
            raise TypeError("Expected Command instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CommandProtocol):
        if not isinstance(value, Command):
            raise TypeError("Expected Command instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CommandProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ConsensusCommitPrologueV1Protocol(typing.Protocol):
    """
    V1 of the consensus commit prologue system transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    consensus-commit-prologue-v1 = u64 u64 (option u64) u64 digest
    consensus-determined-version-assignments
    ```
    """

    def commit_timestamp_ms(self, ):
        """
        Unix timestamp from consensus
        """

        raise NotImplementedError
    def consensus_commit_digest(self, ):
        """
        Digest of consensus output
        """

        raise NotImplementedError
    def consensus_determined_version_assignments(self, ):
        """
        Stores consensus handler determined shared object version assignments.
        """

        raise NotImplementedError
    def epoch(self, ):
        """
        Epoch of the commit prologue transaction
        """

        raise NotImplementedError
    def round(self, ):
        """
        Consensus round of the commit
        """

        raise NotImplementedError
    def sub_dag_index(self, ):
        """
        The sub DAG index of the consensus commit. This field will be populated
        if there are multiple consensus commits per round.
        """

        raise NotImplementedError
# ConsensusCommitPrologueV1 is a Rust-only trait - it's a wrapper around a Rust implementation.
class ConsensusCommitPrologueV1():
    """
    V1 of the consensus commit prologue system transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    consensus-commit-prologue-v1 = u64 u64 (option u64) u64 digest
    consensus-determined-version-assignments
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",round: "int",sub_dag_index: "typing.Optional[int]",commit_timestamp_ms: "int",consensus_commit_digest: "Digest",consensus_determined_version_assignments: "ConsensusDeterminedVersionAssignments"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterUInt64.check_lower(round)
        
        _UniffiConverterOptionalUInt64.check_lower(sub_dag_index)
        
        _UniffiConverterUInt64.check_lower(commit_timestamp_ms)
        
        _UniffiConverterTypeDigest.check_lower(consensus_commit_digest)
        
        _UniffiConverterTypeConsensusDeterminedVersionAssignments.check_lower(consensus_determined_version_assignments)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_consensuscommitprologuev1_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterUInt64.lower(round),
        _UniffiConverterOptionalUInt64.lower(sub_dag_index),
        _UniffiConverterUInt64.lower(commit_timestamp_ms),
        _UniffiConverterTypeDigest.lower(consensus_commit_digest),
        _UniffiConverterTypeConsensusDeterminedVersionAssignments.lower(consensus_determined_version_assignments))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_consensuscommitprologuev1, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_consensuscommitprologuev1, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def commit_timestamp_ms(self, ) -> "int":
        """
        Unix timestamp from consensus
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_commit_timestamp_ms,self._uniffi_clone_pointer(),)
        )





    def consensus_commit_digest(self, ) -> "Digest":
        """
        Digest of consensus output
        """

        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_commit_digest,self._uniffi_clone_pointer(),)
        )





    def consensus_determined_version_assignments(self, ) -> "ConsensusDeterminedVersionAssignments":
        """
        Stores consensus handler determined shared object version assignments.
        """

        return _UniffiConverterTypeConsensusDeterminedVersionAssignments.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_consensus_determined_version_assignments,self._uniffi_clone_pointer(),)
        )





    def epoch(self, ) -> "int":
        """
        Epoch of the commit prologue transaction
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_epoch,self._uniffi_clone_pointer(),)
        )





    def round(self, ) -> "int":
        """
        Consensus round of the commit
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_round,self._uniffi_clone_pointer(),)
        )





    def sub_dag_index(self, ) -> "typing.Optional[int]":
        """
        The sub DAG index of the consensus commit. This field will be populated
        if there are multiple consensus commits per round.
        """

        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensuscommitprologuev1_sub_dag_index,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeConsensusCommitPrologueV1:

    @staticmethod
    def lift(value: int):
        return ConsensusCommitPrologueV1._make_instance_(value)

    @staticmethod
    def check_lower(value: ConsensusCommitPrologueV1):
        if not isinstance(value, ConsensusCommitPrologueV1):
            raise TypeError("Expected ConsensusCommitPrologueV1 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConsensusCommitPrologueV1Protocol):
        if not isinstance(value, ConsensusCommitPrologueV1):
            raise TypeError("Expected ConsensusCommitPrologueV1 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConsensusCommitPrologueV1Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ConsensusDeterminedVersionAssignmentsProtocol(typing.Protocol):
    def as_cancelled_transactions(self, ):
        raise NotImplementedError
    def is_cancelled_transactions(self, ):
        raise NotImplementedError
# ConsensusDeterminedVersionAssignments is a Rust-only trait - it's a wrapper around a Rust implementation.
class ConsensusDeterminedVersionAssignments():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_consensusdeterminedversionassignments, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_consensusdeterminedversionassignments, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_cancelled_transactions(cls, cancelled_transactions: "typing.List[CancelledTransaction]"):
        _UniffiConverterSequenceTypeCancelledTransaction.check_lower(cancelled_transactions)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_consensusdeterminedversionassignments_new_cancelled_transactions,
        _UniffiConverterSequenceTypeCancelledTransaction.lower(cancelled_transactions))
        return cls._make_instance_(pointer)



    def as_cancelled_transactions(self, ) -> "typing.List[CancelledTransaction]":
        return _UniffiConverterSequenceTypeCancelledTransaction.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_as_cancelled_transactions,self._uniffi_clone_pointer(),)
        )





    def is_cancelled_transactions(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_consensusdeterminedversionassignments_is_cancelled_transactions,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeConsensusDeterminedVersionAssignments:

    @staticmethod
    def lift(value: int):
        return ConsensusDeterminedVersionAssignments._make_instance_(value)

    @staticmethod
    def check_lower(value: ConsensusDeterminedVersionAssignments):
        if not isinstance(value, ConsensusDeterminedVersionAssignments):
            raise TypeError("Expected ConsensusDeterminedVersionAssignments instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConsensusDeterminedVersionAssignmentsProtocol):
        if not isinstance(value, ConsensusDeterminedVersionAssignments):
            raise TypeError("Expected ConsensusDeterminedVersionAssignments instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConsensusDeterminedVersionAssignmentsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class DigestProtocol(typing.Protocol):
    """
    A 32-byte Blake2b256 hash output.

    # BCS

    A `Digest`'s BCS serialized form is defined by the following:

    ```text
    digest = %x20 32OCTET
    ```

    Due to historical reasons, even though a `Digest` has a fixed-length of 32,
    IOTA's binary representation of a `Digest` is prefixed with its length
    meaning its serialized binary form (in bcs) is 33 bytes long vs a more
    compact 32 bytes.
    """

    def next_lexicographical(self, ):
        """
        Returns the next digest in byte-increasing order.
        """

        raise NotImplementedError
    def to_base58(self, ):
        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
# Digest is a Rust-only trait - it's a wrapper around a Rust implementation.
class Digest():
    """
    A 32-byte Blake2b256 hash output.

    # BCS

    A `Digest`'s BCS serialized form is defined by the following:

    ```text
    digest = %x20 32OCTET
    ```

    Due to historical reasons, even though a `Digest` has a fixed-length of 32,
    IOTA's binary representation of a `Digest` is prefixed with its length
    meaning its serialized binary form (in bcs) is 33 bytes long vs a more
    compact 32 bytes.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_digest, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_digest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_base58(cls, base58: "str"):
        _UniffiConverterString.check_lower(base58)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_from_base58,
        _UniffiConverterString.lower(base58))
        return cls._make_instance_(pointer)

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_digest_generate,)
        return cls._make_instance_(pointer)



    def next_lexicographical(self, ) -> "Digest":
        """
        Returns the next digest in byte-increasing order.
        """

        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_next_lexicographical,self._uniffi_clone_pointer(),)
        )





    def to_base58(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_to_base58,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_digest_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDigest:

    @staticmethod
    def lift(value: int):
        return Digest._make_instance_(value)

    @staticmethod
    def check_lower(value: Digest):
        if not isinstance(value, Digest):
            raise TypeError("Expected Digest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DigestProtocol):
        if not isinstance(value, Digest):
            raise TypeError("Expected Digest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DigestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Ed25519PrivateKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def sign_personal_message(self, message: "PersonalMessage"):
        """
        Sign a personal message and return a UserSignature.
        """

        raise NotImplementedError
    def sign_transaction(self, transaction: "Transaction"):
        """
        Sign a transaction and return a UserSignature.
        """

        raise NotImplementedError
    def to_bech32(self, ):
        """
        Encode this private key as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        """
        Serialize this private key to bytes.
        """

        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this private key as PEM-encoded PKCS#8
        """

        raise NotImplementedError
    def try_sign(self, message: "bytes"):
        raise NotImplementedError
    def try_sign_simple(self, message: "bytes"):
        raise NotImplementedError
    def try_sign_user(self, message: "bytes"):
        raise NotImplementedError
    def verifying_key(self, ):
        raise NotImplementedError
# Ed25519PrivateKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Ed25519PrivateKey():
    _pointer: ctypes.c_void_p
    def __init__(self, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_new,
        _UniffiConverterBytes.lower(bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519privatekey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519privatekey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, value: "str"):
        """
        Decode a private key from `flag || privkey` in Bech32 starting with
        "iotaprivkey".
        """

        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_bech32,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
        format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_mnemonic(cls, phrase: "str",account_index: "typing.Union[object, int]" = _DEFAULT,password: "typing.Union[object, str]" = _DEFAULT):
        """
        Construct the private key from a mnemonic phrase
        """

        _UniffiConverterString.check_lower(phrase)
        
        if account_index is _DEFAULT:
            account_index = 0
        _UniffiConverterUInt64.check_lower(account_index)
        
        if password is _DEFAULT:
            password = ""
        _UniffiConverterString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic,
        _UniffiConverterString.lower(phrase),
        _UniffiConverterUInt64.lower(account_index),
        _UniffiConverterString.lower(password))
        return cls._make_instance_(pointer)

    @classmethod
    def from_mnemonic_with_path(cls, phrase: "str",path: "str",password: "typing.Union[object, str]" = _DEFAULT):
        """
        Create an instance from a mnemonic phrase and a derivation path like
        `"m/44'/4218'/0'/0'/0'"`
        """

        _UniffiConverterString.check_lower(phrase)
        
        _UniffiConverterString.check_lower(path)
        
        if password is _DEFAULT:
            password = ""
        _UniffiConverterString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_mnemonic_with_path,
        _UniffiConverterString.lower(phrase),
        _UniffiConverterString.lower(path),
        _UniffiConverterString.lower(password))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize PKCS#8-encoded private key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519privatekey_generate,)
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Ed25519PublicKey":
        return _UniffiConverterTypeEd25519PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_public_key,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_scheme,self._uniffi_clone_pointer(),)
        )





    def sign_personal_message(self, message: "PersonalMessage") -> "UserSignature":
        """
        Sign a personal message and return a UserSignature.
        """

        _UniffiConverterTypePersonalMessage.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_personal_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypePersonalMessage.lower(message))
        )





    def sign_transaction(self, transaction: "Transaction") -> "UserSignature":
        """
        Sign a transaction and return a UserSignature.
        """

        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_sign_transaction,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))
        )





    def to_bech32(self, ) -> "str":
        """
        Encode this private key as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        """
        Serialize this private key to bytes.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this private key as PEM-encoded PKCS#8
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_to_pem,self._uniffi_clone_pointer(),)
        )





    def try_sign(self, message: "bytes") -> "Ed25519Signature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeEd25519Signature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_simple(self, message: "bytes") -> "SimpleSignature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_user(self, message: "bytes") -> "UserSignature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_try_sign_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def verifying_key(self, ) -> "Ed25519VerifyingKey":
        return _UniffiConverterTypeEd25519VerifyingKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519privatekey_verifying_key,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEd25519PrivateKey:

    @staticmethod
    def lift(value: int):
        return Ed25519PrivateKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Ed25519PrivateKey):
        if not isinstance(value, Ed25519PrivateKey):
            raise TypeError("Expected Ed25519PrivateKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Ed25519PrivateKeyProtocol):
        if not isinstance(value, Ed25519PrivateKey):
            raise TypeError("Expected Ed25519PrivateKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Ed25519PrivateKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Ed25519PublicKeyProtocol(typing.Protocol):
    """
    An ed25519 public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ed25519-public-key = 32OCTECT
    ```
    """

    def derive_address(self, ):
        """
        Derive an `Address` from this Public Key

        An `Address` can be derived from an `Ed25519PublicKey` by hashing the
        bytes of the public key with no prefix flag.

        `hash(32-byte ed25519 public key)`
        """

        raise NotImplementedError
    def scheme(self, ):
        """
        Returns the signature scheme for this public key.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
    def to_flagged_bytes(self, ):
        """
        Returns the bytes with signature scheme flag prepended.
        """

        raise NotImplementedError
# Ed25519PublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Ed25519PublicKey():
    """
    An ed25519 public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ed25519-public-key = 32OCTECT
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519publickey_generate,)
        return cls._make_instance_(pointer)



    def derive_address(self, ) -> "Address":
        """
        Derive an `Address` from this Public Key

        An `Address` can be derived from an `Ed25519PublicKey` by hashing the
        bytes of the public key with no prefix flag.

        `hash(32-byte ed25519 public key)`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_derive_address,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        """
        Returns the signature scheme for this public key.
        """

        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_scheme,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_flagged_bytes(self, ) -> "bytes":
        """
        Returns the bytes with signature scheme flag prepended.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519publickey_to_flagged_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEd25519PublicKey:

    @staticmethod
    def lift(value: int):
        return Ed25519PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Ed25519PublicKey):
        if not isinstance(value, Ed25519PublicKey):
            raise TypeError("Expected Ed25519PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Ed25519PublicKeyProtocol):
        if not isinstance(value, Ed25519PublicKey):
            raise TypeError("Expected Ed25519PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Ed25519PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Ed25519SignatureProtocol(typing.Protocol):
    """
    An ed25519 signature.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ed25519-signature = 64OCTECT
    ```
    """

    def to_bytes(self, ):
        raise NotImplementedError
# Ed25519Signature is a Rust-only trait - it's a wrapper around a Rust implementation.
class Ed25519Signature():
    """
    An ed25519 signature.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ed25519-signature = 64OCTECT
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519signature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519signature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519signature_generate,)
        return cls._make_instance_(pointer)



    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519signature_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeEd25519Signature:

    @staticmethod
    def lift(value: int):
        return Ed25519Signature._make_instance_(value)

    @staticmethod
    def check_lower(value: Ed25519Signature):
        if not isinstance(value, Ed25519Signature):
            raise TypeError("Expected Ed25519Signature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Ed25519SignatureProtocol):
        if not isinstance(value, Ed25519Signature):
            raise TypeError("Expected Ed25519Signature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Ed25519SignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Ed25519VerifierProtocol(typing.Protocol):
    pass
# Ed25519Verifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class Ed25519Verifier():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519verifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519verifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeEd25519Verifier:

    @staticmethod
    def lift(value: int):
        return Ed25519Verifier._make_instance_(value)

    @staticmethod
    def check_lower(value: Ed25519Verifier):
        if not isinstance(value, Ed25519Verifier):
            raise TypeError("Expected Ed25519Verifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Ed25519VerifierProtocol):
        if not isinstance(value, Ed25519Verifier):
            raise TypeError("Expected Ed25519Verifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Ed25519VerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Ed25519VerifyingKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this public key as DER-encoded data
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this public key into PEM format
        """

        raise NotImplementedError
    def verify(self, message: "bytes",signature: "Ed25519Signature"):
        raise NotImplementedError
    def verify_simple(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
    def verify_user(self, message: "bytes",signature: "UserSignature"):
        raise NotImplementedError
# Ed25519VerifyingKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Ed25519VerifyingKey():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "Ed25519PublicKey"):
        _UniffiConverterTypeEd25519PublicKey.check_lower(public_key)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_new,
        _UniffiConverterTypeEd25519PublicKey.lower(public_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ed25519verifyingkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ed25519verifyingkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize public key from ASN.1 DER-encoded data (binary format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize public key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ed25519verifyingkey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Ed25519PublicKey":
        return _UniffiConverterTypeEd25519PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_public_key,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this public key as DER-encoded data
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this public key into PEM format
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_to_pem,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",signature: "Ed25519Signature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeEd25519Signature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeEd25519Signature.lower(signature))






    def verify_simple(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))






    def verify_user(self, message: "bytes",signature: "UserSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_ed25519verifyingkey_verify_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeUserSignature.lower(signature))







class _UniffiConverterTypeEd25519VerifyingKey:

    @staticmethod
    def lift(value: int):
        return Ed25519VerifyingKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Ed25519VerifyingKey):
        if not isinstance(value, Ed25519VerifyingKey):
            raise TypeError("Expected Ed25519VerifyingKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Ed25519VerifyingKeyProtocol):
        if not isinstance(value, Ed25519VerifyingKey):
            raise TypeError("Expected Ed25519VerifyingKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Ed25519VerifyingKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class EndOfEpochTransactionKindProtocol(typing.Protocol):
    """
    Operation run at the end of an epoch

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    end-of-epoch-transaction-kind   =  eoe-change-epoch
    =/ eoe-authenticator-state-create
    =/ eoe-authenticator-state-expire
    =/ eoe-randomness-state-create
    =/ eoe-deny-list-state-create
    =/ eoe-bridge-state-create
    =/ eoe-bridge-committee-init
    =/ eoe-store-execution-time-observations

    eoe-change-epoch                = %x00 change-epoch
    eoe-authenticator-state-create  = %x01
    eoe-authenticator-state-expire  = %x02 authenticator-state-expire
    eoe-randomness-state-create     = %x03
    eoe-deny-list-state-create      = %x04
    eoe-bridge-state-create         = %x05 digest
    eoe-bridge-committee-init       = %x06 u64
    eoe-store-execution-time-observations = %x07 stored-execution-time-observations
    ```
    """

    pass
# EndOfEpochTransactionKind is a Rust-only trait - it's a wrapper around a Rust implementation.
class EndOfEpochTransactionKind():
    """
    Operation run at the end of an epoch

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    end-of-epoch-transaction-kind   =  eoe-change-epoch
    =/ eoe-authenticator-state-create
    =/ eoe-authenticator-state-expire
    =/ eoe-randomness-state-create
    =/ eoe-deny-list-state-create
    =/ eoe-bridge-state-create
    =/ eoe-bridge-committee-init
    =/ eoe-store-execution-time-observations

    eoe-change-epoch                = %x00 change-epoch
    eoe-authenticator-state-create  = %x01
    eoe-authenticator-state-expire  = %x02 authenticator-state-expire
    eoe-randomness-state-create     = %x03
    eoe-deny-list-state-create      = %x04
    eoe-bridge-state-create         = %x05 digest
    eoe-bridge-committee-init       = %x06 u64
    eoe-store-execution-time-observations = %x07 stored-execution-time-observations
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_endofepochtransactionkind, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_endofepochtransactionkind, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_authenticator_state_create(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_create,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_authenticator_state_expire(cls, tx: "AuthenticatorStateExpire"):
        _UniffiConverterTypeAuthenticatorStateExpire.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_authenticator_state_expire,
        _UniffiConverterTypeAuthenticatorStateExpire.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_change_epoch(cls, tx: "ChangeEpoch"):
        _UniffiConverterTypeChangeEpoch.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch,
        _UniffiConverterTypeChangeEpoch.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_change_epoch_v2(cls, tx: "ChangeEpochV2"):
        _UniffiConverterTypeChangeEpochV2.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v2,
        _UniffiConverterTypeChangeEpochV2.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_change_epoch_v3(cls, tx: "ChangeEpochV3"):
        _UniffiConverterTypeChangeEpochV3.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_endofepochtransactionkind_new_change_epoch_v3,
        _UniffiConverterTypeChangeEpochV3.lower(tx))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeEndOfEpochTransactionKind:

    @staticmethod
    def lift(value: int):
        return EndOfEpochTransactionKind._make_instance_(value)

    @staticmethod
    def check_lower(value: EndOfEpochTransactionKind):
        if not isinstance(value, EndOfEpochTransactionKind):
            raise TypeError("Expected EndOfEpochTransactionKind instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EndOfEpochTransactionKindProtocol):
        if not isinstance(value, EndOfEpochTransactionKind):
            raise TypeError("Expected EndOfEpochTransactionKind instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EndOfEpochTransactionKindProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ExecutionTimeObservationProtocol(typing.Protocol):
    def key(self, ):
        raise NotImplementedError
    def observations(self, ):
        raise NotImplementedError
# ExecutionTimeObservation is a Rust-only trait - it's a wrapper around a Rust implementation.
class ExecutionTimeObservation():
    _pointer: ctypes.c_void_p
    def __init__(self, key: "ExecutionTimeObservationKey",observations: "typing.List[ValidatorExecutionTimeObservation]"):
        _UniffiConverterTypeExecutionTimeObservationKey.check_lower(key)
        
        _UniffiConverterSequenceTypeValidatorExecutionTimeObservation.check_lower(observations)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservation_new,
        _UniffiConverterTypeExecutionTimeObservationKey.lower(key),
        _UniffiConverterSequenceTypeValidatorExecutionTimeObservation.lower(observations))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservation, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservation, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def key(self, ) -> "ExecutionTimeObservationKey":
        return _UniffiConverterTypeExecutionTimeObservationKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_key,self._uniffi_clone_pointer(),)
        )





    def observations(self, ) -> "typing.List[ValidatorExecutionTimeObservation]":
        return _UniffiConverterSequenceTypeValidatorExecutionTimeObservation.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_executiontimeobservation_observations,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeExecutionTimeObservation:

    @staticmethod
    def lift(value: int):
        return ExecutionTimeObservation._make_instance_(value)

    @staticmethod
    def check_lower(value: ExecutionTimeObservation):
        if not isinstance(value, ExecutionTimeObservation):
            raise TypeError("Expected ExecutionTimeObservation instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ExecutionTimeObservationProtocol):
        if not isinstance(value, ExecutionTimeObservation):
            raise TypeError("Expected ExecutionTimeObservation instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ExecutionTimeObservationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ExecutionTimeObservationKeyProtocol(typing.Protocol):
    """
    Key for an execution time observation

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    execution-time-observation-key  =  %x00 move-entry-point
    =/ %x01 ; transfer-objects
    =/ %x02 ; split-coins
    =/ %x03 ; merge-coins
    =/ %x04 ; publish
    =/ %x05 ; make-move-vec
    =/ %x06 ; upgrade

    move-entry-point = object-id string string (vec type-tag)
    ```
    """

    pass
# ExecutionTimeObservationKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class ExecutionTimeObservationKey():
    """
    Key for an execution time observation

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    execution-time-observation-key  =  %x00 move-entry-point
    =/ %x01 ; transfer-objects
    =/ %x02 ; split-coins
    =/ %x03 ; merge-coins
    =/ %x04 ; publish
    =/ %x05 ; make-move-vec
    =/ %x06 ; upgrade

    move-entry-point = object-id string string (vec type-tag)
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservationkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservationkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_make_move_vec(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_make_move_vec,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_merge_coins(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_merge_coins,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_move_entry_point(cls, package: "ObjectId",module: "str",function: "str",type_arguments: "typing.List[TypeTag]"):
        _UniffiConverterTypeObjectId.check_lower(package)
        
        _UniffiConverterString.check_lower(module)
        
        _UniffiConverterString.check_lower(function)
        
        _UniffiConverterSequenceTypeTypeTag.check_lower(type_arguments)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_move_entry_point,
        _UniffiConverterTypeObjectId.lower(package),
        _UniffiConverterString.lower(module),
        _UniffiConverterString.lower(function),
        _UniffiConverterSequenceTypeTypeTag.lower(type_arguments))
        return cls._make_instance_(pointer)

    @classmethod
    def new_publish(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_publish,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_split_coins(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_split_coins,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_transfer_objects(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_transfer_objects,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_upgrade(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservationkey_new_upgrade,)
        return cls._make_instance_(pointer)




class _UniffiConverterTypeExecutionTimeObservationKey:

    @staticmethod
    def lift(value: int):
        return ExecutionTimeObservationKey._make_instance_(value)

    @staticmethod
    def check_lower(value: ExecutionTimeObservationKey):
        if not isinstance(value, ExecutionTimeObservationKey):
            raise TypeError("Expected ExecutionTimeObservationKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ExecutionTimeObservationKeyProtocol):
        if not isinstance(value, ExecutionTimeObservationKey):
            raise TypeError("Expected ExecutionTimeObservationKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ExecutionTimeObservationKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ExecutionTimeObservationsProtocol(typing.Protocol):
    """
    Set of Execution Time Observations from the committee.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    stored-execution-time-observations =  %x00 v1-stored-execution-time-observations

    v1-stored-execution-time-observations = (vec
    execution-time-observation-key
    (vec execution-time-observation)
    )
    ```
    """

    pass
# ExecutionTimeObservations is a Rust-only trait - it's a wrapper around a Rust implementation.
class ExecutionTimeObservations():
    """
    Set of Execution Time Observations from the committee.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    stored-execution-time-observations =  %x00 v1-stored-execution-time-observations

    v1-stored-execution-time-observations = (vec
    execution-time-observation-key
    (vec execution-time-observation)
    )
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_executiontimeobservations, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_executiontimeobservations, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_v1(cls, execution_time_observations: "typing.List[ExecutionTimeObservation]"):
        _UniffiConverterSequenceTypeExecutionTimeObservation.check_lower(execution_time_observations)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_executiontimeobservations_new_v1,
        _UniffiConverterSequenceTypeExecutionTimeObservation.lower(execution_time_observations))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeExecutionTimeObservations:

    @staticmethod
    def lift(value: int):
        return ExecutionTimeObservations._make_instance_(value)

    @staticmethod
    def check_lower(value: ExecutionTimeObservations):
        if not isinstance(value, ExecutionTimeObservations):
            raise TypeError("Expected ExecutionTimeObservations instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ExecutionTimeObservationsProtocol):
        if not isinstance(value, ExecutionTimeObservations):
            raise TypeError("Expected ExecutionTimeObservations instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ExecutionTimeObservationsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class FaucetClientProtocol(typing.Protocol):
    def request(self, address: "Address"):
        """
        Request gas from the faucet. Note that this will return the UUID of the
        request and not wait until the token is received. Use
        `request_and_wait` to wait for the token.
        """

        raise NotImplementedError
    def request_and_wait(self, address: "Address"):
        """
        Request gas from the faucet and wait until the request is completed and
        token is transferred. Returns `FaucetReceipt` if the request is
        successful, which contains the list of tokens transferred, and the
        transaction digest.

        Note that the faucet is heavily rate-limited, so calling repeatedly the
        faucet would likely result in a 429 code or 502 code.
        """

        raise NotImplementedError
    def request_status(self, id: "str"):
        """
        Check the faucet request status.

        Possible statuses are defined in: `BatchSendStatusType`
        """

        raise NotImplementedError
# FaucetClient is a Rust-only trait - it's a wrapper around a Rust implementation.
class FaucetClient():
    _pointer: ctypes.c_void_p
    def __init__(self, faucet_url: "str"):
        """
        Construct a new `FaucetClient` with the given faucet service URL. This
        `FaucetClient` expects that the service provides two endpoints:
        /v1/gas and /v1/status. As such, do not provide the request
        endpoint, just the top level service endpoint.

        - /v1/gas is used to request gas
        - /v1/status/taks-uuid is used to check the status of the request
        """

        _UniffiConverterString.check_lower(faucet_url)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new,
        _UniffiConverterString.lower(faucet_url))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_faucetclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_faucetclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_devnet(cls, ):
        """
        Create a new Faucet client connected to the `devnet` faucet.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_devnet,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_localnet(cls, ):
        """
        Create a new Faucet client connected to a `localnet` faucet.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_localnet,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_testnet(cls, ):
        """
        Create a new Faucet client connected to the `testnet` faucet.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_faucetclient_new_testnet,)
        return cls._make_instance_(pointer)


    async def request(self, address: "Address") -> "typing.Optional[str]":
        """
        Request gas from the faucet. Note that this will return the UUID of the
        request and not wait until the token is received. Use
        `request_and_wait` to wait for the token.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalString.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def request_and_wait(self, address: "Address") -> "typing.Optional[FaucetReceipt]":
        """
        Request gas from the faucet and wait until the request is completed and
        token is transferred. Returns `FaucetReceipt` if the request is
        successful, which contains the list of tokens transferred, and the
        transaction digest.

        Note that the faucet is heavily rate-limited, so calling repeatedly the
        faucet would likely result in a 429 code or 502 code.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_and_wait(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeFaucetReceipt.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def request_status(self, id: "str") -> "typing.Optional[BatchSendStatus]":
        """
        Check the faucet request status.

        Possible statuses are defined in: `BatchSendStatusType`
        """

        _UniffiConverterString.check_lower(id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_faucetclient_request_status(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(id)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeBatchSendStatus.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )





class _UniffiConverterTypeFaucetClient:

    @staticmethod
    def lift(value: int):
        return FaucetClient._make_instance_(value)

    @staticmethod
    def check_lower(value: FaucetClient):
        if not isinstance(value, FaucetClient):
            raise TypeError("Expected FaucetClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FaucetClientProtocol):
        if not isinstance(value, FaucetClient):
            raise TypeError("Expected FaucetClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FaucetClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class GenesisObjectProtocol(typing.Protocol):
    """
    An object part of the initial chain state

    `GenesisObject`'s are included as a part of genesis, the initial
    checkpoint/transaction, that initializes the state of the blockchain.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    genesis-object = object-data owner
    ```
    """

    def data(self, ):
        raise NotImplementedError
    def object_id(self, ):
        raise NotImplementedError
    def object_type(self, ):
        raise NotImplementedError
    def owner(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
# GenesisObject is a Rust-only trait - it's a wrapper around a Rust implementation.
class GenesisObject():
    """
    An object part of the initial chain state

    `GenesisObject`'s are included as a part of genesis, the initial
    checkpoint/transaction, that initializes the state of the blockchain.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    genesis-object = object-data owner
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, data: "ObjectData",owner: "Owner"):
        _UniffiConverterTypeObjectData.check_lower(data)
        
        _UniffiConverterTypeOwner.check_lower(owner)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_genesisobject_new,
        _UniffiConverterTypeObjectData.lower(data),
        _UniffiConverterTypeOwner.lower(owner))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_genesisobject, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_genesisobject, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def data(self, ) -> "ObjectData":
        return _UniffiConverterTypeObjectData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_data,self._uniffi_clone_pointer(),)
        )





    def object_id(self, ) -> "ObjectId":
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_id,self._uniffi_clone_pointer(),)
        )





    def object_type(self, ) -> "ObjectType":
        return _UniffiConverterTypeObjectType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_object_type,self._uniffi_clone_pointer(),)
        )





    def owner(self, ) -> "Owner":
        return _UniffiConverterTypeOwner.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_owner,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesisobject_version,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeGenesisObject:

    @staticmethod
    def lift(value: int):
        return GenesisObject._make_instance_(value)

    @staticmethod
    def check_lower(value: GenesisObject):
        if not isinstance(value, GenesisObject):
            raise TypeError("Expected GenesisObject instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: GenesisObjectProtocol):
        if not isinstance(value, GenesisObject):
            raise TypeError("Expected GenesisObject instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: GenesisObjectProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class GenesisTransactionProtocol(typing.Protocol):
    """
    The genesis transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    genesis-transaction = (vector genesis-object)
    ```
    """

    def events(self, ):
        raise NotImplementedError
    def objects(self, ):
        raise NotImplementedError
# GenesisTransaction is a Rust-only trait - it's a wrapper around a Rust implementation.
class GenesisTransaction():
    """
    The genesis transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    genesis-transaction = (vector genesis-object)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, objects: "typing.List[GenesisObject]",events: "typing.List[Event]"):
        _UniffiConverterSequenceTypeGenesisObject.check_lower(objects)
        
        _UniffiConverterSequenceTypeEvent.check_lower(events)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_genesistransaction_new,
        _UniffiConverterSequenceTypeGenesisObject.lower(objects),
        _UniffiConverterSequenceTypeEvent.lower(events))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_genesistransaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_genesistransaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def events(self, ) -> "typing.List[Event]":
        return _UniffiConverterSequenceTypeEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesistransaction_events,self._uniffi_clone_pointer(),)
        )





    def objects(self, ) -> "typing.List[GenesisObject]":
        return _UniffiConverterSequenceTypeGenesisObject.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_genesistransaction_objects,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeGenesisTransaction:

    @staticmethod
    def lift(value: int):
        return GenesisTransaction._make_instance_(value)

    @staticmethod
    def check_lower(value: GenesisTransaction):
        if not isinstance(value, GenesisTransaction):
            raise TypeError("Expected GenesisTransaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: GenesisTransactionProtocol):
        if not isinstance(value, GenesisTransaction):
            raise TypeError("Expected GenesisTransaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: GenesisTransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class GraphQlClientProtocol(typing.Protocol):
    """
    The GraphQL client for interacting with the IOTA blockchain.
    """

    def active_validators(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get the list of active validators for the provided epoch, including
        related metadata. If no epoch is provided, it will return the active
        validators for the current epoch.
        """

        raise NotImplementedError
    def balance(self, address: "Address",coin_type: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        """
        Get the balance of all the coins owned by address for the provided coin
        type. Coin type will default to `0x2::coin::Coin<0x2::iota::IOTA>`
        if not provided.
        """

        raise NotImplementedError
    def chain_id(self, ):
        """
        Get the chain identifier.
        """

        raise NotImplementedError
    def checkpoint(self, digest: "typing.Union[object, typing.Optional[Digest]]" = _DEFAULT,seq_num: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Get the `CheckpointSummary` for a given checkpoint digest or
        checkpoint id. If none is provided, it will use the last known
        checkpoint id.
        """

        raise NotImplementedError
    def checkpoints(self, pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get a page of `CheckpointSummary` for the provided parameters.
        """

        raise NotImplementedError
    def coin_metadata(self, coin_type: "str"):
        """
        Get the coin metadata for the coin type.
        """

        raise NotImplementedError
    def coins(self, owner: "Address",pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,coin_type: "typing.Union[object, typing.Optional[StructTag]]" = _DEFAULT):
        """
        Get the list of coins for the specified address.

        If `coin_type` is not provided, all coins will be returned. For IOTA
        coins, pass in the coin type: `0x2::iota::IOTA`.
        """

        raise NotImplementedError
    def dry_run_tx(self, tx: "Transaction",skip_checks: "typing.Union[object, bool]" = _DEFAULT):
        """
        Dry run a `Transaction` and return the transaction effects and dry run
        error (if any).

        `skipChecks` optional flag disables the usual verification checks that
        prevent access to objects that are owned by addresses other than the
        sender, and calling non-public, non-entry functions, and some other
        checks. Defaults to false.
        """

        raise NotImplementedError
    def dry_run_tx_kind(self, tx_kind: "TransactionKind",tx_meta: "TransactionMetadata",skip_checks: "typing.Union[object, bool]" = _DEFAULT):
        """
        Dry run a `TransactionKind` and return the transaction effects and dry
        run error (if any).

        `skipChecks` optional flag disables the usual verification checks that
        prevent access to objects that are owned by addresses other than the
        sender, and calling non-public, non-entry functions, and some other
        checks. Defaults to false.

        `tx_meta` is the transaction metadata.
        """

        raise NotImplementedError
    def dynamic_field(self, address: "Address",type_tag: "TypeTag",name: "Value"):
        """
        Access a dynamic field on an object using its name. Names are arbitrary
        Move values whose type have copy, drop, and store, and are specified
        using their type, and their BCS contents, Base64 encoded.

        The `name` argument is a json serialized type.

        This returns `DynamicFieldOutput` which contains the name, the value
        as json, and object.
        """

        raise NotImplementedError
    def dynamic_fields(self, address: "Address",pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get a page of dynamic fields for the provided address. Note that this
        will also fetch dynamic fields on wrapped objects.

        This returns a page of `DynamicFieldOutput`s.
        """

        raise NotImplementedError
    def dynamic_object_field(self, address: "Address",type_tag: "TypeTag",name: "Value"):
        """
        Access a dynamic object field on an object using its name. Names are
        arbitrary Move values whose type have copy, drop, and store, and are
        specified using their type, and their BCS contents, Base64 encoded.

        The `name` argument is a json serialized type.

        This returns `DynamicFieldOutput` which contains the name, the value
        as json, and object.
        """

        raise NotImplementedError
    def epoch(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return the epoch information for the provided epoch. If no epoch is
        provided, it will return the last known epoch.
        """

        raise NotImplementedError
    def epoch_total_checkpoints(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return the number of checkpoints in this epoch. This will return
        `Ok(None)` if the epoch requested is not available in the GraphQL
        service (e.g., due to pruning).
        """

        raise NotImplementedError
    def epoch_total_transaction_blocks(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return the number of transaction blocks in this epoch. This will return
        `Ok(None)` if the epoch requested is not available in the GraphQL
        service (e.g., due to pruning).
        """

        raise NotImplementedError
    def events(self, filter: "typing.Union[object, typing.Optional[EventFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Return a page of tuple (event, transaction digest) based on the
        (optional) event filter.
        """

        raise NotImplementedError
    def execute_tx(self, signatures: "typing.List[UserSignature]",tx: "Transaction",wait_for: "typing.Union[object, typing.Optional[WaitForTx]]" = _DEFAULT):
        """
        Execute a transaction.
        """

        raise NotImplementedError
    def gas_coins(self, owner: "Address",pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get the list of gas coins for the specified address.
        """

        raise NotImplementedError
    def iota_names_default_name(self, address: "Address",format: "typing.Optional[NameFormat]"):
        """
        Get the default name pointing to this address, if one exists.
        """

        raise NotImplementedError
    def iota_names_lookup(self, name: "str"):
        """
        Return the resolved address for the given name.
        """

        raise NotImplementedError
    def iota_names_registrations(self, address: "Address",pagination_filter: "PaginationFilter"):
        """
        Find all registration NFTs for the given address.
        """

        raise NotImplementedError
    def is_tx_finalized(self, digest: "Digest"):
        """
        Returns whether the transaction for the given digest has been included
        in a checkpoint (finalized).
        """

        raise NotImplementedError
    def is_tx_indexed_on_node(self, digest: "Digest"):
        """
        Returns whether the transaction for the given digest has been indexed
        on the node. This means that it can be queries by its digest and its
        effects will be usable for subsequent transactions. To check for
        full finalization, use `is_tx_finalized`.
        """

        raise NotImplementedError
    def latest_checkpoint_sequence_number(self, ):
        """
        Return the sequence number of the latest checkpoint that has been
        executed.
        """

        raise NotImplementedError
    def max_page_size(self, ):
        """
        Lazily fetch the max page size
        """

        raise NotImplementedError
    def move_object_contents(self, object_id: "ObjectId",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return the contents' JSON of an object that is a Move object.

        If the object does not exist (e.g., due to pruning), this will return
        `Ok(None)`. Similarly, if this is not an object but an address, it
        will return `Ok(None)`.
        """

        raise NotImplementedError
    def move_object_contents_bcs(self, object_id: "ObjectId",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return the BCS of an object that is a Move object.

        If the object does not exist (e.g., due to pruning), this will return
        `Ok(None)`. Similarly, if this is not an object but an address, it
        will return `Ok(None)`.
        """

        raise NotImplementedError
    def normalized_move_function(self, package: "Address",module: "str",function: "str",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return the normalized Move function data for the provided package,
        module, and function.
        """

        raise NotImplementedError
    def normalized_move_module(self, package: "Address",module: "str",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter_enums: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,pagination_filter_friends: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,pagination_filter_functions: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,pagination_filter_structs: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Return the normalized Move module data for the provided module.
        """

        raise NotImplementedError
    def object(self, object_id: "ObjectId",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Return an object based on the provided `Address`.

        If the object does not exist (e.g., due to pruning), this will return
        `Ok(None)`. Similarly, if this is not an object but an address, it
        will return `Ok(None)`.
        """

        raise NotImplementedError
    def object_bcs(self, object_id: "ObjectId"):
        """
        Return the object's bcs content `Vec<u8>` based on the provided
        `Address`.
        """

        raise NotImplementedError
    def objects(self, filter: "typing.Union[object, typing.Optional[ObjectFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Return a page of objects based on the provided parameters.

        Use this function together with the `ObjectFilter::owner` to get the
        objects owned by an address.
        """

        raise NotImplementedError
    def package(self, address: "Address",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        The package corresponding to the given address (at the optionally given
        version). When no version is given, the package is loaded directly
        from the address given. Otherwise, the address is translated before
        loading to point to the package whose original ID matches
        the package at address, but whose version is version. For non-system
        packages, this might result in a different address than address
        because different versions of a package, introduced by upgrades,
        exist at distinct addresses.

        Note that this interpretation of version is different from a historical
        object read (the interpretation of version for the object query).
        """

        raise NotImplementedError
    def package_latest(self, address: "Address"):
        """
        Fetch the latest version of the package at address.
        This corresponds to the package with the highest version that shares its
        original ID with the package at address.
        """

        raise NotImplementedError
    def package_versions(self, address: "Address",after_version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,before_version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Fetch all versions of package at address (packages that share this
        package's original ID), optionally bounding the versions exclusively
        from below with afterVersion, or from above with beforeVersion.
        """

        raise NotImplementedError
    def packages(self, after_checkpoint: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,before_checkpoint: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        The Move packages that exist in the network, optionally filtered to be
        strictly before beforeCheckpoint and/or strictly after
        afterCheckpoint.

        This query returns all versions of a given user package that appear
        between the specified checkpoints, but only records the latest
        versions of system packages.
        """

        raise NotImplementedError
    def protocol_config(self, version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Get the protocol configuration.
        """

        raise NotImplementedError
    def reference_gas_price(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT):
        """
        Get the reference gas price for the provided epoch or the last known one
        if no epoch is provided.

        This will return `Ok(None)` if the epoch requested is not available in
        the GraphQL service (e.g., due to pruning).
        """

        raise NotImplementedError
    def run_query(self, query: "Query"):
        """
        Run a query.
        """

        raise NotImplementedError
    def service_config(self, ):
        """
        Get the GraphQL service configuration, including complexity limits, read
        and mutation limits, supported versions, and others.
        """

        raise NotImplementedError
    def set_rpc_server(self, server: "str"):
        """
        Set the server address for the GraphQL GraphQL client. It should be a
        valid URL with a host and optionally a port number.
        """

        raise NotImplementedError
    def total_supply(self, coin_type: "str"):
        """
        Get total supply for the coin type.
        """

        raise NotImplementedError
    def total_transaction_blocks(self, ):
        """
        The total number of transaction blocks in the network by the end of the
        last known checkpoint.
        """

        raise NotImplementedError
    def total_transaction_blocks_by_digest(self, digest: "Digest"):
        """
        The total number of transaction blocks in the network by the end of the
        provided checkpoint digest.
        """

        raise NotImplementedError
    def total_transaction_blocks_by_seq_num(self, seq_num: "int"):
        """
        The total number of transaction blocks in the network by the end of the
        provided checkpoint sequence number.
        """

        raise NotImplementedError
    def transaction(self, digest: "Digest"):
        """
        Get a transaction by its digest.
        """

        raise NotImplementedError
    def transaction_data_effects(self, digest: "Digest"):
        """
        Get a transaction's data and effects by its digest.
        """

        raise NotImplementedError
    def transaction_effects(self, digest: "Digest"):
        """
        Get a transaction's effects by its digest.
        """

        raise NotImplementedError
    def transactions(self, filter: "typing.Union[object, typing.Optional[TransactionsFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get a page of transactions based on the provided filters.
        """

        raise NotImplementedError
    def transactions_data_effects(self, filter: "typing.Union[object, typing.Optional[TransactionsFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get a page of transactions' data and effects based on the provided
        filters.
        """

        raise NotImplementedError
    def transactions_effects(self, filter: "typing.Union[object, typing.Optional[TransactionsFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT):
        """
        Get a page of transactions' effects based on the provided filters.
        """

        raise NotImplementedError
    def wait_for_tx(self, digest: "Digest",wait_for: "WaitForTx",timeout: "typing.Union[object, typing.Optional[Duration]]" = _DEFAULT):
        """
        Wait for the indexing or finalization of a transaction
        by its digest. An optional timeout can be provided, which, if
        exceeded, will return an error (default 60s).
        """

        raise NotImplementedError
# GraphQlClient is a Rust-only trait - it's a wrapper around a Rust implementation.
class GraphQlClient():
    """
    The GraphQL client for interacting with the IOTA blockchain.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, server: "str"):
        """
        Create a new GraphQL client with the provided server address.
        """

        _UniffiConverterString.check_lower(server)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new,
        _UniffiConverterString.lower(server))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_graphqlclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_graphqlclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_devnet(cls, ):
        """
        Create a new GraphQL client connected to the `devnet` GraphQL server:
        {DEVNET_HOST}.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_devnet,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_localnet(cls, ):
        """
        Create a new GraphQL client connected to the `localhost` GraphQL server:
        {DEFAULT_LOCAL_HOST}.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_localnet,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_mainnet(cls, ):
        """
        Create a new GraphQL client connected to the `mainnet` GraphQL server:
        {MAINNET_HOST}.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_mainnet,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_testnet(cls, ):
        """
        Create a new GraphQL client connected to the `testnet` GraphQL server:
        {TESTNET_HOST}.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_graphqlclient_new_testnet,)
        return cls._make_instance_(pointer)


    async def active_validators(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "ValidatorPage":
        """
        Get the list of active validators for the provided epoch, including
        related metadata. If no epoch is provided, it will return the active
        validators for the current epoch.
        """

        if epoch is _DEFAULT:
            epoch = None
        _UniffiConverterOptionalUInt64.check_lower(epoch)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_active_validators(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(epoch),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeValidatorPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def balance(self, address: "Address",coin_type: "typing.Union[object, typing.Optional[str]]" = _DEFAULT) -> "typing.Optional[int]":
        """
        Get the balance of all the coins owned by address for the provided coin
        type. Coin type will default to `0x2::coin::Coin<0x2::iota::IOTA>`
        if not provided.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        if coin_type is _DEFAULT:
            coin_type = None
        _UniffiConverterOptionalString.check_lower(coin_type)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_balance(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterOptionalString.lower(coin_type)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def chain_id(self, ) -> "str":
        """
        Get the chain identifier.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_chain_id(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterString.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def checkpoint(self, digest: "typing.Union[object, typing.Optional[Digest]]" = _DEFAULT,seq_num: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[CheckpointSummary]":
        """
        Get the `CheckpointSummary` for a given checkpoint digest or
        checkpoint id. If none is provided, it will use the last known
        checkpoint id.
        """

        if digest is _DEFAULT:
            digest = None
        _UniffiConverterOptionalTypeDigest.check_lower(digest)
        
        if seq_num is _DEFAULT:
            seq_num = None
        _UniffiConverterOptionalUInt64.check_lower(seq_num)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoint(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeDigest.lower(digest),
        _UniffiConverterOptionalUInt64.lower(seq_num)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeCheckpointSummary.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def checkpoints(self, pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "CheckpointSummaryPage":
        """
        Get a page of `CheckpointSummary` for the provided parameters.
        """

        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_checkpoints(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCheckpointSummaryPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def coin_metadata(self, coin_type: "str") -> "typing.Optional[CoinMetadata]":
        """
        Get the coin metadata for the coin type.
        """

        _UniffiConverterString.check_lower(coin_type)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coin_metadata(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(coin_type)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeCoinMetadata.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def coins(self, owner: "Address",pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,coin_type: "typing.Union[object, typing.Optional[StructTag]]" = _DEFAULT) -> "CoinPage":
        """
        Get the list of coins for the specified address.

        If `coin_type` is not provided, all coins will be returned. For IOTA
        coins, pass in the coin type: `0x2::iota::IOTA`.
        """

        _UniffiConverterTypeAddress.check_lower(owner)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        if coin_type is _DEFAULT:
            coin_type = None
        _UniffiConverterOptionalTypeStructTag.check_lower(coin_type)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_coins(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(owner),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter),
        _UniffiConverterOptionalTypeStructTag.lower(coin_type)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCoinPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def dry_run_tx(self, tx: "Transaction",skip_checks: "typing.Union[object, bool]" = _DEFAULT) -> "DryRunResult":
        """
        Dry run a `Transaction` and return the transaction effects and dry run
        error (if any).

        `skipChecks` optional flag disables the usual verification checks that
        prevent access to objects that are owned by addresses other than the
        sender, and calling non-public, non-entry functions, and some other
        checks. Defaults to false.
        """

        _UniffiConverterTypeTransaction.check_lower(tx)
        
        if skip_checks is _DEFAULT:
            skip_checks = False
        _UniffiConverterBool.check_lower(skip_checks)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeTransaction.lower(tx),
        _UniffiConverterBool.lower(skip_checks)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDryRunResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def dry_run_tx_kind(self, tx_kind: "TransactionKind",tx_meta: "TransactionMetadata",skip_checks: "typing.Union[object, bool]" = _DEFAULT) -> "DryRunResult":
        """
        Dry run a `TransactionKind` and return the transaction effects and dry
        run error (if any).

        `skipChecks` optional flag disables the usual verification checks that
        prevent access to objects that are owned by addresses other than the
        sender, and calling non-public, non-entry functions, and some other
        checks. Defaults to false.

        `tx_meta` is the transaction metadata.
        """

        _UniffiConverterTypeTransactionKind.check_lower(tx_kind)
        
        _UniffiConverterTypeTransactionMetadata.check_lower(tx_meta)
        
        if skip_checks is _DEFAULT:
            skip_checks = False
        _UniffiConverterBool.check_lower(skip_checks)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dry_run_tx_kind(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeTransactionKind.lower(tx_kind),
        _UniffiConverterTypeTransactionMetadata.lower(tx_meta),
        _UniffiConverterBool.lower(skip_checks)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDryRunResult.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def dynamic_field(self, address: "Address",type_tag: "TypeTag",name: "Value") -> "typing.Optional[DynamicFieldOutput]":
        """
        Access a dynamic field on an object using its name. Names are arbitrary
        Move values whose type have copy, drop, and store, and are specified
        using their type, and their BCS contents, Base64 encoded.

        The `name` argument is a json serialized type.

        This returns `DynamicFieldOutput` which contains the name, the value
        as json, and object.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        _UniffiConverterTypeValue.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_field(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterTypeTypeTag.lower(type_tag),
        _UniffiConverterTypeValue.lower(name)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeDynamicFieldOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def dynamic_fields(self, address: "Address",pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "DynamicFieldOutputPage":
        """
        Get a page of dynamic fields for the provided address. Note that this
        will also fetch dynamic fields on wrapped objects.

        This returns a page of `DynamicFieldOutput`s.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_fields(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeDynamicFieldOutputPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def dynamic_object_field(self, address: "Address",type_tag: "TypeTag",name: "Value") -> "typing.Optional[DynamicFieldOutput]":
        """
        Access a dynamic object field on an object using its name. Names are
        arbitrary Move values whose type have copy, drop, and store, and are
        specified using their type, and their BCS contents, Base64 encoded.

        The `name` argument is a json serialized type.

        This returns `DynamicFieldOutput` which contains the name, the value
        as json, and object.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        _UniffiConverterTypeValue.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_dynamic_object_field(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterTypeTypeTag.lower(type_tag),
        _UniffiConverterTypeValue.lower(name)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeDynamicFieldOutput.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def epoch(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[Epoch]":
        """
        Return the epoch information for the provided epoch. If no epoch is
        provided, it will return the last known epoch.
        """

        if epoch is _DEFAULT:
            epoch = None
        _UniffiConverterOptionalUInt64.check_lower(epoch)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(epoch)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeEpoch.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def epoch_total_checkpoints(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[int]":
        """
        Return the number of checkpoints in this epoch. This will return
        `Ok(None)` if the epoch requested is not available in the GraphQL
        service (e.g., due to pruning).
        """

        if epoch is _DEFAULT:
            epoch = None
        _UniffiConverterOptionalUInt64.check_lower(epoch)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_checkpoints(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(epoch)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def epoch_total_transaction_blocks(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[int]":
        """
        Return the number of transaction blocks in this epoch. This will return
        `Ok(None)` if the epoch requested is not available in the GraphQL
        service (e.g., due to pruning).
        """

        if epoch is _DEFAULT:
            epoch = None
        _UniffiConverterOptionalUInt64.check_lower(epoch)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_epoch_total_transaction_blocks(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(epoch)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def events(self, filter: "typing.Union[object, typing.Optional[EventFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "EventPage":
        """
        Return a page of tuple (event, transaction digest) based on the
        (optional) event filter.
        """

        if filter is _DEFAULT:
            filter = None
        _UniffiConverterOptionalTypeEventFilter.check_lower(filter)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_events(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeEventFilter.lower(filter),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeEventPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def execute_tx(self, signatures: "typing.List[UserSignature]",tx: "Transaction",wait_for: "typing.Union[object, typing.Optional[WaitForTx]]" = _DEFAULT) -> "TransactionEffects":
        """
        Execute a transaction.
        """

        _UniffiConverterSequenceTypeUserSignature.check_lower(signatures)
        
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        if wait_for is _DEFAULT:
            wait_for = None
        _UniffiConverterOptionalTypeWaitForTx.check_lower(wait_for)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_execute_tx(
                self._uniffi_clone_pointer(), 
        _UniffiConverterSequenceTypeUserSignature.lower(signatures),
        _UniffiConverterTypeTransaction.lower(tx),
        _UniffiConverterOptionalTypeWaitForTx.lower(wait_for)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_pointer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_pointer,
            # lift function
            _UniffiConverterTypeTransactionEffects.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def gas_coins(self, owner: "Address",pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "CoinPage":
        """
        Get the list of gas coins for the specified address.
        """

        _UniffiConverterTypeAddress.check_lower(owner)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_gas_coins(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(owner),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeCoinPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def iota_names_default_name(self, address: "Address",format: "typing.Optional[NameFormat]") -> "typing.Optional[Name]":
        """
        Get the default name pointing to this address, if one exists.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterOptionalTypeNameFormat.check_lower(format)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_default_name(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterOptionalTypeNameFormat.lower(format)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeName.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def iota_names_lookup(self, name: "str") -> "typing.Optional[Address]":
        """
        Return the resolved address for the given name.
        """

        _UniffiConverterString.check_lower(name)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_lookup(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(name)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeAddress.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def iota_names_registrations(self, address: "Address",pagination_filter: "PaginationFilter") -> "NameRegistrationPage":
        """
        Find all registration NFTs for the given address.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_iota_names_registrations(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeNameRegistrationPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def is_tx_finalized(self, digest: "Digest") -> "bool":
        """
        Returns whether the transaction for the given digest has been included
        in a checkpoint (finalized).
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_finalized(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def is_tx_indexed_on_node(self, digest: "Digest") -> "bool":
        """
        Returns whether the transaction for the given digest has been indexed
        on the node. This means that it can be queries by its digest and its
        effects will be usable for subsequent transactions. To check for
        full finalization, use `is_tx_finalized`.
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_is_tx_indexed_on_node(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i8,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i8,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i8,
            # lift function
            _UniffiConverterBool.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def latest_checkpoint_sequence_number(self, ) -> "typing.Optional[int]":
        """
        Return the sequence number of the latest checkpoint that has been
        executed.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_latest_checkpoint_sequence_number(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def max_page_size(self, ) -> "int":
        """
        Lazily fetch the max page size
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_max_page_size(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_i32,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_i32,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_i32,
            # lift function
            _UniffiConverterInt32.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def move_object_contents(self, object_id: "ObjectId",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[Value]":
        """
        Return the contents' JSON of an object that is a Move object.

        If the object does not exist (e.g., due to pruning), this will return
        `Ok(None)`. Similarly, if this is not an object but an address, it
        will return `Ok(None)`.
        """

        _UniffiConverterTypeObjectId.check_lower(object_id)
        
        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeObjectId.lower(object_id),
        _UniffiConverterOptionalUInt64.lower(version)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeValue.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def move_object_contents_bcs(self, object_id: "ObjectId",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[bytes]":
        """
        Return the BCS of an object that is a Move object.

        If the object does not exist (e.g., due to pruning), this will return
        `Ok(None)`. Similarly, if this is not an object but an address, it
        will return `Ok(None)`.
        """

        _UniffiConverterTypeObjectId.check_lower(object_id)
        
        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_move_object_contents_bcs(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeObjectId.lower(object_id),
        _UniffiConverterOptionalUInt64.lower(version)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def normalized_move_function(self, package: "Address",module: "str",function: "str",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[MoveFunction]":
        """
        Return the normalized Move function data for the provided package,
        module, and function.
        """

        _UniffiConverterTypeAddress.check_lower(package)
        
        _UniffiConverterString.check_lower(module)
        
        _UniffiConverterString.check_lower(function)
        
        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_function(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(package),
        _UniffiConverterString.lower(module),
        _UniffiConverterString.lower(function),
        _UniffiConverterOptionalUInt64.lower(version)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeMoveFunction.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def normalized_move_module(self, package: "Address",module: "str",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter_enums: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,pagination_filter_friends: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,pagination_filter_functions: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT,pagination_filter_structs: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "typing.Optional[MoveModule]":
        """
        Return the normalized Move module data for the provided module.
        """

        _UniffiConverterTypeAddress.check_lower(package)
        
        _UniffiConverterString.check_lower(module)
        
        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        if pagination_filter_enums is _DEFAULT:
            pagination_filter_enums = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter_enums)
        
        if pagination_filter_friends is _DEFAULT:
            pagination_filter_friends = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter_friends)
        
        if pagination_filter_functions is _DEFAULT:
            pagination_filter_functions = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter_functions)
        
        if pagination_filter_structs is _DEFAULT:
            pagination_filter_structs = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter_structs)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_normalized_move_module(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(package),
        _UniffiConverterString.lower(module),
        _UniffiConverterOptionalUInt64.lower(version),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter_enums),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter_friends),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter_functions),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter_structs)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeMoveModule.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def object(self, object_id: "ObjectId",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[Object]":
        """
        Return an object based on the provided `Address`.

        If the object does not exist (e.g., due to pruning), this will return
        `Ok(None)`. Similarly, if this is not an object but an address, it
        will return `Ok(None)`.
        """

        _UniffiConverterTypeObjectId.check_lower(object_id)
        
        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeObjectId.lower(object_id),
        _UniffiConverterOptionalUInt64.lower(version)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeObject.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def object_bcs(self, object_id: "ObjectId") -> "typing.Optional[bytes]":
        """
        Return the object's bcs content `Vec<u8>` based on the provided
        `Address`.
        """

        _UniffiConverterTypeObjectId.check_lower(object_id)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_object_bcs(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeObjectId.lower(object_id)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalBytes.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def objects(self, filter: "typing.Union[object, typing.Optional[ObjectFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "ObjectPage":
        """
        Return a page of objects based on the provided parameters.

        Use this function together with the `ObjectFilter::owner` to get the
        objects owned by an address.
        """

        if filter is _DEFAULT:
            filter = None
        _UniffiConverterOptionalTypeObjectFilter.check_lower(filter)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_objects(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeObjectFilter.lower(filter),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeObjectPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def package(self, address: "Address",version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[MovePackage]":
        """
        The package corresponding to the given address (at the optionally given
        version). When no version is given, the package is loaded directly
        from the address given. Otherwise, the address is translated before
        loading to point to the package whose original ID matches
        the package at address, but whose version is version. For non-system
        packages, this might result in a different address than address
        because different versions of a package, introduced by upgrades,
        exist at distinct addresses.

        Note that this interpretation of version is different from a historical
        object read (the interpretation of version for the object query).
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterOptionalUInt64.lower(version)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeMovePackage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def package_latest(self, address: "Address") -> "typing.Optional[MovePackage]":
        """
        Fetch the latest version of the package at address.
        This corresponds to the package with the highest version that shares its
        original ID with the package at address.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_latest(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeMovePackage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def package_versions(self, address: "Address",after_version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,before_version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "MovePackagePage":
        """
        Fetch all versions of package at address (packages that share this
        package's original ID), optionally bounding the versions exclusively
        from below with afterVersion, or from above with beforeVersion.
        """

        _UniffiConverterTypeAddress.check_lower(address)
        
        if after_version is _DEFAULT:
            after_version = None
        _UniffiConverterOptionalUInt64.check_lower(after_version)
        
        if before_version is _DEFAULT:
            before_version = None
        _UniffiConverterOptionalUInt64.check_lower(before_version)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_package_versions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterOptionalUInt64.lower(after_version),
        _UniffiConverterOptionalUInt64.lower(before_version),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeMovePackagePage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def packages(self, after_checkpoint: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,before_checkpoint: "typing.Union[object, typing.Optional[int]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "MovePackagePage":
        """
        The Move packages that exist in the network, optionally filtered to be
        strictly before beforeCheckpoint and/or strictly after
        afterCheckpoint.

        This query returns all versions of a given user package that appear
        between the specified checkpoints, but only records the latest
        versions of system packages.
        """

        if after_checkpoint is _DEFAULT:
            after_checkpoint = None
        _UniffiConverterOptionalUInt64.check_lower(after_checkpoint)
        
        if before_checkpoint is _DEFAULT:
            before_checkpoint = None
        _UniffiConverterOptionalUInt64.check_lower(before_checkpoint)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_packages(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(after_checkpoint),
        _UniffiConverterOptionalUInt64.lower(before_checkpoint),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeMovePackagePage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def protocol_config(self, version: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "ProtocolConfigs":
        """
        Get the protocol configuration.
        """

        if version is _DEFAULT:
            version = None
        _UniffiConverterOptionalUInt64.check_lower(version)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_protocol_config(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(version)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeProtocolConfigs.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def reference_gas_price(self, epoch: "typing.Union[object, typing.Optional[int]]" = _DEFAULT) -> "typing.Optional[int]":
        """
        Get the reference gas price for the provided epoch or the last known one
        if no epoch is provided.

        This will return `Ok(None)` if the epoch requested is not available in
        the GraphQL service (e.g., due to pruning).
        """

        if epoch is _DEFAULT:
            epoch = None
        _UniffiConverterOptionalUInt64.check_lower(epoch)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_reference_gas_price(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalUInt64.lower(epoch)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def run_query(self, query: "Query") -> "Value":
        """
        Run a query.
        """

        _UniffiConverterTypeQuery.check_lower(query)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_run_query(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeQuery.lower(query)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeValue.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def service_config(self, ) -> "ServiceConfig":
        """
        Get the GraphQL service configuration, including complexity limits, read
        and mutation limits, supported versions, and others.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_service_config(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeServiceConfig.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def set_rpc_server(self, server: "str") -> None:

        """
        Set the server address for the GraphQL GraphQL client. It should be a
        valid URL with a host and optionally a port number.
        """

        _UniffiConverterString.check_lower(server)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_set_rpc_server(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(server)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def total_supply(self, coin_type: "str") -> "typing.Optional[int]":
        """
        Get total supply for the coin type.
        """

        _UniffiConverterString.check_lower(coin_type)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_supply(
                self._uniffi_clone_pointer(), 
        _UniffiConverterString.lower(coin_type)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def total_transaction_blocks(self, ) -> "typing.Optional[int]":
        """
        The total number of transaction blocks in the network by the end of the
        last known checkpoint.
        """

        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks(
                self._uniffi_clone_pointer(), 
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def total_transaction_blocks_by_digest(self, digest: "Digest") -> "typing.Optional[int]":
        """
        The total number of transaction blocks in the network by the end of the
        provided checkpoint digest.
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_digest(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def total_transaction_blocks_by_seq_num(self, seq_num: "int") -> "typing.Optional[int]":
        """
        The total number of transaction blocks in the network by the end of the
        provided checkpoint sequence number.
        """

        _UniffiConverterUInt64.check_lower(seq_num)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_total_transaction_blocks_by_seq_num(
                self._uniffi_clone_pointer(), 
        _UniffiConverterUInt64.lower(seq_num)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalUInt64.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def transaction(self, digest: "Digest") -> "typing.Optional[SignedTransaction]":
        """
        Get a transaction by its digest.
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeSignedTransaction.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def transaction_data_effects(self, digest: "Digest") -> "typing.Optional[TransactionDataEffects]":
        """
        Get a transaction's data and effects by its digest.
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_data_effects(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeTransactionDataEffects.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def transaction_effects(self, digest: "Digest") -> "typing.Optional[TransactionEffects]":
        """
        Get a transaction's effects by its digest.
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transaction_effects(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterOptionalTypeTransactionEffects.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def transactions(self, filter: "typing.Union[object, typing.Optional[TransactionsFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "SignedTransactionPage":
        """
        Get a page of transactions based on the provided filters.
        """

        if filter is _DEFAULT:
            filter = None
        _UniffiConverterOptionalTypeTransactionsFilter.check_lower(filter)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeTransactionsFilter.lower(filter),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeSignedTransactionPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def transactions_data_effects(self, filter: "typing.Union[object, typing.Optional[TransactionsFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "TransactionDataEffectsPage":
        """
        Get a page of transactions' data and effects based on the provided
        filters.
        """

        if filter is _DEFAULT:
            filter = None
        _UniffiConverterOptionalTypeTransactionsFilter.check_lower(filter)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_data_effects(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeTransactionsFilter.lower(filter),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionDataEffectsPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def transactions_effects(self, filter: "typing.Union[object, typing.Optional[TransactionsFilter]]" = _DEFAULT,pagination_filter: "typing.Union[object, typing.Optional[PaginationFilter]]" = _DEFAULT) -> "TransactionEffectsPage":
        """
        Get a page of transactions' effects based on the provided filters.
        """

        if filter is _DEFAULT:
            filter = None
        _UniffiConverterOptionalTypeTransactionsFilter.check_lower(filter)
        
        if pagination_filter is _DEFAULT:
            pagination_filter = None
        _UniffiConverterOptionalTypePaginationFilter.check_lower(pagination_filter)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_transactions_effects(
                self._uniffi_clone_pointer(), 
        _UniffiConverterOptionalTypeTransactionsFilter.lower(filter),
        _UniffiConverterOptionalTypePaginationFilter.lower(pagination_filter)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeTransactionEffectsPage.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )



    async def wait_for_tx(self, digest: "Digest",wait_for: "WaitForTx",timeout: "typing.Union[object, typing.Optional[Duration]]" = _DEFAULT) -> None:

        """
        Wait for the indexing or finalization of a transaction
        by its digest. An optional timeout can be provided, which, if
        exceeded, will return an error (default 60s).
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        _UniffiConverterTypeWaitForTx.check_lower(wait_for)
        
        if timeout is _DEFAULT:
            timeout = None
        _UniffiConverterOptionalDuration.check_lower(timeout)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_graphqlclient_wait_for_tx(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeDigest.lower(digest),
        _UniffiConverterTypeWaitForTx.lower(wait_for),
        _UniffiConverterOptionalDuration.lower(timeout)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_void,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_void,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_void,
            # lift function
            lambda val: None,
            
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )





class _UniffiConverterTypeGraphQlClient:

    @staticmethod
    def lift(value: int):
        return GraphQlClient._make_instance_(value)

    @staticmethod
    def check_lower(value: GraphQlClient):
        if not isinstance(value, GraphQlClient):
            raise TypeError("Expected GraphQlClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: GraphQlClientProtocol):
        if not isinstance(value, GraphQlClient):
            raise TypeError("Expected GraphQlClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: GraphQlClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class IdentifierProtocol(typing.Protocol):
    """
    A move identifier

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    identifier = %x01-80    ; length of the identifier
    (ALPHA *127(ALPHA / DIGIT / UNDERSCORE)) /
    (UNDERSCORE 1*127(ALPHA / DIGIT / UNDERSCORE))

    UNDERSCORE = %x95
    ```
    """

    def as_str(self, ):
        raise NotImplementedError
# Identifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class Identifier():
    """
    A move identifier

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    identifier = %x01-80    ; length of the identifier
    (ALPHA *127(ALPHA / DIGIT / UNDERSCORE)) /
    (UNDERSCORE 1*127(ALPHA / DIGIT / UNDERSCORE))

    UNDERSCORE = %x95
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, identifier: "str"):
        _UniffiConverterString.check_lower(identifier)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_identifier_new,
        _UniffiConverterString.lower(identifier))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_identifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_identifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_identifier_as_str,self._uniffi_clone_pointer(),)
        )





    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_identifier_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeIdentifier:

    @staticmethod
    def lift(value: int):
        return Identifier._make_instance_(value)

    @staticmethod
    def check_lower(value: Identifier):
        if not isinstance(value, Identifier):
            raise TypeError("Expected Identifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: IdentifierProtocol):
        if not isinstance(value, Identifier):
            raise TypeError("Expected Identifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: IdentifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class InputProtocol(typing.Protocol):
    """
    An input to a user transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    input = input-pure / input-immutable-or-owned / input-shared / input-receiving

    input-pure                  = %x00 bytes
    input-immutable-or-owned    = %x01 object-ref
    input-shared                = %x02 object-id u64 bool
    input-receiving             = %x04 object-ref
    ```
    """

    pass
# Input is a Rust-only trait - it's a wrapper around a Rust implementation.
class Input():
    """
    An input to a user transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    input = input-pure / input-immutable-or-owned / input-shared / input-receiving

    input-pure                  = %x00 bytes
    input-immutable-or-owned    = %x01 object-ref
    input-shared                = %x02 object-id u64 bool
    input-receiving             = %x04 object-ref
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_input, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_input, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_immutable_or_owned(cls, object_ref: "ObjectReference"):
        """
        A move object that is either immutable or address owned
        """

        _UniffiConverterTypeObjectReference.check_lower(object_ref)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_immutable_or_owned,
        _UniffiConverterTypeObjectReference.lower(object_ref))
        return cls._make_instance_(pointer)

    @classmethod
    def new_pure(cls, value: "bytes"):
        """
        For normal operations this is required to be a move primitive type and
        not contain structs or objects.
        """

        _UniffiConverterBytes.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_pure,
        _UniffiConverterBytes.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def new_receiving(cls, object_ref: "ObjectReference"):
        _UniffiConverterTypeObjectReference.check_lower(object_ref)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_receiving,
        _UniffiConverterTypeObjectReference.lower(object_ref))
        return cls._make_instance_(pointer)

    @classmethod
    def new_shared(cls, object_id: "ObjectId",initial_shared_version: "int",mutable: "bool"):
        """
        A move object whose owner is "Shared"
        """

        _UniffiConverterTypeObjectId.check_lower(object_id)
        
        _UniffiConverterUInt64.check_lower(initial_shared_version)
        
        _UniffiConverterBool.check_lower(mutable)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_input_new_shared,
        _UniffiConverterTypeObjectId.lower(object_id),
        _UniffiConverterUInt64.lower(initial_shared_version),
        _UniffiConverterBool.lower(mutable))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeInput:

    @staticmethod
    def lift(value: int):
        return Input._make_instance_(value)

    @staticmethod
    def check_lower(value: Input):
        if not isinstance(value, Input):
            raise TypeError("Expected Input instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: InputProtocol):
        if not isinstance(value, Input):
            raise TypeError("Expected Input instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: InputProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MakeMoveVectorProtocol(typing.Protocol):
    """
    Command to build a move vector out of a set of individual elements

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    make-move-vector = (option type-tag) (vector argument)
    ```
    """

    def elements(self, ):
        """
        The set individual elements to build the vector with
        """

        raise NotImplementedError
    def type_tag(self, ):
        """
        Type of the individual elements

        This is required to be set when the type can't be inferred, for example
        when the set of provided arguments are all pure input values.
        """

        raise NotImplementedError
# MakeMoveVector is a Rust-only trait - it's a wrapper around a Rust implementation.
class MakeMoveVector():
    """
    Command to build a move vector out of a set of individual elements

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    make-move-vector = (option type-tag) (vector argument)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, type_tag: "typing.Optional[TypeTag]",elements: "typing.List[Argument]"):
        _UniffiConverterOptionalTypeTypeTag.check_lower(type_tag)
        
        _UniffiConverterSequenceTypeArgument.check_lower(elements)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_makemovevector_new,
        _UniffiConverterOptionalTypeTypeTag.lower(type_tag),
        _UniffiConverterSequenceTypeArgument.lower(elements))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_makemovevector, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_makemovevector, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def elements(self, ) -> "typing.List[Argument]":
        """
        The set individual elements to build the vector with
        """

        return _UniffiConverterSequenceTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_makemovevector_elements,self._uniffi_clone_pointer(),)
        )





    def type_tag(self, ) -> "typing.Optional[TypeTag]":
        """
        Type of the individual elements

        This is required to be set when the type can't be inferred, for example
        when the set of provided arguments are all pure input values.
        """

        return _UniffiConverterOptionalTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_makemovevector_type_tag,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMakeMoveVector:

    @staticmethod
    def lift(value: int):
        return MakeMoveVector._make_instance_(value)

    @staticmethod
    def check_lower(value: MakeMoveVector):
        if not isinstance(value, MakeMoveVector):
            raise TypeError("Expected MakeMoveVector instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MakeMoveVectorProtocol):
        if not isinstance(value, MakeMoveVector):
            raise TypeError("Expected MakeMoveVector instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MakeMoveVectorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MergeCoinsProtocol(typing.Protocol):
    """
    Command to merge multiple coins of the same type into a single coin

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    merge-coins = argument (vector argument)
    ```
    """

    def coin(self, ):
        """
        Coin to merge coins into
        """

        raise NotImplementedError
    def coins_to_merge(self, ):
        """
        Set of coins to merge into `coin`

        All listed coins must be of the same type and be the same type as `coin`
        """

        raise NotImplementedError
# MergeCoins is a Rust-only trait - it's a wrapper around a Rust implementation.
class MergeCoins():
    """
    Command to merge multiple coins of the same type into a single coin

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    merge-coins = argument (vector argument)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, coin: "Argument",coins_to_merge: "typing.List[Argument]"):
        _UniffiConverterTypeArgument.check_lower(coin)
        
        _UniffiConverterSequenceTypeArgument.check_lower(coins_to_merge)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_mergecoins_new,
        _UniffiConverterTypeArgument.lower(coin),
        _UniffiConverterSequenceTypeArgument.lower(coins_to_merge))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_mergecoins, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_mergecoins, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def coin(self, ) -> "Argument":
        """
        Coin to merge coins into
        """

        return _UniffiConverterTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_mergecoins_coin,self._uniffi_clone_pointer(),)
        )





    def coins_to_merge(self, ) -> "typing.List[Argument]":
        """
        Set of coins to merge into `coin`

        All listed coins must be of the same type and be the same type as `coin`
        """

        return _UniffiConverterSequenceTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_mergecoins_coins_to_merge,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMergeCoins:

    @staticmethod
    def lift(value: int):
        return MergeCoins._make_instance_(value)

    @staticmethod
    def check_lower(value: MergeCoins):
        if not isinstance(value, MergeCoins):
            raise TypeError("Expected MergeCoins instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MergeCoinsProtocol):
        if not isinstance(value, MergeCoins):
            raise TypeError("Expected MergeCoins instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MergeCoinsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MoveArgProtocol(typing.Protocol):
    pass
# MoveArg is a Rust-only trait - it's a wrapper around a Rust implementation.
class MoveArg():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movearg, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movearg, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def address(cls, address: "Address"):
        _UniffiConverterTypeAddress.check_lower(address)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address,
        _UniffiConverterTypeAddress.lower(address))
        return cls._make_instance_(pointer)

    @classmethod
    def address_from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def address_vec(cls, addresses: "typing.List[Address]"):
        _UniffiConverterSequenceTypeAddress.check_lower(addresses)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec,
        _UniffiConverterSequenceTypeAddress.lower(addresses))
        return cls._make_instance_(pointer)

    @classmethod
    def address_vec_from_hex(cls, addresses: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(addresses)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_address_vec_from_hex,
        _UniffiConverterSequenceString.lower(addresses))
        return cls._make_instance_(pointer)

    @classmethod
    def bool(cls, value: "bool"):
        _UniffiConverterBool.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool,
        _UniffiConverterBool.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def bool_vec(cls, values: "typing.List[bool]"):
        _UniffiConverterSequenceBool.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_bool_vec,
        _UniffiConverterSequenceBool.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def digest(cls, digest: "Digest"):
        _UniffiConverterTypeDigest.check_lower(digest)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest,
        _UniffiConverterTypeDigest.lower(digest))
        return cls._make_instance_(pointer)

    @classmethod
    def digest_from_base58(cls, base58: "str"):
        _UniffiConverterString.check_lower(base58)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_from_base58,
        _UniffiConverterString.lower(base58))
        return cls._make_instance_(pointer)

    @classmethod
    def digest_vec(cls, digests: "typing.List[Digest]"):
        _UniffiConverterSequenceTypeDigest.check_lower(digests)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec,
        _UniffiConverterSequenceTypeDigest.lower(digests))
        return cls._make_instance_(pointer)

    @classmethod
    def digest_vec_from_base58(cls, digests: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(digests)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_digest_vec_from_base58,
        _UniffiConverterSequenceString.lower(digests))
        return cls._make_instance_(pointer)

    @classmethod
    def option(cls, value: "typing.Optional[MoveArg]"):
        _UniffiConverterOptionalTypeMoveArg.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_option,
        _UniffiConverterOptionalTypeMoveArg.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def string(cls, string: "str"):
        _UniffiConverterString.check_lower(string)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_string,
        _UniffiConverterString.lower(string))
        return cls._make_instance_(pointer)

    @classmethod
    def string_vec(cls, addresses: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(addresses)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_string_vec,
        _UniffiConverterSequenceString.lower(addresses))
        return cls._make_instance_(pointer)

    @classmethod
    def u128(cls, value: "str"):
        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u128_vec(cls, values: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u128_vec,
        _UniffiConverterSequenceString.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u16(cls, value: "int"):
        _UniffiConverterUInt16.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16,
        _UniffiConverterUInt16.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u16_vec(cls, values: "typing.List[int]"):
        _UniffiConverterSequenceUInt16.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u16_vec,
        _UniffiConverterSequenceUInt16.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u256(cls, value: "str"):
        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u256_vec(cls, values: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u256_vec,
        _UniffiConverterSequenceString.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u32(cls, value: "int"):
        _UniffiConverterUInt32.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32,
        _UniffiConverterUInt32.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u32_vec(cls, values: "typing.List[int]"):
        _UniffiConverterSequenceUInt32.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u32_vec,
        _UniffiConverterSequenceUInt32.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u64(cls, value: "int"):
        _UniffiConverterUInt64.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64,
        _UniffiConverterUInt64.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u64_vec(cls, values: "typing.List[int]"):
        _UniffiConverterSequenceUInt64.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u64_vec,
        _UniffiConverterSequenceUInt64.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u8(cls, value: "int"):
        _UniffiConverterUInt8.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8,
        _UniffiConverterUInt8.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u8_vec(cls, values: "bytes"):
        _UniffiConverterBytes.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movearg_u8_vec,
        _UniffiConverterBytes.lower(values))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeMoveArg:

    @staticmethod
    def lift(value: int):
        return MoveArg._make_instance_(value)

    @staticmethod
    def check_lower(value: MoveArg):
        if not isinstance(value, MoveArg):
            raise TypeError("Expected MoveArg instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MoveArgProtocol):
        if not isinstance(value, MoveArg):
            raise TypeError("Expected MoveArg instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MoveArgProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MoveCallProtocol(typing.Protocol):
    """
    Command to call a move function

    Functions that can be called by a `MoveCall` command are those that have a
    function signature that is either `entry` or `public` (which don't have a
    reference return type).

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    move-call = object-id           ; package id
    identifier          ; module name
    identifier          ; function name
    (vector type-tag)   ; type arguments, if any
    (vector argument)   ; input arguments
    ```
    """

    def arguments(self, ):
        """
        The arguments to the function.
        """

        raise NotImplementedError
    def function(self, ):
        """
        The function to be called.
        """

        raise NotImplementedError
    def module(self, ):
        """
        The specific module in the package containing the function.
        """

        raise NotImplementedError
    def package(self, ):
        """
        The package containing the module and function.
        """

        raise NotImplementedError
    def type_arguments(self, ):
        """
        The type arguments to the function.
        """

        raise NotImplementedError
# MoveCall is a Rust-only trait - it's a wrapper around a Rust implementation.
class MoveCall():
    """
    Command to call a move function

    Functions that can be called by a `MoveCall` command are those that have a
    function signature that is either `entry` or `public` (which don't have a
    reference return type).

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    move-call = object-id           ; package id
    identifier          ; module name
    identifier          ; function name
    (vector type-tag)   ; type arguments, if any
    (vector argument)   ; input arguments
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, package: "ObjectId",module: "Identifier",function: "Identifier",type_arguments: "typing.List[TypeTag]",arguments: "typing.List[Argument]"):
        _UniffiConverterTypeObjectId.check_lower(package)
        
        _UniffiConverterTypeIdentifier.check_lower(module)
        
        _UniffiConverterTypeIdentifier.check_lower(function)
        
        _UniffiConverterSequenceTypeTypeTag.check_lower(type_arguments)
        
        _UniffiConverterSequenceTypeArgument.check_lower(arguments)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movecall_new,
        _UniffiConverterTypeObjectId.lower(package),
        _UniffiConverterTypeIdentifier.lower(module),
        _UniffiConverterTypeIdentifier.lower(function),
        _UniffiConverterSequenceTypeTypeTag.lower(type_arguments),
        _UniffiConverterSequenceTypeArgument.lower(arguments))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movecall, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movecall, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def arguments(self, ) -> "typing.List[Argument]":
        """
        The arguments to the function.
        """

        return _UniffiConverterSequenceTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_arguments,self._uniffi_clone_pointer(),)
        )





    def function(self, ) -> "Identifier":
        """
        The function to be called.
        """

        return _UniffiConverterTypeIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_function,self._uniffi_clone_pointer(),)
        )





    def module(self, ) -> "Identifier":
        """
        The specific module in the package containing the function.
        """

        return _UniffiConverterTypeIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_module,self._uniffi_clone_pointer(),)
        )





    def package(self, ) -> "ObjectId":
        """
        The package containing the module and function.
        """

        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_package,self._uniffi_clone_pointer(),)
        )





    def type_arguments(self, ) -> "typing.List[TypeTag]":
        """
        The type arguments to the function.
        """

        return _UniffiConverterSequenceTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movecall_type_arguments,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMoveCall:

    @staticmethod
    def lift(value: int):
        return MoveCall._make_instance_(value)

    @staticmethod
    def check_lower(value: MoveCall):
        if not isinstance(value, MoveCall):
            raise TypeError("Expected MoveCall instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MoveCallProtocol):
        if not isinstance(value, MoveCall):
            raise TypeError("Expected MoveCall instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MoveCallProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MoveFunctionProtocol(typing.Protocol):
    def is_entry(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def parameters(self, ):
        raise NotImplementedError
    def return_type(self, ):
        raise NotImplementedError
    def type_parameters(self, ):
        raise NotImplementedError
    def visibility(self, ):
        raise NotImplementedError
# MoveFunction is a Rust-only trait - it's a wrapper around a Rust implementation.
class MoveFunction():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movefunction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movefunction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def is_entry(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_is_entry,self._uniffi_clone_pointer(),)
        )





    def name(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_name,self._uniffi_clone_pointer(),)
        )





    def parameters(self, ) -> "typing.Optional[typing.List[OpenMoveType]]":
        return _UniffiConverterOptionalSequenceTypeOpenMoveType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_parameters,self._uniffi_clone_pointer(),)
        )





    def return_type(self, ) -> "typing.Optional[typing.List[OpenMoveType]]":
        return _UniffiConverterOptionalSequenceTypeOpenMoveType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_return_type,self._uniffi_clone_pointer(),)
        )





    def type_parameters(self, ) -> "typing.Optional[typing.List[MoveFunctionTypeParameter]]":
        return _UniffiConverterOptionalSequenceTypeMoveFunctionTypeParameter.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_type_parameters,self._uniffi_clone_pointer(),)
        )





    def visibility(self, ) -> "typing.Optional[MoveVisibility]":
        return _UniffiConverterOptionalTypeMoveVisibility.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_visibility,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movefunction_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMoveFunction:

    @staticmethod
    def lift(value: int):
        return MoveFunction._make_instance_(value)

    @staticmethod
    def check_lower(value: MoveFunction):
        if not isinstance(value, MoveFunction):
            raise TypeError("Expected MoveFunction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MoveFunctionProtocol):
        if not isinstance(value, MoveFunction):
            raise TypeError("Expected MoveFunction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MoveFunctionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MovePackageProtocol(typing.Protocol):
    """
    A move package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-move-package = object-id u64 move-modules type-origin-table linkage-table

    move-modules = map (identifier bytes)
    type-origin-table = vector type-origin
    linkage-table = map (object-id upgrade-info)
    ```
    """

    def id(self, ):
        raise NotImplementedError
    def linkage_table(self, ):
        raise NotImplementedError
    def modules(self, ):
        raise NotImplementedError
    def type_origin_table(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
# MovePackage is a Rust-only trait - it's a wrapper around a Rust implementation.
class MovePackage():
    """
    A move package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-move-package = object-id u64 move-modules type-origin-table linkage-table

    move-modules = map (identifier bytes)
    type-origin-table = vector type-origin
    linkage-table = map (object-id upgrade-info)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, id: "ObjectId",version: "int",modules: "dict[Identifier, bytes]",type_origin_table: "typing.List[TypeOrigin]",linkage_table: "dict[ObjectId, UpgradeInfo]"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        _UniffiConverterUInt64.check_lower(version)
        
        _UniffiConverterMapTypeIdentifierBytes.check_lower(modules)
        
        _UniffiConverterSequenceTypeTypeOrigin.check_lower(type_origin_table)
        
        _UniffiConverterMapTypeObjectIdTypeUpgradeInfo.check_lower(linkage_table)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackage_new,
        _UniffiConverterTypeObjectId.lower(id),
        _UniffiConverterUInt64.lower(version),
        _UniffiConverterMapTypeIdentifierBytes.lower(modules),
        _UniffiConverterSequenceTypeTypeOrigin.lower(type_origin_table),
        _UniffiConverterMapTypeObjectIdTypeUpgradeInfo.lower(linkage_table))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movepackage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movepackage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def id(self, ) -> "ObjectId":
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_id,self._uniffi_clone_pointer(),)
        )





    def linkage_table(self, ) -> "dict[ObjectId, UpgradeInfo]":
        return _UniffiConverterMapTypeObjectIdTypeUpgradeInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_linkage_table,self._uniffi_clone_pointer(),)
        )





    def modules(self, ) -> "dict[Identifier, bytes]":
        return _UniffiConverterMapTypeIdentifierBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_modules,self._uniffi_clone_pointer(),)
        )





    def type_origin_table(self, ) -> "typing.List[TypeOrigin]":
        return _UniffiConverterSequenceTypeTypeOrigin.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_type_origin_table,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackage_version,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMovePackage:

    @staticmethod
    def lift(value: int):
        return MovePackage._make_instance_(value)

    @staticmethod
    def check_lower(value: MovePackage):
        if not isinstance(value, MovePackage):
            raise TypeError("Expected MovePackage instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MovePackageProtocol):
        if not isinstance(value, MovePackage):
            raise TypeError("Expected MovePackage instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MovePackageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MovePackageDataProtocol(typing.Protocol):
    """
    Type corresponding to the output of `iota move build
    --dump-bytecode-as-base64`
    """

    def dependencies(self, ):
        """
        Returns the package dependencies.
        """

        raise NotImplementedError
    def digest(self, ):
        """
        Returns the package digest.
        """

        raise NotImplementedError
    def modules(self, ):
        """
        Returns the package modules.
        """

        raise NotImplementedError
    def to_base64(self, ):
        raise NotImplementedError
    def to_json(self, ):
        raise NotImplementedError
# MovePackageData is a Rust-only trait - it's a wrapper around a Rust implementation.
class MovePackageData():
    """
    Type corresponding to the output of `iota move build
    --dump-bytecode-as-base64`
    """

    _pointer: ctypes.c_void_p
    def __init__(self, modules: "typing.List[bytes]",dependencies: "typing.List[ObjectId]"):
        _UniffiConverterSequenceBytes.check_lower(modules)
        
        _UniffiConverterSequenceTypeObjectId.check_lower(dependencies)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_new,
        _UniffiConverterSequenceBytes.lower(modules),
        _UniffiConverterSequenceTypeObjectId.lower(dependencies))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_movepackagedata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_movepackagedata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_base64(cls, base64: "str"):
        _UniffiConverterString.check_lower(base64)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_base64,
        _UniffiConverterString.lower(base64))
        return cls._make_instance_(pointer)

    @classmethod
    def from_json(cls, json: "str"):
        _UniffiConverterString.check_lower(json)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_movepackagedata_from_json,
        _UniffiConverterString.lower(json))
        return cls._make_instance_(pointer)



    def dependencies(self, ) -> "typing.List[ObjectId]":
        """
        Returns the package dependencies.
        """

        return _UniffiConverterSequenceTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_dependencies,self._uniffi_clone_pointer(),)
        )





    def digest(self, ) -> "Digest":
        """
        Returns the package digest.
        """

        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_digest,self._uniffi_clone_pointer(),)
        )





    def modules(self, ) -> "typing.List[bytes]":
        """
        Returns the package modules.
        """

        return _UniffiConverterSequenceBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_modules,self._uniffi_clone_pointer(),)
        )





    def to_base64(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_base64,self._uniffi_clone_pointer(),)
        )





    def to_json(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_movepackagedata_to_json,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMovePackageData:

    @staticmethod
    def lift(value: int):
        return MovePackageData._make_instance_(value)

    @staticmethod
    def check_lower(value: MovePackageData):
        if not isinstance(value, MovePackageData):
            raise TypeError("Expected MovePackageData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MovePackageDataProtocol):
        if not isinstance(value, MovePackageData):
            raise TypeError("Expected MovePackageData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MovePackageDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigAggregatedSignatureProtocol(typing.Protocol):
    """
    Aggregated signature from members of a multisig committee.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-aggregated-signature = (vector multisig-member-signature)
    u16     ; bitmap
    multisig-committee
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-aggregated-signature = (vector multisig-member-signature)
    roaring-bitmap   ; bitmap
    legacy-multisig-committee
    roaring-bitmap = bytes  ; where the contents of the bytes are valid
    ; according to the serialized spec for
    ; roaring bitmaps
    ```

    See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
    serialized format of RoaringBitmaps.
    """

    def bitmap(self, ):
        """
        The bitmap that indicates which committee members provided their
        signature.
        """

        raise NotImplementedError
    def committee(self, ):
        raise NotImplementedError
    def signatures(self, ):
        """
        The list of signatures from committee members
        """

        raise NotImplementedError
# MultisigAggregatedSignature is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigAggregatedSignature():
    """
    Aggregated signature from members of a multisig committee.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-aggregated-signature = (vector multisig-member-signature)
    u16     ; bitmap
    multisig-committee
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-aggregated-signature = (vector multisig-member-signature)
    roaring-bitmap   ; bitmap
    legacy-multisig-committee
    roaring-bitmap = bytes  ; where the contents of the bytes are valid
    ; according to the serialized spec for
    ; roaring bitmaps
    ```

    See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
    serialized format of RoaringBitmaps.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, committee: "MultisigCommittee",signatures: "typing.List[MultisigMemberSignature]",bitmap: "int"):
        """
        Construct a new aggregated multisig signature.

        Since the list of signatures doesn't contain sufficient information to
        identify which committee member provided the signature, it is up to
        the caller to ensure that the provided signature list is in the same
        order as it's corresponding member in the provided committee
        and that it's position in the provided bitmap is set.
        """

        _UniffiConverterTypeMultisigCommittee.check_lower(committee)
        
        _UniffiConverterSequenceTypeMultisigMemberSignature.check_lower(signatures)
        
        _UniffiConverterUInt16.check_lower(bitmap)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregatedsignature_new,
        _UniffiConverterTypeMultisigCommittee.lower(committee),
        _UniffiConverterSequenceTypeMultisigMemberSignature.lower(signatures),
        _UniffiConverterUInt16.lower(bitmap))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigaggregatedsignature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigaggregatedsignature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def bitmap(self, ) -> "int":
        """
        The bitmap that indicates which committee members provided their
        signature.
        """

        return _UniffiConverterUInt16.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_bitmap,self._uniffi_clone_pointer(),)
        )





    def committee(self, ) -> "MultisigCommittee":
        return _UniffiConverterTypeMultisigCommittee.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_committee,self._uniffi_clone_pointer(),)
        )





    def signatures(self, ) -> "typing.List[MultisigMemberSignature]":
        """
        The list of signatures from committee members
        """

        return _UniffiConverterSequenceTypeMultisigMemberSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregatedsignature_signatures,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMultisigAggregatedSignature:

    @staticmethod
    def lift(value: int):
        return MultisigAggregatedSignature._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigAggregatedSignature):
        if not isinstance(value, MultisigAggregatedSignature):
            raise TypeError("Expected MultisigAggregatedSignature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigAggregatedSignatureProtocol):
        if not isinstance(value, MultisigAggregatedSignature):
            raise TypeError("Expected MultisigAggregatedSignature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigAggregatedSignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigAggregatorProtocol(typing.Protocol):
    def finish(self, ):
        raise NotImplementedError
    def verifier(self, ):
        raise NotImplementedError
    def with_signature(self, signature: "UserSignature"):
        raise NotImplementedError
    def with_verifier(self, verifier: "MultisigVerifier"):
        raise NotImplementedError
# MultisigAggregator is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigAggregator():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigaggregator, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigaggregator, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_with_message(cls, committee: "MultisigCommittee",message: "bytes"):
        _UniffiConverterTypeMultisigCommittee.check_lower(committee)
        
        _UniffiConverterBytes.check_lower(message)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_message,
        _UniffiConverterTypeMultisigCommittee.lower(committee),
        _UniffiConverterBytes.lower(message))
        return cls._make_instance_(pointer)

    @classmethod
    def new_with_transaction(cls, committee: "MultisigCommittee",transaction: "Transaction"):
        _UniffiConverterTypeMultisigCommittee.check_lower(committee)
        
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigaggregator_new_with_transaction,
        _UniffiConverterTypeMultisigCommittee.lower(committee),
        _UniffiConverterTypeTransaction.lower(transaction))
        return cls._make_instance_(pointer)



    def finish(self, ) -> "MultisigAggregatedSignature":
        return _UniffiConverterTypeMultisigAggregatedSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_finish,self._uniffi_clone_pointer(),)
        )





    def verifier(self, ) -> "MultisigVerifier":
        return _UniffiConverterTypeMultisigVerifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_verifier,self._uniffi_clone_pointer(),)
        )





    def with_signature(self, signature: "UserSignature") -> "MultisigAggregator":
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        return _UniffiConverterTypeMultisigAggregator.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_signature,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUserSignature.lower(signature))
        )





    def with_verifier(self, verifier: "MultisigVerifier") -> "MultisigAggregator":
        _UniffiConverterTypeMultisigVerifier.check_lower(verifier)
        
        return _UniffiConverterTypeMultisigAggregator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigaggregator_with_verifier,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMultisigVerifier.lower(verifier))
        )






class _UniffiConverterTypeMultisigAggregator:

    @staticmethod
    def lift(value: int):
        return MultisigAggregator._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigAggregator):
        if not isinstance(value, MultisigAggregator):
            raise TypeError("Expected MultisigAggregator instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigAggregatorProtocol):
        if not isinstance(value, MultisigAggregator):
            raise TypeError("Expected MultisigAggregator instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigAggregatorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigCommitteeProtocol(typing.Protocol):
    """
    A multisig committee

    A `MultisigCommittee` is a set of members who collectively control a single
    `Address` on the IOTA blockchain. The number of required signatures to
    authorize the execution of a transaction is determined by
    `(signature_0_weight + signature_1_weight ..) >= threshold`.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-committee = (vector multisig-member)
    u16    ; threshold
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-committee = (vector legacy-multisig-member)
    u16     ; threshold
    ```
    """

    def derive_address(self, ):
        """
        Derive an `Address` from this MultisigCommittee.

        A MultiSig address
        is defined as the 32-byte Blake2b hash of serializing the
        `SignatureScheme` flag (0x03), the threshold (in little endian), and
        the concatenation of all n flag, public keys and its weight.

        `hash(0x03 || threshold || flag_1 || pk_1 || weight_1
        || ... || flag_n || pk_n || weight_n)`.

        When flag_i is ZkLogin, the pk_i for the `ZkLoginPublicIdentifier`
        refers to the same input used when deriving the address using the
        `ZkLoginPublicIdentifier::derive_address_padded` method (using the
        full 32-byte `address_seed` value).
        """

        raise NotImplementedError
    def is_valid(self, ):
        """
        Checks if the Committee is valid.

        A valid committee is one that:
        - Has a nonzero threshold
        - Has at least one member
        - Has at most ten members
        - No member has weight 0
        - the sum of the weights of all members must be larger than the
        threshold
        - contains no duplicate members
        """

        raise NotImplementedError
    def members(self, ):
        """
        The members of the committee
        """

        raise NotImplementedError
    def scheme(self, ):
        """
        Return the flag for this signature scheme
        """

        raise NotImplementedError
    def threshold(self, ):
        """
        The total signature weight required to authorize a transaction for the
        address corresponding to this `MultisigCommittee`.
        """

        raise NotImplementedError
# MultisigCommittee is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigCommittee():
    """
    A multisig committee

    A `MultisigCommittee` is a set of members who collectively control a single
    `Address` on the IOTA blockchain. The number of required signatures to
    authorize the execution of a transaction is determined by
    `(signature_0_weight + signature_1_weight ..) >= threshold`.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-committee = (vector multisig-member)
    u16    ; threshold
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-committee = (vector legacy-multisig-member)
    u16     ; threshold
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, members: "typing.List[MultisigMember]",threshold: "int"):
        """
        Construct a new committee from a list of `MultisigMember`s and a
        `threshold`.

        Note that the order of the members is significant towards deriving the
        `Address` governed by this committee.
        """

        _UniffiConverterSequenceTypeMultisigMember.check_lower(members)
        
        _UniffiConverterUInt16.check_lower(threshold)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigcommittee_new,
        _UniffiConverterSequenceTypeMultisigMember.lower(members),
        _UniffiConverterUInt16.lower(threshold))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigcommittee, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigcommittee, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def derive_address(self, ) -> "Address":
        """
        Derive an `Address` from this MultisigCommittee.

        A MultiSig address
        is defined as the 32-byte Blake2b hash of serializing the
        `SignatureScheme` flag (0x03), the threshold (in little endian), and
        the concatenation of all n flag, public keys and its weight.

        `hash(0x03 || threshold || flag_1 || pk_1 || weight_1
        || ... || flag_n || pk_n || weight_n)`.

        When flag_i is ZkLogin, the pk_i for the `ZkLoginPublicIdentifier`
        refers to the same input used when deriving the address using the
        `ZkLoginPublicIdentifier::derive_address_padded` method (using the
        full 32-byte `address_seed` value).
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_derive_address,self._uniffi_clone_pointer(),)
        )





    def is_valid(self, ) -> "bool":
        """
        Checks if the Committee is valid.

        A valid committee is one that:
        - Has a nonzero threshold
        - Has at least one member
        - Has at most ten members
        - No member has weight 0
        - the sum of the weights of all members must be larger than the
        threshold
        - contains no duplicate members
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_is_valid,self._uniffi_clone_pointer(),)
        )





    def members(self, ) -> "typing.List[MultisigMember]":
        """
        The members of the committee
        """

        return _UniffiConverterSequenceTypeMultisigMember.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_members,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        """
        Return the flag for this signature scheme
        """

        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_scheme,self._uniffi_clone_pointer(),)
        )





    def threshold(self, ) -> "int":
        """
        The total signature weight required to authorize a transaction for the
        address corresponding to this `MultisigCommittee`.
        """

        return _UniffiConverterUInt16.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigcommittee_threshold,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMultisigCommittee:

    @staticmethod
    def lift(value: int):
        return MultisigCommittee._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigCommittee):
        if not isinstance(value, MultisigCommittee):
            raise TypeError("Expected MultisigCommittee instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigCommitteeProtocol):
        if not isinstance(value, MultisigCommittee):
            raise TypeError("Expected MultisigCommittee instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigCommitteeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigMemberProtocol(typing.Protocol):
    """
    A member in a multisig committee

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-member = multisig-member-public-key
    u8    ; weight
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-member = legacy-multisig-member-public-key
    u8     ; weight
    ```
    """

    def public_key(self, ):
        """
        This member's public key.
        """

        raise NotImplementedError
    def weight(self, ):
        """
        Weight of this member's signature.
        """

        raise NotImplementedError
# MultisigMember is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigMember():
    """
    A member in a multisig committee

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-member = multisig-member-public-key
    u8    ; weight
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-member = legacy-multisig-member-public-key
    u8     ; weight
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "MultisigMemberPublicKey",weight: "int"):
        """
        Construct a new member from a `MultisigMemberPublicKey` and a `weight`.
        """

        _UniffiConverterTypeMultisigMemberPublicKey.check_lower(public_key)
        
        _UniffiConverterUInt8.check_lower(weight)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigmember_new,
        _UniffiConverterTypeMultisigMemberPublicKey.lower(public_key),
        _UniffiConverterUInt8.lower(weight))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmember, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmember, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def public_key(self, ) -> "MultisigMemberPublicKey":
        """
        This member's public key.
        """

        return _UniffiConverterTypeMultisigMemberPublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmember_public_key,self._uniffi_clone_pointer(),)
        )





    def weight(self, ) -> "int":
        """
        Weight of this member's signature.
        """

        return _UniffiConverterUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmember_weight,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMultisigMember:

    @staticmethod
    def lift(value: int):
        return MultisigMember._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigMember):
        if not isinstance(value, MultisigMember):
            raise TypeError("Expected MultisigMember instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigMemberProtocol):
        if not isinstance(value, MultisigMember):
            raise TypeError("Expected MultisigMember instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigMemberProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigMemberPublicKeyProtocol(typing.Protocol):
    """
    Enum of valid public keys for multisig committee members

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-member-public-key = ed25519-multisig-member-public-key /
    secp256k1-multisig-member-public-key /
    secp256r1-multisig-member-public-key /
    zklogin-multisig-member-public-key

    ed25519-multisig-member-public-key   = %x00 ed25519-public-key
    secp256k1-multisig-member-public-key = %x01 secp256k1-public-key
    secp256r1-multisig-member-public-key = %x02 secp256r1-public-key
    zklogin-multisig-member-public-key   = %x03 zklogin-public-identifier
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-member-public-key = string ; which is valid base64 encoded
    ; and the decoded bytes are defined
    ; by legacy-public-key
    legacy-public-key = (ed25519-flag ed25519-public-key) /
    (secp256k1-flag secp256k1-public-key) /
    (secp256r1-flag secp256r1-public-key)
    ```
    """

    def as_ed25519(self, ):
        raise NotImplementedError
    def as_ed25519_opt(self, ):
        raise NotImplementedError
    def as_secp256k1(self, ):
        raise NotImplementedError
    def as_secp256k1_opt(self, ):
        raise NotImplementedError
    def as_secp256r1(self, ):
        raise NotImplementedError
    def as_secp256r1_opt(self, ):
        raise NotImplementedError
    def as_zklogin(self, ):
        raise NotImplementedError
    def as_zklogin_opt(self, ):
        raise NotImplementedError
    def is_ed25519(self, ):
        raise NotImplementedError
    def is_secp256k1(self, ):
        raise NotImplementedError
    def is_secp256r1(self, ):
        raise NotImplementedError
    def is_zklogin(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
# MultisigMemberPublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigMemberPublicKey():
    """
    Enum of valid public keys for multisig committee members

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-member-public-key = ed25519-multisig-member-public-key /
    secp256k1-multisig-member-public-key /
    secp256r1-multisig-member-public-key /
    zklogin-multisig-member-public-key

    ed25519-multisig-member-public-key   = %x00 ed25519-public-key
    secp256k1-multisig-member-public-key = %x01 secp256k1-public-key
    secp256r1-multisig-member-public-key = %x02 secp256r1-public-key
    zklogin-multisig-member-public-key   = %x03 zklogin-public-identifier
    ```

    There is also a legacy encoding for this type defined as:

    ```text
    legacy-multisig-member-public-key = string ; which is valid base64 encoded
    ; and the decoded bytes are defined
    ; by legacy-public-key
    legacy-public-key = (ed25519-flag ed25519-public-key) /
    (secp256k1-flag secp256k1-public-key) /
    (secp256r1-flag secp256r1-public-key)
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmemberpublickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmemberpublickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_ed25519(self, ) -> "Ed25519PublicKey":
        return _UniffiConverterTypeEd25519PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519,self._uniffi_clone_pointer(),)
        )





    def as_ed25519_opt(self, ) -> "typing.Optional[Ed25519PublicKey]":
        return _UniffiConverterOptionalTypeEd25519PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_ed25519_opt,self._uniffi_clone_pointer(),)
        )





    def as_secp256k1(self, ) -> "Secp256k1PublicKey":
        return _UniffiConverterTypeSecp256k1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1,self._uniffi_clone_pointer(),)
        )





    def as_secp256k1_opt(self, ) -> "typing.Optional[Secp256k1PublicKey]":
        return _UniffiConverterOptionalTypeSecp256k1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256k1_opt,self._uniffi_clone_pointer(),)
        )





    def as_secp256r1(self, ) -> "Secp256r1PublicKey":
        return _UniffiConverterTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1,self._uniffi_clone_pointer(),)
        )





    def as_secp256r1_opt(self, ) -> "typing.Optional[Secp256r1PublicKey]":
        return _UniffiConverterOptionalTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_secp256r1_opt,self._uniffi_clone_pointer(),)
        )





    def as_zklogin(self, ) -> "ZkLoginPublicIdentifier":
        return _UniffiConverterTypeZkLoginPublicIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin,self._uniffi_clone_pointer(),)
        )





    def as_zklogin_opt(self, ) -> "typing.Optional[ZkLoginPublicIdentifier]":
        return _UniffiConverterOptionalTypeZkLoginPublicIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_as_zklogin_opt,self._uniffi_clone_pointer(),)
        )





    def is_ed25519(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_ed25519,self._uniffi_clone_pointer(),)
        )





    def is_secp256k1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256k1,self._uniffi_clone_pointer(),)
        )





    def is_secp256r1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_secp256r1,self._uniffi_clone_pointer(),)
        )





    def is_zklogin(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_is_zklogin,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmemberpublickey_scheme,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMultisigMemberPublicKey:

    @staticmethod
    def lift(value: int):
        return MultisigMemberPublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigMemberPublicKey):
        if not isinstance(value, MultisigMemberPublicKey):
            raise TypeError("Expected MultisigMemberPublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigMemberPublicKeyProtocol):
        if not isinstance(value, MultisigMemberPublicKey):
            raise TypeError("Expected MultisigMemberPublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigMemberPublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigMemberSignatureProtocol(typing.Protocol):
    """
    A signature from a member of a multisig committee.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-member-signature = ed25519-multisig-member-signature /
    secp256k1-multisig-member-signature /
    secp256r1-multisig-member-signature /
    zklogin-multisig-member-signature

    ed25519-multisig-member-signature   = %x00 ed25519-signature
    secp256k1-multisig-member-signature = %x01 secp256k1-signature
    secp256r1-multisig-member-signature = %x02 secp256r1-signature
    zklogin-multisig-member-signature   = %x03 zklogin-authenticator
    ```
    """

    def as_ed25519(self, ):
        raise NotImplementedError
    def as_ed25519_opt(self, ):
        raise NotImplementedError
    def as_secp256k1(self, ):
        raise NotImplementedError
    def as_secp256k1_opt(self, ):
        raise NotImplementedError
    def as_secp256r1(self, ):
        raise NotImplementedError
    def as_secp256r1_opt(self, ):
        raise NotImplementedError
    def as_zklogin(self, ):
        raise NotImplementedError
    def as_zklogin_opt(self, ):
        raise NotImplementedError
    def is_ed25519(self, ):
        raise NotImplementedError
    def is_secp256k1(self, ):
        raise NotImplementedError
    def is_secp256r1(self, ):
        raise NotImplementedError
    def is_zklogin(self, ):
        raise NotImplementedError
# MultisigMemberSignature is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigMemberSignature():
    """
    A signature from a member of a multisig committee.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    multisig-member-signature = ed25519-multisig-member-signature /
    secp256k1-multisig-member-signature /
    secp256r1-multisig-member-signature /
    zklogin-multisig-member-signature

    ed25519-multisig-member-signature   = %x00 ed25519-signature
    secp256k1-multisig-member-signature = %x01 secp256k1-signature
    secp256r1-multisig-member-signature = %x02 secp256r1-signature
    zklogin-multisig-member-signature   = %x03 zklogin-authenticator
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigmembersignature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigmembersignature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_ed25519(self, ) -> "Ed25519Signature":
        return _UniffiConverterTypeEd25519Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519,self._uniffi_clone_pointer(),)
        )





    def as_ed25519_opt(self, ) -> "typing.Optional[Ed25519Signature]":
        return _UniffiConverterOptionalTypeEd25519Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_ed25519_opt,self._uniffi_clone_pointer(),)
        )





    def as_secp256k1(self, ) -> "Secp256k1Signature":
        return _UniffiConverterTypeSecp256k1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1,self._uniffi_clone_pointer(),)
        )





    def as_secp256k1_opt(self, ) -> "typing.Optional[Secp256k1Signature]":
        return _UniffiConverterOptionalTypeSecp256k1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256k1_opt,self._uniffi_clone_pointer(),)
        )





    def as_secp256r1(self, ) -> "Secp256r1Signature":
        return _UniffiConverterTypeSecp256r1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1,self._uniffi_clone_pointer(),)
        )





    def as_secp256r1_opt(self, ) -> "typing.Optional[Secp256r1Signature]":
        return _UniffiConverterOptionalTypeSecp256r1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_secp256r1_opt,self._uniffi_clone_pointer(),)
        )





    def as_zklogin(self, ) -> "ZkLoginAuthenticator":
        return _UniffiConverterTypeZkLoginAuthenticator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin,self._uniffi_clone_pointer(),)
        )





    def as_zklogin_opt(self, ) -> "typing.Optional[ZkLoginAuthenticator]":
        return _UniffiConverterOptionalTypeZkLoginAuthenticator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_as_zklogin_opt,self._uniffi_clone_pointer(),)
        )





    def is_ed25519(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_ed25519,self._uniffi_clone_pointer(),)
        )





    def is_secp256k1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256k1,self._uniffi_clone_pointer(),)
        )





    def is_secp256r1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_secp256r1,self._uniffi_clone_pointer(),)
        )





    def is_zklogin(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigmembersignature_is_zklogin,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMultisigMemberSignature:

    @staticmethod
    def lift(value: int):
        return MultisigMemberSignature._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigMemberSignature):
        if not isinstance(value, MultisigMemberSignature):
            raise TypeError("Expected MultisigMemberSignature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigMemberSignatureProtocol):
        if not isinstance(value, MultisigMemberSignature):
            raise TypeError("Expected MultisigMemberSignature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigMemberSignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class MultisigVerifierProtocol(typing.Protocol):
    def verify(self, message: "bytes",signature: "MultisigAggregatedSignature"):
        raise NotImplementedError
    def with_zklogin_verifier(self, zklogin_verifier: "ZkloginVerifier"):
        raise NotImplementedError
    def zklogin_verifier(self, ):
        raise NotImplementedError
# MultisigVerifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class MultisigVerifier():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_multisigverifier_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_multisigverifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_multisigverifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def verify(self, message: "bytes",signature: "MultisigAggregatedSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeMultisigAggregatedSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeMultisigAggregatedSignature.lower(signature))






    def with_zklogin_verifier(self, zklogin_verifier: "ZkloginVerifier") -> "MultisigVerifier":
        _UniffiConverterTypeZkloginVerifier.check_lower(zklogin_verifier)
        
        return _UniffiConverterTypeMultisigVerifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_with_zklogin_verifier,self._uniffi_clone_pointer(),
        _UniffiConverterTypeZkloginVerifier.lower(zklogin_verifier))
        )





    def zklogin_verifier(self, ) -> "typing.Optional[ZkloginVerifier]":
        return _UniffiConverterOptionalTypeZkloginVerifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_multisigverifier_zklogin_verifier,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMultisigVerifier:

    @staticmethod
    def lift(value: int):
        return MultisigVerifier._make_instance_(value)

    @staticmethod
    def check_lower(value: MultisigVerifier):
        if not isinstance(value, MultisigVerifier):
            raise TypeError("Expected MultisigVerifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MultisigVerifierProtocol):
        if not isinstance(value, MultisigVerifier):
            raise TypeError("Expected MultisigVerifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MultisigVerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NameProtocol(typing.Protocol):
    def format(self, format: "NameFormat"):
        """
        Formats a name into a string based on the available output formats.
        The default separator is `.`
        """

        raise NotImplementedError
    def is_sln(self, ):
        """
        Returns whether this name is a second-level name (Ex. `test.iota`)
        """

        raise NotImplementedError
    def is_subname(self, ):
        """
        Returns whether this name is a subname (Ex. `sub.test.iota`)
        """

        raise NotImplementedError
    def label(self, index: "int"):
        """
        Get the label at the given index
        """

        raise NotImplementedError
    def labels(self, ):
        """
        Get all of the labels. NOTE: These are in reverse order starting with
        the top-level name and proceeding to subnames.
        """

        raise NotImplementedError
    def num_labels(self, ):
        """
        Returns the number of labels including TLN.
        """

        raise NotImplementedError
    def parent(self, ):
        """
        parents; second-level names return `None`.
        """

        raise NotImplementedError
# Name is a Rust-only trait - it's a wrapper around a Rust implementation.
class Name():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_name, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_name, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_name_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def format(self, format: "NameFormat") -> "str":
        """
        Formats a name into a string based on the available output formats.
        The default separator is `.`
        """

        _UniffiConverterTypeNameFormat.check_lower(format)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_format,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNameFormat.lower(format))
        )





    def is_sln(self, ) -> "bool":
        """
        Returns whether this name is a second-level name (Ex. `test.iota`)
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_is_sln,self._uniffi_clone_pointer(),)
        )





    def is_subname(self, ) -> "bool":
        """
        Returns whether this name is a subname (Ex. `sub.test.iota`)
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_is_subname,self._uniffi_clone_pointer(),)
        )





    def label(self, index: "int") -> "typing.Optional[str]":
        """
        Get the label at the given index
        """

        _UniffiConverterUInt32.check_lower(index)
        
        return _UniffiConverterOptionalString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_label,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(index))
        )





    def labels(self, ) -> "typing.List[str]":
        """
        Get all of the labels. NOTE: These are in reverse order starting with
        the top-level name and proceeding to subnames.
        """

        return _UniffiConverterSequenceString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_labels,self._uniffi_clone_pointer(),)
        )





    def num_labels(self, ) -> "int":
        """
        Returns the number of labels including TLN.
        """

        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_num_labels,self._uniffi_clone_pointer(),)
        )





    def parent(self, ) -> "typing.Optional[Name]":
        """
        parents; second-level names return `None`.
        """

        return _UniffiConverterOptionalTypeName.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_name_parent,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeName:

    @staticmethod
    def lift(value: int):
        return Name._make_instance_(value)

    @staticmethod
    def check_lower(value: Name):
        if not isinstance(value, Name):
            raise TypeError("Expected Name instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NameProtocol):
        if not isinstance(value, Name):
            raise TypeError("Expected Name instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NameProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NameRegistrationProtocol(typing.Protocol):
    """
    An object to manage a second-level name (SLN).
    """

    def expiration_timestamp_ms(self, ):
        raise NotImplementedError
    def id(self, ):
        raise NotImplementedError
    def name(self, ):
        raise NotImplementedError
    def name_str(self, ):
        raise NotImplementedError
# NameRegistration is a Rust-only trait - it's a wrapper around a Rust implementation.
class NameRegistration():
    """
    An object to manage a second-level name (SLN).
    """

    _pointer: ctypes.c_void_p
    def __init__(self, id: "ObjectId",name: "Name",name_str: "str",expiration_timestamp_ms: "int"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        _UniffiConverterTypeName.check_lower(name)
        
        _UniffiConverterString.check_lower(name_str)
        
        _UniffiConverterUInt64.check_lower(expiration_timestamp_ms)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_nameregistration_new,
        _UniffiConverterTypeObjectId.lower(id),
        _UniffiConverterTypeName.lower(name),
        _UniffiConverterString.lower(name_str),
        _UniffiConverterUInt64.lower(expiration_timestamp_ms))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_nameregistration, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_nameregistration, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def expiration_timestamp_ms(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_expiration_timestamp_ms,self._uniffi_clone_pointer(),)
        )





    def id(self, ) -> "ObjectId":
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_id,self._uniffi_clone_pointer(),)
        )





    def name(self, ) -> "Name":
        return _UniffiConverterTypeName.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_name,self._uniffi_clone_pointer(),)
        )





    def name_str(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_nameregistration_name_str,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNameRegistration:

    @staticmethod
    def lift(value: int):
        return NameRegistration._make_instance_(value)

    @staticmethod
    def check_lower(value: NameRegistration):
        if not isinstance(value, NameRegistration):
            raise TypeError("Expected NameRegistration instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NameRegistrationProtocol):
        if not isinstance(value, NameRegistration):
            raise TypeError("Expected NameRegistration instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NameRegistrationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ObjectProtocol(typing.Protocol):
    """
    An object on the IOTA blockchain

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object = object-data owner digest u64
    ```
    """

    def as_package(self, ):
        """
        Interpret this object as a move package
        """

        raise NotImplementedError
    def as_package_opt(self, ):
        """
        Try to interpret this object as a move package
        """

        raise NotImplementedError
    def as_struct(self, ):
        """
        Interpret this object as a move struct
        """

        raise NotImplementedError
    def as_struct_opt(self, ):
        """
        Try to interpret this object as a move struct
        """

        raise NotImplementedError
    def data(self, ):
        """
        Return this object's data
        """

        raise NotImplementedError
    def digest(self, ):
        """
        Calculate the digest of this `Object`

        This is done by hashing the BCS bytes of this `Object` prefixed
        """

        raise NotImplementedError
    def object_id(self, ):
        """
        Return this object's id
        """

        raise NotImplementedError
    def object_ref(self, ):
        """
        Return this object's reference
        """

        raise NotImplementedError
    def object_type(self, ):
        """
        Return this object's type
        """

        raise NotImplementedError
    def owner(self, ):
        """
        Return this object's owner
        """

        raise NotImplementedError
    def previous_transaction(self, ):
        """
        Return the digest of the transaction that last modified this object
        """

        raise NotImplementedError
    def storage_rebate(self, ):
        """
        Return the storage rebate locked in this object

        Storage rebates are credited to the gas coin used in a transaction that
        deletes this object.
        """

        raise NotImplementedError
    def version(self, ):
        """
        Return this object's version
        """

        raise NotImplementedError
# Object is a Rust-only trait - it's a wrapper around a Rust implementation.
class Object():
    """
    An object on the IOTA blockchain

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object = object-data owner digest u64
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, data: "ObjectData",owner: "Owner",previous_transaction: "Digest",storage_rebate: "int"):
        _UniffiConverterTypeObjectData.check_lower(data)
        
        _UniffiConverterTypeOwner.check_lower(owner)
        
        _UniffiConverterTypeDigest.check_lower(previous_transaction)
        
        _UniffiConverterUInt64.check_lower(storage_rebate)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_object_new,
        _UniffiConverterTypeObjectData.lower(data),
        _UniffiConverterTypeOwner.lower(owner),
        _UniffiConverterTypeDigest.lower(previous_transaction),
        _UniffiConverterUInt64.lower(storage_rebate))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_object, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_object, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def as_package(self, ) -> "MovePackage":
        """
        Interpret this object as a move package
        """

        return _UniffiConverterTypeMovePackage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_package,self._uniffi_clone_pointer(),)
        )





    def as_package_opt(self, ) -> "typing.Optional[MovePackage]":
        """
        Try to interpret this object as a move package
        """

        return _UniffiConverterOptionalTypeMovePackage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_package_opt,self._uniffi_clone_pointer(),)
        )





    def as_struct(self, ) -> "MoveStruct":
        """
        Interpret this object as a move struct
        """

        return _UniffiConverterTypeMoveStruct.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_struct,self._uniffi_clone_pointer(),)
        )





    def as_struct_opt(self, ) -> "typing.Optional[MoveStruct]":
        """
        Try to interpret this object as a move struct
        """

        return _UniffiConverterOptionalTypeMoveStruct.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_as_struct_opt,self._uniffi_clone_pointer(),)
        )





    def data(self, ) -> "ObjectData":
        """
        Return this object's data
        """

        return _UniffiConverterTypeObjectData.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_data,self._uniffi_clone_pointer(),)
        )





    def digest(self, ) -> "Digest":
        """
        Calculate the digest of this `Object`

        This is done by hashing the BCS bytes of this `Object` prefixed
        """

        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_digest,self._uniffi_clone_pointer(),)
        )





    def object_id(self, ) -> "ObjectId":
        """
        Return this object's id
        """

        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_id,self._uniffi_clone_pointer(),)
        )





    def object_ref(self, ) -> "ObjectReference":
        """
        Return this object's reference
        """

        return _UniffiConverterTypeObjectReference.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_ref,self._uniffi_clone_pointer(),)
        )





    def object_type(self, ) -> "ObjectType":
        """
        Return this object's type
        """

        return _UniffiConverterTypeObjectType.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_object_type,self._uniffi_clone_pointer(),)
        )





    def owner(self, ) -> "Owner":
        """
        Return this object's owner
        """

        return _UniffiConverterTypeOwner.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_owner,self._uniffi_clone_pointer(),)
        )





    def previous_transaction(self, ) -> "Digest":
        """
        Return the digest of the transaction that last modified this object
        """

        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_previous_transaction,self._uniffi_clone_pointer(),)
        )





    def storage_rebate(self, ) -> "int":
        """
        Return the storage rebate locked in this object

        Storage rebates are credited to the gas coin used in a transaction that
        deletes this object.
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_storage_rebate,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        """
        Return this object's version
        """

        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_object_version,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeObject:

    @staticmethod
    def lift(value: int):
        return Object._make_instance_(value)

    @staticmethod
    def check_lower(value: Object):
        if not isinstance(value, Object):
            raise TypeError("Expected Object instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ObjectProtocol):
        if not isinstance(value, Object):
            raise TypeError("Expected Object instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ObjectProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ObjectDataProtocol(typing.Protocol):
    """
    Object data, either a package or struct

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-data = object-data-struct / object-data-package

    object-data-struct  = %x00 object-move-struct
    object-data-package = %x01 object-move-package
    ```
    """

    def as_package_opt(self, ):
        """
        Try to interpret this object as a `MovePackage`
        """

        raise NotImplementedError
    def as_struct_opt(self, ):
        """
        Try to interpret this object as a `MoveStruct`
        """

        raise NotImplementedError
    def is_package(self, ):
        """
        Return whether this object is a `MovePackage`
        """

        raise NotImplementedError
    def is_struct(self, ):
        """
        Return whether this object is a `MoveStruct`
        """

        raise NotImplementedError
# ObjectData is a Rust-only trait - it's a wrapper around a Rust implementation.
class ObjectData():
    """
    Object data, either a package or struct

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    object-data = object-data-struct / object-data-package

    object-data-struct  = %x00 object-move-struct
    object-data-package = %x01 object-move-package
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objectdata, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objectdata, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_move_package(cls, move_package: "MovePackage"):
        """
        Create an `ObjectData` from  `MovePackage`
        """

        _UniffiConverterTypeMovePackage.check_lower(move_package)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_package,
        _UniffiConverterTypeMovePackage.lower(move_package))
        return cls._make_instance_(pointer)

    @classmethod
    def new_move_struct(cls, move_struct: "MoveStruct"):
        """
        Create an `ObjectData` from a `MoveStruct`
        """

        _UniffiConverterTypeMoveStruct.check_lower(move_struct)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectdata_new_move_struct,
        _UniffiConverterTypeMoveStruct.lower(move_struct))
        return cls._make_instance_(pointer)



    def as_package_opt(self, ) -> "typing.Optional[MovePackage]":
        """
        Try to interpret this object as a `MovePackage`
        """

        return _UniffiConverterOptionalTypeMovePackage.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_as_package_opt,self._uniffi_clone_pointer(),)
        )





    def as_struct_opt(self, ) -> "typing.Optional[MoveStruct]":
        """
        Try to interpret this object as a `MoveStruct`
        """

        return _UniffiConverterOptionalTypeMoveStruct.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_as_struct_opt,self._uniffi_clone_pointer(),)
        )





    def is_package(self, ) -> "bool":
        """
        Return whether this object is a `MovePackage`
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_is_package,self._uniffi_clone_pointer(),)
        )





    def is_struct(self, ) -> "bool":
        """
        Return whether this object is a `MoveStruct`
        """

        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectdata_is_struct,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeObjectData:

    @staticmethod
    def lift(value: int):
        return ObjectData._make_instance_(value)

    @staticmethod
    def check_lower(value: ObjectData):
        if not isinstance(value, ObjectData):
            raise TypeError("Expected ObjectData instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ObjectDataProtocol):
        if not isinstance(value, ObjectData):
            raise TypeError("Expected ObjectData instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ObjectDataProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ObjectIdProtocol(typing.Protocol):
    """
    An `ObjectId` is a 32-byte identifier used to uniquely identify an object on
    the IOTA blockchain.

    ## Relationship to Address

    `Address`es and `ObjectId`s share the same 32-byte addressable space but
    are derived leveraging different domain-separator values to ensure,
    cryptographically, that there won't be any overlap, e.g. there can't be a
    valid `Object` whose `ObjectId` is equal to that of the `Address` of a user
    account.

    # BCS

    An `ObjectId`'s BCS serialized form is defined by the following:

    ```text
    object-id = 32*OCTET
    ```
    """

    def derive_dynamic_child_id(self, key_type_tag: "TypeTag",key_bytes: "bytes"):
        """
        Derive an ObjectId for a Dynamic Child Object.

        hash(parent || len(key) || key || key_type_tag)
        """

        raise NotImplementedError
    def to_address(self, ):
        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
    def to_canonical_string(self, with_prefix: "bool"):
        """
        Returns the string representation of this object ID using the
        canonical display, with or without a `0x` prefix.
        """

        raise NotImplementedError
    def to_hex(self, ):
        raise NotImplementedError
    def to_short_string(self, with_prefix: "bool"):
        """
        Returns the shortest possible string representation of the object ID
        (i.e. with leading zeroes trimmed).
        """

        raise NotImplementedError
# ObjectId is a Rust-only trait - it's a wrapper around a Rust implementation.
class ObjectId():
    """
    An `ObjectId` is a 32-byte identifier used to uniquely identify an object on
    the IOTA blockchain.

    ## Relationship to Address

    `Address`es and `ObjectId`s share the same 32-byte addressable space but
    are derived leveraging different domain-separator values to ensure,
    cryptographically, that there won't be any overlap, e.g. there can't be a
    valid `Object` whose `ObjectId` is equal to that of the `Address` of a user
    account.

    # BCS

    An `ObjectId`'s BCS serialized form is defined by the following:

    ```text
    object-id = 32*OCTET
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objectid, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objectid, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def clock(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_clock,)
        return cls._make_instance_(pointer)

    @classmethod
    def derive_id(cls, digest: "Digest",count: "int"):
        """
        Create an ObjectId from a transaction digest and the number of objects
        that have been created during a transactions.
        """

        _UniffiConverterTypeDigest.check_lower(digest)
        
        _UniffiConverterUInt64.check_lower(count)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_derive_id,
        _UniffiConverterTypeDigest.lower(digest),
        _UniffiConverterUInt64.lower(count))
        return cls._make_instance_(pointer)

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def system(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_system,)
        return cls._make_instance_(pointer)

    @classmethod
    def zero(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objectid_zero,)
        return cls._make_instance_(pointer)



    def derive_dynamic_child_id(self, key_type_tag: "TypeTag",key_bytes: "bytes") -> "ObjectId":
        """
        Derive an ObjectId for a Dynamic Child Object.

        hash(parent || len(key) || key || key_type_tag)
        """

        _UniffiConverterTypeTypeTag.check_lower(key_type_tag)
        
        _UniffiConverterBytes.check_lower(key_bytes)
        
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_derive_dynamic_child_id,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTypeTag.lower(key_type_tag),
        _UniffiConverterBytes.lower(key_bytes))
        )





    def to_address(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_address,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_canonical_string(self, with_prefix: "bool") -> "str":
        """
        Returns the string representation of this object ID using the
        canonical display, with or without a `0x` prefix.
        """

        _UniffiConverterBool.check_lower(with_prefix)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_canonical_string,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(with_prefix))
        )





    def to_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_hex,self._uniffi_clone_pointer(),)
        )





    def to_short_string(self, with_prefix: "bool") -> "str":
        """
        Returns the shortest possible string representation of the object ID
        (i.e. with leading zeroes trimmed).
        """

        _UniffiConverterBool.check_lower(with_prefix)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_to_short_string,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(with_prefix))
        )





    def __hash__(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objectid_uniffi_trait_hash,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeObjectId:

    @staticmethod
    def lift(value: int):
        return ObjectId._make_instance_(value)

    @staticmethod
    def check_lower(value: ObjectId):
        if not isinstance(value, ObjectId):
            raise TypeError("Expected ObjectId instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ObjectIdProtocol):
        if not isinstance(value, ObjectId):
            raise TypeError("Expected ObjectId instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ObjectIdProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ObjectTypeProtocol(typing.Protocol):
    """
    Type of an IOTA object
    """

    def as_struct(self, ):
        raise NotImplementedError
    def as_struct_opt(self, ):
        raise NotImplementedError
    def is_package(self, ):
        raise NotImplementedError
    def is_struct(self, ):
        raise NotImplementedError
# ObjectType is a Rust-only trait - it's a wrapper around a Rust implementation.
class ObjectType():
    """
    Type of an IOTA object
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_objecttype, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_objecttype, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_package(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_package,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_struct(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_objecttype_new_struct,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)



    def as_struct(self, ) -> "StructTag":
        return _UniffiConverterTypeStructTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct,self._uniffi_clone_pointer(),)
        )





    def as_struct_opt(self, ) -> "typing.Optional[StructTag]":
        return _UniffiConverterOptionalTypeStructTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_as_struct_opt,self._uniffi_clone_pointer(),)
        )





    def is_package(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_is_package,self._uniffi_clone_pointer(),)
        )





    def is_struct(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_is_struct,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_objecttype_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeObjectType:

    @staticmethod
    def lift(value: int):
        return ObjectType._make_instance_(value)

    @staticmethod
    def check_lower(value: ObjectType):
        if not isinstance(value, ObjectType):
            raise TypeError("Expected ObjectType instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ObjectTypeProtocol):
        if not isinstance(value, ObjectType):
            raise TypeError("Expected ObjectType instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ObjectTypeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class OwnerProtocol(typing.Protocol):
    """
    Enum of different types of ownership for an object.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    owner = owner-address / owner-object / owner-shared / owner-immutable

    owner-address   = %x00 address
    owner-object    = %x01 object-id
    owner-shared    = %x02 u64
    owner-immutable = %x03
    ```
    """

    def as_address(self, ):
        raise NotImplementedError
    def as_address_opt(self, ):
        raise NotImplementedError
    def as_object(self, ):
        raise NotImplementedError
    def as_object_opt(self, ):
        raise NotImplementedError
    def as_shared(self, ):
        raise NotImplementedError
    def as_shared_opt(self, ):
        raise NotImplementedError
    def is_address(self, ):
        raise NotImplementedError
    def is_immutable(self, ):
        raise NotImplementedError
    def is_object(self, ):
        raise NotImplementedError
    def is_shared(self, ):
        raise NotImplementedError
# Owner is a Rust-only trait - it's a wrapper around a Rust implementation.
class Owner():
    """
    Enum of different types of ownership for an object.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    owner = owner-address / owner-object / owner-shared / owner-immutable

    owner-address   = %x00 address
    owner-object    = %x01 object-id
    owner-shared    = %x02 u64
    owner-immutable = %x03
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_owner, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_owner, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_address(cls, address: "Address"):
        _UniffiConverterTypeAddress.check_lower(address)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_address,
        _UniffiConverterTypeAddress.lower(address))
        return cls._make_instance_(pointer)

    @classmethod
    def new_immutable(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_immutable,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_object(cls, id: "ObjectId"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_object,
        _UniffiConverterTypeObjectId.lower(id))
        return cls._make_instance_(pointer)

    @classmethod
    def new_shared(cls, version: "int"):
        _UniffiConverterUInt64.check_lower(version)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_owner_new_shared,
        _UniffiConverterUInt64.lower(version))
        return cls._make_instance_(pointer)



    def as_address(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_address,self._uniffi_clone_pointer(),)
        )





    def as_address_opt(self, ) -> "typing.Optional[Address]":
        return _UniffiConverterOptionalTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_address_opt,self._uniffi_clone_pointer(),)
        )





    def as_object(self, ) -> "ObjectId":
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_object,self._uniffi_clone_pointer(),)
        )





    def as_object_opt(self, ) -> "typing.Optional[ObjectId]":
        return _UniffiConverterOptionalTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_object_opt,self._uniffi_clone_pointer(),)
        )





    def as_shared(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_shared,self._uniffi_clone_pointer(),)
        )





    def as_shared_opt(self, ) -> "typing.Optional[int]":
        return _UniffiConverterOptionalUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_as_shared_opt,self._uniffi_clone_pointer(),)
        )





    def is_address(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_address,self._uniffi_clone_pointer(),)
        )





    def is_immutable(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_immutable,self._uniffi_clone_pointer(),)
        )





    def is_object(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_object,self._uniffi_clone_pointer(),)
        )





    def is_shared(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_is_shared,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_owner_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeOwner:

    @staticmethod
    def lift(value: int):
        return Owner._make_instance_(value)

    @staticmethod
    def check_lower(value: Owner):
        if not isinstance(value, Owner):
            raise TypeError("Expected Owner instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: OwnerProtocol):
        if not isinstance(value, Owner):
            raise TypeError("Expected Owner instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: OwnerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PasskeyAuthenticatorProtocol(typing.Protocol):
    """
    A passkey authenticator.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    passkey-bcs = bytes               ; where the contents of the bytes are
    ; defined by <passkey>
    passkey     = passkey-flag
    bytes               ; passkey authenticator data
    client-data-json    ; valid json
    simple-signature    ; required to be a secp256r1 signature

    client-data-json = string ; valid json
    ```

    See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata> for
    the required json-schema for the `client-data-json` rule. In addition, IOTA
    currently requires that the `CollectedClientData.type` field is required to
    be `webauthn.get`.

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    def authenticator_data(self, ):
        """
        Opaque authenticator data for this passkey signature.

        See <https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>
        for more information on this field.
        """

        raise NotImplementedError
    def challenge(self, ):
        """
        The parsed challenge message for this passkey signature.

        This is parsed by decoding the base64url data from the
        `client_data_json.challenge` field.
        """

        raise NotImplementedError
    def client_data_json(self, ):
        """
        Structured, unparsed, JSON for this passkey signature.

        See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>
        for more information on this field.
        """

        raise NotImplementedError
    def public_key(self, ):
        """
        The passkey public key
        """

        raise NotImplementedError
    def signature(self, ):
        """
        The passkey signature.
        """

        raise NotImplementedError
# PasskeyAuthenticator is a Rust-only trait - it's a wrapper around a Rust implementation.
class PasskeyAuthenticator():
    """
    A passkey authenticator.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    passkey-bcs = bytes               ; where the contents of the bytes are
    ; defined by <passkey>
    passkey     = passkey-flag
    bytes               ; passkey authenticator data
    client-data-json    ; valid json
    simple-signature    ; required to be a secp256r1 signature

    client-data-json = string ; valid json
    ```

    See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata> for
    the required json-schema for the `client-data-json` rule. In addition, IOTA
    currently requires that the `CollectedClientData.type` field is required to
    be `webauthn.get`.

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeyauthenticator, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeyauthenticator, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def authenticator_data(self, ) -> "bytes":
        """
        Opaque authenticator data for this passkey signature.

        See <https://www.w3.org/TR/webauthn-2/#sctn-authenticator-data>
        for more information on this field.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_authenticator_data,self._uniffi_clone_pointer(),)
        )





    def challenge(self, ) -> "bytes":
        """
        The parsed challenge message for this passkey signature.

        This is parsed by decoding the base64url data from the
        `client_data_json.challenge` field.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_challenge,self._uniffi_clone_pointer(),)
        )





    def client_data_json(self, ) -> "str":
        """
        Structured, unparsed, JSON for this passkey signature.

        See <https://www.w3.org/TR/webauthn-2/#dictdef-collectedclientdata>
        for more information on this field.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_client_data_json,self._uniffi_clone_pointer(),)
        )





    def public_key(self, ) -> "PasskeyPublicKey":
        """
        The passkey public key
        """

        return _UniffiConverterTypePasskeyPublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_public_key,self._uniffi_clone_pointer(),)
        )





    def signature(self, ) -> "SimpleSignature":
        """
        The passkey signature.
        """

        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyauthenticator_signature,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePasskeyAuthenticator:

    @staticmethod
    def lift(value: int):
        return PasskeyAuthenticator._make_instance_(value)

    @staticmethod
    def check_lower(value: PasskeyAuthenticator):
        if not isinstance(value, PasskeyAuthenticator):
            raise TypeError("Expected PasskeyAuthenticator instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PasskeyAuthenticatorProtocol):
        if not isinstance(value, PasskeyAuthenticator):
            raise TypeError("Expected PasskeyAuthenticator instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PasskeyAuthenticatorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PasskeyPublicKeyProtocol(typing.Protocol):
    """
    Public key of a `PasskeyAuthenticator`.

    This is used to derive the onchain `Address` for a `PasskeyAuthenticator`.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    passkey-public-key = passkey-flag secp256r1-public-key
    ```
    """

    def derive_address(self, ):
        """
        Derive an `Address` from this Passkey Public Key

        An `Address` can be derived from a `PasskeyPublicKey` by hashing the
        bytes of the `Secp256r1PublicKey` that corresponds to this passkey
        prefixed with the Passkey `SignatureScheme` flag (`0x06`).

        `hash( 0x06 || 33-byte secp256r1 public key)`
        """

        raise NotImplementedError
    def inner(self, ):
        raise NotImplementedError
# PasskeyPublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class PasskeyPublicKey():
    """
    Public key of a `PasskeyAuthenticator`.

    This is used to derive the onchain `Address` for a `PasskeyAuthenticator`.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    passkey-public-key = passkey-flag secp256r1-public-key
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "Secp256r1PublicKey"):
        _UniffiConverterTypeSecp256r1PublicKey.check_lower(public_key)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_passkeypublickey_new,
        _UniffiConverterTypeSecp256r1PublicKey.lower(public_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeypublickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeypublickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def derive_address(self, ) -> "Address":
        """
        Derive an `Address` from this Passkey Public Key

        An `Address` can be derived from a `PasskeyPublicKey` by hashing the
        bytes of the `Secp256r1PublicKey` that corresponds to this passkey
        prefixed with the Passkey `SignatureScheme` flag (`0x06`).

        `hash( 0x06 || 33-byte secp256r1 public key)`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_derive_address,self._uniffi_clone_pointer(),)
        )





    def inner(self, ) -> "Secp256r1PublicKey":
        return _UniffiConverterTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeypublickey_inner,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePasskeyPublicKey:

    @staticmethod
    def lift(value: int):
        return PasskeyPublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: PasskeyPublicKey):
        if not isinstance(value, PasskeyPublicKey):
            raise TypeError("Expected PasskeyPublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PasskeyPublicKeyProtocol):
        if not isinstance(value, PasskeyPublicKey):
            raise TypeError("Expected PasskeyPublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PasskeyPublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PasskeyVerifierProtocol(typing.Protocol):
    def verify(self, message: "bytes",authenticator: "PasskeyAuthenticator"):
        raise NotImplementedError
# PasskeyVerifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class PasskeyVerifier():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_passkeyverifier_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_passkeyverifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_passkeyverifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def verify(self, message: "bytes",authenticator: "PasskeyAuthenticator") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypePasskeyAuthenticator.check_lower(authenticator)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_passkeyverifier_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypePasskeyAuthenticator.lower(authenticator))







class _UniffiConverterTypePasskeyVerifier:

    @staticmethod
    def lift(value: int):
        return PasskeyVerifier._make_instance_(value)

    @staticmethod
    def check_lower(value: PasskeyVerifier):
        if not isinstance(value, PasskeyVerifier):
            raise TypeError("Expected PasskeyVerifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PasskeyVerifierProtocol):
        if not isinstance(value, PasskeyVerifier):
            raise TypeError("Expected PasskeyVerifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PasskeyVerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PersonalMessageProtocol(typing.Protocol):
    def message_bytes(self, ):
        raise NotImplementedError
    def signing_digest(self, ):
        raise NotImplementedError
    def signing_digest_hex(self, ):
        raise NotImplementedError
# PersonalMessage is a Rust-only trait - it's a wrapper around a Rust implementation.
class PersonalMessage():
    _pointer: ctypes.c_void_p
    def __init__(self, message_bytes: "bytes"):
        _UniffiConverterBytes.check_lower(message_bytes)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_personalmessage_new,
        _UniffiConverterBytes.lower(message_bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_personalmessage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_personalmessage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def message_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_message_bytes,self._uniffi_clone_pointer(),)
        )





    def signing_digest(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest,self._uniffi_clone_pointer(),)
        )





    def signing_digest_hex(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_personalmessage_signing_digest_hex,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePersonalMessage:

    @staticmethod
    def lift(value: int):
        return PersonalMessage._make_instance_(value)

    @staticmethod
    def check_lower(value: PersonalMessage):
        if not isinstance(value, PersonalMessage):
            raise TypeError("Expected PersonalMessage instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PersonalMessageProtocol):
        if not isinstance(value, PersonalMessage):
            raise TypeError("Expected PersonalMessage instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PersonalMessageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ProgrammableTransactionProtocol(typing.Protocol):
    """
    A user transaction

    Contains a series of native commands and move calls where the results of one
    command can be used in future commands.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ptb = (vector input) (vector command)
    ```
    """

    def commands(self, ):
        """
        The commands to be executed sequentially. A failure in any command will
        result in the failure of the entire transaction.
        """

        raise NotImplementedError
    def inputs(self, ):
        """
        Input objects or primitive values
        """

        raise NotImplementedError
# ProgrammableTransaction is a Rust-only trait - it's a wrapper around a Rust implementation.
class ProgrammableTransaction():
    """
    A user transaction

    Contains a series of native commands and move calls where the results of one
    command can be used in future commands.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    ptb = (vector input) (vector command)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, inputs: "typing.List[Input]",commands: "typing.List[Command]"):
        _UniffiConverterSequenceTypeInput.check_lower(inputs)
        
        _UniffiConverterSequenceTypeCommand.check_lower(commands)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_programmabletransaction_new,
        _UniffiConverterSequenceTypeInput.lower(inputs),
        _UniffiConverterSequenceTypeCommand.lower(commands))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_programmabletransaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_programmabletransaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def commands(self, ) -> "typing.List[Command]":
        """
        The commands to be executed sequentially. A failure in any command will
        result in the failure of the entire transaction.
        """

        return _UniffiConverterSequenceTypeCommand.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_commands,self._uniffi_clone_pointer(),)
        )





    def inputs(self, ) -> "typing.List[Input]":
        """
        Input objects or primitive values
        """

        return _UniffiConverterSequenceTypeInput.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_programmabletransaction_inputs,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeProgrammableTransaction:

    @staticmethod
    def lift(value: int):
        return ProgrammableTransaction._make_instance_(value)

    @staticmethod
    def check_lower(value: ProgrammableTransaction):
        if not isinstance(value, ProgrammableTransaction):
            raise TypeError("Expected ProgrammableTransaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ProgrammableTransactionProtocol):
        if not isinstance(value, ProgrammableTransaction):
            raise TypeError("Expected ProgrammableTransaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ProgrammableTransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PtbArgumentProtocol(typing.Protocol):
    pass
# PtbArgument is a Rust-only trait - it's a wrapper around a Rust implementation.
class PtbArgument():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_ptbargument, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_ptbargument, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def address(cls, address: "Address"):
        _UniffiConverterTypeAddress.check_lower(address)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address,
        _UniffiConverterTypeAddress.lower(address))
        return cls._make_instance_(pointer)

    @classmethod
    def address_from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def address_vec(cls, addresses: "typing.List[Address]"):
        _UniffiConverterSequenceTypeAddress.check_lower(addresses)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec,
        _UniffiConverterSequenceTypeAddress.lower(addresses))
        return cls._make_instance_(pointer)

    @classmethod
    def address_vec_from_hex(cls, addresses: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(addresses)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_address_vec_from_hex,
        _UniffiConverterSequenceString.lower(addresses))
        return cls._make_instance_(pointer)

    @classmethod
    def bool(cls, value: "bool"):
        _UniffiConverterBool.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool,
        _UniffiConverterBool.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def bool_vec(cls, values: "typing.List[bool]"):
        _UniffiConverterSequenceBool.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_bool_vec,
        _UniffiConverterSequenceBool.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def digest(cls, digest: "Digest"):
        _UniffiConverterTypeDigest.check_lower(digest)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest,
        _UniffiConverterTypeDigest.lower(digest))
        return cls._make_instance_(pointer)

    @classmethod
    def digest_from_base58(cls, base58: "str"):
        _UniffiConverterString.check_lower(base58)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_from_base58,
        _UniffiConverterString.lower(base58))
        return cls._make_instance_(pointer)

    @classmethod
    def digest_vec(cls, digests: "typing.List[Digest]"):
        _UniffiConverterSequenceTypeDigest.check_lower(digests)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec,
        _UniffiConverterSequenceTypeDigest.lower(digests))
        return cls._make_instance_(pointer)

    @classmethod
    def digest_vec_from_base58(cls, digests: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(digests)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_digest_vec_from_base58,
        _UniffiConverterSequenceString.lower(digests))
        return cls._make_instance_(pointer)

    @classmethod
    def gas(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_gas,)
        return cls._make_instance_(pointer)

    @classmethod
    def move_arg(cls, arg: "MoveArg"):
        _UniffiConverterTypeMoveArg.check_lower(arg)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_move_arg,
        _UniffiConverterTypeMoveArg.lower(arg))
        return cls._make_instance_(pointer)

    @classmethod
    def object_id(cls, id: "ObjectId"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id,
        _UniffiConverterTypeObjectId.lower(id))
        return cls._make_instance_(pointer)

    @classmethod
    def object_id_from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_id_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def object_ref(cls, id: "ObjectReference"):
        _UniffiConverterTypeObjectReference.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_object_ref,
        _UniffiConverterTypeObjectReference.lower(id))
        return cls._make_instance_(pointer)

    @classmethod
    def option(cls, value: "typing.Optional[MoveArg]"):
        _UniffiConverterOptionalTypeMoveArg.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_option,
        _UniffiConverterOptionalTypeMoveArg.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def receiving(cls, id: "ObjectId"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving,
        _UniffiConverterTypeObjectId.lower(id))
        return cls._make_instance_(pointer)

    @classmethod
    def receiving_from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_receiving_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def res(cls, name: "str"):
        _UniffiConverterString.check_lower(name)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_res,
        _UniffiConverterString.lower(name))
        return cls._make_instance_(pointer)

    @classmethod
    def shared(cls, id: "ObjectId"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared,
        _UniffiConverterTypeObjectId.lower(id))
        return cls._make_instance_(pointer)

    @classmethod
    def shared_from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def shared_mut(cls, id: "ObjectId"):
        _UniffiConverterTypeObjectId.check_lower(id)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut,
        _UniffiConverterTypeObjectId.lower(id))
        return cls._make_instance_(pointer)

    @classmethod
    def shared_mut_from_hex(cls, hex: "str"):
        _UniffiConverterString.check_lower(hex)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_shared_mut_from_hex,
        _UniffiConverterString.lower(hex))
        return cls._make_instance_(pointer)

    @classmethod
    def string(cls, string: "str"):
        _UniffiConverterString.check_lower(string)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_string,
        _UniffiConverterString.lower(string))
        return cls._make_instance_(pointer)

    @classmethod
    def u128(cls, value: "str"):
        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u128_vec(cls, values: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u128_vec,
        _UniffiConverterSequenceString.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u16(cls, value: "int"):
        _UniffiConverterUInt16.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16,
        _UniffiConverterUInt16.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u16_vec(cls, values: "typing.List[int]"):
        _UniffiConverterSequenceUInt16.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u16_vec,
        _UniffiConverterSequenceUInt16.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u256(cls, value: "str"):
        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u256_vec(cls, values: "typing.List[str]"):
        _UniffiConverterSequenceString.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u256_vec,
        _UniffiConverterSequenceString.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u32(cls, value: "int"):
        _UniffiConverterUInt32.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32,
        _UniffiConverterUInt32.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u32_vec(cls, values: "typing.List[int]"):
        _UniffiConverterSequenceUInt32.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u32_vec,
        _UniffiConverterSequenceUInt32.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u64(cls, value: "int"):
        _UniffiConverterUInt64.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64,
        _UniffiConverterUInt64.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u64_vec(cls, values: "typing.List[int]"):
        _UniffiConverterSequenceUInt64.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u64_vec,
        _UniffiConverterSequenceUInt64.lower(values))
        return cls._make_instance_(pointer)

    @classmethod
    def u8(cls, value: "int"):
        _UniffiConverterUInt8.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8,
        _UniffiConverterUInt8.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def u8_vec(cls, values: "bytes"):
        _UniffiConverterBytes.check_lower(values)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_ptbargument_u8_vec,
        _UniffiConverterBytes.lower(values))
        return cls._make_instance_(pointer)




class _UniffiConverterTypePtbArgument:

    @staticmethod
    def lift(value: int):
        return PtbArgument._make_instance_(value)

    @staticmethod
    def check_lower(value: PtbArgument):
        if not isinstance(value, PtbArgument):
            raise TypeError("Expected PtbArgument instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PtbArgumentProtocol):
        if not isinstance(value, PtbArgument):
            raise TypeError("Expected PtbArgument instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PtbArgumentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class PublishProtocol(typing.Protocol):
    """
    Command to publish a new move package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    publish = (vector bytes)        ; the serialized move modules
    (vector object-id)    ; the set of package dependencies
    ```
    """

    def dependencies(self, ):
        """
        Set of packages that the to-be published package depends on
        """

        raise NotImplementedError
    def modules(self, ):
        """
        The serialized move modules
        """

        raise NotImplementedError
# Publish is a Rust-only trait - it's a wrapper around a Rust implementation.
class Publish():
    """
    Command to publish a new move package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    publish = (vector bytes)        ; the serialized move modules
    (vector object-id)    ; the set of package dependencies
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, modules: "typing.List[bytes]",dependencies: "typing.List[ObjectId]"):
        _UniffiConverterSequenceBytes.check_lower(modules)
        
        _UniffiConverterSequenceTypeObjectId.check_lower(dependencies)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_publish_new,
        _UniffiConverterSequenceBytes.lower(modules),
        _UniffiConverterSequenceTypeObjectId.lower(dependencies))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_publish, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_publish, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def dependencies(self, ) -> "typing.List[ObjectId]":
        """
        Set of packages that the to-be published package depends on
        """

        return _UniffiConverterSequenceTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_publish_dependencies,self._uniffi_clone_pointer(),)
        )





    def modules(self, ) -> "typing.List[bytes]":
        """
        The serialized move modules
        """

        return _UniffiConverterSequenceBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_publish_modules,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePublish:

    @staticmethod
    def lift(value: int):
        return Publish._make_instance_(value)

    @staticmethod
    def check_lower(value: Publish):
        if not isinstance(value, Publish):
            raise TypeError("Expected Publish instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PublishProtocol):
        if not isinstance(value, Publish):
            raise TypeError("Expected Publish instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PublishProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256k1PrivateKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def sign_personal_message(self, message: "PersonalMessage"):
        """
        Sign a personal message and return a UserSignature.
        """

        raise NotImplementedError
    def sign_transaction(self, transaction: "Transaction"):
        """
        Sign a transaction and return a UserSignature.
        """

        raise NotImplementedError
    def to_bech32(self, ):
        """
        Encode this private key as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        """
        Serialize this private key to bytes.
        """

        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this private key as PEM-encoded PKCS#8
        """

        raise NotImplementedError
    def try_sign(self, message: "bytes"):
        raise NotImplementedError
    def try_sign_simple(self, message: "bytes"):
        raise NotImplementedError
    def try_sign_user(self, message: "bytes"):
        raise NotImplementedError
    def verifying_key(self, ):
        raise NotImplementedError
# Secp256k1PrivateKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256k1PrivateKey():
    _pointer: ctypes.c_void_p
    def __init__(self, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_new,
        _UniffiConverterBytes.lower(bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1privatekey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1privatekey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, value: "str"):
        """
        Decode a private key from `flag || privkey` in Bech32 starting with
        "iotaprivkey".
        """

        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_bech32,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
        format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_mnemonic(cls, phrase: "str",account_index: "typing.Union[object, int]" = _DEFAULT,password: "typing.Union[object, str]" = _DEFAULT):
        """
        Construct the private key from a mnemonic phrase
        """

        _UniffiConverterString.check_lower(phrase)
        
        if account_index is _DEFAULT:
            account_index = 0
        _UniffiConverterUInt64.check_lower(account_index)
        
        if password is _DEFAULT:
            password = ""
        _UniffiConverterString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic,
        _UniffiConverterString.lower(phrase),
        _UniffiConverterUInt64.lower(account_index),
        _UniffiConverterString.lower(password))
        return cls._make_instance_(pointer)

    @classmethod
    def from_mnemonic_with_path(cls, phrase: "str",path: "str",password: "typing.Union[object, str]" = _DEFAULT):
        """
        Create an instance from a mnemonic phrase and a derivation path like
        `"m/54'/4218'/0'/0/0"`
        """

        _UniffiConverterString.check_lower(phrase)
        
        _UniffiConverterString.check_lower(path)
        
        if password is _DEFAULT:
            password = ""
        _UniffiConverterString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_mnemonic_with_path,
        _UniffiConverterString.lower(phrase),
        _UniffiConverterString.lower(path),
        _UniffiConverterString.lower(password))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize PKCS#8-encoded private key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1privatekey_generate,)
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Secp256k1PublicKey":
        return _UniffiConverterTypeSecp256k1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_public_key,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_scheme,self._uniffi_clone_pointer(),)
        )





    def sign_personal_message(self, message: "PersonalMessage") -> "UserSignature":
        """
        Sign a personal message and return a UserSignature.
        """

        _UniffiConverterTypePersonalMessage.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_personal_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypePersonalMessage.lower(message))
        )





    def sign_transaction(self, transaction: "Transaction") -> "UserSignature":
        """
        Sign a transaction and return a UserSignature.
        """

        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_sign_transaction,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))
        )





    def to_bech32(self, ) -> "str":
        """
        Encode this private key as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        """
        Serialize this private key to bytes.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this private key as PEM-encoded PKCS#8
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_to_pem,self._uniffi_clone_pointer(),)
        )





    def try_sign(self, message: "bytes") -> "Secp256k1Signature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeSecp256k1Signature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_simple(self, message: "bytes") -> "SimpleSignature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_user(self, message: "bytes") -> "UserSignature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_try_sign_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def verifying_key(self, ) -> "Secp256k1VerifyingKey":
        return _UniffiConverterTypeSecp256k1VerifyingKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1privatekey_verifying_key,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSecp256k1PrivateKey:

    @staticmethod
    def lift(value: int):
        return Secp256k1PrivateKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256k1PrivateKey):
        if not isinstance(value, Secp256k1PrivateKey):
            raise TypeError("Expected Secp256k1PrivateKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256k1PrivateKeyProtocol):
        if not isinstance(value, Secp256k1PrivateKey):
            raise TypeError("Expected Secp256k1PrivateKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256k1PrivateKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256k1PublicKeyProtocol(typing.Protocol):
    """
    A secp256k1 signature.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256k1-signature = 64OCTECT
    ```
    """

    def derive_address(self, ):
        """
        Derive an `Address` from this Public Key

        An `Address` can be derived from a `Secp256k1PublicKey` by hashing the
        bytes of the public key prefixed with the Secp256k1
        `SignatureScheme` flag (`0x01`).

        `hash( 0x01 || 33-byte secp256k1 public key)`
        """

        raise NotImplementedError
    def scheme(self, ):
        """
        Returns the signature scheme for this public key.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
    def to_flagged_bytes(self, ):
        """
        Returns the bytes with signature scheme flag prepended.
        """

        raise NotImplementedError
# Secp256k1PublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256k1PublicKey():
    """
    A secp256k1 signature.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256k1-signature = 64OCTECT
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1publickey_generate,)
        return cls._make_instance_(pointer)



    def derive_address(self, ) -> "Address":
        """
        Derive an `Address` from this Public Key

        An `Address` can be derived from a `Secp256k1PublicKey` by hashing the
        bytes of the public key prefixed with the Secp256k1
        `SignatureScheme` flag (`0x01`).

        `hash( 0x01 || 33-byte secp256k1 public key)`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_derive_address,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        """
        Returns the signature scheme for this public key.
        """

        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_scheme,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_flagged_bytes(self, ) -> "bytes":
        """
        Returns the bytes with signature scheme flag prepended.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1publickey_to_flagged_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSecp256k1PublicKey:

    @staticmethod
    def lift(value: int):
        return Secp256k1PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256k1PublicKey):
        if not isinstance(value, Secp256k1PublicKey):
            raise TypeError("Expected Secp256k1PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256k1PublicKeyProtocol):
        if not isinstance(value, Secp256k1PublicKey):
            raise TypeError("Expected Secp256k1PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256k1PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256k1SignatureProtocol(typing.Protocol):
    """
    A secp256k1 public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256k1-public-key = 33OCTECT
    ```
    """

    def to_bytes(self, ):
        raise NotImplementedError
# Secp256k1Signature is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256k1Signature():
    """
    A secp256k1 public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256k1-public-key = 33OCTECT
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1signature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1signature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1signature_generate,)
        return cls._make_instance_(pointer)



    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1signature_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSecp256k1Signature:

    @staticmethod
    def lift(value: int):
        return Secp256k1Signature._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256k1Signature):
        if not isinstance(value, Secp256k1Signature):
            raise TypeError("Expected Secp256k1Signature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256k1SignatureProtocol):
        if not isinstance(value, Secp256k1Signature):
            raise TypeError("Expected Secp256k1Signature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256k1SignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256k1VerifierProtocol(typing.Protocol):
    def verify_simple(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
    def verify_user(self, message: "bytes",signature: "UserSignature"):
        raise NotImplementedError
# Secp256k1Verifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256k1Verifier():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifier_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1verifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def verify_simple(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))






    def verify_user(self, message: "bytes",signature: "UserSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifier_verify_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeUserSignature.lower(signature))







class _UniffiConverterTypeSecp256k1Verifier:

    @staticmethod
    def lift(value: int):
        return Secp256k1Verifier._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256k1Verifier):
        if not isinstance(value, Secp256k1Verifier):
            raise TypeError("Expected Secp256k1Verifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256k1VerifierProtocol):
        if not isinstance(value, Secp256k1Verifier):
            raise TypeError("Expected Secp256k1Verifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256k1VerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256k1VerifyingKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this public key as DER-encoded data
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this public key into PEM
        """

        raise NotImplementedError
    def verify(self, message: "bytes",signature: "Secp256k1Signature"):
        raise NotImplementedError
    def verify_simple(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
    def verify_user(self, message: "bytes",signature: "UserSignature"):
        raise NotImplementedError
# Secp256k1VerifyingKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256k1VerifyingKey():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "Secp256k1PublicKey"):
        _UniffiConverterTypeSecp256k1PublicKey.check_lower(public_key)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_new,
        _UniffiConverterTypeSecp256k1PublicKey.lower(public_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256k1verifyingkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256k1verifyingkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize public key from ASN.1 DER-encoded data (binary format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize public key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256k1verifyingkey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Secp256k1PublicKey":
        return _UniffiConverterTypeSecp256k1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_public_key,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this public key as DER-encoded data
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this public key into PEM
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_to_pem,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",signature: "Secp256k1Signature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSecp256k1Signature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSecp256k1Signature.lower(signature))






    def verify_simple(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))






    def verify_user(self, message: "bytes",signature: "UserSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256k1verifyingkey_verify_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeUserSignature.lower(signature))







class _UniffiConverterTypeSecp256k1VerifyingKey:

    @staticmethod
    def lift(value: int):
        return Secp256k1VerifyingKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256k1VerifyingKey):
        if not isinstance(value, Secp256k1VerifyingKey):
            raise TypeError("Expected Secp256k1VerifyingKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256k1VerifyingKeyProtocol):
        if not isinstance(value, Secp256k1VerifyingKey):
            raise TypeError("Expected Secp256k1VerifyingKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256k1VerifyingKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256r1PrivateKeyProtocol(typing.Protocol):
    def public_key(self, ):
        """
        Get the public key corresponding to this private key.
        """

        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def sign_personal_message(self, message: "PersonalMessage"):
        """
        Sign a personal message and return a UserSignature.
        """

        raise NotImplementedError
    def sign_transaction(self, transaction: "Transaction"):
        """
        Sign a transaction and return a UserSignature.
        """

        raise NotImplementedError
    def to_bech32(self, ):
        """
        Encode this private key as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        """
        Serialize this private key to bytes.
        """

        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this private key as PEM-encoded PKCS#8
        """

        raise NotImplementedError
    def try_sign(self, message: "bytes"):
        """
        Sign a message and return a Secp256r1Signature.
        """

        raise NotImplementedError
    def try_sign_simple(self, message: "bytes"):
        """
        Sign a message and return a SimpleSignature.
        """

        raise NotImplementedError
    def try_sign_user(self, message: "bytes"):
        """
        Sign a message and return a UserSignature.
        """

        raise NotImplementedError
    def verifying_key(self, ):
        raise NotImplementedError
# Secp256r1PrivateKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256r1PrivateKey():
    _pointer: ctypes.c_void_p
    def __init__(self, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_new,
        _UniffiConverterBytes.lower(bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1privatekey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1privatekey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, value: "str"):
        """
        Decode a private key from `flag || privkey` in Bech32 starting with
        "iotaprivkey".
        """

        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_bech32,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
        format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_mnemonic(cls, phrase: "str",account_index: "typing.Union[object, int]" = _DEFAULT,password: "typing.Union[object, str]" = _DEFAULT):
        """
        Construct the private key from a mnemonic phrase
        """

        _UniffiConverterString.check_lower(phrase)
        
        if account_index is _DEFAULT:
            account_index = 0
        _UniffiConverterUInt64.check_lower(account_index)
        
        if password is _DEFAULT:
            password = ""
        _UniffiConverterString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic,
        _UniffiConverterString.lower(phrase),
        _UniffiConverterUInt64.lower(account_index),
        _UniffiConverterString.lower(password))
        return cls._make_instance_(pointer)

    @classmethod
    def from_mnemonic_with_path(cls, phrase: "str",path: "str",password: "typing.Union[object, str]" = _DEFAULT):
        """
        Create an instance from a mnemonic phrase and a derivation path like
        `"m/74'/4218'/0'/0/0"`
        """

        _UniffiConverterString.check_lower(phrase)
        
        _UniffiConverterString.check_lower(path)
        
        if password is _DEFAULT:
            password = ""
        _UniffiConverterString.check_lower(password)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_mnemonic_with_path,
        _UniffiConverterString.lower(phrase),
        _UniffiConverterString.lower(path),
        _UniffiConverterString.lower(password))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize PKCS#8-encoded private key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        """
        Generate a new random Secp256r1PrivateKey
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1privatekey_generate,)
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Secp256r1PublicKey":
        """
        Get the public key corresponding to this private key.
        """

        return _UniffiConverterTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_public_key,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_scheme,self._uniffi_clone_pointer(),)
        )





    def sign_personal_message(self, message: "PersonalMessage") -> "UserSignature":
        """
        Sign a personal message and return a UserSignature.
        """

        _UniffiConverterTypePersonalMessage.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_personal_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypePersonalMessage.lower(message))
        )





    def sign_transaction(self, transaction: "Transaction") -> "UserSignature":
        """
        Sign a transaction and return a UserSignature.
        """

        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_sign_transaction,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))
        )





    def to_bech32(self, ) -> "str":
        """
        Encode this private key as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        """
        Serialize this private key to bytes.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this private key as PEM-encoded PKCS#8
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_to_pem,self._uniffi_clone_pointer(),)
        )





    def try_sign(self, message: "bytes") -> "Secp256r1Signature":
        """
        Sign a message and return a Secp256r1Signature.
        """

        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeSecp256r1Signature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_simple(self, message: "bytes") -> "SimpleSignature":
        """
        Sign a message and return a SimpleSignature.
        """

        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_user(self, message: "bytes") -> "UserSignature":
        """
        Sign a message and return a UserSignature.
        """

        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_try_sign_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def verifying_key(self, ) -> "Secp256r1VerifyingKey":
        return _UniffiConverterTypeSecp256r1VerifyingKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1privatekey_verifying_key,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSecp256r1PrivateKey:

    @staticmethod
    def lift(value: int):
        return Secp256r1PrivateKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256r1PrivateKey):
        if not isinstance(value, Secp256r1PrivateKey):
            raise TypeError("Expected Secp256r1PrivateKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256r1PrivateKeyProtocol):
        if not isinstance(value, Secp256r1PrivateKey):
            raise TypeError("Expected Secp256r1PrivateKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256r1PrivateKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256r1PublicKeyProtocol(typing.Protocol):
    """
    A secp256r1 signature.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256r1-signature = 64OCTECT
    ```
    """

    def derive_address(self, ):
        """
        Derive an `Address` from this Public Key

        An `Address` can be derived from a `Secp256r1PublicKey` by hashing the
        bytes of the public key prefixed with the Secp256r1
        `SignatureScheme` flag (`0x02`).

        `hash( 0x02 || 33-byte secp256r1 public key)`
        """

        raise NotImplementedError
    def scheme(self, ):
        """
        Returns the signature scheme for this public key.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
    def to_flagged_bytes(self, ):
        """
        Returns the bytes with signature scheme flag prepended
        """

        raise NotImplementedError
# Secp256r1PublicKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256r1PublicKey():
    """
    A secp256r1 signature.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256r1-signature = 64OCTECT
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1publickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1publickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1publickey_generate,)
        return cls._make_instance_(pointer)



    def derive_address(self, ) -> "Address":
        """
        Derive an `Address` from this Public Key

        An `Address` can be derived from a `Secp256r1PublicKey` by hashing the
        bytes of the public key prefixed with the Secp256r1
        `SignatureScheme` flag (`0x02`).

        `hash( 0x02 || 33-byte secp256r1 public key)`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_derive_address,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        """
        Returns the signature scheme for this public key.
        """

        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_scheme,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_flagged_bytes(self, ) -> "bytes":
        """
        Returns the bytes with signature scheme flag prepended
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1publickey_to_flagged_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSecp256r1PublicKey:

    @staticmethod
    def lift(value: int):
        return Secp256r1PublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256r1PublicKey):
        if not isinstance(value, Secp256r1PublicKey):
            raise TypeError("Expected Secp256r1PublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256r1PublicKeyProtocol):
        if not isinstance(value, Secp256r1PublicKey):
            raise TypeError("Expected Secp256r1PublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256r1PublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256r1SignatureProtocol(typing.Protocol):
    """
    A secp256r1 public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256r1-public-key = 33OCTECT
    ```
    """

    def to_bytes(self, ):
        raise NotImplementedError
# Secp256r1Signature is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256r1Signature():
    """
    A secp256r1 public key.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    secp256r1-public-key = 33OCTECT
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1signature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1signature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_str(cls, s: "str"):
        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_from_str,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def generate(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1signature_generate,)
        return cls._make_instance_(pointer)



    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1signature_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSecp256r1Signature:

    @staticmethod
    def lift(value: int):
        return Secp256r1Signature._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256r1Signature):
        if not isinstance(value, Secp256r1Signature):
            raise TypeError("Expected Secp256r1Signature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256r1SignatureProtocol):
        if not isinstance(value, Secp256r1Signature):
            raise TypeError("Expected Secp256r1Signature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256r1SignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256r1VerifierProtocol(typing.Protocol):
    def verify_simple(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
    def verify_user(self, message: "bytes",signature: "UserSignature"):
        raise NotImplementedError
# Secp256r1Verifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256r1Verifier():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifier_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1verifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def verify_simple(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))






    def verify_user(self, message: "bytes",signature: "UserSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifier_verify_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeUserSignature.lower(signature))







class _UniffiConverterTypeSecp256r1Verifier:

    @staticmethod
    def lift(value: int):
        return Secp256r1Verifier._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256r1Verifier):
        if not isinstance(value, Secp256r1Verifier):
            raise TypeError("Expected Secp256r1Verifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256r1VerifierProtocol):
        if not isinstance(value, Secp256r1Verifier):
            raise TypeError("Expected Secp256r1Verifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256r1VerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class Secp256r1VerifyingKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this public key as DER-encoded data.
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this public key into PEM.
        """

        raise NotImplementedError
    def verify(self, message: "bytes",signature: "Secp256r1Signature"):
        raise NotImplementedError
    def verify_simple(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
    def verify_user(self, message: "bytes",signature: "UserSignature"):
        raise NotImplementedError
# Secp256r1VerifyingKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class Secp256r1VerifyingKey():
    _pointer: ctypes.c_void_p
    def __init__(self, public_key: "Secp256r1PublicKey"):
        _UniffiConverterTypeSecp256r1PublicKey.check_lower(public_key)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_new,
        _UniffiConverterTypeSecp256r1PublicKey.lower(public_key))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_secp256r1verifyingkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_secp256r1verifyingkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize public key from ASN.1 DER-encoded data (binary format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize public key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_secp256r1verifyingkey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "Secp256r1PublicKey":
        return _UniffiConverterTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_public_key,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this public key as DER-encoded data.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this public key into PEM.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_to_pem,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",signature: "Secp256r1Signature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSecp256r1Signature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSecp256r1Signature.lower(signature))






    def verify_simple(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_simple,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))






    def verify_user(self, message: "bytes",signature: "UserSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_secp256r1verifyingkey_verify_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeUserSignature.lower(signature))







class _UniffiConverterTypeSecp256r1VerifyingKey:

    @staticmethod
    def lift(value: int):
        return Secp256r1VerifyingKey._make_instance_(value)

    @staticmethod
    def check_lower(value: Secp256r1VerifyingKey):
        if not isinstance(value, Secp256r1VerifyingKey):
            raise TypeError("Expected Secp256r1VerifyingKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: Secp256r1VerifyingKeyProtocol):
        if not isinstance(value, Secp256r1VerifyingKey):
            raise TypeError("Expected Secp256r1VerifyingKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: Secp256r1VerifyingKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SimpleKeypairProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def sign_personal_message(self, message: "PersonalMessage"):
        """
        Sign a personal message and return a UserSignature.
        """

        raise NotImplementedError
    def sign_transaction(self, transaction: "Transaction"):
        """
        Sign a transaction and return a UserSignature.
        """

        raise NotImplementedError
    def to_bech32(self, ):
        """
        Encode a SimpleKeypair as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string. Note that the pubkey is not encoded.
        """

        raise NotImplementedError
    def to_bytes(self, ):
        """
        Encode a SimpleKeypair as `flag || privkey` in bytes
        """

        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def try_sign(self, message: "bytes"):
        raise NotImplementedError
    def try_sign_user(self, message: "bytes"):
        raise NotImplementedError
    def verifying_key(self, ):
        raise NotImplementedError
# SimpleKeypair is a Rust-only trait - it's a wrapper around a Rust implementation.
class SimpleKeypair():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simplekeypair, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simplekeypair, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_bech32(cls, value: "str"):
        """
        Decode a SimpleKeypair from `flag || privkey` in Bech32 starting with
        "iotaprivkey" to SimpleKeypair. The public key is computed directly from
        the private key bytes.
        """

        _UniffiConverterString.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bech32,
        _UniffiConverterString.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        """
        Decode a SimpleKeypair from `flag || privkey` bytes
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
        format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_ed25519(cls, keypair: "Ed25519PrivateKey"):
        _UniffiConverterTypeEd25519PrivateKey.check_lower(keypair)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_ed25519,
        _UniffiConverterTypeEd25519PrivateKey.lower(keypair))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize PKCS#8-encoded private key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)

    @classmethod
    def from_secp256k1(cls, keypair: "Secp256k1PrivateKey"):
        _UniffiConverterTypeSecp256k1PrivateKey.check_lower(keypair)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256k1,
        _UniffiConverterTypeSecp256k1PrivateKey.lower(keypair))
        return cls._make_instance_(pointer)

    @classmethod
    def from_secp256r1(cls, keypair: "Secp256r1PrivateKey"):
        _UniffiConverterTypeSecp256r1PrivateKey.check_lower(keypair)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplekeypair_from_secp256r1,
        _UniffiConverterTypeSecp256r1PrivateKey.lower(keypair))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "MultisigMemberPublicKey":
        return _UniffiConverterTypeMultisigMemberPublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_public_key,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_scheme,self._uniffi_clone_pointer(),)
        )





    def sign_personal_message(self, message: "PersonalMessage") -> "UserSignature":
        """
        Sign a personal message and return a UserSignature.
        """

        _UniffiConverterTypePersonalMessage.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_personal_message,self._uniffi_clone_pointer(),
        _UniffiConverterTypePersonalMessage.lower(message))
        )





    def sign_transaction(self, transaction: "Transaction") -> "UserSignature":
        """
        Sign a transaction and return a UserSignature.
        """

        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_sign_transaction,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))
        )





    def to_bech32(self, ) -> "str":
        """
        Encode a SimpleKeypair as `flag || privkey` in Bech32 starting with
        "iotaprivkey" to a string. Note that the pubkey is not encoded.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bech32,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        """
        Encode a SimpleKeypair as `flag || privkey` in bytes
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_bytes,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_to_pem,self._uniffi_clone_pointer(),)
        )





    def try_sign(self, message: "bytes") -> "SimpleSignature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def try_sign_user(self, message: "bytes") -> "UserSignature":
        _UniffiConverterBytes.check_lower(message)
        
        return _UniffiConverterTypeUserSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_try_sign_user,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message))
        )





    def verifying_key(self, ) -> "SimpleVerifyingKey":
        return _UniffiConverterTypeSimpleVerifyingKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplekeypair_verifying_key,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSimpleKeypair:

    @staticmethod
    def lift(value: int):
        return SimpleKeypair._make_instance_(value)

    @staticmethod
    def check_lower(value: SimpleKeypair):
        if not isinstance(value, SimpleKeypair):
            raise TypeError("Expected SimpleKeypair instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SimpleKeypairProtocol):
        if not isinstance(value, SimpleKeypair):
            raise TypeError("Expected SimpleKeypair instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SimpleKeypairProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SimpleSignatureProtocol(typing.Protocol):
    """
    A basic signature

    This enumeration defines the set of simple or basic signature schemes
    supported by IOTA. Most signature schemes supported by IOTA end up
    comprising of a at least one simple signature scheme.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    simple-signature-bcs = bytes ; where the contents of the bytes are defined by <simple-signature>
    simple-signature = (ed25519-flag ed25519-signature ed25519-public-key) /
    (secp256k1-flag secp256k1-signature secp256k1-public-key) /
    (secp256r1-flag secp256r1-signature secp256r1-public-key)
    ```

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    def ed25519_pub_key(self, ):
        raise NotImplementedError
    def ed25519_pub_key_opt(self, ):
        raise NotImplementedError
    def ed25519_sig(self, ):
        raise NotImplementedError
    def ed25519_sig_opt(self, ):
        raise NotImplementedError
    def is_ed25519(self, ):
        raise NotImplementedError
    def is_secp256k1(self, ):
        raise NotImplementedError
    def is_secp256r1(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def secp256k1_pub_key(self, ):
        raise NotImplementedError
    def secp256k1_pub_key_opt(self, ):
        raise NotImplementedError
    def secp256k1_sig(self, ):
        raise NotImplementedError
    def secp256k1_sig_opt(self, ):
        raise NotImplementedError
    def secp256r1_pub_key(self, ):
        raise NotImplementedError
    def secp256r1_pub_key_opt(self, ):
        raise NotImplementedError
    def secp256r1_sig(self, ):
        raise NotImplementedError
    def secp256r1_sig_opt(self, ):
        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
# SimpleSignature is a Rust-only trait - it's a wrapper around a Rust implementation.
class SimpleSignature():
    """
    A basic signature

    This enumeration defines the set of simple or basic signature schemes
    supported by IOTA. Most signature schemes supported by IOTA end up
    comprising of a at least one simple signature scheme.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    simple-signature-bcs = bytes ; where the contents of the bytes are defined by <simple-signature>
    simple-signature = (ed25519-flag ed25519-signature ed25519-public-key) /
    (secp256k1-flag secp256k1-signature secp256k1-public-key) /
    (secp256r1-flag secp256r1-signature secp256r1-public-key)
    ```

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simplesignature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simplesignature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_ed25519(cls, signature: "Ed25519Signature",public_key: "Ed25519PublicKey"):
        _UniffiConverterTypeEd25519Signature.check_lower(signature)
        
        _UniffiConverterTypeEd25519PublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_ed25519,
        _UniffiConverterTypeEd25519Signature.lower(signature),
        _UniffiConverterTypeEd25519PublicKey.lower(public_key))
        return cls._make_instance_(pointer)

    @classmethod
    def new_secp256k1(cls, signature: "Secp256k1Signature",public_key: "Secp256k1PublicKey"):
        _UniffiConverterTypeSecp256k1Signature.check_lower(signature)
        
        _UniffiConverterTypeSecp256k1PublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256k1,
        _UniffiConverterTypeSecp256k1Signature.lower(signature),
        _UniffiConverterTypeSecp256k1PublicKey.lower(public_key))
        return cls._make_instance_(pointer)

    @classmethod
    def new_secp256r1(cls, signature: "Secp256r1Signature",public_key: "Secp256r1PublicKey"):
        _UniffiConverterTypeSecp256r1Signature.check_lower(signature)
        
        _UniffiConverterTypeSecp256r1PublicKey.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simplesignature_new_secp256r1,
        _UniffiConverterTypeSecp256r1Signature.lower(signature),
        _UniffiConverterTypeSecp256r1PublicKey.lower(public_key))
        return cls._make_instance_(pointer)



    def ed25519_pub_key(self, ) -> "Ed25519PublicKey":
        return _UniffiConverterTypeEd25519PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key,self._uniffi_clone_pointer(),)
        )





    def ed25519_pub_key_opt(self, ) -> "typing.Optional[Ed25519PublicKey]":
        return _UniffiConverterOptionalTypeEd25519PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_pub_key_opt,self._uniffi_clone_pointer(),)
        )





    def ed25519_sig(self, ) -> "Ed25519Signature":
        return _UniffiConverterTypeEd25519Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig,self._uniffi_clone_pointer(),)
        )





    def ed25519_sig_opt(self, ) -> "typing.Optional[Ed25519Signature]":
        return _UniffiConverterOptionalTypeEd25519Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_ed25519_sig_opt,self._uniffi_clone_pointer(),)
        )





    def is_ed25519(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_ed25519,self._uniffi_clone_pointer(),)
        )





    def is_secp256k1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256k1,self._uniffi_clone_pointer(),)
        )





    def is_secp256r1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_is_secp256r1,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_scheme,self._uniffi_clone_pointer(),)
        )





    def secp256k1_pub_key(self, ) -> "Secp256k1PublicKey":
        return _UniffiConverterTypeSecp256k1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key,self._uniffi_clone_pointer(),)
        )





    def secp256k1_pub_key_opt(self, ) -> "typing.Optional[Secp256k1PublicKey]":
        return _UniffiConverterOptionalTypeSecp256k1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_pub_key_opt,self._uniffi_clone_pointer(),)
        )





    def secp256k1_sig(self, ) -> "Secp256k1Signature":
        return _UniffiConverterTypeSecp256k1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig,self._uniffi_clone_pointer(),)
        )





    def secp256k1_sig_opt(self, ) -> "typing.Optional[Secp256k1Signature]":
        return _UniffiConverterOptionalTypeSecp256k1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256k1_sig_opt,self._uniffi_clone_pointer(),)
        )





    def secp256r1_pub_key(self, ) -> "Secp256r1PublicKey":
        return _UniffiConverterTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key,self._uniffi_clone_pointer(),)
        )





    def secp256r1_pub_key_opt(self, ) -> "typing.Optional[Secp256r1PublicKey]":
        return _UniffiConverterOptionalTypeSecp256r1PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_pub_key_opt,self._uniffi_clone_pointer(),)
        )





    def secp256r1_sig(self, ) -> "Secp256r1Signature":
        return _UniffiConverterTypeSecp256r1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig,self._uniffi_clone_pointer(),)
        )





    def secp256r1_sig_opt(self, ) -> "typing.Optional[Secp256r1Signature]":
        return _UniffiConverterOptionalTypeSecp256r1Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_secp256r1_sig_opt,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simplesignature_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSimpleSignature:

    @staticmethod
    def lift(value: int):
        return SimpleSignature._make_instance_(value)

    @staticmethod
    def check_lower(value: SimpleSignature):
        if not isinstance(value, SimpleSignature):
            raise TypeError("Expected SimpleSignature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SimpleSignatureProtocol):
        if not isinstance(value, SimpleSignature):
            raise TypeError("Expected SimpleSignature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SimpleSignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SimpleVerifierProtocol(typing.Protocol):
    def verify(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
# SimpleVerifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class SimpleVerifier():
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifier_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simpleverifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simpleverifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def verify(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifier_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))







class _UniffiConverterTypeSimpleVerifier:

    @staticmethod
    def lift(value: int):
        return SimpleVerifier._make_instance_(value)

    @staticmethod
    def check_lower(value: SimpleVerifier):
        if not isinstance(value, SimpleVerifier):
            raise TypeError("Expected SimpleVerifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SimpleVerifierProtocol):
        if not isinstance(value, SimpleVerifier):
            raise TypeError("Expected SimpleVerifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SimpleVerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SimpleVerifyingKeyProtocol(typing.Protocol):
    def public_key(self, ):
        raise NotImplementedError
    def scheme(self, ):
        raise NotImplementedError
    def to_der(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def to_pem(self, ):
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        raise NotImplementedError
    def verify(self, message: "bytes",signature: "SimpleSignature"):
        raise NotImplementedError
# SimpleVerifyingKey is a Rust-only trait - it's a wrapper around a Rust implementation.
class SimpleVerifyingKey():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_simpleverifyingkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_simpleverifyingkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_der(cls, bytes: "bytes"):
        """
        Deserialize PKCS#8 private key from ASN.1 DER-encoded data (binary
        format).
        """

        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_der,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def from_pem(cls, s: "str"):
        """
        Deserialize PKCS#8-encoded private key from PEM.
        """

        _UniffiConverterString.check_lower(s)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_simpleverifyingkey_from_pem,
        _UniffiConverterString.lower(s))
        return cls._make_instance_(pointer)



    def public_key(self, ) -> "MultisigMemberPublicKey":
        return _UniffiConverterTypeMultisigMemberPublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_public_key,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_scheme,self._uniffi_clone_pointer(),)
        )





    def to_der(self, ) -> "bytes":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_der,self._uniffi_clone_pointer(),)
        )





    def to_pem(self, ) -> "str":
        """
        Serialize this private key as DER-encoded PKCS#8
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_to_pem,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",signature: "SimpleSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_simpleverifyingkey_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeSimpleSignature.lower(signature))







class _UniffiConverterTypeSimpleVerifyingKey:

    @staticmethod
    def lift(value: int):
        return SimpleVerifyingKey._make_instance_(value)

    @staticmethod
    def check_lower(value: SimpleVerifyingKey):
        if not isinstance(value, SimpleVerifyingKey):
            raise TypeError("Expected SimpleVerifyingKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SimpleVerifyingKeyProtocol):
        if not isinstance(value, SimpleVerifyingKey):
            raise TypeError("Expected SimpleVerifyingKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SimpleVerifyingKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SplitCoinsProtocol(typing.Protocol):
    """
    Command to split a single coin object into multiple coins

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    split-coins = argument (vector argument)
    ```
    """

    def amounts(self, ):
        """
        The amounts to split off
        """

        raise NotImplementedError
    def coin(self, ):
        """
        The coin to split
        """

        raise NotImplementedError
# SplitCoins is a Rust-only trait - it's a wrapper around a Rust implementation.
class SplitCoins():
    """
    Command to split a single coin object into multiple coins

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    split-coins = argument (vector argument)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, coin: "Argument",amounts: "typing.List[Argument]"):
        _UniffiConverterTypeArgument.check_lower(coin)
        
        _UniffiConverterSequenceTypeArgument.check_lower(amounts)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_splitcoins_new,
        _UniffiConverterTypeArgument.lower(coin),
        _UniffiConverterSequenceTypeArgument.lower(amounts))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_splitcoins, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_splitcoins, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def amounts(self, ) -> "typing.List[Argument]":
        """
        The amounts to split off
        """

        return _UniffiConverterSequenceTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_splitcoins_amounts,self._uniffi_clone_pointer(),)
        )





    def coin(self, ) -> "Argument":
        """
        The coin to split
        """

        return _UniffiConverterTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_splitcoins_coin,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSplitCoins:

    @staticmethod
    def lift(value: int):
        return SplitCoins._make_instance_(value)

    @staticmethod
    def check_lower(value: SplitCoins):
        if not isinstance(value, SplitCoins):
            raise TypeError("Expected SplitCoins instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SplitCoinsProtocol):
        if not isinstance(value, SplitCoins):
            raise TypeError("Expected SplitCoins instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SplitCoinsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class StructTagProtocol(typing.Protocol):
    """
    Type information for a move struct

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    struct-tag = address            ; address of the package
    identifier         ; name of the module
    identifier         ; name of the type
    (vector type-tag)  ; type parameters
    ```
    """

    def address(self, ):
        """
        Returns the address part of a `StructTag`
        """

        raise NotImplementedError
    def coin_type(self, ):
        """
        Checks if this is a Coin type
        """

        raise NotImplementedError
    def coin_type_opt(self, ):
        """
        Checks if this is a Coin type
        """

        raise NotImplementedError
    def module(self, ):
        """
        Returns the module part of a `StructTag`
        """

        raise NotImplementedError
    def name(self, ):
        """
        Returns the name part of a `StructTag`
        """

        raise NotImplementedError
    def to_canonical_string(self, with_prefix: "bool"):
        """
        Returns the string representation of this struct tag using the
        canonical display, with or without a `0x` prefix.
        """

        raise NotImplementedError
    def type_args(self, ):
        """
        Returns the type params part of a `StructTag`
        """

        raise NotImplementedError
# StructTag is a Rust-only trait - it's a wrapper around a Rust implementation.
class StructTag():
    """
    Type information for a move struct

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    struct-tag = address            ; address of the package
    identifier         ; name of the module
    identifier         ; name of the type
    (vector type-tag)  ; type parameters
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, address: "Address",module: "Identifier",name: "Identifier",type_params: "typing.Union[object, typing.List[TypeTag]]" = _DEFAULT):
        _UniffiConverterTypeAddress.check_lower(address)
        
        _UniffiConverterTypeIdentifier.check_lower(module)
        
        _UniffiConverterTypeIdentifier.check_lower(name)
        
        if type_params is _DEFAULT:
            type_params = []
        _UniffiConverterSequenceTypeTypeTag.check_lower(type_params)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new,
        _UniffiConverterTypeAddress.lower(address),
        _UniffiConverterTypeIdentifier.lower(module),
        _UniffiConverterTypeIdentifier.lower(name),
        _UniffiConverterSequenceTypeTypeTag.lower(type_params))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_structtag, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_structtag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_ascii_string(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_ascii_string,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_balance(cls, type_tag: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_balance,
        _UniffiConverterTypeTypeTag.lower(type_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_clock(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_clock,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_coin(cls, type_tag: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin,
        _UniffiConverterTypeTypeTag.lower(type_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_coin_manager(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_manager,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_coin_metadata(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_coin_metadata,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_config(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_config_setting(cls, type_tag: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_config_setting,
        _UniffiConverterTypeTypeTag.lower(type_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_deny_list_address_key(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_address_key,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_deny_list_config_key(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_config_key,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_deny_list_global_pause_key(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_deny_list_global_pause_key,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_display_created(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_display_created,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_dynamic_object_field_wrapper(cls, type_tag: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_dynamic_object_field_wrapper,
        _UniffiConverterTypeTypeTag.lower(type_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_field(cls, key: "TypeTag",value: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(key)
        
        _UniffiConverterTypeTypeTag.check_lower(value)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_field,
        _UniffiConverterTypeTypeTag.lower(key),
        _UniffiConverterTypeTypeTag.lower(value))
        return cls._make_instance_(pointer)

    @classmethod
    def new_gas_coin(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_gas_coin,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_id(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_id,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_iota_coin_type(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_coin_type,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_iota_system_admin_cap(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_admin_cap,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_iota_system_state(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_system_state,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_iota_treasury_cap(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_iota_treasury_cap,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_name(cls, address: "Address"):
        _UniffiConverterTypeAddress.check_lower(address)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_name,
        _UniffiConverterTypeAddress.lower(address))
        return cls._make_instance_(pointer)

    @classmethod
    def new_staked_iota(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_staked_iota,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_string(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_string,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_system_epoch_info_event(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_system_epoch_info_event,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_time_lock(cls, type_tag: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_time_lock,
        _UniffiConverterTypeTypeTag.lower(type_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_timelocked_staked_iota(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_timelocked_staked_iota,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_transfer_receiving(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_transfer_receiving,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_treasury_cap(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_treasury_cap,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_uid(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_uid,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_upgrade_cap(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_cap,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_upgrade_receipt(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_receipt,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_upgrade_ticket(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_upgrade_ticket,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_version_updated(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_structtag_new_version_updated,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)



    def address(self, ) -> "Address":
        """
        Returns the address part of a `StructTag`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_address,self._uniffi_clone_pointer(),)
        )





    def coin_type(self, ) -> "TypeTag":
        """
        Checks if this is a Coin type
        """

        return _UniffiConverterTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type,self._uniffi_clone_pointer(),)
        )





    def coin_type_opt(self, ) -> "typing.Optional[TypeTag]":
        """
        Checks if this is a Coin type
        """

        return _UniffiConverterOptionalTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_coin_type_opt,self._uniffi_clone_pointer(),)
        )





    def module(self, ) -> "Identifier":
        """
        Returns the module part of a `StructTag`
        """

        return _UniffiConverterTypeIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_module,self._uniffi_clone_pointer(),)
        )





    def name(self, ) -> "Identifier":
        """
        Returns the name part of a `StructTag`
        """

        return _UniffiConverterTypeIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_name,self._uniffi_clone_pointer(),)
        )





    def to_canonical_string(self, with_prefix: "bool") -> "str":
        """
        Returns the string representation of this struct tag using the
        canonical display, with or without a `0x` prefix.
        """

        _UniffiConverterBool.check_lower(with_prefix)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_to_canonical_string,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(with_prefix))
        )





    def type_args(self, ) -> "typing.List[TypeTag]":
        """
        Returns the type params part of a `StructTag`
        """

        return _UniffiConverterSequenceTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_type_args,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, StructTag):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeStructTag.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, StructTag):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_structtag_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeStructTag.lower(other)))



class _UniffiConverterTypeStructTag:

    @staticmethod
    def lift(value: int):
        return StructTag._make_instance_(value)

    @staticmethod
    def check_lower(value: StructTag):
        if not isinstance(value, StructTag):
            raise TypeError("Expected StructTag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: StructTagProtocol):
        if not isinstance(value, StructTag):
            raise TypeError("Expected StructTag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: StructTagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SystemPackageProtocol(typing.Protocol):
    """
    System package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    system-package = u64                ; version
    (vector bytes)     ; modules
    (vector object-id) ; dependencies
    ```
    """

    def dependencies(self, ):
        raise NotImplementedError
    def modules(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
# SystemPackage is a Rust-only trait - it's a wrapper around a Rust implementation.
class SystemPackage():
    """
    System package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    system-package = u64                ; version
    (vector bytes)     ; modules
    (vector object-id) ; dependencies
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, version: "int",modules: "typing.List[bytes]",dependencies: "typing.List[ObjectId]"):
        _UniffiConverterUInt64.check_lower(version)
        
        _UniffiConverterSequenceBytes.check_lower(modules)
        
        _UniffiConverterSequenceTypeObjectId.check_lower(dependencies)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_systempackage_new,
        _UniffiConverterUInt64.lower(version),
        _UniffiConverterSequenceBytes.lower(modules),
        _UniffiConverterSequenceTypeObjectId.lower(dependencies))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_systempackage, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_systempackage, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def dependencies(self, ) -> "typing.List[ObjectId]":
        return _UniffiConverterSequenceTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_dependencies,self._uniffi_clone_pointer(),)
        )





    def modules(self, ) -> "typing.List[bytes]":
        return _UniffiConverterSequenceBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_modules,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_systempackage_version,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSystemPackage:

    @staticmethod
    def lift(value: int):
        return SystemPackage._make_instance_(value)

    @staticmethod
    def check_lower(value: SystemPackage):
        if not isinstance(value, SystemPackage):
            raise TypeError("Expected SystemPackage instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SystemPackageProtocol):
        if not isinstance(value, SystemPackage):
            raise TypeError("Expected SystemPackage instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SystemPackageProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionProtocol(typing.Protocol):
    """
    Transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction = %x00 transaction-v1

    transaction-v1 = transaction-kind address gas-payment transaction-expiration
    ```
    """

    def as_v1(self, ):
        raise NotImplementedError
    def digest(self, ):
        raise NotImplementedError
    def expiration(self, ):
        raise NotImplementedError
    def gas_payment(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def sender(self, ):
        raise NotImplementedError
    def signing_digest(self, ):
        """
        Get the signing digest.
        """

        raise NotImplementedError
    def signing_digest_hex(self, ):
        """
        Get the signing digest as a hex string.
        """

        raise NotImplementedError
    def to_base64(self, ):
        """
        Serialize the transaction as a base64-encoded string.
        """

        raise NotImplementedError
# Transaction is a Rust-only trait - it's a wrapper around a Rust implementation.
class Transaction():
    """
    Transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction = %x00 transaction-v1

    transaction-v1 = transaction-kind address gas-payment transaction-expiration
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_base64(cls, base64: "str"):
        """
        Deserialize a transaction from a base64-encoded string.
        """

        _UniffiConverterString.check_lower(base64)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transaction_from_base64,
        _UniffiConverterString.lower(base64))
        return cls._make_instance_(pointer)

    @classmethod
    def new_v1(cls, transaction_v1: "TransactionV1"):
        _UniffiConverterTypeTransactionV1.check_lower(transaction_v1)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transaction_new_v1,
        _UniffiConverterTypeTransactionV1.lower(transaction_v1))
        return cls._make_instance_(pointer)



    def as_v1(self, ) -> "TransactionV1":
        return _UniffiConverterTypeTransactionV1.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_as_v1,self._uniffi_clone_pointer(),)
        )





    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_digest,self._uniffi_clone_pointer(),)
        )





    def expiration(self, ) -> "TransactionExpiration":
        return _UniffiConverterTypeTransactionExpiration.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_expiration,self._uniffi_clone_pointer(),)
        )





    def gas_payment(self, ) -> "GasPayment":
        return _UniffiConverterTypeGasPayment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_gas_payment,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "TransactionKind":
        return _UniffiConverterTypeTransactionKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_kind,self._uniffi_clone_pointer(),)
        )





    def sender(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_sender,self._uniffi_clone_pointer(),)
        )





    def signing_digest(self, ) -> "bytes":
        """
        Get the signing digest.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest,self._uniffi_clone_pointer(),)
        )





    def signing_digest_hex(self, ) -> "str":
        """
        Get the signing digest as a hex string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_signing_digest_hex,self._uniffi_clone_pointer(),)
        )





    def to_base64(self, ) -> "str":
        """
        Serialize the transaction as a base64-encoded string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transaction_to_base64,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransaction:

    @staticmethod
    def lift(value: int):
        return Transaction._make_instance_(value)

    @staticmethod
    def check_lower(value: Transaction):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionProtocol):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionBuilderProtocol(typing.Protocol):
    """
    A builder for creating transactions. Use `finish` to finalize the
    transaction data.
    """

    def execute_with_gas_station(self, keypair: "SimpleKeypair"):
        """
        Execute the transaction using the gas station and return the JSON
        transaction effects. This will fail unless data is set with the
        `gas_station_sponsor` function.

        NOTE: These effects are not necessarily compatible with
        `TransactionEffects`
        """

        raise NotImplementedError
    def expiration(self, epoch: "int"):
        """
        Set the expiration of the transaction to be a specific epoch.
        """

        raise NotImplementedError
    def finish(self, ):
        """
        Convert this builder into a transaction.
        """

        raise NotImplementedError
    def gas(self, object_refs: "typing.List[ObjectReference]"):
        """
        Add gas coins that will be consumed. Optional.
        """

        raise NotImplementedError
    def gas_budget(self, budget: "int"):
        """
        Set the gas budget for the transaction.
        """

        raise NotImplementedError
    def gas_price(self, price: "int"):
        """
        Set the gas price for the transaction.
        """

        raise NotImplementedError
    def gas_station_sponsor(self, url: "str",duration: "typing.Union[object, typing.Optional[Duration]]" = _DEFAULT,headers: "typing.Union[object, typing.Optional[dict[str, typing.List[str]]]]" = _DEFAULT):
        """
        Set the gas station sponsor.
        """

        raise NotImplementedError
    def make_move_vec(self, elements: "typing.List[MoveArg]",type_tag: "TypeTag",name: "str"):
        """
        Make a move vector from a list of elements. The elements must all be of
        the type indicated by `type_tag`.
        """

        raise NotImplementedError
    def merge_coins(self, primary_coin: "PtbArgument",consumed_coins: "typing.List[PtbArgument]"):
        """
        Merge multiple coins into one.

        This method combines the balances of multiple coins of the same coin
        type into a single coin. The `primary_coin` will receive the balances
        from all `consumed_coins`. After merging, the `consumed_coins` will
        be consumed and no longer exist.
        """

        raise NotImplementedError
    def move_call(self, package: "Address",module: "Identifier",function: "Identifier",arguments: "typing.Union[object, typing.List[PtbArgument]]" = _DEFAULT,type_args: "typing.Union[object, typing.List[TypeTag]]" = _DEFAULT,names: "typing.Union[object, typing.List[str]]" = _DEFAULT):
        """
        Call a Move function with the given arguments.
        """

        raise NotImplementedError
    def publish(self, package_data: "MovePackageData",upgrade_cap_name: "str"):
        """
        Publish a list of modules with the given dependencies. The result
        assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
        Move type. Note that the upgrade capability needs to be handled
        after this call:
        - transfer it to the transaction sender or another address
        - burn it
        - wrap it for access control
        - discard the it to make a package immutable

        The arguments required for this command are:
        - `modules`: is the modules' bytecode to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package
        """

        raise NotImplementedError
    def send_coins(self, coins: "typing.List[PtbArgument]",recipient: "Address",amount: "typing.Union[object, typing.Optional[PtbArgument]]" = _DEFAULT):
        """
        Transfer some coins to a recipient address. If multiple coins are
        provided then they will be merged.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS.
        If `amount` is provided, that amount is split from the provided coins
        and sent.
        If `amount` is `None`, the entire coins are transferred.

        All provided coins must have the same coin type. Mixing coins of
        different types will result in an error.

        If you intend to transfer all provided coins to another address in a
        single transaction, consider using
        `TransactionBuilder::transfer_objects()` instead.
        """

        raise NotImplementedError
    def send_iota(self, recipient: "Address",amount: "PtbArgument"):
        """
        Send IOTA to a recipient address.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS. That amount is split from the gas coin and
        sent.
        """

        raise NotImplementedError
    def split_coins(self, coin: "PtbArgument",amounts: "typing.List[PtbArgument]",names: "typing.Union[object, typing.List[str]]" = _DEFAULT):
        """
        Split a coin by the provided amounts.
        """

        raise NotImplementedError
    def sponsor(self, sponsor: "Address"):
        """
        Set the sponsor of the transaction.
        """

        raise NotImplementedError
    def stake(self, stake: "PtbArgument",validator_address: "Address"):
        """
        Add stake to a validator's staking pool.

        This is a high-level function which will split the provided stake amount
        from the gas coin and then stake using the resulting coin.
        """

        raise NotImplementedError
    def transfer_objects(self, recipient: "Address",objects: "typing.List[PtbArgument]"):
        """
        Transfer a list of objects to the given address, without producing any
        result.
        """

        raise NotImplementedError
    def unstake(self, staked_iota: "PtbArgument"):
        """
        Withdraw stake from a validator's staking pool.
        """

        raise NotImplementedError
    def upgrade(self, package_id: "ObjectId",package_data: "MovePackageData",upgrade_ticket: "PtbArgument",name: "typing.Union[object, typing.Optional[str]]" = _DEFAULT):
        """
        Upgrade a Move package.

        - `modules`: is the modules' bytecode for the modules to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package to be upgraded
        - `package`: is the ID of the current package being upgraded
        - `ticket`: is the upgrade ticket

        To get the ticket, you have to call the
        `0x2::package::authorize_upgrade` function, and pass the package
        ID, the upgrade policy, and package digest.
        """

        raise NotImplementedError
    def with_client(self, client: "GraphQlClient"):
        raise NotImplementedError
# TransactionBuilder is a Rust-only trait - it's a wrapper around a Rust implementation.
class TransactionBuilder():
    """
    A builder for creating transactions. Use `finish` to finalize the
    transaction data.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, sender: "Address"):
        """
        Create a new transaction builder and initialize its elements to default.
        """

        _UniffiConverterTypeAddress.check_lower(sender)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionbuilder_new,
        _UniffiConverterTypeAddress.lower(sender))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    async def execute_with_gas_station(self, keypair: "SimpleKeypair") -> "Value":
        """
        Execute the transaction using the gas station and return the JSON
        transaction effects. This will fail unless data is set with the
        `gas_station_sponsor` function.

        NOTE: These effects are not necessarily compatible with
        `TransactionEffects`
        """

        _UniffiConverterTypeSimpleKeypair.check_lower(keypair)
        
        return await _uniffi_rust_call_async(
            _UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_execute_with_gas_station(
                self._uniffi_clone_pointer(), 
        _UniffiConverterTypeSimpleKeypair.lower(keypair)
            ),
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_poll_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_complete_rust_buffer,
            _UniffiLib.ffi_iota_sdk_ffi_rust_future_free_rust_buffer,
            # lift function
            _UniffiConverterTypeValue.lift,
            
    # Error FFI converter
_UniffiConverterTypeSdkFfiError,

        )




    def expiration(self, epoch: "int") -> "TransactionBuilder":
        """
        Set the expiration of the transaction to be a specific epoch.
        """

        _UniffiConverterUInt64.check_lower(epoch)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_expiration,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(epoch))
        )





    def finish(self, ) -> "Transaction":
        """
        Convert this builder into a transaction.
        """

        return _UniffiConverterTypeTransaction.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_finish,self._uniffi_clone_pointer(),)
        )





    def gas(self, object_refs: "typing.List[ObjectReference]") -> "TransactionBuilder":
        """
        Add gas coins that will be consumed. Optional.
        """

        _UniffiConverterSequenceTypeObjectReference.check_lower(object_refs)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeObjectReference.lower(object_refs))
        )





    def gas_budget(self, budget: "int") -> "TransactionBuilder":
        """
        Set the gas budget for the transaction.
        """

        _UniffiConverterUInt64.check_lower(budget)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_budget,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(budget))
        )





    def gas_price(self, price: "int") -> "TransactionBuilder":
        """
        Set the gas price for the transaction.
        """

        _UniffiConverterUInt64.check_lower(price)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_price,self._uniffi_clone_pointer(),
        _UniffiConverterUInt64.lower(price))
        )





    def gas_station_sponsor(self, url: "str",duration: "typing.Union[object, typing.Optional[Duration]]" = _DEFAULT,headers: "typing.Union[object, typing.Optional[dict[str, typing.List[str]]]]" = _DEFAULT) -> "TransactionBuilder":
        """
        Set the gas station sponsor.
        """

        _UniffiConverterString.check_lower(url)
        
        if duration is _DEFAULT:
            duration = None
        _UniffiConverterOptionalDuration.check_lower(duration)
        
        if headers is _DEFAULT:
            headers = None
        _UniffiConverterOptionalMapStringSequenceString.check_lower(headers)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_gas_station_sponsor,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(url),
        _UniffiConverterOptionalDuration.lower(duration),
        _UniffiConverterOptionalMapStringSequenceString.lower(headers))
        )





    def make_move_vec(self, elements: "typing.List[MoveArg]",type_tag: "TypeTag",name: "str") -> "TransactionBuilder":
        """
        Make a move vector from a list of elements. The elements must all be of
        the type indicated by `type_tag`.
        """

        _UniffiConverterSequenceTypeMoveArg.check_lower(elements)
        
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        _UniffiConverterString.check_lower(name)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_make_move_vec,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeMoveArg.lower(elements),
        _UniffiConverterTypeTypeTag.lower(type_tag),
        _UniffiConverterString.lower(name))
        )





    def merge_coins(self, primary_coin: "PtbArgument",consumed_coins: "typing.List[PtbArgument]") -> "TransactionBuilder":
        """
        Merge multiple coins into one.

        This method combines the balances of multiple coins of the same coin
        type into a single coin. The `primary_coin` will receive the balances
        from all `consumed_coins`. After merging, the `consumed_coins` will
        be consumed and no longer exist.
        """

        _UniffiConverterTypePtbArgument.check_lower(primary_coin)
        
        _UniffiConverterSequenceTypePtbArgument.check_lower(consumed_coins)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_merge_coins,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(primary_coin),
        _UniffiConverterSequenceTypePtbArgument.lower(consumed_coins))
        )





    def move_call(self, package: "Address",module: "Identifier",function: "Identifier",arguments: "typing.Union[object, typing.List[PtbArgument]]" = _DEFAULT,type_args: "typing.Union[object, typing.List[TypeTag]]" = _DEFAULT,names: "typing.Union[object, typing.List[str]]" = _DEFAULT) -> "TransactionBuilder":
        """
        Call a Move function with the given arguments.
        """

        _UniffiConverterTypeAddress.check_lower(package)
        
        _UniffiConverterTypeIdentifier.check_lower(module)
        
        _UniffiConverterTypeIdentifier.check_lower(function)
        
        if arguments is _DEFAULT:
            arguments = []
        _UniffiConverterSequenceTypePtbArgument.check_lower(arguments)
        
        if type_args is _DEFAULT:
            type_args = []
        _UniffiConverterSequenceTypeTypeTag.check_lower(type_args)
        
        if names is _DEFAULT:
            names = []
        _UniffiConverterSequenceString.check_lower(names)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_move_call,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(package),
        _UniffiConverterTypeIdentifier.lower(module),
        _UniffiConverterTypeIdentifier.lower(function),
        _UniffiConverterSequenceTypePtbArgument.lower(arguments),
        _UniffiConverterSequenceTypeTypeTag.lower(type_args),
        _UniffiConverterSequenceString.lower(names))
        )





    def publish(self, package_data: "MovePackageData",upgrade_cap_name: "str") -> "TransactionBuilder":
        """
        Publish a list of modules with the given dependencies. The result
        assigned to `upgrade_cap_name` is the `0x2::package::UpgradeCap`
        Move type. Note that the upgrade capability needs to be handled
        after this call:
        - transfer it to the transaction sender or another address
        - burn it
        - wrap it for access control
        - discard the it to make a package immutable

        The arguments required for this command are:
        - `modules`: is the modules' bytecode to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package
        """

        _UniffiConverterTypeMovePackageData.check_lower(package_data)
        
        _UniffiConverterString.check_lower(upgrade_cap_name)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_publish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeMovePackageData.lower(package_data),
        _UniffiConverterString.lower(upgrade_cap_name))
        )





    def send_coins(self, coins: "typing.List[PtbArgument]",recipient: "Address",amount: "typing.Union[object, typing.Optional[PtbArgument]]" = _DEFAULT) -> "TransactionBuilder":
        """
        Transfer some coins to a recipient address. If multiple coins are
        provided then they will be merged.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS.
        If `amount` is provided, that amount is split from the provided coins
        and sent.
        If `amount` is `None`, the entire coins are transferred.

        All provided coins must have the same coin type. Mixing coins of
        different types will result in an error.

        If you intend to transfer all provided coins to another address in a
        single transaction, consider using
        `TransactionBuilder::transfer_objects()` instead.
        """

        _UniffiConverterSequenceTypePtbArgument.check_lower(coins)
        
        _UniffiConverterTypeAddress.check_lower(recipient)
        
        if amount is _DEFAULT:
            amount = None
        _UniffiConverterOptionalTypePtbArgument.check_lower(amount)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_coins,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypePtbArgument.lower(coins),
        _UniffiConverterTypeAddress.lower(recipient),
        _UniffiConverterOptionalTypePtbArgument.lower(amount))
        )





    def send_iota(self, recipient: "Address",amount: "PtbArgument") -> "TransactionBuilder":
        """
        Send IOTA to a recipient address.

        The `amount` parameter specifies the quantity in NANOS, where 1 IOTA
        equals 1_000_000_000 NANOS. That amount is split from the gas coin and
        sent.
        """

        _UniffiConverterTypeAddress.check_lower(recipient)
        
        _UniffiConverterTypePtbArgument.check_lower(amount)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_send_iota,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(recipient),
        _UniffiConverterTypePtbArgument.lower(amount))
        )





    def split_coins(self, coin: "PtbArgument",amounts: "typing.List[PtbArgument]",names: "typing.Union[object, typing.List[str]]" = _DEFAULT) -> "TransactionBuilder":
        """
        Split a coin by the provided amounts.
        """

        _UniffiConverterTypePtbArgument.check_lower(coin)
        
        _UniffiConverterSequenceTypePtbArgument.check_lower(amounts)
        
        if names is _DEFAULT:
            names = []
        _UniffiConverterSequenceString.check_lower(names)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_split_coins,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(coin),
        _UniffiConverterSequenceTypePtbArgument.lower(amounts),
        _UniffiConverterSequenceString.lower(names))
        )





    def sponsor(self, sponsor: "Address") -> "TransactionBuilder":
        """
        Set the sponsor of the transaction.
        """

        _UniffiConverterTypeAddress.check_lower(sponsor)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_sponsor,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(sponsor))
        )





    def stake(self, stake: "PtbArgument",validator_address: "Address") -> "TransactionBuilder":
        """
        Add stake to a validator's staking pool.

        This is a high-level function which will split the provided stake amount
        from the gas coin and then stake using the resulting coin.
        """

        _UniffiConverterTypePtbArgument.check_lower(stake)
        
        _UniffiConverterTypeAddress.check_lower(validator_address)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_stake,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(stake),
        _UniffiConverterTypeAddress.lower(validator_address))
        )





    def transfer_objects(self, recipient: "Address",objects: "typing.List[PtbArgument]") -> "TransactionBuilder":
        """
        Transfer a list of objects to the given address, without producing any
        result.
        """

        _UniffiConverterTypeAddress.check_lower(recipient)
        
        _UniffiConverterSequenceTypePtbArgument.check_lower(objects)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_transfer_objects,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAddress.lower(recipient),
        _UniffiConverterSequenceTypePtbArgument.lower(objects))
        )





    def unstake(self, staked_iota: "PtbArgument") -> "TransactionBuilder":
        """
        Withdraw stake from a validator's staking pool.
        """

        _UniffiConverterTypePtbArgument.check_lower(staked_iota)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_unstake,self._uniffi_clone_pointer(),
        _UniffiConverterTypePtbArgument.lower(staked_iota))
        )





    def upgrade(self, package_id: "ObjectId",package_data: "MovePackageData",upgrade_ticket: "PtbArgument",name: "typing.Union[object, typing.Optional[str]]" = _DEFAULT) -> "TransactionBuilder":
        """
        Upgrade a Move package.

        - `modules`: is the modules' bytecode for the modules to be published
        - `dependencies`: is the list of IDs of the transitive dependencies of
        the package to be upgraded
        - `package`: is the ID of the current package being upgraded
        - `ticket`: is the upgrade ticket

        To get the ticket, you have to call the
        `0x2::package::authorize_upgrade` function, and pass the package
        ID, the upgrade policy, and package digest.
        """

        _UniffiConverterTypeObjectId.check_lower(package_id)
        
        _UniffiConverterTypeMovePackageData.check_lower(package_data)
        
        _UniffiConverterTypePtbArgument.check_lower(upgrade_ticket)
        
        if name is _DEFAULT:
            name = None
        _UniffiConverterOptionalString.check_lower(name)
        
        return _UniffiConverterTypeTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_upgrade,self._uniffi_clone_pointer(),
        _UniffiConverterTypeObjectId.lower(package_id),
        _UniffiConverterTypeMovePackageData.lower(package_data),
        _UniffiConverterTypePtbArgument.lower(upgrade_ticket),
        _UniffiConverterOptionalString.lower(name))
        )





    def with_client(self, client: "GraphQlClient") -> "ClientTransactionBuilder":
        _UniffiConverterTypeGraphQlClient.check_lower(client)
        
        return _UniffiConverterTypeClientTransactionBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionbuilder_with_client,self._uniffi_clone_pointer(),
        _UniffiConverterTypeGraphQlClient.lower(client))
        )






class _UniffiConverterTypeTransactionBuilder:

    @staticmethod
    def lift(value: int):
        return TransactionBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionBuilder):
        if not isinstance(value, TransactionBuilder):
            raise TypeError("Expected TransactionBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionBuilderProtocol):
        if not isinstance(value, TransactionBuilder):
            raise TypeError("Expected TransactionBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionEffectsProtocol(typing.Protocol):
    """
    The output or effects of executing a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-effects =  %x00 effects-v1
    =/ %x01 effects-v2
    ```
    """

    def as_v1(self, ):
        raise NotImplementedError
    def digest(self, ):
        raise NotImplementedError
    def is_v1(self, ):
        raise NotImplementedError
# TransactionEffects is a Rust-only trait - it's a wrapper around a Rust implementation.
class TransactionEffects():
    """
    The output or effects of executing a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-effects =  %x00 effects-v1
    =/ %x01 effects-v2
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactioneffects, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactioneffects, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_v1(cls, effects: "TransactionEffectsV1"):
        _UniffiConverterTypeTransactionEffectsV1.check_lower(effects)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactioneffects_new_v1,
        _UniffiConverterTypeTransactionEffectsV1.lower(effects))
        return cls._make_instance_(pointer)



    def as_v1(self, ) -> "TransactionEffectsV1":
        return _UniffiConverterTypeTransactionEffectsV1.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_as_v1,self._uniffi_clone_pointer(),)
        )





    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_digest,self._uniffi_clone_pointer(),)
        )





    def is_v1(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactioneffects_is_v1,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransactionEffects:

    @staticmethod
    def lift(value: int):
        return TransactionEffects._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionEffects):
        if not isinstance(value, TransactionEffects):
            raise TypeError("Expected TransactionEffects instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionEffectsProtocol):
        if not isinstance(value, TransactionEffects):
            raise TypeError("Expected TransactionEffects instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionEffectsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionEventsProtocol(typing.Protocol):
    """
    Events emitted during the successful execution of a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-events = vector event
    ```
    """

    def digest(self, ):
        raise NotImplementedError
    def events(self, ):
        raise NotImplementedError
# TransactionEvents is a Rust-only trait - it's a wrapper around a Rust implementation.
class TransactionEvents():
    """
    Events emitted during the successful execution of a transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-events = vector event
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, events: "typing.List[Event]"):
        _UniffiConverterSequenceTypeEvent.check_lower(events)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionevents_new,
        _UniffiConverterSequenceTypeEvent.lower(events))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionevents, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionevents, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionevents_digest,self._uniffi_clone_pointer(),)
        )





    def events(self, ) -> "typing.List[Event]":
        return _UniffiConverterSequenceTypeEvent.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionevents_events,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransactionEvents:

    @staticmethod
    def lift(value: int):
        return TransactionEvents._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionEvents):
        if not isinstance(value, TransactionEvents):
            raise TypeError("Expected TransactionEvents instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionEventsProtocol):
        if not isinstance(value, TransactionEvents):
            raise TypeError("Expected TransactionEvents instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionEventsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionKindProtocol(typing.Protocol):
    """
    Transaction type

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-kind    =  %x00 ptb
    =/ %x01 change-epoch
    =/ %x02 genesis-transaction
    =/ %x03 consensus-commit-prologue
    =/ %x04 authenticator-state-update
    =/ %x05 (vector end-of-epoch-transaction-kind)
    =/ %x06 randomness-state-update
    =/ %x07 consensus-commit-prologue-v2
    =/ %x08 consensus-commit-prologue-v3
    ```
    """

    pass
# TransactionKind is a Rust-only trait - it's a wrapper around a Rust implementation.
class TransactionKind():
    """
    Transaction type

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction-kind    =  %x00 ptb
    =/ %x01 change-epoch
    =/ %x02 genesis-transaction
    =/ %x03 consensus-commit-prologue
    =/ %x04 authenticator-state-update
    =/ %x05 (vector end-of-epoch-transaction-kind)
    =/ %x06 randomness-state-update
    =/ %x07 consensus-commit-prologue-v2
    =/ %x08 consensus-commit-prologue-v3
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionkind, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionkind, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_authenticator_state_update_v1(cls, tx: "AuthenticatorStateUpdateV1"):
        _UniffiConverterTypeAuthenticatorStateUpdateV1.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_authenticator_state_update_v1,
        _UniffiConverterTypeAuthenticatorStateUpdateV1.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_consensus_commit_prologue_v1(cls, tx: "ConsensusCommitPrologueV1"):
        _UniffiConverterTypeConsensusCommitPrologueV1.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_consensus_commit_prologue_v1,
        _UniffiConverterTypeConsensusCommitPrologueV1.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_end_of_epoch(cls, tx: "typing.List[EndOfEpochTransactionKind]"):
        _UniffiConverterSequenceTypeEndOfEpochTransactionKind.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_end_of_epoch,
        _UniffiConverterSequenceTypeEndOfEpochTransactionKind.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_genesis(cls, tx: "GenesisTransaction"):
        _UniffiConverterTypeGenesisTransaction.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_genesis,
        _UniffiConverterTypeGenesisTransaction.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_programmable_transaction(cls, tx: "ProgrammableTransaction"):
        _UniffiConverterTypeProgrammableTransaction.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_programmable_transaction,
        _UniffiConverterTypeProgrammableTransaction.lower(tx))
        return cls._make_instance_(pointer)

    @classmethod
    def new_randomness_state_update(cls, tx: "RandomnessStateUpdate"):
        _UniffiConverterTypeRandomnessStateUpdate.check_lower(tx)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionkind_new_randomness_state_update,
        _UniffiConverterTypeRandomnessStateUpdate.lower(tx))
        return cls._make_instance_(pointer)




class _UniffiConverterTypeTransactionKind:

    @staticmethod
    def lift(value: int):
        return TransactionKind._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionKind):
        if not isinstance(value, TransactionKind):
            raise TypeError("Expected TransactionKind instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionKindProtocol):
        if not isinstance(value, TransactionKind):
            raise TypeError("Expected TransactionKind instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionKindProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransactionV1Protocol(typing.Protocol):
    """
    A transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction = %x00 transaction-v1

    transaction-v1 = transaction-kind address gas-payment transaction-expiration
    ```
    """

    def digest(self, ):
        raise NotImplementedError
    def expiration(self, ):
        raise NotImplementedError
    def gas_payment(self, ):
        raise NotImplementedError
    def kind(self, ):
        raise NotImplementedError
    def sender(self, ):
        raise NotImplementedError
    def signing_digest(self, ):
        """
        Get the signing digest.
        """

        raise NotImplementedError
    def signing_digest_hex(self, ):
        """
        Get the signing digest as a hex string.
        """

        raise NotImplementedError
    def to_base64(self, ):
        """
        Serialize the transaction as a base64-encoded string.
        """

        raise NotImplementedError
# TransactionV1 is a Rust-only trait - it's a wrapper around a Rust implementation.
class TransactionV1():
    """
    A transaction

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transaction = %x00 transaction-v1

    transaction-v1 = transaction-kind address gas-payment transaction-expiration
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, kind: "TransactionKind",sender: "Address",gas_payment: "GasPayment",expiration: "TransactionExpiration"):
        _UniffiConverterTypeTransactionKind.check_lower(kind)
        
        _UniffiConverterTypeAddress.check_lower(sender)
        
        _UniffiConverterTypeGasPayment.check_lower(gas_payment)
        
        _UniffiConverterTypeTransactionExpiration.check_lower(expiration)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_new,
        _UniffiConverterTypeTransactionKind.lower(kind),
        _UniffiConverterTypeAddress.lower(sender),
        _UniffiConverterTypeGasPayment.lower(gas_payment),
        _UniffiConverterTypeTransactionExpiration.lower(expiration))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transactionv1, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transactionv1, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_base64(cls, bytes: "str"):
        """
        Deserialize a transaction from a base64-encoded string.
        """

        _UniffiConverterString.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transactionv1_from_base64,
        _UniffiConverterString.lower(bytes))
        return cls._make_instance_(pointer)



    def digest(self, ) -> "Digest":
        return _UniffiConverterTypeDigest.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_digest,self._uniffi_clone_pointer(),)
        )





    def expiration(self, ) -> "TransactionExpiration":
        return _UniffiConverterTypeTransactionExpiration.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_expiration,self._uniffi_clone_pointer(),)
        )





    def gas_payment(self, ) -> "GasPayment":
        return _UniffiConverterTypeGasPayment.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_gas_payment,self._uniffi_clone_pointer(),)
        )





    def kind(self, ) -> "TransactionKind":
        return _UniffiConverterTypeTransactionKind.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_kind,self._uniffi_clone_pointer(),)
        )





    def sender(self, ) -> "Address":
        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_sender,self._uniffi_clone_pointer(),)
        )





    def signing_digest(self, ) -> "bytes":
        """
        Get the signing digest.
        """

        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest,self._uniffi_clone_pointer(),)
        )





    def signing_digest_hex(self, ) -> "str":
        """
        Get the signing digest as a hex string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_signing_digest_hex,self._uniffi_clone_pointer(),)
        )





    def to_base64(self, ) -> "str":
        """
        Serialize the transaction as a base64-encoded string.
        """

        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transactionv1_to_base64,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransactionV1:

    @staticmethod
    def lift(value: int):
        return TransactionV1._make_instance_(value)

    @staticmethod
    def check_lower(value: TransactionV1):
        if not isinstance(value, TransactionV1):
            raise TypeError("Expected TransactionV1 instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionV1Protocol):
        if not isinstance(value, TransactionV1):
            raise TypeError("Expected TransactionV1 instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionV1Protocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TransferObjectsProtocol(typing.Protocol):
    """
    Command to transfer ownership of a set of objects to an address

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transfer-objects = (vector argument) argument
    ```
    """

    def address(self, ):
        """
        The address to transfer ownership to
        """

        raise NotImplementedError
    def objects(self, ):
        """
        Set of objects to transfer
        """

        raise NotImplementedError
# TransferObjects is a Rust-only trait - it's a wrapper around a Rust implementation.
class TransferObjects():
    """
    Command to transfer ownership of a set of objects to an address

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    transfer-objects = (vector argument) argument
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, objects: "typing.List[Argument]",address: "Argument"):
        _UniffiConverterSequenceTypeArgument.check_lower(objects)
        
        _UniffiConverterTypeArgument.check_lower(address)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_transferobjects_new,
        _UniffiConverterSequenceTypeArgument.lower(objects),
        _UniffiConverterTypeArgument.lower(address))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_transferobjects, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_transferobjects, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def address(self, ) -> "Argument":
        """
        The address to transfer ownership to
        """

        return _UniffiConverterTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transferobjects_address,self._uniffi_clone_pointer(),)
        )





    def objects(self, ) -> "typing.List[Argument]":
        """
        Set of objects to transfer
        """

        return _UniffiConverterSequenceTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_transferobjects_objects,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransferObjects:

    @staticmethod
    def lift(value: int):
        return TransferObjects._make_instance_(value)

    @staticmethod
    def check_lower(value: TransferObjects):
        if not isinstance(value, TransferObjects):
            raise TypeError("Expected TransferObjects instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransferObjectsProtocol):
        if not isinstance(value, TransferObjects):
            raise TypeError("Expected TransferObjects instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransferObjectsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class TypeTagProtocol(typing.Protocol):
    """
    Type of a move value

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    type-tag = type-tag-u8 \
    type-tag-u16 \
    type-tag-u32 \
    type-tag-u64 \
    type-tag-u128 \
    type-tag-u256 \
    type-tag-bool \
    type-tag-address \
    type-tag-signer \
    type-tag-vector \
    type-tag-struct

    type-tag-u8 = %x01
    type-tag-u16 = %x08
    type-tag-u32 = %x09
    type-tag-u64 = %x02
    type-tag-u128 = %x03
    type-tag-u256 = %x0a
    type-tag-bool = %x00
    type-tag-address = %x04
    type-tag-signer = %x05
    type-tag-vector = %x06 type-tag
    type-tag-struct = %x07 struct-tag
    ```
    """

    def as_struct_tag(self, ):
        raise NotImplementedError
    def as_struct_tag_opt(self, ):
        raise NotImplementedError
    def as_vector_type_tag(self, ):
        raise NotImplementedError
    def as_vector_type_tag_opt(self, ):
        raise NotImplementedError
    def is_address(self, ):
        raise NotImplementedError
    def is_bool(self, ):
        raise NotImplementedError
    def is_signer(self, ):
        raise NotImplementedError
    def is_struct(self, ):
        raise NotImplementedError
    def is_u128(self, ):
        raise NotImplementedError
    def is_u16(self, ):
        raise NotImplementedError
    def is_u256(self, ):
        raise NotImplementedError
    def is_u32(self, ):
        raise NotImplementedError
    def is_u64(self, ):
        raise NotImplementedError
    def is_u8(self, ):
        raise NotImplementedError
    def is_vector(self, ):
        raise NotImplementedError
    def to_canonical_string(self, with_prefix: "bool"):
        """
        Returns the string representation of this type tag using the
        canonical display, with or without a `0x` prefix.
        """

        raise NotImplementedError
# TypeTag is a Rust-only trait - it's a wrapper around a Rust implementation.
class TypeTag():
    """
    Type of a move value

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    type-tag = type-tag-u8 \
    type-tag-u16 \
    type-tag-u32 \
    type-tag-u64 \
    type-tag-u128 \
    type-tag-u256 \
    type-tag-bool \
    type-tag-address \
    type-tag-signer \
    type-tag-vector \
    type-tag-struct

    type-tag-u8 = %x01
    type-tag-u16 = %x08
    type-tag-u32 = %x09
    type-tag-u64 = %x02
    type-tag-u128 = %x03
    type-tag-u256 = %x0a
    type-tag-bool = %x00
    type-tag-address = %x04
    type-tag-signer = %x05
    type-tag-vector = %x06 type-tag
    type-tag-struct = %x07 struct-tag
    ```
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_typetag, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_typetag, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_address(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_address,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_bool(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_bool,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_signer(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_signer,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_struct(cls, struct_tag: "StructTag"):
        _UniffiConverterTypeStructTag.check_lower(struct_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_struct,
        _UniffiConverterTypeStructTag.lower(struct_tag))
        return cls._make_instance_(pointer)

    @classmethod
    def new_u128(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u128,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_u16(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u16,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_u256(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u256,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_u32(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u32,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_u64(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u64,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_u8(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_u8,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_vector(cls, type_tag: "TypeTag"):
        _UniffiConverterTypeTypeTag.check_lower(type_tag)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_typetag_new_vector,
        _UniffiConverterTypeTypeTag.lower(type_tag))
        return cls._make_instance_(pointer)



    def as_struct_tag(self, ) -> "StructTag":
        return _UniffiConverterTypeStructTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag,self._uniffi_clone_pointer(),)
        )





    def as_struct_tag_opt(self, ) -> "typing.Optional[StructTag]":
        return _UniffiConverterOptionalTypeStructTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_struct_tag_opt,self._uniffi_clone_pointer(),)
        )





    def as_vector_type_tag(self, ) -> "TypeTag":
        return _UniffiConverterTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag,self._uniffi_clone_pointer(),)
        )





    def as_vector_type_tag_opt(self, ) -> "typing.Optional[TypeTag]":
        return _UniffiConverterOptionalTypeTypeTag.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_as_vector_type_tag_opt,self._uniffi_clone_pointer(),)
        )





    def is_address(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_address,self._uniffi_clone_pointer(),)
        )





    def is_bool(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_bool,self._uniffi_clone_pointer(),)
        )





    def is_signer(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_signer,self._uniffi_clone_pointer(),)
        )





    def is_struct(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_struct,self._uniffi_clone_pointer(),)
        )





    def is_u128(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u128,self._uniffi_clone_pointer(),)
        )





    def is_u16(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u16,self._uniffi_clone_pointer(),)
        )





    def is_u256(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u256,self._uniffi_clone_pointer(),)
        )





    def is_u32(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u32,self._uniffi_clone_pointer(),)
        )





    def is_u64(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u64,self._uniffi_clone_pointer(),)
        )





    def is_u8(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_u8,self._uniffi_clone_pointer(),)
        )





    def is_vector(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_is_vector,self._uniffi_clone_pointer(),)
        )





    def to_canonical_string(self, with_prefix: "bool") -> "str":
        """
        Returns the string representation of this type tag using the
        canonical display, with or without a `0x` prefix.
        """

        _UniffiConverterBool.check_lower(with_prefix)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_to_canonical_string,self._uniffi_clone_pointer(),
        _UniffiConverterBool.lower(with_prefix))
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_typetag_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTypeTag:

    @staticmethod
    def lift(value: int):
        return TypeTag._make_instance_(value)

    @staticmethod
    def check_lower(value: TypeTag):
        if not isinstance(value, TypeTag):
            raise TypeError("Expected TypeTag instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TypeTagProtocol):
        if not isinstance(value, TypeTag):
            raise TypeError("Expected TypeTag instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TypeTagProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UpgradeProtocol(typing.Protocol):
    """
    Command to upgrade an already published package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    upgrade = (vector bytes)        ; move modules
    (vector object-id)    ; dependencies
    object-id             ; package-id of the package
    argument              ; upgrade ticket
    ```
    """

    def dependencies(self, ):
        """
        Set of packages that the to-be published package depends on
        """

        raise NotImplementedError
    def modules(self, ):
        """
        The serialized move modules
        """

        raise NotImplementedError
    def package(self, ):
        """
        Package id of the package to upgrade
        """

        raise NotImplementedError
    def ticket(self, ):
        """
        Ticket authorizing the upgrade
        """

        raise NotImplementedError
# Upgrade is a Rust-only trait - it's a wrapper around a Rust implementation.
class Upgrade():
    """
    Command to upgrade an already published package

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    upgrade = (vector bytes)        ; move modules
    (vector object-id)    ; dependencies
    object-id             ; package-id of the package
    argument              ; upgrade ticket
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, modules: "typing.List[bytes]",dependencies: "typing.List[ObjectId]",package: "ObjectId",ticket: "Argument"):
        _UniffiConverterSequenceBytes.check_lower(modules)
        
        _UniffiConverterSequenceTypeObjectId.check_lower(dependencies)
        
        _UniffiConverterTypeObjectId.check_lower(package)
        
        _UniffiConverterTypeArgument.check_lower(ticket)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgrade_new,
        _UniffiConverterSequenceBytes.lower(modules),
        _UniffiConverterSequenceTypeObjectId.lower(dependencies),
        _UniffiConverterTypeObjectId.lower(package),
        _UniffiConverterTypeArgument.lower(ticket))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_upgrade, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_upgrade, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def dependencies(self, ) -> "typing.List[ObjectId]":
        """
        Set of packages that the to-be published package depends on
        """

        return _UniffiConverterSequenceTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_dependencies,self._uniffi_clone_pointer(),)
        )





    def modules(self, ) -> "typing.List[bytes]":
        """
        The serialized move modules
        """

        return _UniffiConverterSequenceBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_modules,self._uniffi_clone_pointer(),)
        )





    def package(self, ) -> "ObjectId":
        """
        Package id of the package to upgrade
        """

        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_package,self._uniffi_clone_pointer(),)
        )





    def ticket(self, ) -> "Argument":
        """
        Ticket authorizing the upgrade
        """

        return _UniffiConverterTypeArgument.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgrade_ticket,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeUpgrade:

    @staticmethod
    def lift(value: int):
        return Upgrade._make_instance_(value)

    @staticmethod
    def check_lower(value: Upgrade):
        if not isinstance(value, Upgrade):
            raise TypeError("Expected Upgrade instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UpgradeProtocol):
        if not isinstance(value, Upgrade):
            raise TypeError("Expected Upgrade instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UpgradeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UpgradePolicyProtocol(typing.Protocol):
    """
    Representation of upgrade policy constants in `iota::package`.
    """

    def as_u8(self, ):
        """
        Returns the internal representation.
        """

        raise NotImplementedError
# UpgradePolicy is a Rust-only trait - it's a wrapper around a Rust implementation.
class UpgradePolicy():
    """
    Representation of upgrade policy constants in `iota::package`.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_upgradepolicy, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_upgradepolicy, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def additive(cls, ):
        """
        Allows adding new functionalities (e.g., new public functions or
        structs) but restricts changes to existing functionalities.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_additive,)
        return cls._make_instance_(pointer)

    @classmethod
    def compatible(cls, ):
        """
        The least restrictive policy. Permits changes to all function
        implementations, the removal of ability constraints on generic type
        parameters in function signatures, and modifications to private,
        public(friend), and entry function signatures. However, public function
        signatures and existing types cannot be changed.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_compatible,)
        return cls._make_instance_(pointer)

    @classmethod
    def dep_only(cls, ):
        """
        Limits modifications to the packages dependencies only.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_upgradepolicy_dep_only,)
        return cls._make_instance_(pointer)



    def as_u8(self, ) -> "int":
        """
        Returns the internal representation.
        """

        return _UniffiConverterUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_as_u8,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )



    def __eq__(self, other: object) -> bool:
        if not isinstance(other, UpgradePolicy):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_eq,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUpgradePolicy.lower(other)))

    def __ne__(self, other: object) -> bool:
        if not isinstance(other, UpgradePolicy):
            return NotImplemented

        return _UniffiConverterBool.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_upgradepolicy_uniffi_trait_eq_ne,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUpgradePolicy.lower(other)))



class _UniffiConverterTypeUpgradePolicy:

    @staticmethod
    def lift(value: int):
        return UpgradePolicy._make_instance_(value)

    @staticmethod
    def check_lower(value: UpgradePolicy):
        if not isinstance(value, UpgradePolicy):
            raise TypeError("Expected UpgradePolicy instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UpgradePolicyProtocol):
        if not isinstance(value, UpgradePolicy):
            raise TypeError("Expected UpgradePolicy instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UpgradePolicyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UserSignatureProtocol(typing.Protocol):
    """
    A signature from a user

    A `UserSignature` is most commonly used to authorize the execution and
    inclusion of a transaction to the blockchain.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    user-signature-bcs = bytes ; where the contents of the bytes are defined by <user-signature>
    user-signature = simple-signature / multisig / multisig-legacy / zklogin / passkey
    ```

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    def as_multisig(self, ):
        raise NotImplementedError
    def as_multisig_opt(self, ):
        raise NotImplementedError
    def as_passkey(self, ):
        raise NotImplementedError
    def as_passkey_opt(self, ):
        raise NotImplementedError
    def as_simple(self, ):
        raise NotImplementedError
    def as_simple_opt(self, ):
        raise NotImplementedError
    def as_zklogin(self, ):
        raise NotImplementedError
    def as_zklogin_opt(self, ):
        raise NotImplementedError
    def is_multisig(self, ):
        raise NotImplementedError
    def is_passkey(self, ):
        raise NotImplementedError
    def is_simple(self, ):
        raise NotImplementedError
    def is_zklogin(self, ):
        raise NotImplementedError
    def scheme(self, ):
        """
        Return the flag for this signature scheme
        """

        raise NotImplementedError
    def to_base64(self, ):
        raise NotImplementedError
    def to_bytes(self, ):
        raise NotImplementedError
# UserSignature is a Rust-only trait - it's a wrapper around a Rust implementation.
class UserSignature():
    """
    A signature from a user

    A `UserSignature` is most commonly used to authorize the execution and
    inclusion of a transaction to the blockchain.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    user-signature-bcs = bytes ; where the contents of the bytes are defined by <user-signature>
    user-signature = simple-signature / multisig / multisig-legacy / zklogin / passkey
    ```

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_usersignature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_usersignature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def from_base64(cls, base64: "str"):
        _UniffiConverterString.check_lower(base64)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_base64,
        _UniffiConverterString.lower(base64))
        return cls._make_instance_(pointer)

    @classmethod
    def from_bytes(cls, bytes: "bytes"):
        _UniffiConverterBytes.check_lower(bytes)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_from_bytes,
        _UniffiConverterBytes.lower(bytes))
        return cls._make_instance_(pointer)

    @classmethod
    def new_multisig(cls, signature: "MultisigAggregatedSignature"):
        _UniffiConverterTypeMultisigAggregatedSignature.check_lower(signature)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_multisig,
        _UniffiConverterTypeMultisigAggregatedSignature.lower(signature))
        return cls._make_instance_(pointer)

    @classmethod
    def new_passkey(cls, authenticator: "PasskeyAuthenticator"):
        _UniffiConverterTypePasskeyAuthenticator.check_lower(authenticator)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_passkey,
        _UniffiConverterTypePasskeyAuthenticator.lower(authenticator))
        return cls._make_instance_(pointer)

    @classmethod
    def new_simple(cls, signature: "SimpleSignature"):
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_simple,
        _UniffiConverterTypeSimpleSignature.lower(signature))
        return cls._make_instance_(pointer)

    @classmethod
    def new_zklogin(cls, authenticator: "ZkLoginAuthenticator"):
        _UniffiConverterTypeZkLoginAuthenticator.check_lower(authenticator)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignature_new_zklogin,
        _UniffiConverterTypeZkLoginAuthenticator.lower(authenticator))
        return cls._make_instance_(pointer)



    def as_multisig(self, ) -> "MultisigAggregatedSignature":
        return _UniffiConverterTypeMultisigAggregatedSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig,self._uniffi_clone_pointer(),)
        )





    def as_multisig_opt(self, ) -> "typing.Optional[MultisigAggregatedSignature]":
        return _UniffiConverterOptionalTypeMultisigAggregatedSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_multisig_opt,self._uniffi_clone_pointer(),)
        )





    def as_passkey(self, ) -> "PasskeyAuthenticator":
        return _UniffiConverterTypePasskeyAuthenticator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey,self._uniffi_clone_pointer(),)
        )





    def as_passkey_opt(self, ) -> "typing.Optional[PasskeyAuthenticator]":
        return _UniffiConverterOptionalTypePasskeyAuthenticator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_passkey_opt,self._uniffi_clone_pointer(),)
        )





    def as_simple(self, ) -> "SimpleSignature":
        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple,self._uniffi_clone_pointer(),)
        )





    def as_simple_opt(self, ) -> "typing.Optional[SimpleSignature]":
        return _UniffiConverterOptionalTypeSimpleSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_simple_opt,self._uniffi_clone_pointer(),)
        )





    def as_zklogin(self, ) -> "ZkLoginAuthenticator":
        return _UniffiConverterTypeZkLoginAuthenticator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin,self._uniffi_clone_pointer(),)
        )





    def as_zklogin_opt(self, ) -> "typing.Optional[ZkLoginAuthenticator]":
        return _UniffiConverterOptionalTypeZkLoginAuthenticator.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_as_zklogin_opt,self._uniffi_clone_pointer(),)
        )





    def is_multisig(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_multisig,self._uniffi_clone_pointer(),)
        )





    def is_passkey(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_passkey,self._uniffi_clone_pointer(),)
        )





    def is_simple(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_simple,self._uniffi_clone_pointer(),)
        )





    def is_zklogin(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_is_zklogin,self._uniffi_clone_pointer(),)
        )





    def scheme(self, ) -> "SignatureScheme":
        """
        Return the flag for this signature scheme
        """

        return _UniffiConverterTypeSignatureScheme.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_scheme,self._uniffi_clone_pointer(),)
        )





    def to_base64(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_to_base64,self._uniffi_clone_pointer(),)
        )





    def to_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignature_to_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeUserSignature:

    @staticmethod
    def lift(value: int):
        return UserSignature._make_instance_(value)

    @staticmethod
    def check_lower(value: UserSignature):
        if not isinstance(value, UserSignature):
            raise TypeError("Expected UserSignature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UserSignatureProtocol):
        if not isinstance(value, UserSignature):
            raise TypeError("Expected UserSignature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UserSignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class UserSignatureVerifierProtocol(typing.Protocol):
    """
    Verifier that will verify all UserSignature variants
    """

    def verify(self, message: "bytes",signature: "UserSignature"):
        raise NotImplementedError
    def with_zklogin_verifier(self, zklogin_verifier: "ZkloginVerifier"):
        raise NotImplementedError
    def zklogin_verifier(self, ):
        raise NotImplementedError
# UserSignatureVerifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class UserSignatureVerifier():
    """
    Verifier that will verify all UserSignature variants
    """

    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_usersignatureverifier_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_usersignatureverifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_usersignatureverifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def verify(self, message: "bytes",signature: "UserSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeUserSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeUserSignature.lower(signature))






    def with_zklogin_verifier(self, zklogin_verifier: "ZkloginVerifier") -> "UserSignatureVerifier":
        _UniffiConverterTypeZkloginVerifier.check_lower(zklogin_verifier)
        
        return _UniffiConverterTypeUserSignatureVerifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_with_zklogin_verifier,self._uniffi_clone_pointer(),
        _UniffiConverterTypeZkloginVerifier.lower(zklogin_verifier))
        )





    def zklogin_verifier(self, ) -> "typing.Optional[ZkloginVerifier]":
        return _UniffiConverterOptionalTypeZkloginVerifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_usersignatureverifier_zklogin_verifier,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeUserSignatureVerifier:

    @staticmethod
    def lift(value: int):
        return UserSignatureVerifier._make_instance_(value)

    @staticmethod
    def check_lower(value: UserSignatureVerifier):
        if not isinstance(value, UserSignatureVerifier):
            raise TypeError("Expected UserSignatureVerifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UserSignatureVerifierProtocol):
        if not isinstance(value, UserSignatureVerifier):
            raise TypeError("Expected UserSignatureVerifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UserSignatureVerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ValidatorAggregatedSignatureProtocol(typing.Protocol):
    """
    An aggregated signature from multiple Validators.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    validator-aggregated-signature = u64               ; epoch
    bls-signature
    roaring-bitmap
    roaring-bitmap = bytes  ; where the contents of the bytes are valid
    ; according to the serialized spec for
    ; roaring bitmaps
    ```

    See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
    serialized format of RoaringBitmaps.
    """

    def bitmap_bytes(self, ):
        raise NotImplementedError
    def epoch(self, ):
        raise NotImplementedError
    def signature(self, ):
        raise NotImplementedError
# ValidatorAggregatedSignature is a Rust-only trait - it's a wrapper around a Rust implementation.
class ValidatorAggregatedSignature():
    """
    An aggregated signature from multiple Validators.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    validator-aggregated-signature = u64               ; epoch
    bls-signature
    roaring-bitmap
    roaring-bitmap = bytes  ; where the contents of the bytes are valid
    ; according to the serialized spec for
    ; roaring bitmaps
    ```

    See <https://github.com/RoaringBitmap/RoaringFormatSpec> for the specification for the
    serialized format of RoaringBitmaps.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",signature: "Bls12381Signature",bitmap_bytes: "bytes"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterTypeBls12381Signature.check_lower(signature)
        
        _UniffiConverterBytes.check_lower(bitmap_bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatoraggregatedsignature_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterTypeBls12381Signature.lower(signature),
        _UniffiConverterBytes.lower(bitmap_bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatoraggregatedsignature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatoraggregatedsignature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def bitmap_bytes(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_bitmap_bytes,self._uniffi_clone_pointer(),)
        )





    def epoch(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_epoch,self._uniffi_clone_pointer(),)
        )





    def signature(self, ) -> "Bls12381Signature":
        return _UniffiConverterTypeBls12381Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatoraggregatedsignature_signature,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeValidatorAggregatedSignature:

    @staticmethod
    def lift(value: int):
        return ValidatorAggregatedSignature._make_instance_(value)

    @staticmethod
    def check_lower(value: ValidatorAggregatedSignature):
        if not isinstance(value, ValidatorAggregatedSignature):
            raise TypeError("Expected ValidatorAggregatedSignature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ValidatorAggregatedSignatureProtocol):
        if not isinstance(value, ValidatorAggregatedSignature):
            raise TypeError("Expected ValidatorAggregatedSignature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ValidatorAggregatedSignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ValidatorCommitteeSignatureAggregatorProtocol(typing.Protocol):
    def add_signature(self, signature: "ValidatorSignature"):
        raise NotImplementedError
    def committee(self, ):
        raise NotImplementedError
    def finish(self, ):
        raise NotImplementedError
# ValidatorCommitteeSignatureAggregator is a Rust-only trait - it's a wrapper around a Rust implementation.
class ValidatorCommitteeSignatureAggregator():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureaggregator, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureaggregator, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_checkpoint_summary(cls, committee: "ValidatorCommittee",summary: "CheckpointSummary"):
        _UniffiConverterTypeValidatorCommittee.check_lower(committee)
        
        _UniffiConverterTypeCheckpointSummary.check_lower(summary)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureaggregator_new_checkpoint_summary,
        _UniffiConverterTypeValidatorCommittee.lower(committee),
        _UniffiConverterTypeCheckpointSummary.lower(summary))
        return cls._make_instance_(pointer)



    def add_signature(self, signature: "ValidatorSignature") -> None:
        _UniffiConverterTypeValidatorSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_add_signature,self._uniffi_clone_pointer(),
        _UniffiConverterTypeValidatorSignature.lower(signature))






    def committee(self, ) -> "ValidatorCommittee":
        return _UniffiConverterTypeValidatorCommittee.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_committee,self._uniffi_clone_pointer(),)
        )





    def finish(self, ) -> "ValidatorAggregatedSignature":
        return _UniffiConverterTypeValidatorAggregatedSignature.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureaggregator_finish,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeValidatorCommitteeSignatureAggregator:

    @staticmethod
    def lift(value: int):
        return ValidatorCommitteeSignatureAggregator._make_instance_(value)

    @staticmethod
    def check_lower(value: ValidatorCommitteeSignatureAggregator):
        if not isinstance(value, ValidatorCommitteeSignatureAggregator):
            raise TypeError("Expected ValidatorCommitteeSignatureAggregator instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ValidatorCommitteeSignatureAggregatorProtocol):
        if not isinstance(value, ValidatorCommitteeSignatureAggregator):
            raise TypeError("Expected ValidatorCommitteeSignatureAggregator instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ValidatorCommitteeSignatureAggregatorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ValidatorCommitteeSignatureVerifierProtocol(typing.Protocol):
    def committee(self, ):
        raise NotImplementedError
    def verify(self, message: "bytes",signature: "ValidatorSignature"):
        raise NotImplementedError
    def verify_aggregated(self, message: "bytes",signature: "ValidatorAggregatedSignature"):
        raise NotImplementedError
    def verify_checkpoint_summary(self, summary: "CheckpointSummary",signature: "ValidatorAggregatedSignature"):
        raise NotImplementedError
# ValidatorCommitteeSignatureVerifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class ValidatorCommitteeSignatureVerifier():
    _pointer: ctypes.c_void_p
    def __init__(self, committee: "ValidatorCommittee"):
        _UniffiConverterTypeValidatorCommittee.check_lower(committee)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorcommitteesignatureverifier_new,
        _UniffiConverterTypeValidatorCommittee.lower(committee))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorcommitteesignatureverifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorcommitteesignatureverifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def committee(self, ) -> "ValidatorCommittee":
        return _UniffiConverterTypeValidatorCommittee.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_committee,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",signature: "ValidatorSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeValidatorSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeValidatorSignature.lower(signature))






    def verify_aggregated(self, message: "bytes",signature: "ValidatorAggregatedSignature") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeValidatorAggregatedSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_aggregated,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeValidatorAggregatedSignature.lower(signature))






    def verify_checkpoint_summary(self, summary: "CheckpointSummary",signature: "ValidatorAggregatedSignature") -> None:
        _UniffiConverterTypeCheckpointSummary.check_lower(summary)
        
        _UniffiConverterTypeValidatorAggregatedSignature.check_lower(signature)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorcommitteesignatureverifier_verify_checkpoint_summary,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCheckpointSummary.lower(summary),
        _UniffiConverterTypeValidatorAggregatedSignature.lower(signature))







class _UniffiConverterTypeValidatorCommitteeSignatureVerifier:

    @staticmethod
    def lift(value: int):
        return ValidatorCommitteeSignatureVerifier._make_instance_(value)

    @staticmethod
    def check_lower(value: ValidatorCommitteeSignatureVerifier):
        if not isinstance(value, ValidatorCommitteeSignatureVerifier):
            raise TypeError("Expected ValidatorCommitteeSignatureVerifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ValidatorCommitteeSignatureVerifierProtocol):
        if not isinstance(value, ValidatorCommitteeSignatureVerifier):
            raise TypeError("Expected ValidatorCommitteeSignatureVerifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ValidatorCommitteeSignatureVerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ValidatorExecutionTimeObservationProtocol(typing.Protocol):
    """
    An execution time observation from a particular validator

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    execution-time-observation = bls-public-key duration
    duration =  u64 ; seconds
    u32 ; subsecond nanoseconds
    ```
    """

    def duration(self, ):
        raise NotImplementedError
    def validator(self, ):
        raise NotImplementedError
# ValidatorExecutionTimeObservation is a Rust-only trait - it's a wrapper around a Rust implementation.
class ValidatorExecutionTimeObservation():
    """
    An execution time observation from a particular validator

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    execution-time-observation = bls-public-key duration
    duration =  u64 ; seconds
    u32 ; subsecond nanoseconds
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, validator: "Bls12381PublicKey",duration: "Duration"):
        _UniffiConverterTypeBls12381PublicKey.check_lower(validator)
        
        _UniffiConverterDuration.check_lower(duration)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorexecutiontimeobservation_new,
        _UniffiConverterTypeBls12381PublicKey.lower(validator),
        _UniffiConverterDuration.lower(duration))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorexecutiontimeobservation, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorexecutiontimeobservation, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def duration(self, ) -> "Duration":
        return _UniffiConverterDuration.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_duration,self._uniffi_clone_pointer(),)
        )





    def validator(self, ) -> "Bls12381PublicKey":
        return _UniffiConverterTypeBls12381PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorexecutiontimeobservation_validator,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeValidatorExecutionTimeObservation:

    @staticmethod
    def lift(value: int):
        return ValidatorExecutionTimeObservation._make_instance_(value)

    @staticmethod
    def check_lower(value: ValidatorExecutionTimeObservation):
        if not isinstance(value, ValidatorExecutionTimeObservation):
            raise TypeError("Expected ValidatorExecutionTimeObservation instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ValidatorExecutionTimeObservationProtocol):
        if not isinstance(value, ValidatorExecutionTimeObservation):
            raise TypeError("Expected ValidatorExecutionTimeObservation instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ValidatorExecutionTimeObservationProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ValidatorSignatureProtocol(typing.Protocol):
    """
    A signature from a Validator

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    validator-signature = u64               ; epoch
    bls-public-key
    bls-signature
    ```
    """

    def epoch(self, ):
        raise NotImplementedError
    def public_key(self, ):
        raise NotImplementedError
    def signature(self, ):
        raise NotImplementedError
# ValidatorSignature is a Rust-only trait - it's a wrapper around a Rust implementation.
class ValidatorSignature():
    """
    A signature from a Validator

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    validator-signature = u64               ; epoch
    bls-public-key
    bls-signature
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, epoch: "int",public_key: "Bls12381PublicKey",signature: "Bls12381Signature"):
        _UniffiConverterUInt64.check_lower(epoch)
        
        _UniffiConverterTypeBls12381PublicKey.check_lower(public_key)
        
        _UniffiConverterTypeBls12381Signature.check_lower(signature)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_validatorsignature_new,
        _UniffiConverterUInt64.lower(epoch),
        _UniffiConverterTypeBls12381PublicKey.lower(public_key),
        _UniffiConverterTypeBls12381Signature.lower(signature))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_validatorsignature, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_validatorsignature, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def epoch(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_epoch,self._uniffi_clone_pointer(),)
        )





    def public_key(self, ) -> "Bls12381PublicKey":
        return _UniffiConverterTypeBls12381PublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_public_key,self._uniffi_clone_pointer(),)
        )





    def signature(self, ) -> "Bls12381Signature":
        return _UniffiConverterTypeBls12381Signature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_validatorsignature_signature,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeValidatorSignature:

    @staticmethod
    def lift(value: int):
        return ValidatorSignature._make_instance_(value)

    @staticmethod
    def check_lower(value: ValidatorSignature):
        if not isinstance(value, ValidatorSignature):
            raise TypeError("Expected ValidatorSignature instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ValidatorSignatureProtocol):
        if not isinstance(value, ValidatorSignature):
            raise TypeError("Expected ValidatorSignature instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ValidatorSignatureProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class VersionAssignmentProtocol(typing.Protocol):
    """
    Object version assignment from consensus

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    version-assignment = object-id u64
    ```
    """

    def object_id(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
# VersionAssignment is a Rust-only trait - it's a wrapper around a Rust implementation.
class VersionAssignment():
    """
    Object version assignment from consensus

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    version-assignment = object-id u64
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, object_id: "ObjectId",version: "int"):
        _UniffiConverterTypeObjectId.check_lower(object_id)
        
        _UniffiConverterUInt64.check_lower(version)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_versionassignment_new,
        _UniffiConverterTypeObjectId.lower(object_id),
        _UniffiConverterUInt64.lower(version))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_versionassignment, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_versionassignment, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def object_id(self, ) -> "ObjectId":
        return _UniffiConverterTypeObjectId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_versionassignment_object_id,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_versionassignment_version,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeVersionAssignment:

    @staticmethod
    def lift(value: int):
        return VersionAssignment._make_instance_(value)

    @staticmethod
    def check_lower(value: VersionAssignment):
        if not isinstance(value, VersionAssignment):
            raise TypeError("Expected VersionAssignment instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: VersionAssignmentProtocol):
        if not isinstance(value, VersionAssignment):
            raise TypeError("Expected VersionAssignment instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: VersionAssignmentProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ZkLoginAuthenticatorProtocol(typing.Protocol):
    """
    A zklogin authenticator

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-bcs = bytes             ; contents are defined by <zklogin-authenticator>
    zklogin     = zklogin-flag
    zklogin-inputs
    u64               ; max epoch
    simple-signature
    ```

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    def inputs(self, ):
        raise NotImplementedError
    def max_epoch(self, ):
        raise NotImplementedError
    def signature(self, ):
        raise NotImplementedError
# ZkLoginAuthenticator is a Rust-only trait - it's a wrapper around a Rust implementation.
class ZkLoginAuthenticator():
    """
    A zklogin authenticator

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-bcs = bytes             ; contents are defined by <zklogin-authenticator>
    zklogin     = zklogin-flag
    zklogin-inputs
    u64               ; max epoch
    simple-signature
    ```

    Note: Due to historical reasons, signatures are serialized slightly
    different from the majority of the types in IOTA. In particular if a
    signature is ever embedded in another structure it generally is serialized
    as `bytes` meaning it has a length prefix that defines the length of
    the completely serialized signature.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, inputs: "ZkLoginInputs",max_epoch: "int",signature: "SimpleSignature"):
        _UniffiConverterTypeZkLoginInputs.check_lower(inputs)
        
        _UniffiConverterUInt64.check_lower(max_epoch)
        
        _UniffiConverterTypeSimpleSignature.check_lower(signature)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginauthenticator_new,
        _UniffiConverterTypeZkLoginInputs.lower(inputs),
        _UniffiConverterUInt64.lower(max_epoch),
        _UniffiConverterTypeSimpleSignature.lower(signature))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginauthenticator, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginauthenticator, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def inputs(self, ) -> "ZkLoginInputs":
        return _UniffiConverterTypeZkLoginInputs.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_inputs,self._uniffi_clone_pointer(),)
        )





    def max_epoch(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_max_epoch,self._uniffi_clone_pointer(),)
        )





    def signature(self, ) -> "SimpleSignature":
        return _UniffiConverterTypeSimpleSignature.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginauthenticator_signature,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeZkLoginAuthenticator:

    @staticmethod
    def lift(value: int):
        return ZkLoginAuthenticator._make_instance_(value)

    @staticmethod
    def check_lower(value: ZkLoginAuthenticator):
        if not isinstance(value, ZkLoginAuthenticator):
            raise TypeError("Expected ZkLoginAuthenticator instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZkLoginAuthenticatorProtocol):
        if not isinstance(value, ZkLoginAuthenticator):
            raise TypeError("Expected ZkLoginAuthenticator instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZkLoginAuthenticatorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ZkLoginInputsProtocol(typing.Protocol):
    """
    A zklogin groth16 proof and the required inputs to perform proof
    verification.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-inputs = zklogin-proof
    zklogin-claim
    string              ; base64url-unpadded encoded JwtHeader
    bn254-field-element ; address_seed
    ```
    """

    def address_seed(self, ):
        raise NotImplementedError
    def header_base64(self, ):
        raise NotImplementedError
    def iss(self, ):
        raise NotImplementedError
    def iss_base64_details(self, ):
        raise NotImplementedError
    def jwk_id(self, ):
        raise NotImplementedError
    def proof_points(self, ):
        raise NotImplementedError
    def public_identifier(self, ):
        raise NotImplementedError
# ZkLoginInputs is a Rust-only trait - it's a wrapper around a Rust implementation.
class ZkLoginInputs():
    """
    A zklogin groth16 proof and the required inputs to perform proof
    verification.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-inputs = zklogin-proof
    zklogin-claim
    string              ; base64url-unpadded encoded JwtHeader
    bn254-field-element ; address_seed
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, proof_points: "ZkLoginProof",iss_base64_details: "ZkLoginClaim",header_base64: "str",address_seed: "Bn254FieldElement"):
        _UniffiConverterTypeZkLoginProof.check_lower(proof_points)
        
        _UniffiConverterTypeZkLoginClaim.check_lower(iss_base64_details)
        
        _UniffiConverterString.check_lower(header_base64)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(address_seed)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zklogininputs_new,
        _UniffiConverterTypeZkLoginProof.lower(proof_points),
        _UniffiConverterTypeZkLoginClaim.lower(iss_base64_details),
        _UniffiConverterString.lower(header_base64),
        _UniffiConverterTypeBn254FieldElement.lower(address_seed))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zklogininputs, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zklogininputs, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def address_seed(self, ) -> "Bn254FieldElement":
        return _UniffiConverterTypeBn254FieldElement.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_address_seed,self._uniffi_clone_pointer(),)
        )





    def header_base64(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_header_base64,self._uniffi_clone_pointer(),)
        )





    def iss(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss,self._uniffi_clone_pointer(),)
        )





    def iss_base64_details(self, ) -> "ZkLoginClaim":
        return _UniffiConverterTypeZkLoginClaim.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_iss_base64_details,self._uniffi_clone_pointer(),)
        )





    def jwk_id(self, ) -> "JwkId":
        return _UniffiConverterTypeJwkId.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_jwk_id,self._uniffi_clone_pointer(),)
        )





    def proof_points(self, ) -> "ZkLoginProof":
        return _UniffiConverterTypeZkLoginProof.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_proof_points,self._uniffi_clone_pointer(),)
        )





    def public_identifier(self, ) -> "ZkLoginPublicIdentifier":
        return _UniffiConverterTypeZkLoginPublicIdentifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zklogininputs_public_identifier,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeZkLoginInputs:

    @staticmethod
    def lift(value: int):
        return ZkLoginInputs._make_instance_(value)

    @staticmethod
    def check_lower(value: ZkLoginInputs):
        if not isinstance(value, ZkLoginInputs):
            raise TypeError("Expected ZkLoginInputs instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZkLoginInputsProtocol):
        if not isinstance(value, ZkLoginInputs):
            raise TypeError("Expected ZkLoginInputs instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZkLoginInputsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ZkLoginProofProtocol(typing.Protocol):
    """
    A zklogin groth16 proof

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-proof = circom-g1 circom-g2 circom-g1
    ```
    """

    def a(self, ):
        raise NotImplementedError
    def b(self, ):
        raise NotImplementedError
    def c(self, ):
        raise NotImplementedError
# ZkLoginProof is a Rust-only trait - it's a wrapper around a Rust implementation.
class ZkLoginProof():
    """
    A zklogin groth16 proof

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-proof = circom-g1 circom-g2 circom-g1
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, a: "CircomG1",b: "CircomG2",c: "CircomG1"):
        _UniffiConverterTypeCircomG1.check_lower(a)
        
        _UniffiConverterTypeCircomG2.check_lower(b)
        
        _UniffiConverterTypeCircomG1.check_lower(c)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginproof_new,
        _UniffiConverterTypeCircomG1.lower(a),
        _UniffiConverterTypeCircomG2.lower(b),
        _UniffiConverterTypeCircomG1.lower(c))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginproof, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginproof, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def a(self, ) -> "CircomG1":
        return _UniffiConverterTypeCircomG1.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_a,self._uniffi_clone_pointer(),)
        )





    def b(self, ) -> "CircomG2":
        return _UniffiConverterTypeCircomG2.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_b,self._uniffi_clone_pointer(),)
        )





    def c(self, ) -> "CircomG1":
        return _UniffiConverterTypeCircomG1.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginproof_c,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeZkLoginProof:

    @staticmethod
    def lift(value: int):
        return ZkLoginProof._make_instance_(value)

    @staticmethod
    def check_lower(value: ZkLoginProof):
        if not isinstance(value, ZkLoginProof):
            raise TypeError("Expected ZkLoginProof instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZkLoginProofProtocol):
        if not isinstance(value, ZkLoginProof):
            raise TypeError("Expected ZkLoginProof instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZkLoginProofProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ZkLoginPublicIdentifierProtocol(typing.Protocol):
    """
    Public Key equivalent for Zklogin authenticators

    A `ZkLoginPublicIdentifier` is the equivalent of a public key for other
    account authenticators, and contains the information required to derive the
    onchain account `Address` for a Zklogin authenticator.

    ## Note

    Due to a historical bug that was introduced in the IOTA Typescript SDK when
    the zklogin authenticator was first introduced, there are now possibly two
    "valid" addresses for each zklogin authenticator depending on the
    bit-pattern of the `address_seed` value.

    The original bug incorrectly derived a zklogin's address by stripping any
    leading zero-bytes that could have been present in the 32-byte length
    `address_seed` value prior to hashing, leading to a different derived
    address. This incorrectly derived address was presented to users of various
    wallets, leading them to sending funds to these addresses that they couldn't
    access. Instead of letting these users lose any assets that were sent to
    these addresses, the IOTA network decided to change the protocol to allow
    for a zklogin authenticator who's `address_seed` value had leading
    zero-bytes be authorized to sign for both the addresses derived from both
    the unpadded and padded `address_seed` value.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-public-identifier-bcs = bytes ; where the contents are defined by
    ; <zklogin-public-identifier>

    zklogin-public-identifier = zklogin-public-identifier-iss
    address-seed

    zklogin-public-identifier-unpadded = zklogin-public-identifier-iss
    address-seed-unpadded

    ; The iss, or issuer, is a utf8 string that is less than 255 bytes long
    ; and is serialized with the iss's length in bytes as a u8 followed by
    ; the bytes of the iss
    zklogin-public-identifier-iss = u8 *255(OCTET)

    ; A Bn254FieldElement serialized as a 32-byte big-endian value
    address-seed = 32(OCTET)

    ; A Bn254FieldElement serialized as a 32-byte big-endian value
    ; with any leading zero bytes stripped
    address-seed-unpadded = %x00 / %x01-ff *31(OCTET)
    ```
    """

    def address_seed(self, ):
        raise NotImplementedError
    def derive_address(self, ):
        """
        Provides an iterator over the addresses that correspond to this zklogin
        authenticator.

        In the majority of instances this will only yield a single address,
        except for the instances where the `address_seed` value has a
        leading zero-byte, in such cases the returned iterator will yield
        two addresses.
        """

        raise NotImplementedError
    def derive_address_padded(self, ):
        """
        Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
        byte length of the `iss` followed by the `iss` bytes themselves and
        the full 32 byte `address_seed` value, all prefixed with the zklogin
        `SignatureScheme` flag (`0x05`).

        `hash( 0x05 || iss_bytes_len || iss_bytes || 32_byte_address_seed )`
        """

        raise NotImplementedError
    def derive_address_unpadded(self, ):
        """
        Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
        byte length of the `iss` followed by the `iss` bytes themselves and
        the `address_seed` bytes with any leading zero-bytes stripped, all
        prefixed with the zklogin `SignatureScheme` flag (`0x05`).

        `hash( 0x05 || iss_bytes_len || iss_bytes ||
        unpadded_32_byte_address_seed )`
        """

        raise NotImplementedError
    def iss(self, ):
        raise NotImplementedError
# ZkLoginPublicIdentifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class ZkLoginPublicIdentifier():
    """
    Public Key equivalent for Zklogin authenticators

    A `ZkLoginPublicIdentifier` is the equivalent of a public key for other
    account authenticators, and contains the information required to derive the
    onchain account `Address` for a Zklogin authenticator.

    ## Note

    Due to a historical bug that was introduced in the IOTA Typescript SDK when
    the zklogin authenticator was first introduced, there are now possibly two
    "valid" addresses for each zklogin authenticator depending on the
    bit-pattern of the `address_seed` value.

    The original bug incorrectly derived a zklogin's address by stripping any
    leading zero-bytes that could have been present in the 32-byte length
    `address_seed` value prior to hashing, leading to a different derived
    address. This incorrectly derived address was presented to users of various
    wallets, leading them to sending funds to these addresses that they couldn't
    access. Instead of letting these users lose any assets that were sent to
    these addresses, the IOTA network decided to change the protocol to allow
    for a zklogin authenticator who's `address_seed` value had leading
    zero-bytes be authorized to sign for both the addresses derived from both
    the unpadded and padded `address_seed` value.

    # BCS

    The BCS serialized form for this type is defined by the following ABNF:

    ```text
    zklogin-public-identifier-bcs = bytes ; where the contents are defined by
    ; <zklogin-public-identifier>

    zklogin-public-identifier = zklogin-public-identifier-iss
    address-seed

    zklogin-public-identifier-unpadded = zklogin-public-identifier-iss
    address-seed-unpadded

    ; The iss, or issuer, is a utf8 string that is less than 255 bytes long
    ; and is serialized with the iss's length in bytes as a u8 followed by
    ; the bytes of the iss
    zklogin-public-identifier-iss = u8 *255(OCTET)

    ; A Bn254FieldElement serialized as a 32-byte big-endian value
    address-seed = 32(OCTET)

    ; A Bn254FieldElement serialized as a 32-byte big-endian value
    ; with any leading zero bytes stripped
    address-seed-unpadded = %x00 / %x01-ff *31(OCTET)
    ```
    """

    _pointer: ctypes.c_void_p
    def __init__(self, iss: "str",address_seed: "Bn254FieldElement"):
        _UniffiConverterString.check_lower(iss)
        
        _UniffiConverterTypeBn254FieldElement.check_lower(address_seed)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginpublicidentifier_new,
        _UniffiConverterString.lower(iss),
        _UniffiConverterTypeBn254FieldElement.lower(address_seed))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginpublicidentifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginpublicidentifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def address_seed(self, ) -> "Bn254FieldElement":
        return _UniffiConverterTypeBn254FieldElement.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_address_seed,self._uniffi_clone_pointer(),)
        )





    def derive_address(self, ) -> "typing.List[Address]":
        """
        Provides an iterator over the addresses that correspond to this zklogin
        authenticator.

        In the majority of instances this will only yield a single address,
        except for the instances where the `address_seed` value has a
        leading zero-byte, in such cases the returned iterator will yield
        two addresses.
        """

        return _UniffiConverterSequenceTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address,self._uniffi_clone_pointer(),)
        )





    def derive_address_padded(self, ) -> "Address":
        """
        Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
        byte length of the `iss` followed by the `iss` bytes themselves and
        the full 32 byte `address_seed` value, all prefixed with the zklogin
        `SignatureScheme` flag (`0x05`).

        `hash( 0x05 || iss_bytes_len || iss_bytes || 32_byte_address_seed )`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_padded,self._uniffi_clone_pointer(),)
        )





    def derive_address_unpadded(self, ) -> "Address":
        """
        Derive an `Address` from this `ZkLoginPublicIdentifier` by hashing the
        byte length of the `iss` followed by the `iss` bytes themselves and
        the `address_seed` bytes with any leading zero-bytes stripped, all
        prefixed with the zklogin `SignatureScheme` flag (`0x05`).

        `hash( 0x05 || iss_bytes_len || iss_bytes ||
        unpadded_32_byte_address_seed )`
        """

        return _UniffiConverterTypeAddress.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_derive_address_unpadded,self._uniffi_clone_pointer(),)
        )





    def iss(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginpublicidentifier_iss,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeZkLoginPublicIdentifier:

    @staticmethod
    def lift(value: int):
        return ZkLoginPublicIdentifier._make_instance_(value)

    @staticmethod
    def check_lower(value: ZkLoginPublicIdentifier):
        if not isinstance(value, ZkLoginPublicIdentifier):
            raise TypeError("Expected ZkLoginPublicIdentifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZkLoginPublicIdentifierProtocol):
        if not isinstance(value, ZkLoginPublicIdentifier):
            raise TypeError("Expected ZkLoginPublicIdentifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZkLoginPublicIdentifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class ZkloginVerifierProtocol(typing.Protocol):
    def jwks(self, ):
        raise NotImplementedError
    def verify(self, message: "bytes",authenticator: "ZkLoginAuthenticator"):
        raise NotImplementedError
    def with_jwks(self, jwks: "dict[JwkId, Jwk]"):
        raise NotImplementedError
# ZkloginVerifier is a Rust-only trait - it's a wrapper around a Rust implementation.
class ZkloginVerifier():
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_free_zkloginverifier, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_clone_zkloginverifier, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def new_dev(cls, ):
        """
        Load a fixed verifying key from zkLogin.vkey output. This is based on a
        local setup and should not be used in production.
        """

        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_dev,)
        return cls._make_instance_(pointer)

    @classmethod
    def new_mainnet(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_constructor_zkloginverifier_new_mainnet,)
        return cls._make_instance_(pointer)



    def jwks(self, ) -> "dict[JwkId, Jwk]":
        return _UniffiConverterMapTypeJwkIdTypeJwk.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_jwks,self._uniffi_clone_pointer(),)
        )





    def verify(self, message: "bytes",authenticator: "ZkLoginAuthenticator") -> None:
        _UniffiConverterBytes.check_lower(message)
        
        _UniffiConverterTypeZkLoginAuthenticator.check_lower(authenticator)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_verify,self._uniffi_clone_pointer(),
        _UniffiConverterBytes.lower(message),
        _UniffiConverterTypeZkLoginAuthenticator.lower(authenticator))






    def with_jwks(self, jwks: "dict[JwkId, Jwk]") -> "ZkloginVerifier":
        _UniffiConverterMapTypeJwkIdTypeJwk.check_lower(jwks)
        
        return _UniffiConverterTypeZkloginVerifier.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_method_zkloginverifier_with_jwks,self._uniffi_clone_pointer(),
        _UniffiConverterMapTypeJwkIdTypeJwk.lower(jwks))
        )






class _UniffiConverterTypeZkloginVerifier:

    @staticmethod
    def lift(value: int):
        return ZkloginVerifier._make_instance_(value)

    @staticmethod
    def check_lower(value: ZkloginVerifier):
        if not isinstance(value, ZkloginVerifier):
            raise TypeError("Expected ZkloginVerifier instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ZkloginVerifierProtocol):
        if not isinstance(value, ZkloginVerifier):
            raise TypeError("Expected ZkloginVerifier instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ZkloginVerifierProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
Base64 = str
BigInt = str
Value = str

# Async support# RustFuturePoll values
_UNIFFI_RUST_FUTURE_POLL_READY = 0
_UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1

# Stores futures for _uniffi_continuation_callback
_UniffiContinuationHandleMap = _UniffiHandleMap()

_UNIFFI_GLOBAL_EVENT_LOOP = None

"""
Set the event loop to use for async functions

This is needed if some async functions run outside of the eventloop, for example:
    - A non-eventloop thread is spawned, maybe from `EventLoop.run_in_executor` or maybe from the
      Rust code spawning its own thread.
    - The Rust code calls an async callback method from a sync callback function, using something
      like `pollster` to block on the async call.

In this case, we need an event loop to run the Python async function, but there's no eventloop set
for the thread.  Use `uniffi_set_event_loop` to force an eventloop to be used in this case.
"""
def uniffi_set_event_loop(eventloop: asyncio.BaseEventLoop):
    global _UNIFFI_GLOBAL_EVENT_LOOP
    _UNIFFI_GLOBAL_EVENT_LOOP = eventloop

def _uniffi_get_event_loop():
    if _UNIFFI_GLOBAL_EVENT_LOOP is not None:
        return _UNIFFI_GLOBAL_EVENT_LOOP
    else:
        return asyncio.get_running_loop()

# Continuation callback for async functions
# lift the return value or error and resolve the future, causing the async function to resume.
@_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK
def _uniffi_continuation_callback(future_ptr, poll_code):
    (eventloop, future) = _UniffiContinuationHandleMap.remove(future_ptr)
    eventloop.call_soon_threadsafe(_uniffi_set_future_result, future, poll_code)

def _uniffi_set_future_result(future, poll_code):
    if not future.cancelled():
        future.set_result(poll_code)

async def _uniffi_rust_call_async(rust_future, ffi_poll, ffi_complete, ffi_free, lift_func, error_ffi_converter):
    try:
        eventloop = _uniffi_get_event_loop()

        # Loop and poll until we see a _UNIFFI_RUST_FUTURE_POLL_READY value
        while True:
            future = eventloop.create_future()
            ffi_poll(
                rust_future,
                _uniffi_continuation_callback,
                _UniffiContinuationHandleMap.insert((eventloop, future)),
            )
            poll_code = await future
            if poll_code == _UNIFFI_RUST_FUTURE_POLL_READY:
                break

        return lift_func(
            _uniffi_rust_call_with_error(error_ffi_converter, ffi_complete, rust_future)
        )
    finally:
        ffi_free(rust_future)

def active_jwk_from_bcs(bcs: "bytes") -> "ActiveJwk":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeActiveJwk.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_active_jwk_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def active_jwk_to_bcs(data: "ActiveJwk") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeActiveJwk.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_active_jwk_to_bcs,
        _UniffiConverterTypeActiveJwk.lower(data)))


def address_from_bcs(bcs: "bytes") -> "Address":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeAddress.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_address_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def address_to_bcs(data: "Address") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeAddress.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_address_to_bcs,
        _UniffiConverterTypeAddress.lower(data)))


def argument_from_bcs(bcs: "bytes") -> "Argument":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeArgument.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_argument_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def argument_to_bcs(data: "Argument") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeArgument.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_argument_to_bcs,
        _UniffiConverterTypeArgument.lower(data)))


def authenticator_state_expire_from_bcs(bcs: "bytes") -> "AuthenticatorStateExpire":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeAuthenticatorStateExpire.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def authenticator_state_expire_to_bcs(data: "AuthenticatorStateExpire") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeAuthenticatorStateExpire.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_expire_to_bcs,
        _UniffiConverterTypeAuthenticatorStateExpire.lower(data)))


def authenticator_state_update_v1_from_bcs(bcs: "bytes") -> "AuthenticatorStateUpdateV1":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeAuthenticatorStateUpdateV1.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def authenticator_state_update_v1_to_bcs(data: "AuthenticatorStateUpdateV1") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeAuthenticatorStateUpdateV1.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_authenticator_state_update_v1_to_bcs,
        _UniffiConverterTypeAuthenticatorStateUpdateV1.lower(data)))


def base64_decode(input: "str") -> "bytes":
    _UniffiConverterString.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_base64_decode,
        _UniffiConverterString.lower(input)))


def base64_encode(input: "bytes") -> "str":
    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_func_base64_encode,
        _UniffiConverterBytes.lower(input)))


def bls12381_public_key_from_bcs(bcs: "bytes") -> "Bls12381PublicKey":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeBls12381PublicKey.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def bls12381_public_key_to_bcs(data: "Bls12381PublicKey") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeBls12381PublicKey.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_public_key_to_bcs,
        _UniffiConverterTypeBls12381PublicKey.lower(data)))


def bls12381_signature_from_bcs(bcs: "bytes") -> "Bls12381Signature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeBls12381Signature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def bls12381_signature_to_bcs(data: "Bls12381Signature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeBls12381Signature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bls12381_signature_to_bcs,
        _UniffiConverterTypeBls12381Signature.lower(data)))


def bn254_field_element_from_bcs(bcs: "bytes") -> "Bn254FieldElement":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeBn254FieldElement.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def bn254_field_element_to_bcs(data: "Bn254FieldElement") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeBn254FieldElement.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bn254_field_element_to_bcs,
        _UniffiConverterTypeBn254FieldElement.lower(data)))


def bool_from_bcs(input: "bytes") -> "bool":
    """
    Create a bool from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterBool.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bool_from_bcs,
        _UniffiConverterBytes.lower(input)))


def bool_to_bcs(input: "bool") -> "bytes":
    """
    Convert this bool to BCS encoded bytes.
    """

    _UniffiConverterBool.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_bool_to_bcs,
        _UniffiConverterBool.lower(input)))


def cancelled_transaction_from_bcs(bcs: "bytes") -> "CancelledTransaction":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCancelledTransaction.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def cancelled_transaction_to_bcs(data: "CancelledTransaction") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCancelledTransaction.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_cancelled_transaction_to_bcs,
        _UniffiConverterTypeCancelledTransaction.lower(data)))


def change_epoch_from_bcs(bcs: "bytes") -> "ChangeEpoch":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeChangeEpoch.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def change_epoch_to_bcs(data: "ChangeEpoch") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeChangeEpoch.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_to_bcs,
        _UniffiConverterTypeChangeEpoch.lower(data)))


def change_epoch_v2_from_bcs(bcs: "bytes") -> "ChangeEpochV2":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeChangeEpochV2.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def change_epoch_v2_to_bcs(data: "ChangeEpochV2") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeChangeEpochV2.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_change_epoch_v2_to_bcs,
        _UniffiConverterTypeChangeEpochV2.lower(data)))


def changed_object_from_bcs(bcs: "bytes") -> "ChangedObject":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeChangedObject.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_changed_object_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def changed_object_to_bcs(data: "ChangedObject") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeChangedObject.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_changed_object_to_bcs,
        _UniffiConverterTypeChangedObject.lower(data)))


def checkpoint_commitment_from_bcs(bcs: "bytes") -> "CheckpointCommitment":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCheckpointCommitment.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def checkpoint_commitment_to_bcs(data: "CheckpointCommitment") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCheckpointCommitment.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_commitment_to_bcs,
        _UniffiConverterTypeCheckpointCommitment.lower(data)))


def checkpoint_contents_from_bcs(bcs: "bytes") -> "CheckpointContents":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCheckpointContents.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def checkpoint_contents_to_bcs(data: "CheckpointContents") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCheckpointContents.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_contents_to_bcs,
        _UniffiConverterTypeCheckpointContents.lower(data)))


def checkpoint_summary_from_bcs(bcs: "bytes") -> "CheckpointSummary":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCheckpointSummary.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def checkpoint_summary_to_bcs(data: "CheckpointSummary") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCheckpointSummary.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_summary_to_bcs,
        _UniffiConverterTypeCheckpointSummary.lower(data)))


def checkpoint_transaction_info_from_bcs(bcs: "bytes") -> "CheckpointTransactionInfo":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCheckpointTransactionInfo.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def checkpoint_transaction_info_to_bcs(data: "CheckpointTransactionInfo") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCheckpointTransactionInfo.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_checkpoint_transaction_info_to_bcs,
        _UniffiConverterTypeCheckpointTransactionInfo.lower(data)))


def circom_g1_from_bcs(bcs: "bytes") -> "CircomG1":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCircomG1.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g1_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def circom_g1_to_bcs(data: "CircomG1") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCircomG1.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g1_to_bcs,
        _UniffiConverterTypeCircomG1.lower(data)))


def circom_g2_from_bcs(bcs: "bytes") -> "CircomG2":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCircomG2.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g2_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def circom_g2_to_bcs(data: "CircomG2") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCircomG2.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_circom_g2_to_bcs,
        _UniffiConverterTypeCircomG2.lower(data)))


def command_argument_error_from_bcs(bcs: "bytes") -> "CommandArgumentError":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCommandArgumentError.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_argument_error_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def command_argument_error_to_bcs(data: "CommandArgumentError") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCommandArgumentError.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_argument_error_to_bcs,
        _UniffiConverterTypeCommandArgumentError.lower(data)))


def command_from_bcs(bcs: "bytes") -> "Command":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeCommand.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def command_to_bcs(data: "Command") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeCommand.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_command_to_bcs,
        _UniffiConverterTypeCommand.lower(data)))


def consensus_commit_prologue_v1_from_bcs(bcs: "bytes") -> "ConsensusCommitPrologueV1":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeConsensusCommitPrologueV1.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def consensus_commit_prologue_v1_to_bcs(data: "ConsensusCommitPrologueV1") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeConsensusCommitPrologueV1.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_commit_prologue_v1_to_bcs,
        _UniffiConverterTypeConsensusCommitPrologueV1.lower(data)))


def consensus_determined_version_assignments_from_bcs(bcs: "bytes") -> "ConsensusDeterminedVersionAssignments":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeConsensusDeterminedVersionAssignments.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def consensus_determined_version_assignments_to_bcs(data: "ConsensusDeterminedVersionAssignments") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeConsensusDeterminedVersionAssignments.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_consensus_determined_version_assignments_to_bcs,
        _UniffiConverterTypeConsensusDeterminedVersionAssignments.lower(data)))


def digest_from_bcs(bcs: "bytes") -> "Digest":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeDigest.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_digest_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def digest_to_bcs(data: "Digest") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeDigest.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_digest_to_bcs,
        _UniffiConverterTypeDigest.lower(data)))


def ed25519_public_key_from_bcs(bcs: "bytes") -> "Ed25519PublicKey":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeEd25519PublicKey.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def ed25519_public_key_to_bcs(data: "Ed25519PublicKey") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeEd25519PublicKey.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_public_key_to_bcs,
        _UniffiConverterTypeEd25519PublicKey.lower(data)))


def ed25519_signature_from_bcs(bcs: "bytes") -> "Ed25519Signature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeEd25519Signature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def ed25519_signature_to_bcs(data: "Ed25519Signature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeEd25519Signature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_ed25519_signature_to_bcs,
        _UniffiConverterTypeEd25519Signature.lower(data)))


def end_of_epoch_data_from_bcs(bcs: "bytes") -> "EndOfEpochData":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeEndOfEpochData.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def end_of_epoch_data_to_bcs(data: "EndOfEpochData") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeEndOfEpochData.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_end_of_epoch_data_to_bcs,
        _UniffiConverterTypeEndOfEpochData.lower(data)))


def event_from_bcs(bcs: "bytes") -> "Event":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeEvent.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_event_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def event_to_bcs(data: "Event") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeEvent.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_event_to_bcs,
        _UniffiConverterTypeEvent.lower(data)))


def execution_error_from_bcs(bcs: "bytes") -> "ExecutionError":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeExecutionError.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_error_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def execution_error_to_bcs(data: "ExecutionError") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeExecutionError.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_error_to_bcs,
        _UniffiConverterTypeExecutionError.lower(data)))


def execution_status_from_bcs(bcs: "bytes") -> "ExecutionStatus":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeExecutionStatus.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_status_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def execution_status_to_bcs(data: "ExecutionStatus") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeExecutionStatus.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_status_to_bcs,
        _UniffiConverterTypeExecutionStatus.lower(data)))


def execution_time_observation_from_bcs(bcs: "bytes") -> "ExecutionTimeObservation":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeExecutionTimeObservation.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def execution_time_observation_key_from_bcs(bcs: "bytes") -> "ExecutionTimeObservationKey":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeExecutionTimeObservationKey.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def execution_time_observation_key_to_bcs(data: "ExecutionTimeObservationKey") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeExecutionTimeObservationKey.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_key_to_bcs,
        _UniffiConverterTypeExecutionTimeObservationKey.lower(data)))


def execution_time_observation_to_bcs(data: "ExecutionTimeObservation") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeExecutionTimeObservation.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observation_to_bcs,
        _UniffiConverterTypeExecutionTimeObservation.lower(data)))


def execution_time_observations_from_bcs(bcs: "bytes") -> "ExecutionTimeObservations":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeExecutionTimeObservations.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def execution_time_observations_to_bcs(data: "ExecutionTimeObservations") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeExecutionTimeObservations.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_execution_time_observations_to_bcs,
        _UniffiConverterTypeExecutionTimeObservations.lower(data)))


def gas_cost_summary_from_bcs(bcs: "bytes") -> "GasCostSummary":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeGasCostSummary.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def gas_cost_summary_to_bcs(data: "GasCostSummary") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeGasCostSummary.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_cost_summary_to_bcs,
        _UniffiConverterTypeGasCostSummary.lower(data)))


def gas_payment_from_bcs(bcs: "bytes") -> "GasPayment":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeGasPayment.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_payment_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def gas_payment_to_bcs(data: "GasPayment") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeGasPayment.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_gas_payment_to_bcs,
        _UniffiConverterTypeGasPayment.lower(data)))


def generate_mnemonic(word_count: "typing.Optional[MnemonicLength]") -> "str":
    """
    Generate a new BIP-39 mnemonic in English.
    Supported word counts are 12 and 24 (default).
    """

    _UniffiConverterOptionalTypeMnemonicLength.check_lower(word_count)
    
    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_func_generate_mnemonic,
        _UniffiConverterOptionalTypeMnemonicLength.lower(word_count)))


def genesis_object_from_bcs(bcs: "bytes") -> "GenesisObject":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeGenesisObject.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_object_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def genesis_object_to_bcs(data: "GenesisObject") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeGenesisObject.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_object_to_bcs,
        _UniffiConverterTypeGenesisObject.lower(data)))


def genesis_transaction_from_bcs(bcs: "bytes") -> "GenesisTransaction":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeGenesisTransaction.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def genesis_transaction_to_bcs(data: "GenesisTransaction") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeGenesisTransaction.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_genesis_transaction_to_bcs,
        _UniffiConverterTypeGenesisTransaction.lower(data)))


def hex_decode(input: "str") -> "bytes":
    _UniffiConverterString.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_hex_decode,
        _UniffiConverterString.lower(input)))


def hex_encode(input: "bytes") -> "str":
    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterString.lift(_uniffi_rust_call(_UniffiLib.uniffi_iota_sdk_ffi_fn_func_hex_encode,
        _UniffiConverterBytes.lower(input)))


def i16_from_bcs(input: "bytes") -> "int":
    """
    Create a i16 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterInt16.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i16_from_bcs,
        _UniffiConverterBytes.lower(input)))


def i16_to_bcs(input: "int") -> "bytes":
    """
    Convert this i16 to BCS encoded bytes.
    """

    _UniffiConverterInt16.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i16_to_bcs,
        _UniffiConverterInt16.lower(input)))


def i32_from_bcs(input: "bytes") -> "int":
    """
    Create a i32 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterInt32.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i32_from_bcs,
        _UniffiConverterBytes.lower(input)))


def i32_to_bcs(input: "int") -> "bytes":
    """
    Convert this i32 to BCS encoded bytes.
    """

    _UniffiConverterInt32.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i32_to_bcs,
        _UniffiConverterInt32.lower(input)))


def i64_from_bcs(input: "bytes") -> "int":
    """
    Create a i64 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterInt64.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i64_from_bcs,
        _UniffiConverterBytes.lower(input)))


def i64_to_bcs(input: "int") -> "bytes":
    """
    Convert this i64 to BCS encoded bytes.
    """

    _UniffiConverterInt64.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i64_to_bcs,
        _UniffiConverterInt64.lower(input)))


def i8_from_bcs(input: "bytes") -> "int":
    """
    Create a i8 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterInt8.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i8_from_bcs,
        _UniffiConverterBytes.lower(input)))


def i8_to_bcs(input: "int") -> "bytes":
    """
    Convert this i8 to BCS encoded bytes.
    """

    _UniffiConverterInt8.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_i8_to_bcs,
        _UniffiConverterInt8.lower(input)))


def id_operation_from_bcs(bcs: "bytes") -> "IdOperation":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeIdOperation.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_id_operation_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def id_operation_to_bcs(data: "IdOperation") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeIdOperation.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_id_operation_to_bcs,
        _UniffiConverterTypeIdOperation.lower(data)))


def identifier_from_bcs(bcs: "bytes") -> "Identifier":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeIdentifier.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_identifier_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def identifier_to_bcs(data: "Identifier") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeIdentifier.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_identifier_to_bcs,
        _UniffiConverterTypeIdentifier.lower(data)))


def input_from_bcs(bcs: "bytes") -> "Input":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeInput.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_input_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def input_to_bcs(data: "Input") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeInput.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_input_to_bcs,
        _UniffiConverterTypeInput.lower(data)))


def jwk_from_bcs(bcs: "bytes") -> "Jwk":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeJwk.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def jwk_id_from_bcs(bcs: "bytes") -> "JwkId":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeJwkId.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_id_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def jwk_id_to_bcs(data: "JwkId") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeJwkId.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_id_to_bcs,
        _UniffiConverterTypeJwkId.lower(data)))


def jwk_to_bcs(data: "Jwk") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeJwk.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_jwk_to_bcs,
        _UniffiConverterTypeJwk.lower(data)))


def make_move_vector_from_bcs(bcs: "bytes") -> "MakeMoveVector":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMakeMoveVector.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_make_move_vector_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def make_move_vector_to_bcs(data: "MakeMoveVector") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMakeMoveVector.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_make_move_vector_to_bcs,
        _UniffiConverterTypeMakeMoveVector.lower(data)))


def merge_coins_from_bcs(bcs: "bytes") -> "MergeCoins":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMergeCoins.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_merge_coins_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def merge_coins_to_bcs(data: "MergeCoins") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMergeCoins.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_merge_coins_to_bcs,
        _UniffiConverterTypeMergeCoins.lower(data)))


def move_call_from_bcs(bcs: "bytes") -> "MoveCall":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMoveCall.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_call_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def move_call_to_bcs(data: "MoveCall") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMoveCall.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_call_to_bcs,
        _UniffiConverterTypeMoveCall.lower(data)))


def move_location_from_bcs(bcs: "bytes") -> "MoveLocation":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMoveLocation.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_location_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def move_location_to_bcs(data: "MoveLocation") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMoveLocation.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_location_to_bcs,
        _UniffiConverterTypeMoveLocation.lower(data)))


def move_package_from_bcs(bcs: "bytes") -> "MovePackage":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMovePackage.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_package_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def move_package_to_bcs(data: "MovePackage") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMovePackage.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_package_to_bcs,
        _UniffiConverterTypeMovePackage.lower(data)))


def move_struct_from_bcs(bcs: "bytes") -> "MoveStruct":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMoveStruct.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_struct_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def move_struct_to_bcs(data: "MoveStruct") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMoveStruct.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_move_struct_to_bcs,
        _UniffiConverterTypeMoveStruct.lower(data)))


def multisig_aggregated_signature_from_bcs(bcs: "bytes") -> "MultisigAggregatedSignature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMultisigAggregatedSignature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def multisig_aggregated_signature_to_bcs(data: "MultisigAggregatedSignature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMultisigAggregatedSignature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_aggregated_signature_to_bcs,
        _UniffiConverterTypeMultisigAggregatedSignature.lower(data)))


def multisig_committee_from_bcs(bcs: "bytes") -> "MultisigCommittee":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMultisigCommittee.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_committee_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def multisig_committee_to_bcs(data: "MultisigCommittee") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMultisigCommittee.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_committee_to_bcs,
        _UniffiConverterTypeMultisigCommittee.lower(data)))


def multisig_member_from_bcs(bcs: "bytes") -> "MultisigMember":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMultisigMember.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def multisig_member_public_key_from_bcs(bcs: "bytes") -> "MultisigMemberPublicKey":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMultisigMemberPublicKey.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def multisig_member_public_key_to_bcs(data: "MultisigMemberPublicKey") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMultisigMemberPublicKey.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_public_key_to_bcs,
        _UniffiConverterTypeMultisigMemberPublicKey.lower(data)))


def multisig_member_signature_from_bcs(bcs: "bytes") -> "MultisigMemberSignature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeMultisigMemberSignature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def multisig_member_signature_to_bcs(data: "MultisigMemberSignature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMultisigMemberSignature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_signature_to_bcs,
        _UniffiConverterTypeMultisigMemberSignature.lower(data)))


def multisig_member_to_bcs(data: "MultisigMember") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeMultisigMember.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_multisig_member_to_bcs,
        _UniffiConverterTypeMultisigMember.lower(data)))


def object_data_from_bcs(bcs: "bytes") -> "ObjectData":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeObjectData.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_data_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def object_data_to_bcs(data: "ObjectData") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeObjectData.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_data_to_bcs,
        _UniffiConverterTypeObjectData.lower(data)))


def object_from_bcs(bcs: "bytes") -> "Object":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeObject.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def object_id_from_bcs(bcs: "bytes") -> "ObjectId":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeObjectId.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_id_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def object_id_to_bcs(data: "ObjectId") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeObjectId.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_id_to_bcs,
        _UniffiConverterTypeObjectId.lower(data)))


def object_in_from_bcs(bcs: "bytes") -> "ObjectIn":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeObjectIn.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_in_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def object_in_to_bcs(data: "ObjectIn") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeObjectIn.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_in_to_bcs,
        _UniffiConverterTypeObjectIn.lower(data)))


def object_out_from_bcs(bcs: "bytes") -> "ObjectOut":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeObjectOut.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_out_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def object_out_to_bcs(data: "ObjectOut") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeObjectOut.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_out_to_bcs,
        _UniffiConverterTypeObjectOut.lower(data)))


def object_reference_from_bcs(bcs: "bytes") -> "ObjectReference":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeObjectReference.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_reference_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def object_reference_to_bcs(data: "ObjectReference") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeObjectReference.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_reference_to_bcs,
        _UniffiConverterTypeObjectReference.lower(data)))


def object_to_bcs(data: "Object") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeObject.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_object_to_bcs,
        _UniffiConverterTypeObject.lower(data)))


def owner_from_bcs(bcs: "bytes") -> "Owner":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeOwner.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_owner_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def owner_to_bcs(data: "Owner") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeOwner.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_owner_to_bcs,
        _UniffiConverterTypeOwner.lower(data)))


def package_upgrade_error_from_bcs(bcs: "bytes") -> "PackageUpgradeError":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypePackageUpgradeError.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def package_upgrade_error_to_bcs(data: "PackageUpgradeError") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypePackageUpgradeError.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_package_upgrade_error_to_bcs,
        _UniffiConverterTypePackageUpgradeError.lower(data)))


def passkey_authenticator_from_bcs(bcs: "bytes") -> "PasskeyAuthenticator":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypePasskeyAuthenticator.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def passkey_authenticator_to_bcs(data: "PasskeyAuthenticator") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypePasskeyAuthenticator.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_passkey_authenticator_to_bcs,
        _UniffiConverterTypePasskeyAuthenticator.lower(data)))


def programmable_transaction_from_bcs(bcs: "bytes") -> "ProgrammableTransaction":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeProgrammableTransaction.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def programmable_transaction_to_bcs(data: "ProgrammableTransaction") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeProgrammableTransaction.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_programmable_transaction_to_bcs,
        _UniffiConverterTypeProgrammableTransaction.lower(data)))


def publish_from_bcs(bcs: "bytes") -> "Publish":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypePublish.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_publish_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def publish_to_bcs(data: "Publish") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypePublish.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_publish_to_bcs,
        _UniffiConverterTypePublish.lower(data)))


def randomness_state_update_from_bcs(bcs: "bytes") -> "RandomnessStateUpdate":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeRandomnessStateUpdate.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def randomness_state_update_to_bcs(data: "RandomnessStateUpdate") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeRandomnessStateUpdate.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_randomness_state_update_to_bcs,
        _UniffiConverterTypeRandomnessStateUpdate.lower(data)))


def secp256k1_public_key_from_bcs(bcs: "bytes") -> "Secp256k1PublicKey":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSecp256k1PublicKey.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def secp256k1_public_key_to_bcs(data: "Secp256k1PublicKey") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSecp256k1PublicKey.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_public_key_to_bcs,
        _UniffiConverterTypeSecp256k1PublicKey.lower(data)))


def secp256k1_signature_from_bcs(bcs: "bytes") -> "Secp256k1Signature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSecp256k1Signature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def secp256k1_signature_to_bcs(data: "Secp256k1Signature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSecp256k1Signature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256k1_signature_to_bcs,
        _UniffiConverterTypeSecp256k1Signature.lower(data)))


def secp256r1_public_key_from_bcs(bcs: "bytes") -> "Secp256r1PublicKey":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSecp256r1PublicKey.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def secp256r1_public_key_to_bcs(data: "Secp256r1PublicKey") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSecp256r1PublicKey.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_public_key_to_bcs,
        _UniffiConverterTypeSecp256r1PublicKey.lower(data)))


def secp256r1_signature_from_bcs(bcs: "bytes") -> "Secp256r1Signature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSecp256r1Signature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def secp256r1_signature_to_bcs(data: "Secp256r1Signature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSecp256r1Signature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_secp256r1_signature_to_bcs,
        _UniffiConverterTypeSecp256r1Signature.lower(data)))


def signed_transaction_from_bcs(bcs: "bytes") -> "SignedTransaction":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSignedTransaction.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_signed_transaction_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def signed_transaction_to_bcs(data: "SignedTransaction") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSignedTransaction.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_signed_transaction_to_bcs,
        _UniffiConverterTypeSignedTransaction.lower(data)))


def simple_signature_from_bcs(bcs: "bytes") -> "SimpleSignature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSimpleSignature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_simple_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def simple_signature_to_bcs(data: "SimpleSignature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSimpleSignature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_simple_signature_to_bcs,
        _UniffiConverterTypeSimpleSignature.lower(data)))


def split_coins_from_bcs(bcs: "bytes") -> "SplitCoins":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSplitCoins.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_split_coins_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def split_coins_to_bcs(data: "SplitCoins") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSplitCoins.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_split_coins_to_bcs,
        _UniffiConverterTypeSplitCoins.lower(data)))


def string_from_bcs(input: "bytes") -> "str":
    """
    Create a String from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterString.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_string_from_bcs,
        _UniffiConverterBytes.lower(input)))


def string_to_bcs(input: "str") -> "bytes":
    """
    Convert this String to BCS encoded bytes.
    """

    _UniffiConverterString.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_string_to_bcs,
        _UniffiConverterString.lower(input)))


def struct_tag_from_bcs(bcs: "bytes") -> "StructTag":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeStructTag.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_struct_tag_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def struct_tag_to_bcs(data: "StructTag") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeStructTag.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_struct_tag_to_bcs,
        _UniffiConverterTypeStructTag.lower(data)))


def system_package_from_bcs(bcs: "bytes") -> "SystemPackage":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeSystemPackage.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_system_package_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def system_package_to_bcs(data: "SystemPackage") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeSystemPackage.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_system_package_to_bcs,
        _UniffiConverterTypeSystemPackage.lower(data)))


def transaction_effects_from_bcs(bcs: "bytes") -> "TransactionEffects":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransactionEffects.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_effects_to_bcs(data: "TransactionEffects") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransactionEffects.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_to_bcs,
        _UniffiConverterTypeTransactionEffects.lower(data)))


def transaction_effects_v1_from_bcs(bcs: "bytes") -> "TransactionEffectsV1":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransactionEffectsV1.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_effects_v1_to_bcs(data: "TransactionEffectsV1") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransactionEffectsV1.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_effects_v1_to_bcs,
        _UniffiConverterTypeTransactionEffectsV1.lower(data)))


def transaction_events_from_bcs(bcs: "bytes") -> "TransactionEvents":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransactionEvents.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_events_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_events_to_bcs(data: "TransactionEvents") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransactionEvents.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_events_to_bcs,
        _UniffiConverterTypeTransactionEvents.lower(data)))


def transaction_expiration_from_bcs(bcs: "bytes") -> "TransactionExpiration":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransactionExpiration.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_expiration_to_bcs(data: "TransactionExpiration") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransactionExpiration.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_expiration_to_bcs,
        _UniffiConverterTypeTransactionExpiration.lower(data)))


def transaction_from_bcs(bcs: "bytes") -> "Transaction":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransaction.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_kind_from_bcs(bcs: "bytes") -> "TransactionKind":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransactionKind.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_kind_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_kind_to_bcs(data: "TransactionKind") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransactionKind.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_kind_to_bcs,
        _UniffiConverterTypeTransactionKind.lower(data)))


def transaction_to_bcs(data: "Transaction") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransaction.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_to_bcs,
        _UniffiConverterTypeTransaction.lower(data)))


def transaction_v1_from_bcs(bcs: "bytes") -> "TransactionV1":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransactionV1.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_v1_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transaction_v1_to_bcs(data: "TransactionV1") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransactionV1.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transaction_v1_to_bcs,
        _UniffiConverterTypeTransactionV1.lower(data)))


def transfer_objects_from_bcs(bcs: "bytes") -> "TransferObjects":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTransferObjects.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transfer_objects_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def transfer_objects_to_bcs(data: "TransferObjects") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTransferObjects.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_transfer_objects_to_bcs,
        _UniffiConverterTypeTransferObjects.lower(data)))


def type_argument_error_from_bcs(bcs: "bytes") -> "TypeArgumentError":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTypeArgumentError.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_argument_error_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def type_argument_error_to_bcs(data: "TypeArgumentError") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTypeArgumentError.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_argument_error_to_bcs,
        _UniffiConverterTypeTypeArgumentError.lower(data)))


def type_origin_from_bcs(bcs: "bytes") -> "TypeOrigin":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTypeOrigin.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_origin_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def type_origin_to_bcs(data: "TypeOrigin") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTypeOrigin.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_origin_to_bcs,
        _UniffiConverterTypeTypeOrigin.lower(data)))


def type_tag_from_bcs(bcs: "bytes") -> "TypeTag":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeTypeTag.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_tag_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def type_tag_to_bcs(data: "TypeTag") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeTypeTag.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_type_tag_to_bcs,
        _UniffiConverterTypeTypeTag.lower(data)))


def u16_from_bcs(input: "bytes") -> "int":
    """
    Create a u16 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterUInt16.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u16_from_bcs,
        _UniffiConverterBytes.lower(input)))


def u16_to_bcs(input: "int") -> "bytes":
    """
    Convert this u16 to BCS encoded bytes.
    """

    _UniffiConverterUInt16.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u16_to_bcs,
        _UniffiConverterUInt16.lower(input)))


def u32_from_bcs(input: "bytes") -> "int":
    """
    Create a u32 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterUInt32.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u32_from_bcs,
        _UniffiConverterBytes.lower(input)))


def u32_to_bcs(input: "int") -> "bytes":
    """
    Convert this u32 to BCS encoded bytes.
    """

    _UniffiConverterUInt32.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u32_to_bcs,
        _UniffiConverterUInt32.lower(input)))


def u64_from_bcs(input: "bytes") -> "int":
    """
    Create a u64 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterUInt64.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u64_from_bcs,
        _UniffiConverterBytes.lower(input)))


def u64_to_bcs(input: "int") -> "bytes":
    """
    Convert this u64 to BCS encoded bytes.
    """

    _UniffiConverterUInt64.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u64_to_bcs,
        _UniffiConverterUInt64.lower(input)))


def u8_from_bcs(input: "bytes") -> "int":
    """
    Create a u8 from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(input)
    
    return _UniffiConverterUInt8.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u8_from_bcs,
        _UniffiConverterBytes.lower(input)))


def u8_to_bcs(input: "int") -> "bytes":
    """
    Convert this u8 to BCS encoded bytes.
    """

    _UniffiConverterUInt8.check_lower(input)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_u8_to_bcs,
        _UniffiConverterUInt8.lower(input)))


def unchanged_shared_kind_from_bcs(bcs: "bytes") -> "UnchangedSharedKind":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeUnchangedSharedKind.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def unchanged_shared_kind_to_bcs(data: "UnchangedSharedKind") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeUnchangedSharedKind.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_kind_to_bcs,
        _UniffiConverterTypeUnchangedSharedKind.lower(data)))


def unchanged_shared_object_from_bcs(bcs: "bytes") -> "UnchangedSharedObject":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeUnchangedSharedObject.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def unchanged_shared_object_to_bcs(data: "UnchangedSharedObject") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeUnchangedSharedObject.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_unchanged_shared_object_to_bcs,
        _UniffiConverterTypeUnchangedSharedObject.lower(data)))


def upgrade_from_bcs(bcs: "bytes") -> "Upgrade":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeUpgrade.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def upgrade_info_from_bcs(bcs: "bytes") -> "UpgradeInfo":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeUpgradeInfo.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_info_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def upgrade_info_to_bcs(data: "UpgradeInfo") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeUpgradeInfo.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_info_to_bcs,
        _UniffiConverterTypeUpgradeInfo.lower(data)))


def upgrade_to_bcs(data: "Upgrade") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeUpgrade.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_upgrade_to_bcs,
        _UniffiConverterTypeUpgrade.lower(data)))


def user_signature_from_bcs(bcs: "bytes") -> "UserSignature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeUserSignature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_user_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def user_signature_to_bcs(data: "UserSignature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeUserSignature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_user_signature_to_bcs,
        _UniffiConverterTypeUserSignature.lower(data)))


def validator_aggregated_signature_from_bcs(bcs: "bytes") -> "ValidatorAggregatedSignature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeValidatorAggregatedSignature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def validator_aggregated_signature_to_bcs(data: "ValidatorAggregatedSignature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeValidatorAggregatedSignature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_aggregated_signature_to_bcs,
        _UniffiConverterTypeValidatorAggregatedSignature.lower(data)))


def validator_committee_from_bcs(bcs: "bytes") -> "ValidatorCommittee":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeValidatorCommittee.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def validator_committee_member_from_bcs(bcs: "bytes") -> "ValidatorCommitteeMember":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeValidatorCommitteeMember.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def validator_committee_member_to_bcs(data: "ValidatorCommitteeMember") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeValidatorCommitteeMember.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_member_to_bcs,
        _UniffiConverterTypeValidatorCommitteeMember.lower(data)))


def validator_committee_to_bcs(data: "ValidatorCommittee") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeValidatorCommittee.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_committee_to_bcs,
        _UniffiConverterTypeValidatorCommittee.lower(data)))


def validator_execution_time_observation_from_bcs(bcs: "bytes") -> "ValidatorExecutionTimeObservation":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeValidatorExecutionTimeObservation.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def validator_execution_time_observation_to_bcs(data: "ValidatorExecutionTimeObservation") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeValidatorExecutionTimeObservation.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_execution_time_observation_to_bcs,
        _UniffiConverterTypeValidatorExecutionTimeObservation.lower(data)))


def validator_signature_from_bcs(bcs: "bytes") -> "ValidatorSignature":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeValidatorSignature.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_signature_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def validator_signature_to_bcs(data: "ValidatorSignature") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeValidatorSignature.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_validator_signature_to_bcs,
        _UniffiConverterTypeValidatorSignature.lower(data)))


def version_assignment_from_bcs(bcs: "bytes") -> "VersionAssignment":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeVersionAssignment.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_version_assignment_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def version_assignment_to_bcs(data: "VersionAssignment") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeVersionAssignment.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_version_assignment_to_bcs,
        _UniffiConverterTypeVersionAssignment.lower(data)))


def zk_login_authenticator_from_bcs(bcs: "bytes") -> "ZkLoginAuthenticator":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeZkLoginAuthenticator.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def zk_login_authenticator_to_bcs(data: "ZkLoginAuthenticator") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeZkLoginAuthenticator.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_authenticator_to_bcs,
        _UniffiConverterTypeZkLoginAuthenticator.lower(data)))


def zk_login_claim_from_bcs(bcs: "bytes") -> "ZkLoginClaim":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeZkLoginClaim.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def zk_login_claim_to_bcs(data: "ZkLoginClaim") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeZkLoginClaim.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_claim_to_bcs,
        _UniffiConverterTypeZkLoginClaim.lower(data)))


def zk_login_proof_from_bcs(bcs: "bytes") -> "ZkLoginProof":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeZkLoginProof.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def zk_login_proof_to_bcs(data: "ZkLoginProof") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeZkLoginProof.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_proof_to_bcs,
        _UniffiConverterTypeZkLoginProof.lower(data)))


def zk_login_public_identifier_from_bcs(bcs: "bytes") -> "ZkLoginPublicIdentifier":
    """
    Create this type from BCS encoded bytes.
    """

    _UniffiConverterBytes.check_lower(bcs)
    
    return _UniffiConverterTypeZkLoginPublicIdentifier.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_from_bcs,
        _UniffiConverterBytes.lower(bcs)))


def zk_login_public_identifier_to_bcs(data: "ZkLoginPublicIdentifier") -> "bytes":
    """
    Convert this type to BCS encoded bytes.
    """

    _UniffiConverterTypeZkLoginPublicIdentifier.check_lower(data)
    
    return _UniffiConverterBytes.lift(_uniffi_rust_call_with_error(_UniffiConverterTypeSdkFfiError,_UniffiLib.uniffi_iota_sdk_ffi_fn_func_zk_login_public_identifier_to_bcs,
        _UniffiConverterTypeZkLoginPublicIdentifier.lower(data)))


__all__ = [
    "InternalError",
    "BatchSendStatusType",
    "CommandArgumentError",
    "Direction",
    "ExecutionError",
    "ExecutionStatus",
    "Feature",
    "IdOperation",
    "MnemonicLength",
    "MoveAbility",
    "MoveVisibility",
    "NameFormat",
    "ObjectIn",
    "ObjectOut",
    "PackageUpgradeError",
    "SdkFfiError",
    "SignatureScheme",
    "TransactionArgument",
    "TransactionBlockKindInput",
    "TransactionExpiration",
    "TypeArgumentError",
    "UnchangedSharedKind",
    "WaitForTx",
    "ActiveJwk",
    "AuthenticatorStateExpire",
    "AuthenticatorStateUpdateV1",
    "BatchSendStatus",
    "ChangedObject",
    "CheckpointSummaryPage",
    "CoinInfo",
    "CoinMetadata",
    "CoinPage",
    "DryRunEffect",
    "DryRunMutation",
    "DryRunResult",
    "DryRunReturn",
    "DynamicFieldName",
    "DynamicFieldOutput",
    "DynamicFieldOutputPage",
    "DynamicFieldValue",
    "EndOfEpochData",
    "Epoch",
    "EpochPage",
    "Event",
    "EventFilter",
    "EventPage",
    "FaucetReceipt",
    "GasCostSummary",
    "GasPayment",
    "GqlAddress",
    "Jwk",
    "JwkId",
    "MoveEnum",
    "MoveEnumConnection",
    "MoveEnumVariant",
    "MoveField",
    "MoveFunctionConnection",
    "MoveFunctionTypeParameter",
    "MoveLocation",
    "MoveModule",
    "MoveModuleConnection",
    "MoveModuleQuery",
    "MoveObject",
    "MovePackagePage",
    "MovePackageQuery",
    "MoveStruct",
    "MoveStructConnection",
    "MoveStructQuery",
    "MoveStructTypeParameter",
    "NameRegistrationPage",
    "ObjectFilter",
    "ObjectPage",
    "ObjectRef",
    "ObjectReference",
    "OpenMoveType",
    "PageInfo",
    "PaginationFilter",
    "ProtocolConfigAttr",
    "ProtocolConfigFeatureFlag",
    "ProtocolConfigs",
    "Query",
    "RandomnessStateUpdate",
    "ServiceConfig",
    "SignedTransaction",
    "SignedTransactionPage",
    "TransactionDataEffects",
    "TransactionDataEffectsPage",
    "TransactionEffectsPage",
    "TransactionEffectsV1",
    "TransactionMetadata",
    "TransactionsFilter",
    "TypeOrigin",
    "UnchangedSharedObject",
    "UpgradeInfo",
    "Validator",
    "ValidatorCommittee",
    "ValidatorCommitteeMember",
    "ValidatorConnection",
    "ValidatorCredentials",
    "ValidatorPage",
    "ValidatorSet",
    "ZkLoginClaim",
    "active_jwk_from_bcs",
    "active_jwk_to_bcs",
    "address_from_bcs",
    "address_to_bcs",
    "argument_from_bcs",
    "argument_to_bcs",
    "authenticator_state_expire_from_bcs",
    "authenticator_state_expire_to_bcs",
    "authenticator_state_update_v1_from_bcs",
    "authenticator_state_update_v1_to_bcs",
    "base64_decode",
    "base64_encode",
    "bls12381_public_key_from_bcs",
    "bls12381_public_key_to_bcs",
    "bls12381_signature_from_bcs",
    "bls12381_signature_to_bcs",
    "bn254_field_element_from_bcs",
    "bn254_field_element_to_bcs",
    "bool_from_bcs",
    "bool_to_bcs",
    "cancelled_transaction_from_bcs",
    "cancelled_transaction_to_bcs",
    "change_epoch_from_bcs",
    "change_epoch_to_bcs",
    "change_epoch_v2_from_bcs",
    "change_epoch_v2_to_bcs",
    "changed_object_from_bcs",
    "changed_object_to_bcs",
    "checkpoint_commitment_from_bcs",
    "checkpoint_commitment_to_bcs",
    "checkpoint_contents_from_bcs",
    "checkpoint_contents_to_bcs",
    "checkpoint_summary_from_bcs",
    "checkpoint_summary_to_bcs",
    "checkpoint_transaction_info_from_bcs",
    "checkpoint_transaction_info_to_bcs",
    "circom_g1_from_bcs",
    "circom_g1_to_bcs",
    "circom_g2_from_bcs",
    "circom_g2_to_bcs",
    "command_argument_error_from_bcs",
    "command_argument_error_to_bcs",
    "command_from_bcs",
    "command_to_bcs",
    "consensus_commit_prologue_v1_from_bcs",
    "consensus_commit_prologue_v1_to_bcs",
    "consensus_determined_version_assignments_from_bcs",
    "consensus_determined_version_assignments_to_bcs",
    "digest_from_bcs",
    "digest_to_bcs",
    "ed25519_public_key_from_bcs",
    "ed25519_public_key_to_bcs",
    "ed25519_signature_from_bcs",
    "ed25519_signature_to_bcs",
    "end_of_epoch_data_from_bcs",
    "end_of_epoch_data_to_bcs",
    "event_from_bcs",
    "event_to_bcs",
    "execution_error_from_bcs",
    "execution_error_to_bcs",
    "execution_status_from_bcs",
    "execution_status_to_bcs",
    "execution_time_observation_from_bcs",
    "execution_time_observation_key_from_bcs",
    "execution_time_observation_key_to_bcs",
    "execution_time_observation_to_bcs",
    "execution_time_observations_from_bcs",
    "execution_time_observations_to_bcs",
    "gas_cost_summary_from_bcs",
    "gas_cost_summary_to_bcs",
    "gas_payment_from_bcs",
    "gas_payment_to_bcs",
    "generate_mnemonic",
    "genesis_object_from_bcs",
    "genesis_object_to_bcs",
    "genesis_transaction_from_bcs",
    "genesis_transaction_to_bcs",
    "hex_decode",
    "hex_encode",
    "i16_from_bcs",
    "i16_to_bcs",
    "i32_from_bcs",
    "i32_to_bcs",
    "i64_from_bcs",
    "i64_to_bcs",
    "i8_from_bcs",
    "i8_to_bcs",
    "id_operation_from_bcs",
    "id_operation_to_bcs",
    "identifier_from_bcs",
    "identifier_to_bcs",
    "input_from_bcs",
    "input_to_bcs",
    "jwk_from_bcs",
    "jwk_id_from_bcs",
    "jwk_id_to_bcs",
    "jwk_to_bcs",
    "make_move_vector_from_bcs",
    "make_move_vector_to_bcs",
    "merge_coins_from_bcs",
    "merge_coins_to_bcs",
    "move_call_from_bcs",
    "move_call_to_bcs",
    "move_location_from_bcs",
    "move_location_to_bcs",
    "move_package_from_bcs",
    "move_package_to_bcs",
    "move_struct_from_bcs",
    "move_struct_to_bcs",
    "multisig_aggregated_signature_from_bcs",
    "multisig_aggregated_signature_to_bcs",
    "multisig_committee_from_bcs",
    "multisig_committee_to_bcs",
    "multisig_member_from_bcs",
    "multisig_member_public_key_from_bcs",
    "multisig_member_public_key_to_bcs",
    "multisig_member_signature_from_bcs",
    "multisig_member_signature_to_bcs",
    "multisig_member_to_bcs",
    "object_data_from_bcs",
    "object_data_to_bcs",
    "object_from_bcs",
    "object_id_from_bcs",
    "object_id_to_bcs",
    "object_in_from_bcs",
    "object_in_to_bcs",
    "object_out_from_bcs",
    "object_out_to_bcs",
    "object_reference_from_bcs",
    "object_reference_to_bcs",
    "object_to_bcs",
    "owner_from_bcs",
    "owner_to_bcs",
    "package_upgrade_error_from_bcs",
    "package_upgrade_error_to_bcs",
    "passkey_authenticator_from_bcs",
    "passkey_authenticator_to_bcs",
    "programmable_transaction_from_bcs",
    "programmable_transaction_to_bcs",
    "publish_from_bcs",
    "publish_to_bcs",
    "randomness_state_update_from_bcs",
    "randomness_state_update_to_bcs",
    "secp256k1_public_key_from_bcs",
    "secp256k1_public_key_to_bcs",
    "secp256k1_signature_from_bcs",
    "secp256k1_signature_to_bcs",
    "secp256r1_public_key_from_bcs",
    "secp256r1_public_key_to_bcs",
    "secp256r1_signature_from_bcs",
    "secp256r1_signature_to_bcs",
    "signed_transaction_from_bcs",
    "signed_transaction_to_bcs",
    "simple_signature_from_bcs",
    "simple_signature_to_bcs",
    "split_coins_from_bcs",
    "split_coins_to_bcs",
    "string_from_bcs",
    "string_to_bcs",
    "struct_tag_from_bcs",
    "struct_tag_to_bcs",
    "system_package_from_bcs",
    "system_package_to_bcs",
    "transaction_effects_from_bcs",
    "transaction_effects_to_bcs",
    "transaction_effects_v1_from_bcs",
    "transaction_effects_v1_to_bcs",
    "transaction_events_from_bcs",
    "transaction_events_to_bcs",
    "transaction_expiration_from_bcs",
    "transaction_expiration_to_bcs",
    "transaction_from_bcs",
    "transaction_kind_from_bcs",
    "transaction_kind_to_bcs",
    "transaction_to_bcs",
    "transaction_v1_from_bcs",
    "transaction_v1_to_bcs",
    "transfer_objects_from_bcs",
    "transfer_objects_to_bcs",
    "type_argument_error_from_bcs",
    "type_argument_error_to_bcs",
    "type_origin_from_bcs",
    "type_origin_to_bcs",
    "type_tag_from_bcs",
    "type_tag_to_bcs",
    "u16_from_bcs",
    "u16_to_bcs",
    "u32_from_bcs",
    "u32_to_bcs",
    "u64_from_bcs",
    "u64_to_bcs",
    "u8_from_bcs",
    "u8_to_bcs",
    "unchanged_shared_kind_from_bcs",
    "unchanged_shared_kind_to_bcs",
    "unchanged_shared_object_from_bcs",
    "unchanged_shared_object_to_bcs",
    "upgrade_from_bcs",
    "upgrade_info_from_bcs",
    "upgrade_info_to_bcs",
    "upgrade_to_bcs",
    "user_signature_from_bcs",
    "user_signature_to_bcs",
    "validator_aggregated_signature_from_bcs",
    "validator_aggregated_signature_to_bcs",
    "validator_committee_from_bcs",
    "validator_committee_member_from_bcs",
    "validator_committee_member_to_bcs",
    "validator_committee_to_bcs",
    "validator_execution_time_observation_from_bcs",
    "validator_execution_time_observation_to_bcs",
    "validator_signature_from_bcs",
    "validator_signature_to_bcs",
    "version_assignment_from_bcs",
    "version_assignment_to_bcs",
    "zk_login_authenticator_from_bcs",
    "zk_login_authenticator_to_bcs",
    "zk_login_claim_from_bcs",
    "zk_login_claim_to_bcs",
    "zk_login_proof_from_bcs",
    "zk_login_proof_to_bcs",
    "zk_login_public_identifier_from_bcs",
    "zk_login_public_identifier_to_bcs",
    "Address",
    "Argument",
    "Bls12381PrivateKey",
    "Bls12381PublicKey",
    "Bls12381Signature",
    "Bls12381VerifyingKey",
    "Bn254FieldElement",
    "CancelledTransaction",
    "ChangeEpoch",
    "ChangeEpochV2",
    "ChangeEpochV3",
    "CheckpointCommitment",
    "CheckpointContents",
    "CheckpointSummary",
    "CheckpointTransactionInfo",
    "CircomG1",
    "CircomG2",
    "ClientTransactionBuilder",
    "Coin",
    "Command",
    "ConsensusCommitPrologueV1",
    "ConsensusDeterminedVersionAssignments",
    "Digest",
    "Ed25519PrivateKey",
    "Ed25519PublicKey",
    "Ed25519Signature",
    "Ed25519Verifier",
    "Ed25519VerifyingKey",
    "EndOfEpochTransactionKind",
    "ExecutionTimeObservation",
    "ExecutionTimeObservationKey",
    "ExecutionTimeObservations",
    "FaucetClient",
    "GenesisObject",
    "GenesisTransaction",
    "GraphQlClient",
    "Identifier",
    "Input",
    "MakeMoveVector",
    "MergeCoins",
    "MoveArg",
    "MoveCall",
    "MoveFunction",
    "MovePackage",
    "MovePackageData",
    "MultisigAggregatedSignature",
    "MultisigAggregator",
    "MultisigCommittee",
    "MultisigMember",
    "MultisigMemberPublicKey",
    "MultisigMemberSignature",
    "MultisigVerifier",
    "Name",
    "NameRegistration",
    "Object",
    "ObjectData",
    "ObjectId",
    "ObjectType",
    "Owner",
    "PtbArgument",
    "PasskeyAuthenticator",
    "PasskeyPublicKey",
    "PasskeyVerifier",
    "PersonalMessage",
    "ProgrammableTransaction",
    "Publish",
    "Secp256k1PrivateKey",
    "Secp256k1PublicKey",
    "Secp256k1Signature",
    "Secp256k1Verifier",
    "Secp256k1VerifyingKey",
    "Secp256r1PrivateKey",
    "Secp256r1PublicKey",
    "Secp256r1Signature",
    "Secp256r1Verifier",
    "Secp256r1VerifyingKey",
    "SimpleKeypair",
    "SimpleSignature",
    "SimpleVerifier",
    "SimpleVerifyingKey",
    "SplitCoins",
    "StructTag",
    "SystemPackage",
    "Transaction",
    "TransactionBuilder",
    "TransactionEffects",
    "TransactionEvents",
    "TransactionKind",
    "TransactionV1",
    "TransferObjects",
    "TypeTag",
    "Upgrade",
    "UpgradePolicy",
    "UserSignature",
    "UserSignatureVerifier",
    "ValidatorAggregatedSignature",
    "ValidatorCommitteeSignatureAggregator",
    "ValidatorCommitteeSignatureVerifier",
    "ValidatorExecutionTimeObservation",
    "ValidatorSignature",
    "VersionAssignment",
    "ZkLoginAuthenticator",
    "ZkLoginInputs",
    "ZkLoginProof",
    "ZkLoginPublicIdentifier",
    "ZkloginVerifier",
]

