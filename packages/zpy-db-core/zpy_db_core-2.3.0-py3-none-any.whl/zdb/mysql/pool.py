# ðŸ›¸ Generated by zPy
"""
Single Connection Pool for AWS Lambda
Optimized connection pooling for Lambda's single-request-at-a-time execution model.

This module provides connection reuse between Lambda invocations to reduce
connection overhead and improve performance.

Usage:
    from zdb.mysql import ZMySQLWithPool

    # Create instance with single connection pool
    db = ZMySQLWithPool.from_of(
        user="user",
        password="pass",
        host="localhost",
        db_name="mydb"
    )

    # Use normally - connection is reused between invocations
    result = db.call("SP_MY_PROCEDURE", ret_type=DBTypes.cursor, jsonfy=True)

    # Check pool stats
    stats = db.get_pool_stats()
"""
from typing import Optional, Any, List
from mysql.connector import MySQLConnection
from mysql import connector
import logging

logger = logging.getLogger(__name__)


class SingleConnectionPool:
    """
    Single connection pool optimized for AWS Lambda.

    Lambda executes one request at a time, so a complex connection pool is unnecessary.
    This class maintains a single connection open between invocations to reduce latency.

    Features:
    - Connection reuse between Lambda invocations
    - Automatic connection health checks with ping
    - Automatic reconnection on connection loss
    - Configurable retry logic
    - Detailed logging for debugging

    Attributes:
        config (dict): MySQL connection configuration
        _connection (MySQLConnection): Current active connection
        _connection_attempts (int): Number of reconnection attempts
        _max_reconnect_attempts (int): Maximum reconnection attempts before failing
    """

    def __init__(self, config: dict, max_reconnect_attempts: int = 3):
        """
        Initialize the single connection pool.

        Args:
            config: MySQL connection configuration dict
                   (user, password, host, database, etc.)
            max_reconnect_attempts: Maximum number of reconnection attempts
        """
        self.config = config
        self._connection: Optional[MySQLConnection] = None
        self._connection_attempts = 0
        self._max_reconnect_attempts = max_reconnect_attempts
        self._total_connections_created = 0
        self._total_reuses = 0

    def get_connection(self) -> MySQLConnection:
        """
        Get a valid connection, reusing existing one if alive.

        This is the main method to obtain a connection. It will:
        1. Return existing connection if alive
        2. Create new connection if none exists
        3. Reconnect if existing connection is dead

        Returns:
            MySQLConnection: Active connection ready to use

        Raises:
            Exception: If max reconnection attempts exceeded
        """
        # No existing connection, create new one
        if self._connection is None:
            logger.info("No existing connection, creating new one")
            return self._create_connection()

        # Check if connection is alive
        if not self._is_connection_alive():
            logger.warning("Connection is dead, reconnecting")
            self._close_connection()
            return self._create_connection()

        # Connection is alive, reuse it
        logger.debug("Reusing existing connection")
        self._connection_attempts = 0  # Reset counter on successful reuse
        self._total_reuses += 1
        return self._connection

    def _create_connection(self) -> MySQLConnection:
        """
        Create a new database connection.

        Returns:
            MySQLConnection: Newly created connection

        Raises:
            Exception: If connection creation fails after max attempts
        """
        try:
            self._connection = connector.connect(**self.config)
            self._connection_attempts = 0
            self._total_connections_created += 1
            logger.info(
                f"âœ… New database connection created successfully "
                f"(total created: {self._total_connections_created})"
            )
            return self._connection
        except Exception as e:
            self._connection_attempts += 1
            logger.error(
                f"âŒ Error creating connection "
                f"(attempt {self._connection_attempts}/{self._max_reconnect_attempts}): {e}"
            )

            if self._connection_attempts >= self._max_reconnect_attempts:
                logger.error(
                    f"Max reconnection attempts ({self._max_reconnect_attempts}) reached"
                )
                raise

            # Retry
            return self._create_connection()

    def _is_connection_alive(self) -> bool:
        """
        Check if connection is alive using ping.

        Returns:
            bool: True if connection is alive, False otherwise
        """
        if self._connection is None:
            return False

        try:
            # ping() with reconnect=False to manually control reconnection
            self._connection.ping(reconnect=False, attempts=1, delay=0)
            return True
        except Exception as e:
            logger.debug(f"Connection ping failed: {e}")
            return False

    def _close_connection(self):
        """Close current connection safely."""
        if self._connection is not None:
            try:
                if self._connection.is_connected():
                    self._connection.close()
                logger.debug("Connection closed")
            except Exception as e:
                logger.warning(f"Error closing connection: {e}")
            finally:
                self._connection = None

    def close(self):
        """
        Close the pool connection.

        Useful for cleanup or testing. In Lambda, this is typically not needed
        as the connection will be closed when the container is recycled.
        """
        self._close_connection()

    def reset_stats(self):
        """Reset connection statistics."""
        self._total_connections_created = 0
        self._total_reuses = 0

    def get_stats(self) -> dict:
        """
        Get pool statistics.

        Returns:
            dict: Statistics including:
                - has_connection: Whether pool has a connection
                - is_alive: Whether connection is alive
                - connection_attempts: Current reconnection attempts
                - connection_id: MySQL connection ID (if alive)
                - total_connections_created: Total connections created
                - total_reuses: Total connection reuses
                - reuse_rate: Percentage of reuses vs new connections
        """
        is_alive = self._is_connection_alive()
        total_uses = self._total_connections_created + self._total_reuses
        reuse_rate = (self._total_reuses / total_uses * 100) if total_uses > 0 else 0

        return {
            "has_connection": self._connection is not None,
            "is_alive": is_alive,
            "connection_attempts": self._connection_attempts,
            "connection_id": (
                self._connection.connection_id
                if self._connection and is_alive
                else None
            ),
            "total_connections_created": self._total_connections_created,
            "total_reuses": self._total_reuses,
            "reuse_rate_percent": round(reuse_rate, 2),
        }


class ZMySQLWithPool:
    """
    ZMySQL wrapper with single connection pooling for Lambda.

    This class wraps ZMySQL to provide connection reuse between Lambda invocations,
    significantly reducing connection overhead and improving performance.

    Compatible with ZMySQL interface, can be used as a drop-in replacement.

    Example:
        # Instead of:
        db = ZMySQL.from_of(user="user", password="pass", host="host", db_name="db")

        # Use:
        db = ZMySQLWithPool.from_of(user="user", password="pass", host="host", db_name="db")

        # Use normally
        result = db.call("SP_PROCEDURE", ret_type=DBTypes.cursor, jsonfy=True)
    """

    def __init__(self, zmysql_instance, pool: SingleConnectionPool):
        """
        Initialize with ZMySQL instance and connection pool.

        Args:
            zmysql_instance: ZMySQL instance
            pool: SingleConnectionPool instance
        """
        self._zmysql = zmysql_instance
        self._pool = pool

    @classmethod
    def from_of(
        cls,
        user: str,
        password: str,
        host: str,
        db_name: str,
        verbose: bool = False,
        connect_timeout: int = 10,
        autocommit: bool = True,
        max_reconnect_attempts: int = 3,
    ):
        """
        Create instance with single connection pool.

        Args:
            user: MySQL username
            password: MySQL password
            host: MySQL host
            db_name: Database name
            verbose: Enable verbose logging
            connect_timeout: Connection timeout in seconds
            autocommit: Enable autocommit (recommended for Lambda)
            max_reconnect_attempts: Max reconnection attempts

        Returns:
            ZMySQLWithPool: Instance with connection pooling
        """
        from zdb.mysql import ZMySQL

        config = {
            "user": user,
            "password": password,
            "host": host,
            "database": db_name,
            "raise_on_warnings": False,
            "autocommit": autocommit,
            "connect_timeout": connect_timeout,
        }

        zmysql = ZMySQL.setup(config, verbose=verbose)
        pool = SingleConnectionPool(config, max_reconnect_attempts)

        return cls(zmysql, pool)

    def call(
        self,
        name: str,
        ret_type=None,
        params=None,
        list_params=None,
        model=None,
        connection=None,
        jsonfy: bool = False,
        throw: bool = True,
    ) -> Any:
        """
        Call stored procedure using pooled connection.

        Compatible with ZMySQL.call(). If connection is explicitly passed
        (for transactions), it will be used instead of pool connection.

        Args:
            name: Stored procedure name
            ret_type: Return type (DBTypes)
            params: Named parameters dict
            list_params: Positional parameters list
            model: Model class for result mapping
            connection: Explicit connection (for transactions)
            jsonfy: Return as dict if True
            throw: Raise exceptions if True

        Returns:
            Any: Procedure result
        """
        # Use explicit connection if provided (for transactions)
        if connection is not None:
            return self._zmysql.call(
                name, ret_type, params, list_params, model, connection, jsonfy, throw
            )

        # Use pooled connection
        conn = self._pool.get_connection()
        return self._zmysql.call(
            name, ret_type, params, list_params, model, conn, jsonfy, throw
        )

    def exec(
        self,
        fn_name: str,
        ret_type=None,
        params=None,
        list_params=None,
        model=None,
        connection=None,
        jsonfy: bool = False,
        throw: bool = True,
    ) -> Any:
        """
        Execute MySQL function using pooled connection.

        Compatible with ZMySQL.exec().

        Args:
            fn_name: Function name
            ret_type: Return type (DBTypes)
            params: Named parameters dict
            list_params: Positional parameters list
            model: Model class for result mapping
            connection: Explicit connection (for transactions)
            jsonfy: Return as dict if True
            throw: Raise exceptions if True

        Returns:
            Any: Function result
        """
        if connection is not None:
            return self._zmysql.exec(
                fn_name, ret_type, params, list_params, model, connection, jsonfy, throw
            )

        conn = self._pool.get_connection()
        return self._zmysql.exec(
            fn_name, ret_type, params, list_params, model, conn, jsonfy, throw
        )

    def new_connect(self) -> MySQLConnection:
        """
        Get connection from pool.

        Compatible with ZMySQL.new_connect().

        Returns:
            MySQLConnection: Pooled connection
        """
        return self._pool.get_connection()

    def get_pool_stats(self) -> dict:
        """
        Get connection pool statistics.

        Returns:
            dict: Pool statistics
        """
        return self._pool.get_stats()

    def close_pool(self):
        """
        Close the connection pool.

        Useful for cleanup or testing. In Lambda, typically not needed.
        """
        self._pool.close()

    def reset_pool_stats(self):
        """Reset pool statistics."""
        self._pool.reset_stats()
