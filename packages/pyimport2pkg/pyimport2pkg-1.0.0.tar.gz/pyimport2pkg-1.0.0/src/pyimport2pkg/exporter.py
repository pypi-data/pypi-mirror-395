"""
Exporter module: Generates output in various formats.

Supports requirements.txt, JSON, and other output formats.
"""

import json
from datetime import datetime
from pathlib import Path
from typing import TextIO

from . import __version__
from .models import MappingResult, AnalysisResult, ImportInfo, ImportContext


class Exporter:
    """
    Exports analysis results to various formats.
    """

    def __init__(
        self,
        include_optional: bool = True,
        include_comments: bool = True,
        include_sources: bool = False,
    ):
        """
        Initialize the exporter.

        Args:
            include_optional: Include optional packages (from conditional imports)
            include_comments: Include explanatory comments
            include_sources: Include source file locations in comments
        """
        self.include_optional = include_optional
        self.include_comments = include_comments
        self.include_sources = include_sources

    def _get_unique_packages(
        self,
        results: list[MappingResult],
    ) -> dict[str, MappingResult]:
        """
        Get unique packages from results.

        Returns dict of {package_name: MappingResult}
        """
        packages = {}
        for result in results:
            if result.resolved_package:
                pkg = result.resolved_package
                if pkg not in packages:
                    packages[pkg] = result
        return packages

    def _format_downloads(self, count: int) -> str:
        """Format download count to human readable format."""
        if count >= 1_000_000:
            return f"{count/1_000_000:.1f}M"
        elif count >= 1_000:
            return f"{count/1_000:.1f}K"
        elif count > 0:
            return str(count)
        return ""

    def _get_context_label(self, context: ImportContext) -> str:
        """Get human-readable label for import context."""
        labels = {
            ImportContext.CONDITIONAL: "conditional",
            ImportContext.TRY_EXCEPT: "try_except",
            ImportContext.FUNCTION: "function",
            ImportContext.CLASS: "class",
            ImportContext.TOP_LEVEL: "top_level",
        }
        return labels.get(context, "unknown")

    def export_requirements_txt(
        self,
        required: list[MappingResult],
        optional: list[MappingResult] | None = None,
        warnings: list[str] | None = None,
        errors: list[ImportInfo] | None = None,
        output: TextIO | Path | None = None,
    ) -> str:
        """
        Export to requirements.txt format.

        Args:
            required: Required package mappings
            optional: Optional package mappings
            warnings: List of warning messages
            errors: List of error imports (syntax errors, read errors, etc.)
            output: Output file path or file object

        Returns:
            The requirements.txt content as string
        """
        lines = []

        if self.include_comments:
            lines.append("# Auto-generated by pyimport2pkg")
            lines.append(f"# Generated at: {datetime.now().isoformat()}")
            lines.append("")

        # Required packages
        if self.include_comments:
            lines.append("# === Required packages ===")

        required_pkgs = self._get_unique_packages(required)
        for pkg_name in sorted(required_pkgs.keys()):
            result = required_pkgs[pkg_name]

            line = pkg_name

            if self.include_sources and result.import_info.file_path:
                line = f"{pkg_name}  # from {result.import_info.file_path.name}:{result.import_info.line_number}"

            lines.append(line)

        # Optional packages - now included as actual entries with detailed labels
        if self.include_optional and optional:
            # Separate by context type
            conditional_imports = [r for r in optional if r.import_info.context == ImportContext.CONDITIONAL]
            try_except_imports = [r for r in optional if r.import_info.context == ImportContext.TRY_EXCEPT]
            other_optional = [r for r in optional if r.import_info.context not in (ImportContext.CONDITIONAL, ImportContext.TRY_EXCEPT)]

            if conditional_imports:
                lines.append("")
                if self.include_comments:
                    lines.append("# === Conditional imports (platform/environment specific) ===")

                conditional_pkgs = self._get_unique_packages(conditional_imports)
                for pkg_name in sorted(conditional_pkgs.keys()):
                    result = conditional_pkgs[pkg_name]
                    location = ""
                    if result.import_info.file_path:
                        location = f" in {result.import_info.file_path.name}:{result.import_info.line_number}"
                    lines.append(f"{pkg_name}  # conditional{location}")

            if try_except_imports:
                lines.append("")
                if self.include_comments:
                    lines.append("# === Try-except imports (optional dependencies) ===")

                try_except_pkgs = self._get_unique_packages(try_except_imports)
                for pkg_name in sorted(try_except_pkgs.keys()):
                    result = try_except_pkgs[pkg_name]
                    location = ""
                    if result.import_info.file_path:
                        location = f" in {result.import_info.file_path.name}:{result.import_info.line_number}"
                    lines.append(f"{pkg_name}  # try_except{location}")

            if other_optional:
                lines.append("")
                if self.include_comments:
                    lines.append("# === Other optional imports ===")

                other_pkgs = self._get_unique_packages(other_optional)
                for pkg_name in sorted(other_pkgs.keys()):
                    result = other_pkgs[pkg_name]
                    context = self._get_context_label(result.import_info.context)
                    location = ""
                    if result.import_info.file_path:
                        location = f" in {result.import_info.file_path.name}:{result.import_info.line_number}"
                    lines.append(f"{pkg_name}  # {context}{location}")

        # Errors section
        if self.include_comments and errors:
            lines.append("")
            lines.append("# === Errors (manual review required) ===")
            for err in errors:
                error_type = "Unknown"
                if err.module_name == "<syntax_error>":
                    error_type = "Syntax Error"
                elif err.module_name == "<read_error>":
                    error_type = "Read Error"
                elif err.module_name == "<dynamic>":
                    error_type = "Dynamic Import"

                location = ""
                if err.file_path:
                    location = f" {err.file_path.name}:{err.line_number}"

                warning_detail = ""
                if err.warnings:
                    warning_detail = f" - {err.warnings[0]}"

                lines.append(f"# [{error_type}]{location}{warning_detail}")

        # Warnings
        if self.include_comments and warnings:
            lines.append("")
            lines.append("# === Warnings ===")
            for warning in warnings:
                lines.append(f"# - {warning}")

        # Multiple candidates notice with download counts
        multi_candidates = [r for r in required if len(r.candidates) > 1]
        if self.include_comments and multi_candidates:
            lines.append("")
            lines.append("# === Packages with multiple candidates ===")
            for result in multi_candidates:
                selected = result.resolved_package
                selected_candidate = next(
                    (c for c in result.candidates if c.package_name == selected),
                    None
                )
                selected_downloads = ""
                if selected_candidate and selected_candidate.download_count:
                    selected_downloads = f" ({self._format_downloads(selected_candidate.download_count)})"

                alternatives = []
                for c in result.candidates:
                    if c.package_name != selected:
                        dl = f" ({self._format_downloads(c.download_count)})" if c.download_count else ""
                        alternatives.append(f"{c.package_name}{dl}")

                if alternatives:
                    lines.append(
                        f"# {result.import_info.module_name} -> "
                        f"Selected: {selected}{selected_downloads}"
                    )
                    lines.append(
                        f"#        Alternatives: {', '.join(alternatives)}"
                    )

        content = "\n".join(lines) + "\n"

        # Write to output if specified
        if output:
            if isinstance(output, Path):
                output.write_text(content)
            else:
                output.write(content)

        return content

    def export_json(
        self,
        required: list[MappingResult],
        optional: list[MappingResult] | None = None,
        unresolved: list[ImportInfo] | None = None,
        warnings: list[str] | None = None,
        output: TextIO | Path | None = None,
    ) -> str:
        """
        Export to JSON format.

        Args:
            required: Required package mappings
            optional: Optional package mappings
            unresolved: Unresolved imports
            warnings: Warning messages
            output: Output file path or file object

        Returns:
            The JSON content as string
        """
        data = {
            "meta": {
                "generated_at": datetime.now().isoformat(),
                "tool": "pyimport2pkg",
                "version": __version__,
            },
            "required": [],
            "optional": [],
            "unresolved": [],
            "warnings": warnings or [],
        }

        # Required packages
        for result in required:
            if result.resolved_package:
                entry = {
                    "package": result.resolved_package,
                    "module": result.import_info.module_name,
                    "source": result.source,
                }
                if result.import_info.file_path:
                    entry["file"] = str(result.import_info.file_path)
                    entry["line"] = result.import_info.line_number

                if len(result.candidates) > 1:
                    entry["alternatives"] = [
                        c.package_name
                        for c in result.candidates
                        if c.package_name != result.resolved_package
                    ]

                data["required"].append(entry)

        # Optional packages
        if optional:
            for result in optional:
                if result.resolved_package:
                    entry = {
                        "package": result.resolved_package,
                        "module": result.import_info.module_name,
                        "context": result.import_info.context.name.lower(),
                    }
                    if result.import_info.file_path:
                        entry["file"] = str(result.import_info.file_path)
                        entry["line"] = result.import_info.line_number
                    data["optional"].append(entry)

        # Unresolved imports
        if unresolved:
            for imp in unresolved:
                entry = {
                    "module": imp.module_name,
                }
                if imp.file_path:
                    entry["file"] = str(imp.file_path)
                    entry["line"] = imp.line_number
                if imp.warnings:
                    entry["warnings"] = imp.warnings
                data["unresolved"].append(entry)

        content = json.dumps(data, indent=2)

        # Write to output if specified
        if output:
            if isinstance(output, Path):
                output.write_text(content)
            else:
                output.write(content)

        return content

    def export_simple_list(
        self,
        required: list[MappingResult],
    ) -> list[str]:
        """
        Export as a simple list of package names.

        Args:
            required: Required package mappings

        Returns:
            List of package names
        """
        packages = self._get_unique_packages(required)
        return sorted(packages.keys())


def export_requirements(
    results: list[MappingResult],
    output: Path | None = None,
    include_optional: bool = False,
) -> str:
    """
    Convenience function to export to requirements.txt.

    Args:
        results: Mapping results
        output: Output file path
        include_optional: Include optional packages

    Returns:
        The requirements.txt content
    """
    # Separate required and optional
    required = [r for r in results if not r.import_info.is_optional]
    optional = [r for r in results if r.import_info.is_optional]

    exporter = Exporter(include_optional=include_optional)
    return exporter.export_requirements_txt(required, optional, output=output)


def export_json(
    results: list[MappingResult],
    output: Path | None = None,
) -> str:
    """
    Convenience function to export to JSON.

    Args:
        results: Mapping results
        output: Output file path

    Returns:
        The JSON content
    """
    required = [r for r in results if not r.import_info.is_optional]
    optional = [r for r in results if r.import_info.is_optional]

    exporter = Exporter()
    return exporter.export_json(required, optional, output=output)
