jinx_name: plonk
description: Vision-based GUI automation - use vision model to interact with screen elements
inputs:
  - task: null
  - vmodel: null
  - vprovider: null
  - max_iterations: 10
  - debug: true

steps:
  - name: plonk_execute
    engine: python
    code: |
      import os
      import time
      import platform
      from termcolor import colored

      from npcpy.llm_funcs import get_llm_response
      from npcpy.data.image import capture_screenshot
      from npcpy.work.desktop import perform_action

      npc = context.get('npc')
      messages = context.get('messages', [])

      task = context.get('task')
      vision_model = context.get('vmodel') or (npc.model if npc else 'gpt-4o')
      vision_provider = context.get('vprovider') or (npc.provider if npc else 'openai')
      max_iterations = int(context.get('max_iterations', 10))
      debug = context.get('debug', True)

      if not task:
          context['output'] = """Usage: /plonk <task description>

      Options:
        --vmodel MODEL      Vision model to use (default: gpt-4o)
        --vprovider PROV    Vision provider (default: openai)
        --max-iterations N  Max steps (default: 10)

      Example: /plonk Open Firefox and navigate to google.com"""
          context['messages'] = messages
          exit()

      print(f"""
      ██████╗ ██╗      ██████╗ ███╗   ██╗██╗  ██╗
      ██╔══██╗██║     ██╔═══██╗████╗  ██║██║ ██╔╝
      ██████╔╝██║     ██║   ██║██╔██╗ ██║█████╔╝
      ██╔═══╝ ██║     ██║   ██║██║╚██╗██║██╔═██╗
      ██║     ███████╗╚██████╔╝██║ ╚████║██║  ██╗
      ╚═╝     ╚══════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝  ╚═╝

      Vision GUI Automation
      Task: {task}
      Model: {vision_model} | Max iterations: {max_iterations}
      """)

      # System-specific examples
      system = platform.system()
      if system == "Windows":
          app_examples = "start firefox, notepad, calc"
      elif system == "Darwin":
          app_examples = "open -a Firefox, open -a TextEdit"
      else:
          app_examples = "firefox &, gedit &, gnome-calculator &"

      # Action types
      ACTION_SCHEMA = {
          "type": "object",
          "properties": {
              "action": {
                  "type": "string",
                  "enum": ["click", "type", "key", "launch", "wait", "done", "fail"],
                  "description": "Action to perform"
              },
              "x": {"type": "number", "description": "X coordinate (0-100 percentage)"},
              "y": {"type": "number", "description": "Y coordinate (0-100 percentage)"},
              "text": {"type": "string", "description": "Text to type or key to press"},
              "command": {"type": "string", "description": "Command to launch"},
              "duration": {"type": "number", "description": "Wait duration in seconds"},
              "reason": {"type": "string", "description": "Explanation of action"}
          },
          "required": ["action", "reason"]
      }

      click_history = []
      summary = []

      for iteration in range(max_iterations):
          print(colored(f"\n--- Iteration {iteration + 1}/{max_iterations} ---", "cyan"))

          # Capture screenshot
          ss = capture_screenshot()
          if not ss or 'file_path' not in ss:
              print(colored("Failed to capture screenshot", "red"))
              break

          screenshot_path = ss['file_path']
          if debug:
              print(colored(f"Screenshot: {screenshot_path}", "gray"))

          # Build context from history
          history_context = ""
          if click_history:
              history_context = f"\nPrevious actions ({len(click_history)}):\n"
              for i, click in enumerate(click_history[-5:], 1):
                  history_context += f"  {i}. {click.get('action', 'unknown')} at ({click.get('x', '?')}, {click.get('y', '?')}) - {click.get('reason', '')}\n"

          prompt = f"""You are a GUI automation assistant. Analyze this screenshot and determine the next action to complete the task.

      TASK: {task}

      {history_context}

      Available actions:
      - click: Click at x,y coordinates (0-100 percentage of screen)
      - type: Type text
      - key: Press key (enter, tab, escape, etc.)
      - launch: Launch application ({app_examples})
      - wait: Wait for duration seconds
      - done: Task completed successfully
      - fail: Task cannot be completed

      Respond with JSON: {{"action": "...", "x": N, "y": N, "text": "...", "command": "...", "duration": N, "reason": "..."}}"""

          try:
              resp = get_llm_response(
                  prompt,
                  model=vision_model,
                  provider=vision_provider,
                  images=[screenshot_path],
                  format="json",
                  npc=npc
              )

              action_response = resp.get('response', {})
              if isinstance(action_response, str):
                  import json
                  try:
                      action_response = json.loads(action_response)
                  except:
                      print(colored(f"Invalid JSON response: {action_response[:100]}", "red"))
                      continue

              action = action_response.get('action', 'fail')
              reason = action_response.get('reason', 'No reason provided')

              print(colored(f"Action: {action} - {reason}", "yellow"))

              if action == 'done':
                  print(colored("Task completed successfully!", "green"))
                  summary.append({"iteration": iteration + 1, "action": "done", "reason": reason})
                  break

              if action == 'fail':
                  print(colored(f"Task failed: {reason}", "red"))
                  summary.append({"iteration": iteration + 1, "action": "fail", "reason": reason})
                  break

              # Execute action
              if action == 'click':
                  x, y = action_response.get('x', 50), action_response.get('y', 50)
                  perform_action('click', x=x, y=y)
                  click_history.append({"action": "click", "x": x, "y": y, "reason": reason})
                  print(colored(f"Clicked at ({x}, {y})", "green"))

              elif action == 'type':
                  text = action_response.get('text', '')
                  perform_action('type', text=text)
                  click_history.append({"action": "type", "text": text[:20], "reason": reason})
                  print(colored(f"Typed: {text[:30]}...", "green"))

              elif action == 'key':
                  key = action_response.get('text', 'enter')
                  perform_action('key', key=key)
                  click_history.append({"action": "key", "key": key, "reason": reason})
                  print(colored(f"Pressed key: {key}", "green"))

              elif action == 'launch':
                  cmd = action_response.get('command', '')
                  perform_action('launch', command=cmd)
                  click_history.append({"action": "launch", "command": cmd, "reason": reason})
                  print(colored(f"Launched: {cmd}", "green"))
                  time.sleep(2)  # Wait for app to open

              elif action == 'wait':
                  duration = action_response.get('duration', 1)
                  time.sleep(duration)
                  click_history.append({"action": "wait", "duration": duration, "reason": reason})
                  print(colored(f"Waited {duration}s", "green"))

              summary.append({
                  "iteration": iteration + 1,
                  "action": action,
                  "last_click_coords": f"({click_history[-1].get('x', 'N/A')}, {click_history[-1].get('y', 'N/A')})" if click_history else "N/A",
                  "reason": reason
              })

              time.sleep(0.5)  # Brief pause between actions

          except Exception as e:
              print(colored(f"Error in iteration {iteration + 1}: {e}", "red"))
              summary.append({"iteration": iteration + 1, "error": str(e)})

      # Generate summary
      print("\n" + "="*50)
      print(colored("PLONK SESSION SUMMARY", "cyan", attrs=['bold']))
      print("="*50)
      for s in summary:
          print(f"  Step {s.get('iteration', '?')}: {s.get('action', 'unknown')} - {s.get('reason', s.get('error', ''))[:60]}")

      context['output'] = f"Plonk completed with {len(summary)} actions"
      context['messages'] = messages
      context['plonk_summary'] = summary
      context['click_history'] = click_history
