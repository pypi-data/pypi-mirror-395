jinx_name: guac
description: Python data analysis mode - execute Python code with persistent locals, auto-load files
inputs:
  - model: null
  - provider: null
  - plots_dir: null

steps:
  - name: guac_repl
    engine: python
    code: |
      import os
      import sys
      import io
      import re
      import traceback
      from pathlib import Path
      from datetime import datetime
      from termcolor import colored

      import numpy as np
      import pandas as pd
      import matplotlib.pyplot as plt

      from npcpy.llm_funcs import get_llm_response
      from npcpy.npc_sysenv import render_markdown, get_system_message

      npc = context.get('npc')
      team = context.get('team')
      messages = context.get('messages', [])
      plots_dir = context.get('plots_dir') or os.path.expanduser("~/.npcsh/plots")

      model = context.get('model') or (npc.model if npc else None)
      provider = context.get('provider') or (npc.provider if npc else None)

      # Use shared_context for persistent Python locals
      shared_ctx = npc.shared_context if npc and hasattr(npc, 'shared_context') else {}
      if 'locals' not in shared_ctx:
          shared_ctx['locals'] = {}

      # Initialize locals with useful imports
      guac_locals = shared_ctx['locals']
      guac_locals.update({
          'np': np,
          'pd': pd,
          'plt': plt,
          'Path': Path,
          'os': os,
      })

      # Also store dataframes reference
      if 'dataframes' not in shared_ctx:
          shared_ctx['dataframes'] = {}
      guac_locals['dataframes'] = shared_ctx['dataframes']

      os.makedirs(plots_dir, exist_ok=True)

      print("""
       ██████╗ ██╗   ██╗ █████╗  ██████╗
      ██╔════╝ ██║   ██║██╔══██╗██╔════╝
      ██║  ███╗██║   ██║███████║██║
      ██║   ██║██║   ██║██╔══██║██║
      ╚██████╔╝╚██████╔╝██║  ██║╚██████╗
       ╚═════╝  ╚═════╝ ╚═╝  ╚═╝ ╚═════╝
      """)

      npc_name = npc.name if npc else "guac"
      print(f"Entering guac mode (NPC: {npc_name}). Type '/gq' to exit.")
      print("  - Type Python code directly to execute")
      print("  - Type natural language to get code suggestions")
      print("  - Drop file paths to auto-load data")
      print(f"  - Plots saved to: {plots_dir}")

      def is_python_code(text):
          """Check if text looks like Python code"""
          text = text.strip()
          if not text:
              return False
          # Common Python patterns
          if re.match(r'^(import |from |def |class |if |for |while |with |try:|@|#)', text):
              return True
          if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\s*=', text):
              return True
          if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\s*\(', text):
              return True
          if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*\s*\[', text):
              return True
          if text.startswith('print(') or text.startswith('plt.'):
              return True
          try:
              compile(text, "<input>", "exec")
              return True
          except SyntaxError:
              return False

      def execute_python(code_str, locals_dict):
          """Execute Python code and return output"""
          output_capture = io.StringIO()
          old_stdout, old_stderr = sys.stdout, sys.stderr

          try:
              sys.stdout = output_capture
              sys.stderr = output_capture

              # Try as expression first (for REPL-like behavior)
              if '\n' not in code_str.strip():
                  try:
                      result = eval(compile(code_str, "<input>", "eval"), locals_dict)
                      if result is not None:
                          print(repr(result))
                      return output_capture.getvalue().strip()
                  except SyntaxError:
                      pass

              # Execute as statements
              exec(compile(code_str, "<input>", "exec"), locals_dict)
              return output_capture.getvalue().strip()

          except Exception:
              traceback.print_exc(file=output_capture)
              return output_capture.getvalue().strip()
          finally:
              sys.stdout, sys.stderr = old_stdout, old_stderr

      def auto_load_file(file_path, locals_dict):
          """Auto-load a file into locals based on extension"""
          path = Path(file_path).expanduser()
          if not path.exists():
              return None

          ext = path.suffix.lower()
          var_name = f"data_{datetime.now().strftime('%H%M%S')}"

          try:
              if ext == '.csv':
                  df = pd.read_csv(path)
                  locals_dict[var_name] = df
                  shared_ctx['dataframes'][var_name] = df
                  return f"Loaded CSV as '{var_name}': {len(df)} rows, {len(df.columns)} columns\nColumns: {list(df.columns)}"

              elif ext in ['.xlsx', '.xls']:
                  df = pd.read_excel(path)
                  locals_dict[var_name] = df
                  shared_ctx['dataframes'][var_name] = df
                  return f"Loaded Excel as '{var_name}': {len(df)} rows, {len(df.columns)} columns"

              elif ext == '.json':
                  import json
                  with open(path) as f:
                      data = json.load(f)
                  locals_dict[var_name] = data
                  return f"Loaded JSON as '{var_name}': {type(data).__name__}"

              elif ext in ['.png', '.jpg', '.jpeg', '.gif']:
                  from PIL import Image
                  img = Image.open(path)
                  arr = np.array(img)
                  locals_dict[f"{var_name}_img"] = img
                  locals_dict[f"{var_name}_arr"] = arr
                  return f"Loaded image as '{var_name}_img' and '{var_name}_arr': {img.size}"

              elif ext == '.npy':
                  arr = np.load(path)
                  locals_dict[var_name] = arr
                  return f"Loaded numpy array as '{var_name}': shape {arr.shape}"

              elif ext in ['.txt', '.md']:
                  with open(path) as f:
                      text = f.read()
                  locals_dict[var_name] = text
                  return f"Loaded text as '{var_name}': {len(text)} chars"

              else:
                  with open(path, 'rb') as f:
                      data = f.read()
                  locals_dict[var_name] = data
                  return f"Loaded binary as '{var_name}': {len(data)} bytes"

          except Exception as e:
              return f"Error loading {path}: {e}"

      def save_current_plot():
          """Save current matplotlib figure if any"""
          if plt.get_fignums():
              timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
              plot_path = os.path.join(plots_dir, f"plot_{timestamp}.png")
              plt.savefig(plot_path, dpi=150, bbox_inches='tight')
              plt.close()
              return plot_path
          return None

      # Ensure system message for LLM help
      if not messages or messages[0].get("role") != "system":
          sys_msg = """You are a Python data analysis assistant. When the user asks questions:
      1. Generate clean, executable Python code
      2. Use pandas, numpy, matplotlib as needed
      3. Reference variables already in the user's session
      4. Keep code concise and focused"""
          messages.insert(0, {"role": "system", "content": sys_msg})

      # REPL loop
      while True:
          try:
              prompt_str = f"{npc_name}:guac> "
              user_input = input(prompt_str).strip()

              if not user_input:
                  continue

              if user_input.lower() == "/gq":
                  print("Exiting guac mode.")
                  break

              # /vars - show current variables
              if user_input.lower() == "/vars":
                  print(colored("Current variables:", "cyan"))
                  for k, v in guac_locals.items():
                      if not k.startswith('_') and k not in ['np', 'pd', 'plt', 'Path', 'os', 'dataframes']:
                          vtype = type(v).__name__
                          if isinstance(v, pd.DataFrame):
                              print(f"  {k}: DataFrame ({len(v)} rows)")
                          elif isinstance(v, np.ndarray):
                              print(f"  {k}: ndarray {v.shape}")
                          else:
                              print(f"  {k}: {vtype}")
                  continue

              # /clear - clear variables
              if user_input.lower() == "/clear":
                  keep = {'np', 'pd', 'plt', 'Path', 'os', 'dataframes'}
                  guac_locals.clear()
                  guac_locals.update({k: v for k, v in [('np', np), ('pd', pd), ('plt', plt), ('Path', Path), ('os', os), ('dataframes', shared_ctx['dataframes'])]})
                  print(colored("Variables cleared.", "yellow"))
                  continue

              # Check if it's a file path (drag & drop)
              potential_path = user_input.strip("'\"")
              if os.path.exists(os.path.expanduser(potential_path)):
                  result = auto_load_file(potential_path, guac_locals)
                  if result:
                      print(colored(result, "green"))
                  continue

              # Check if it's Python code
              if is_python_code(user_input):
                  output = execute_python(user_input, guac_locals)
                  if output:
                      print(output)

                  # Save any plots
                  plot_path = save_current_plot()
                  if plot_path:
                      print(colored(f"Plot saved: {plot_path}", "green"))
                  continue

              # Natural language - ask LLM for code
              # Include current variables in context
              var_context = "Current variables:\n"
              for k, v in guac_locals.items():
                  if not k.startswith('_') and k not in ['np', 'pd', 'plt', 'Path', 'os', 'dataframes']:
                      if isinstance(v, pd.DataFrame):
                          var_context += f"  {k}: DataFrame with columns {list(v.columns)}\n"
                      elif isinstance(v, np.ndarray):
                          var_context += f"  {k}: ndarray shape {v.shape}\n"
                      else:
                          var_context += f"  {k}: {type(v).__name__}\n"

              prompt = f"{var_context}\nUser request: {user_input}\n\nGenerate Python code to accomplish this. Return ONLY the code, no explanation."

              resp = get_llm_response(
                  prompt,
                  model=model,
                  provider=provider,
                  messages=messages,
                  npc=npc
              )

              messages = resp.get('messages', messages)
              code_response = str(resp.get('response', ''))

              # Extract code from response (strip markdown if present)
              code = code_response
              if '```python' in code:
                  code = code.split('```python')[1].split('```')[0]
              elif '```' in code:
                  code = code.split('```')[1].split('```')[0]
              code = code.strip()

              if code:
                  print(colored("Generated code:", "cyan"))
                  print(code)
                  confirm = input("Execute? [Y/n/e(dit)]: ").strip().lower()

                  if confirm in ['', 'y', 'yes']:
                      output = execute_python(code, guac_locals)
                      if output:
                          print(output)
                      plot_path = save_current_plot()
                      if plot_path:
                          print(colored(f"Plot saved: {plot_path}", "green"))

                  elif confirm == 'e':
                      edited = input("Enter modified code: ").strip()
                      if edited:
                          output = execute_python(edited, guac_locals)
                          if output:
                              print(output)

          except KeyboardInterrupt:
              print("\nUse '/gq' to exit or continue.")
              continue
          except EOFError:
              print("\nExiting guac mode.")
              break

      context['output'] = "Exited guac mode."
      context['messages'] = messages
