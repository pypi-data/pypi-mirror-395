// Grafana Alloy configuration for Cascade lakehouse observability
// Collects Docker container logs and forwards to Loki

// Logging configuration
logging {
  level  = "info"
  format = "logfmt"
}

// Discovery: Find all Docker containers
discovery.docker "containers" {
  host = "unix:///var/run/docker.sock"
  refresh_interval = "5s"
}

// Relabel Docker container labels to Loki labels
discovery.relabel "containers" {
  targets = discovery.docker.containers.targets

  // Keep only running containers
  rule {
    source_labels = ["__meta_docker_container_state"]
    regex         = "running"
    action        = "keep"
  }

  // Container name as job label
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/(.*)"
    target_label  = "job"
    replacement   = "$1"
  }

  // Container ID
  rule {
    source_labels = ["__meta_docker_container_id"]
    target_label  = "container_id"
  }

  // Container image
  rule {
    source_labels = ["__meta_docker_container_image"]
    target_label  = "image"
  }

  // Service label from docker-compose
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
    target_label  = "service"
  }

  // Project label from docker-compose
  rule {
    source_labels = ["__meta_docker_container_label_com_docker_compose_project"]
    target_label  = "compose_project"
  }

  // Add custom cascade_component label for key services
  rule {
    source_labels = ["__meta_docker_container_name"]
    regex         = "/(postgres|minio|nessie|trino|dagster-.*|superset|grafana|prometheus|loki)"
    target_label  = "cascade_component"
    replacement   = "$1"
  }
}

// Read Docker container logs
loki.source.docker "containers" {
  host             = "unix:///var/run/docker.sock"
  targets          = discovery.relabel.containers.output
  forward_to       = [loki.process.parse_logs.receiver]
  refresh_interval = "5s"
}

// Process and parse logs
loki.process "parse_logs" {
  // Try to parse JSON logs
  stage.json {
    expressions = {
      level     = "level",
      timestamp = "timestamp",
      message   = "message",
      logger    = "logger",
    }
  }

  // Extract log level from various formats
  stage.regex {
    expression = "(?P<level>DEBUG|INFO|WARN|ERROR|FATAL|TRACE)"
  }

  // Promote log level to label
  stage.labels {
    values = {
      level = "",
    }
  }

  forward_to = [loki.write.local.receiver]
}

// Write logs to local Loki instance
loki.write "local" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
  }
}

// Expose Alloy's own metrics for Prometheus
prometheus.exporter.self "alloy" { }

prometheus.scrape "alloy" {
  targets    = prometheus.exporter.self.alloy.targets
  forward_to = [prometheus.remote_write.local.receiver]
}

// Remote write to local Prometheus
prometheus.remote_write "local" {
  endpoint {
    url = "http://prometheus:9090/api/v1/write"
  }
}
